<Type Name="Math" FullName="System.Math">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cf82b36db267286b9bb75c3110971d76bd72f7b1" /><Meta Name="ms.sourcegitcommit" Value="0959d8d88abd48debd487e54e54df29d51634f7f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/02/2019" /><Meta Name="ms.locfileid" Value="68732099" /></Metadata><TypeSignature Language="C#" Value="public static class Math" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Math extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Math" />
  <TypeSignature Language="VB.NET" Value="Public Class Math" />
  <TypeSignature Language="C++ CLI" Value="public ref class Math abstract sealed" />
  <TypeSignature Language="F#" Value="type Math = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="e585d-101">Zapewnia stałe i statyczne metody dla kątów, logarytmu i innych typowych funkcji matematycznych.</span><span class="sxs-lookup"><span data-stu-id="e585d-101">Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-102">W poniższym przykładzie zastosowano kilka funkcji matematycznych i trygonometrycznych z <xref:System.Math> klasy w celu obliczenia wewnętrznych kątów trapezu.</span><span class="sxs-lookup"><span data-stu-id="e585d-102">The following example uses several mathematical and trigonometric functions from the <xref:System.Math> class to calculate the inner angles of a trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Abs">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e585d-103">Zwraca wartość bezwzględną podanej liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-103">Returns the absolute value of a specified number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static decimal Abs (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Abs(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Abs(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Abs : decimal -&gt; decimal" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-104">Liczba, która jest większa lub równa <see cref="F:System.Decimal.MinValue" />, ale mniejsza lub <see cref="F:System.Decimal.MaxValue" />równa.</span><span class="sxs-lookup"><span data-stu-id="e585d-104">A number that is greater than or equal to <see cref="F:System.Decimal.MinValue" />, but less than or equal to <see cref="F:System.Decimal.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="e585d-105">Zwraca wartość <see cref="T:System.Decimal" /> bezwzględną liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-105">Returns the absolute value of a <see cref="T:System.Decimal" /> number.</span></span></summary>
        <returns><span data-ttu-id="e585d-106">Liczba dziesiętna, x, taka jak 0 ≤ x ≤<see cref="F:System.Decimal.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-106">A decimal number, x, such that 0 ≤ x ≤<see cref="F:System.Decimal.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-107">Wartość bezwzględna elementu <xref:System.Decimal> jest wartością numeryczną bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-107">The absolute value of a <xref:System.Decimal> is its numeric value without its sign.</span></span> <span data-ttu-id="e585d-108">Na przykład wartość bezwzględna obu 1,2 i-1,2 to 1,2.</span><span class="sxs-lookup"><span data-stu-id="e585d-108">For example, the absolute value of both 1.2 and -1.2 is 1.2.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-109">Poniższy przykład używa metody, <xref:System.Math.Abs%28System.Decimal%29> Aby uzyskać wartość bezwzględną <xref:System.Decimal> liczby wartości.</span><span class="sxs-lookup"><span data-stu-id="e585d-109">The following example uses the <xref:System.Math.Abs%28System.Decimal%29> method to get the absolute value of a number of <xref:System.Decimal> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Math.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(double value);" />
      <MemberSignature Language="F#" Value="static member Abs : double -&gt; double" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-110">Liczba, która jest większa lub równa <see cref="F:System.Double.MinValue" />, ale mniejsza lub <see cref="F:System.Double.MaxValue" />równa.</span><span class="sxs-lookup"><span data-stu-id="e585d-110">A number that is greater than or equal to <see cref="F:System.Double.MinValue" />, but less than or equal to <see cref="F:System.Double.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="e585d-111">Zwraca wartość bezwzględną liczby zmiennoprzecinkowej o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-111">Returns the absolute value of a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="e585d-112">Liczba zmiennoprzecinkowa podwójnej precyzji, x, taka jak 0 ≤ x ≤<see cref="F:System.Double.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-112">A double-precision floating-point number, x, such that 0 ≤ x ≤<see cref="F:System.Double.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-113">Wartość bezwzględna elementu <xref:System.Double> jest wartością numeryczną bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-113">The absolute value of a <xref:System.Double> is its numeric value without its sign.</span></span> <span data-ttu-id="e585d-114">Na przykład wartość bezwzględna obu 1,2 E03 i-1,2 E03 to 1,2 E03.</span><span class="sxs-lookup"><span data-stu-id="e585d-114">For example, the absolute value of both 1.2e03 and -1.2e03 is 1.2e03.</span></span>  
  
 <span data-ttu-id="e585d-115">Jeśli `value` jest <xref:System.Double.PositiveInfinity> <xref:System.Double.PositiveInfinity>równa lub, wartość zwracana to. <xref:System.Double.NegativeInfinity></span><span class="sxs-lookup"><span data-stu-id="e585d-115">If `value` is equal to <xref:System.Double.NegativeInfinity> or <xref:System.Double.PositiveInfinity>, the return value is <xref:System.Double.PositiveInfinity>.</span></span> <span data-ttu-id="e585d-116">Jeśli `value` jest <xref:System.Double.NaN>równa, wartość zwracana to. <xref:System.Double.NaN></span><span class="sxs-lookup"><span data-stu-id="e585d-116">If `value` is equal to <xref:System.Double.NaN>, the return value is <xref:System.Double.NaN>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-117">Poniższy przykład używa metody, <xref:System.Math.Abs%28System.Double%29> Aby uzyskać wartość bezwzględną <xref:System.Double> liczby wartości.</span><span class="sxs-lookup"><span data-stu-id="e585d-117">The following example uses the <xref:System.Math.Abs%28System.Double%29> method to get the absolute value of a number of <xref:System.Double> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs2.cs#2)]
 [!code-vb[System.Math.Abs#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static short Abs (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Abs(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Abs(short value);" />
      <MemberSignature Language="F#" Value="static member Abs : int16 -&gt; int16" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-118">Liczba, która jest większa niż <see cref="F:System.Int16.MinValue" />, ale mniejsza lub <see cref="F:System.Int16.MaxValue" />równa.</span><span class="sxs-lookup"><span data-stu-id="e585d-118">A number that is greater than <see cref="F:System.Int16.MinValue" />, but less than or equal to <see cref="F:System.Int16.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="e585d-119">Zwraca wartość bezwzględną 16-bitową liczbę całkowitą ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-119">Returns the absolute value of a 16-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="e585d-120">16-bitowa liczba całkowita ze znakiem x, taka jak 0 ≤ x<see cref="F:System.Int16.MaxValue" />≤.</span><span class="sxs-lookup"><span data-stu-id="e585d-120">A 16-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.Int16.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-121">Wartość bezwzględna <xref:System.Int16> jest wartością numeryczną bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-121">The absolute value of an <xref:System.Int16> is its numeric value without its sign.</span></span> <span data-ttu-id="e585d-122">Na przykład wartość bezwzględna obu 123 i-123 to 123.</span><span class="sxs-lookup"><span data-stu-id="e585d-122">For example, the absolute value of both 123 and -123 is 123.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-123">Poniższy przykład używa metody, <xref:System.Math.Abs%28System.Int16%29> Aby uzyskać wartość bezwzględną <xref:System.Int16> liczby wartości.</span><span class="sxs-lookup"><span data-stu-id="e585d-123">The following example uses the <xref:System.Math.Abs%28System.Int16%29> method to get the absolute value of a number of <xref:System.Int16> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs3.cs#3)]
 [!code-vb[System.Math.Abs#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="e585d-124"><paramref name="value" />równa <see cref="F:System.Int16.MinValue" />się.</span><span class="sxs-lookup"><span data-stu-id="e585d-124"><paramref name="value" /> equals <see cref="F:System.Int16.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static int Abs (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Abs(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Abs(int value);" />
      <MemberSignature Language="F#" Value="static member Abs : int -&gt; int" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-125">Liczba, która jest większa niż <see cref="F:System.Int32.MinValue" />, ale mniejsza lub <see cref="F:System.Int32.MaxValue" />równa.</span><span class="sxs-lookup"><span data-stu-id="e585d-125">A number that is greater than <see cref="F:System.Int32.MinValue" />, but less than or equal to <see cref="F:System.Int32.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="e585d-126">Zwraca wartość bezwzględną 32-bitową liczbę całkowitą ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-126">Returns the absolute value of a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="e585d-127">32-bitowa liczba całkowita ze znakiem x, taka jak 0 ≤ x<see cref="F:System.Int32.MaxValue" />≤.</span><span class="sxs-lookup"><span data-stu-id="e585d-127">A 32-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.Int32.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-128">Wartość bezwzględna <xref:System.Int32> jest wartością numeryczną bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-128">The absolute value of an <xref:System.Int32> is its numeric value without its sign.</span></span> <span data-ttu-id="e585d-129">Na przykład wartość bezwzględna obu 123 i-123 to 123.</span><span class="sxs-lookup"><span data-stu-id="e585d-129">For example, the absolute value of both 123 and -123 is 123.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-130">Poniższy przykład używa metody, <xref:System.Math.Abs%28System.Int32%29> Aby uzyskać wartość bezwzględną <xref:System.Int32> liczby wartości.</span><span class="sxs-lookup"><span data-stu-id="e585d-130">The following example uses the <xref:System.Math.Abs%28System.Int32%29> method to get the absolute value of a number of <xref:System.Int32> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs4.cs#4)]
 [!code-vb[System.Math.Abs#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="e585d-131"><paramref name="value" />równa <see cref="F:System.Int32.MinValue" />się.</span><span class="sxs-lookup"><span data-stu-id="e585d-131"><paramref name="value" /> equals <see cref="F:System.Int32.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static long Abs (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Abs(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Abs(long value);" />
      <MemberSignature Language="F#" Value="static member Abs : int64 -&gt; int64" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-132">Liczba, która jest większa niż <see cref="F:System.Int64.MinValue" />, ale mniejsza lub <see cref="F:System.Int64.MaxValue" />równa.</span><span class="sxs-lookup"><span data-stu-id="e585d-132">A number that is greater than <see cref="F:System.Int64.MinValue" />, but less than or equal to <see cref="F:System.Int64.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="e585d-133">Zwraca wartość bezwzględną 64-bitową liczbę całkowitą ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-133">Returns the absolute value of a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="e585d-134">64-bitowa liczba całkowita ze znakiem x, taka jak 0 ≤ x<see cref="F:System.Int64.MaxValue" />≤.</span><span class="sxs-lookup"><span data-stu-id="e585d-134">A 64-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.Int64.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-135">Wartość bezwzględna <xref:System.Int64> jest wartością numeryczną bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-135">The absolute value of an <xref:System.Int64> is its numeric value without its sign.</span></span> <span data-ttu-id="e585d-136">Na przykład wartość bezwzględna obu 123 i-123 to 123.</span><span class="sxs-lookup"><span data-stu-id="e585d-136">For example, the absolute value of both 123 and -123 is 123.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-137">Poniższy przykład używa metody, <xref:System.Math.Abs%28System.Int64%29> Aby uzyskać wartość bezwzględną <xref:System.Int64> liczby wartości.</span><span class="sxs-lookup"><span data-stu-id="e585d-137">The following example uses the <xref:System.Math.Abs%28System.Int64%29> method to get the absolute value of a number of <xref:System.Int64> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs5.cs#5)]
 [!code-vb[System.Math.Abs#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="e585d-138"><paramref name="value" />równa <see cref="F:System.Int64.MinValue" />się.</span><span class="sxs-lookup"><span data-stu-id="e585d-138"><paramref name="value" /> equals <see cref="F:System.Int64.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static sbyte Abs (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Abs(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Abs(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member Abs : sbyte -&gt; sbyte" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-139">Liczba, która jest większa niż <see cref="F:System.SByte.MinValue" />, ale mniejsza lub <see cref="F:System.SByte.MaxValue" />równa.</span><span class="sxs-lookup"><span data-stu-id="e585d-139">A number that is greater than <see cref="F:System.SByte.MinValue" />, but less than or equal to <see cref="F:System.SByte.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="e585d-140">Zwraca wartość bezwzględną 8-bitową liczbę całkowitą ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-140">Returns the absolute value of an 8-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="e585d-141">8-bitowa liczba całkowita ze znakiem x, taka jak 0 ≤ x<see cref="F:System.SByte.MaxValue" />≤.</span><span class="sxs-lookup"><span data-stu-id="e585d-141">An 8-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.SByte.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-142">Bezwzględna wartość bajtu ze znakiem jest wartością numeryczną bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-142">The absolute value of a signed byte is its numeric value without its sign.</span></span> <span data-ttu-id="e585d-143">Na przykład wartość bezwzględna równa 12 i-12 to 12.</span><span class="sxs-lookup"><span data-stu-id="e585d-143">For example, the absolute value of both 12 and -12 is 12.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-144">Poniższy przykład używa metody, <xref:System.Math.Abs%28System.SByte%29> Aby uzyskać wartość bezwzględną <xref:System.SByte> liczby wartości.</span><span class="sxs-lookup"><span data-stu-id="e585d-144">The following example uses the <xref:System.Math.Abs%28System.SByte%29> method to get the absolute value of a number of <xref:System.SByte> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs6.cs#6)]
 [!code-vb[System.Math.Abs#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="e585d-145"><paramref name="value" />równa <see cref="F:System.SByte.MinValue" />się.</span><span class="sxs-lookup"><span data-stu-id="e585d-145"><paramref name="value" /> equals <see cref="F:System.SByte.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static float Abs (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Abs(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Abs(float value);" />
      <MemberSignature Language="F#" Value="static member Abs : single -&gt; single" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-146">Liczba, która jest większa lub równa <see cref="F:System.Single.MinValue" />, ale mniejsza lub <see cref="F:System.Single.MaxValue" />równa.</span><span class="sxs-lookup"><span data-stu-id="e585d-146">A number that is greater than or equal to <see cref="F:System.Single.MinValue" />, but less than or equal to <see cref="F:System.Single.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="e585d-147">Zwraca wartość bezwzględną liczby zmiennoprzecinkowej o pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-147">Returns the absolute value of a single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="e585d-148">Liczba zmiennoprzecinkowa o pojedynczej precyzji, x, taka jak 0 ≤ x ≤<see cref="F:System.Single.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-148">A single-precision floating-point number, x, such that 0 ≤ x ≤<see cref="F:System.Single.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-149">Wartość bezwzględna elementu <xref:System.Single> jest wartością numeryczną bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-149">The absolute value of a <xref:System.Single> is its numeric value without its sign.</span></span> <span data-ttu-id="e585d-150">Na przykład absolutna wartość obu 1,2 e-03 i-1,2 E03 to 1,2 E03.</span><span class="sxs-lookup"><span data-stu-id="e585d-150">For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.</span></span>  
  
 <span data-ttu-id="e585d-151">Jeśli `value` jest <xref:System.Single.PositiveInfinity> <xref:System.Single.PositiveInfinity>równa lub, wartość zwracana to. <xref:System.Single.NegativeInfinity></span><span class="sxs-lookup"><span data-stu-id="e585d-151">If `value` is equal to <xref:System.Single.NegativeInfinity> or <xref:System.Single.PositiveInfinity>, the return value is <xref:System.Single.PositiveInfinity>.</span></span> <span data-ttu-id="e585d-152">Jeśli `value` jest <xref:System.Single.NaN>równa, wartość zwracana to. <xref:System.Single.NaN></span><span class="sxs-lookup"><span data-stu-id="e585d-152">If `value` is equal to <xref:System.Single.NaN>, the return value is <xref:System.Single.NaN>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-153">Poniższy przykład używa metody, <xref:System.Math.Abs%28System.Single%29> Aby uzyskać wartość bezwzględną <xref:System.Single> liczby wartości.</span><span class="sxs-lookup"><span data-stu-id="e585d-153">The following example uses the <xref:System.Math.Abs%28System.Single%29> method to get the absolute value of a number of <xref:System.Single> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs7.cs#7)]
 [!code-vb[System.Math.Abs#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static double Acos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Acos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Acos(double d);" />
      <MemberSignature Language="F#" Value="static member Acos : double -&gt; double" Usage="System.Math.Acos d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-154">Liczba reprezentująca cosinus, gdzie <paramref name="d" /> musi być większa lub równa-1, ale mniejsza lub równa 1.</span><span class="sxs-lookup"><span data-stu-id="e585d-154">A number representing a cosine, where <paramref name="d" /> must be greater than or equal to -1, but less than or equal to 1.</span></span></param>
        <summary><span data-ttu-id="e585d-155">Zwraca kąt, którego cosinus jest równy podanej liczbie.</span><span class="sxs-lookup"><span data-stu-id="e585d-155">Returns the angle whose cosine is the specified number.</span></span></summary>
        <returns><span data-ttu-id="e585d-156">Kąt, θ, mierzony w radianach, taki jak 0 ≤ θ ≤ π</span><span class="sxs-lookup"><span data-stu-id="e585d-156">An angle, θ, measured in radians, such that 0 ≤θ≤π</span></span> 
<span data-ttu-id="e585d-157">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-157">-or-</span></span> 
 <span data-ttu-id="e585d-158"><see cref="F:System.Double.NaN" />Jeśli <paramref name="d" /> -1<paramref name="d" /> lub 1lub<paramref name="d" /> równa się<see cref="F:System.Double.NaN" />. &lt; &gt;</span><span class="sxs-lookup"><span data-stu-id="e585d-158"><see cref="F:System.Double.NaN" /> if <paramref name="d" /> &lt; -1 or <paramref name="d" /> &gt; 1 or <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-159">Pomnóż wartość zwracaną przez 180/<xref:System.Math.PI?displayProperty=nameWithType> do konwersji z radianów na stopnie.</span><span class="sxs-lookup"><span data-stu-id="e585d-159">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-160">W poniższym przykładzie zastosowano <xref:System.Math.Acos%2A> metodę, aby pomóc w obliczaniu kątów wewnętrznych danego trapezu.</span><span class="sxs-lookup"><span data-stu-id="e585d-160">The following example uses the <xref:System.Math.Acos%2A> method to assist in the computation of the inner angles of a given trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh">
      <MemberSignature Language="C#" Value="public static double Acosh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acosh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Acosh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acosh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Acosh(double d);" />
      <MemberSignature Language="F#" Value="static member Acosh : double -&gt; double" Usage="System.Math.Acosh d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-161">Liczba reprezentująca cosinus hiperboliczny, gdzie <paramref name="d" /> musi być większa lub równa 1, ale mniejsza lub <see cref="F:System.Double.PositiveInfinity" />równa.</span><span class="sxs-lookup"><span data-stu-id="e585d-161">A number representing a hyperbolic cosine, where <paramref name="d" /> must be greater than or equal to 1, but less than or equal to <see cref="F:System.Double.PositiveInfinity" />.</span></span></param>
        <summary><span data-ttu-id="e585d-162">Zwraca kąt, którego cosinus hiperboliczny jest równy podanej liczbie.</span><span class="sxs-lookup"><span data-stu-id="e585d-162">Returns the angle whose hyperbolic cosine is the specified number.</span></span></summary>
        <returns><span data-ttu-id="e585d-163">Kąt θ, mierzony w radianach, taki jak 0 ≤ θ ≤ ∞.</span><span class="sxs-lookup"><span data-stu-id="e585d-163">An angle, θ, measured in radians, such that 0 ≤ θ ≤ ∞.</span></span>  
  
<span data-ttu-id="e585d-164">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-164">-or-</span></span> 
 <span data-ttu-id="e585d-165"><see cref="F:System.Double.NaN" />Jeśli <paramref name="d" /> 1&lt; lub <paramref name="d" /> równa<see cref="F:System.Double.NaN" />się.</span><span class="sxs-lookup"><span data-stu-id="e585d-165"><see cref="F:System.Double.NaN" /> if <paramref name="d" /> &lt; 1 or <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-166">Pomnóż wartość zwracaną przez 180/<xref:System.Math.PI?displayProperty=nameWithType> do konwersji z radianów na stopnie.</span><span class="sxs-lookup"><span data-stu-id="e585d-166">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static double Asin (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asin(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Asin(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Asin(double d);" />
      <MemberSignature Language="F#" Value="static member Asin : double -&gt; double" Usage="System.Math.Asin d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-167">Liczba reprezentująca sinus, gdzie <paramref name="d" /> musi być większa lub równa-1, ale mniejsza lub równa 1.</span><span class="sxs-lookup"><span data-stu-id="e585d-167">A number representing a sine, where <paramref name="d" /> must be greater than or equal to -1, but less than or equal to 1.</span></span></param>
        <summary><span data-ttu-id="e585d-168">Zwraca kąt, którego sinus jest równy podanej liczbie.</span><span class="sxs-lookup"><span data-stu-id="e585d-168">Returns the angle whose sine is the specified number.</span></span></summary>
        <returns><span data-ttu-id="e585d-169">Kąt, θ, mierzony w radianach, taki jak π/2 ≤ θ ≤ π/2</span><span class="sxs-lookup"><span data-stu-id="e585d-169">An angle, θ, measured in radians, such that -π/2 ≤θ≤π/2</span></span> 
<span data-ttu-id="e585d-170">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-170">-or-</span></span> 
 <span data-ttu-id="e585d-171"><see cref="F:System.Double.NaN" />Jeśli <paramref name="d" /> -1<paramref name="d" /> lub 1lub<paramref name="d" /> równa się<see cref="F:System.Double.NaN" />. &lt; &gt;</span><span class="sxs-lookup"><span data-stu-id="e585d-171"><see cref="F:System.Double.NaN" /> if <paramref name="d" /> &lt; -1 or <paramref name="d" /> &gt; 1 or <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-172">Dodatnia wartość zwrotna reprezentuje kąt w kierunku przeciwnym do osi x. ujemna wartość zwracana reprezentuje kąt w prawo.</span><span class="sxs-lookup"><span data-stu-id="e585d-172">A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.</span></span>  
  
 <span data-ttu-id="e585d-173">Pomnóż wartość zwracaną przez 180/<xref:System.Math.PI?displayProperty=nameWithType> do konwersji z radianów na stopnie.</span><span class="sxs-lookup"><span data-stu-id="e585d-173">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-174">Poniższy przykład używa <xref:System.Math.Asin%2A> , aby pomóc w obliczaniu kątów wewnętrznych danego trapezu.</span><span class="sxs-lookup"><span data-stu-id="e585d-174">The following example uses <xref:System.Math.Asin%2A> to assist in the computation of the inner angles of a given trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh">
      <MemberSignature Language="C#" Value="public static double Asinh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asinh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Asinh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asinh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Asinh(double d);" />
      <MemberSignature Language="F#" Value="static member Asinh : double -&gt; double" Usage="System.Math.Asinh d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-175">Liczba reprezentująca sinus hiperboliczny, gdzie <paramref name="d" /> musi być większa lub <see cref="F:System.Double.NegativeInfinity" />równa, ale <see cref="F:System.Double.PositiveInfinity" />mniejsza lub równa.</span><span class="sxs-lookup"><span data-stu-id="e585d-175">A number representing a hyperbolic sine, where <paramref name="d" /> must be greater than or equal to <see cref="F:System.Double.NegativeInfinity" />, but less than or equal to <see cref="F:System.Double.PositiveInfinity" />.</span></span></param>
        <summary><span data-ttu-id="e585d-176">Zwraca kąt, którego sinus hiperboliczny jest podaną liczbą.</span><span class="sxs-lookup"><span data-stu-id="e585d-176">Returns the angle whose hyperbolic sine is the specified number.</span></span></summary>
        <returns><span data-ttu-id="e585d-177">Kąt θ, mierzony w radianach, taki jak ∞ &lt; θ ≤-1 lub 1 ≤ θ &lt; ∞.</span><span class="sxs-lookup"><span data-stu-id="e585d-177">An angle, θ, measured in radians, such that -∞ &lt; θ ≤-1, or 1 ≤ θ &lt; ∞.</span></span> 
  
<span data-ttu-id="e585d-178">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-178">-or-</span></span> 
 <span data-ttu-id="e585d-179"><see cref="F:System.Double.NaN" />Jeśli <paramref name="d" /> jest <see cref="F:System.Double.NaN" />równe.</span><span class="sxs-lookup"><span data-stu-id="e585d-179"><see cref="F:System.Double.NaN" /> if <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-180">Pomnóż wartość zwracaną przez 180/<xref:System.Math.PI?displayProperty=nameWithType> do konwersji z radianów na stopnie.</span><span class="sxs-lookup"><span data-stu-id="e585d-180">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static double Atan (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atan(double d);" />
      <MemberSignature Language="F#" Value="static member Atan : double -&gt; double" Usage="System.Math.Atan d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-181">Liczba reprezentująca tangens.</span><span class="sxs-lookup"><span data-stu-id="e585d-181">A number representing a tangent.</span></span></param>
        <summary><span data-ttu-id="e585d-182">Zwraca kąt, którego tangens jest równy podanej liczbie.</span><span class="sxs-lookup"><span data-stu-id="e585d-182">Returns the angle whose tangent is the specified number.</span></span></summary>
        <returns><span data-ttu-id="e585d-183">Kąt, θ, mierzony w radianach, taki jak π/2 ≤ θ ≤ π/2.</span><span class="sxs-lookup"><span data-stu-id="e585d-183">An angle, θ, measured in radians, such that -π/2 ≤θ≤π/2.</span></span>  
  
<span data-ttu-id="e585d-184">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-184">-or-</span></span> 
 <span data-ttu-id="e585d-185"><see cref="F:System.Double.NaN" />Jeśli <paramref name="d" /> jest <see cref="F:System.Double.NaN" />równe,-π/2 zaokrąglony do podwójnej precyzji ( <paramref name="d" /> - <see cref="F:System.Double.NegativeInfinity" />1.5707963267949), jeśli Equals, lub π/2 zaokrąglony do <paramref name="d" /> podwójnej precyzji (1.5707963267949), jeśli jest równa <see cref="F:System.Double.PositiveInfinity" />się.</span><span class="sxs-lookup"><span data-stu-id="e585d-185"><see cref="F:System.Double.NaN" /> if <paramref name="d" /> equals <see cref="F:System.Double.NaN" />, -π/2 rounded to double precision (-1.5707963267949) if <paramref name="d" /> equals <see cref="F:System.Double.NegativeInfinity" />, or π/2 rounded to double precision (1.5707963267949) if <paramref name="d" /> equals <see cref="F:System.Double.PositiveInfinity" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-186">Dodatnia wartość zwrotna reprezentuje kąt w kierunku przeciwnym do osi x. ujemna wartość zwracana reprezentuje kąt w prawo.</span><span class="sxs-lookup"><span data-stu-id="e585d-186">A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.</span></span>  
  
 <span data-ttu-id="e585d-187">Pomnóż wartość zwracaną przez 180/<xref:System.Math.PI?displayProperty=nameWithType> do konwersji z radianów na stopnie.</span><span class="sxs-lookup"><span data-stu-id="e585d-187">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-188">W poniższym przykładzie pokazano, jak obliczyć arcus tangens wartości i wyświetlić ją w konsoli.</span><span class="sxs-lookup"><span data-stu-id="e585d-188">The following example demonstrates how to calculate the arctangent of a value and display it to the console.</span></span>  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static double Atan2 (double y, double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan2(float64 y, float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan2(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2 (y As Double, x As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atan2(double y, double x);" />
      <MemberSignature Language="F#" Value="static member Atan2 : double * double -&gt; double" Usage="System.Math.Atan2 (y, x)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Double" />
        <Parameter Name="x" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="y"><span data-ttu-id="e585d-189">Współrzędna y punktu.</span><span class="sxs-lookup"><span data-stu-id="e585d-189">The y coordinate of a point.</span></span></param>
        <param name="x"><span data-ttu-id="e585d-190">Współrzędna x punktu.</span><span class="sxs-lookup"><span data-stu-id="e585d-190">The x coordinate of a point.</span></span></param>
        <summary><span data-ttu-id="e585d-191">Zwraca kąt, którego tangens jest ilorazem dwóch określonych liczb.</span><span class="sxs-lookup"><span data-stu-id="e585d-191">Returns the angle whose tangent is the quotient of two specified numbers.</span></span></summary>
        <returns><span data-ttu-id="e585d-192">Kąt θ, mierzony w radianach, taki jak π ≤ θ ≤ π, i Tan (θ) <paramref name="y" />=  /  <paramref name="x" />, gdzie (<paramref name="x" />, <paramref name="y" />) jest punktem w płaszczyźnie kartezjańskiego.</span><span class="sxs-lookup"><span data-stu-id="e585d-192">An angle, θ, measured in radians, such that -π≤θ≤π, and tan(θ) = <paramref name="y" /> / <paramref name="x" />, where (<paramref name="x" />, <paramref name="y" />) is a point in the Cartesian plane.</span></span> <span data-ttu-id="e585d-193">Zwróć uwagę na następujące kwestie:</span><span class="sxs-lookup"><span data-stu-id="e585d-193">Observe the following:</span></span> 
<span data-ttu-id="e585d-194">-For (<paramref name="x" />, <paramref name="y" />) w ćwiartki 1, &lt; 0 &lt; θ π/2.</span><span class="sxs-lookup"><span data-stu-id="e585d-194">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 1, 0 &lt; θ &lt; π/2.</span></span>  
  
<span data-ttu-id="e585d-195">-For (<paramref name="x" />, <paramref name="y" />) w ćwiartki 2, π/ &lt; 2 θ ≤ π.</span><span class="sxs-lookup"><span data-stu-id="e585d-195">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 2, π/2 &lt; θ≤π.</span></span>  
  
<span data-ttu-id="e585d-196">-For (<paramref name="x" />, <paramref name="y" />) w ćwiartki 3,- &lt; π &lt; θ-π/2.</span><span class="sxs-lookup"><span data-stu-id="e585d-196">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 3, -π &lt; θ &lt; -π/2.</span></span>  
  
<span data-ttu-id="e585d-197">-For (<paramref name="x" />, <paramref name="y" />) w ćwiartki 4,-π/ &lt; 2 &lt; θ 0.</span><span class="sxs-lookup"><span data-stu-id="e585d-197">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 4, -π/2 &lt; θ &lt; 0.</span></span>  
  
<span data-ttu-id="e585d-198">Dla punktów na granicach ćwiartek wartość zwracana jest następująca:</span><span class="sxs-lookup"><span data-stu-id="e585d-198">For points on the boundaries of the quadrants, the return value is the following:</span></span> 
<span data-ttu-id="e585d-199">-Jeśli y jest 0, a x nie jest ujemna, θ = 0.</span><span class="sxs-lookup"><span data-stu-id="e585d-199">-   If y is 0 and x is not negative, θ = 0.</span></span>  
  
<span data-ttu-id="e585d-200">-Jeśli y jest 0, a x jest ujemna, θ = π.</span><span class="sxs-lookup"><span data-stu-id="e585d-200">-   If y is 0 and x is negative, θ = π.</span></span>  
  
<span data-ttu-id="e585d-201">-Jeśli y jest dodatnia, a x to 0, θ = π/2.</span><span class="sxs-lookup"><span data-stu-id="e585d-201">-   If y is positive and x is 0, θ = π/2.</span></span>  
  
<span data-ttu-id="e585d-202">-Jeśli y jest ujemna, a x to 0, θ =-π/2.</span><span class="sxs-lookup"><span data-stu-id="e585d-202">-   If y is negative and x is 0, θ = -π/2.</span></span>  
  
<span data-ttu-id="e585d-203">-Jeśli y jest 0, a x to 0, θ = 0.</span><span class="sxs-lookup"><span data-stu-id="e585d-203">-   If y is 0 and x is 0, θ = 0.</span></span>  
  
<span data-ttu-id="e585d-204"><paramref name="x" /> Jeślilub<see cref="F:System.Double.NaN" /> <paramref name="x" /> jestlub<see cref="F:System.Double.NegativeInfinity" />, lub jeśli i<paramref name="y" /> są albo<see cref="F:System.Double.PositiveInfinity" /> lub, metoda zwraca <see cref="F:System.Double.NaN" />. <paramref name="y" /></span><span class="sxs-lookup"><span data-stu-id="e585d-204">If <paramref name="x" /> or <paramref name="y" /> is <see cref="F:System.Double.NaN" />, or if <paramref name="x" /> and <paramref name="y" /> are either <see cref="F:System.Double.PositiveInfinity" /> or <see cref="F:System.Double.NegativeInfinity" />, the method returns <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-205">Wartość zwracana to kąt w płaszczyźnie kartezjańskiego utworzony przez oś x, a wektor rozpoczynający się od źródła (0, 0) i kończący się w punkcie (x, y).</span><span class="sxs-lookup"><span data-stu-id="e585d-205">The return value is the angle in the Cartesian plane formed by the x-axis, and a vector starting from the origin, (0,0), and terminating at the point, (x,y).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-206">W poniższym przykładzie pokazano, jak obliczyć arcus tangens kąta i wektora.</span><span class="sxs-lookup"><span data-stu-id="e585d-206">The following example demonstrates how to calculate the arctangent of an angle and a vector.</span></span> <span data-ttu-id="e585d-207">Wartość wyników zostanie wyświetlona w konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="e585d-207">The resulting value is displayed in the console.</span></span>  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh">
      <MemberSignature Language="C#" Value="public static double Atanh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atanh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atanh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atanh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atanh(double d);" />
      <MemberSignature Language="F#" Value="static member Atanh : double -&gt; double" Usage="System.Math.Atanh d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-208">Liczba reprezentująca tangens hiperboliczny, gdzie <paramref name="d" /> musi być większa lub równa-1, ale mniejsza lub równa 1.</span><span class="sxs-lookup"><span data-stu-id="e585d-208">A number representing a hyperbolic tangent, where <paramref name="d" /> must be greater than or equal to -1, but less than or equal to 1.</span></span></param>
        <summary><span data-ttu-id="e585d-209">Zwraca kąt, którego tangens hiperboliczny jest równy podanej liczbie.</span><span class="sxs-lookup"><span data-stu-id="e585d-209">Returns the angle whose hyperbolic tangent is the specified number.</span></span></summary>
        <returns><span data-ttu-id="e585d-210">Kąt θ, mierzony &lt; w radianach, taki jak ∞ θ &lt; -1 lub 1 &lt; θ &lt; ∞.</span><span class="sxs-lookup"><span data-stu-id="e585d-210">An angle, θ, measured in radians, such that -∞ &lt; θ &lt; -1, or 1 &lt; θ &lt; ∞.</span></span> 
  
<span data-ttu-id="e585d-211">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-211">-or-</span></span> 
 <span data-ttu-id="e585d-212"><see cref="F:System.Double.NaN" />Jeśli <paramref name="d" /> -1<paramref name="d" /> lub 1lub<paramref name="d" /> równa się<see cref="F:System.Double.NaN" />. &lt; &gt;</span><span class="sxs-lookup"><span data-stu-id="e585d-212"><see cref="F:System.Double.NaN" /> if <paramref name="d" /> &lt; -1 or <paramref name="d" /> &gt; 1 or <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-213">Pomnóż wartość zwracaną przez 180/<xref:System.Math.PI?displayProperty=nameWithType> do konwersji z radianów na stopnie.</span><span class="sxs-lookup"><span data-stu-id="e585d-213">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BigMul">
      <MemberSignature Language="C#" Value="public static long BigMul (int a, int b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 BigMul(int32 a, int32 b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.BigMul(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BigMul (a As Integer, b As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long BigMul(int a, int b);" />
      <MemberSignature Language="F#" Value="static member BigMul : int * int -&gt; int64" Usage="System.Math.BigMul (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="b" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="e585d-214">Pierwsza liczba do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="e585d-214">The first number to multiply.</span></span></param>
        <param name="b"><span data-ttu-id="e585d-215">Druga liczba do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="e585d-215">The second number to multiply.</span></span></param>
        <summary><span data-ttu-id="e585d-216">Tworzy pełny iloczyn liczby 2 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="e585d-216">Produces the full product of two 32-bit numbers.</span></span></summary>
        <returns><span data-ttu-id="e585d-217">Liczba zawierająca iloczyn określonych liczb.</span><span class="sxs-lookup"><span data-stu-id="e585d-217">The number containing the product of the specified numbers.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-218">Poniższy przykład ilustruje użycie <xref:System.Math.BigMul%2A> metody do obliczenia iloczynu dwóch wartości całkowitych.</span><span class="sxs-lookup"><span data-stu-id="e585d-218">The following example demonstrates the use of the <xref:System.Math.BigMul%2A> method to calculate the product of two integer values.</span></span>  
  
 [!code-cpp[math.bigmul#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.bigmul/CPP/bigmul.cpp#1)]
 [!code-csharp[math.bigmul#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.bigmul/CS/bigmul.cs#1)]
 [!code-vb[math.bigmul#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.bigmul/VB/bigmul.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitDecrement">
      <MemberSignature Language="C#" Value="public static double BitDecrement (double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 BitDecrement(float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.BitDecrement(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitDecrement (x As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double BitDecrement(double x);" />
      <MemberSignature Language="F#" Value="static member BitDecrement : double -&gt; double" Usage="System.Math.BitDecrement x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="e585d-219">Wartość do zmniejszenia.</span><span class="sxs-lookup"><span data-stu-id="e585d-219">The value to decrement.</span></span></param>
        <summary><span data-ttu-id="e585d-220">Zwraca następną najmniejszą wartość, która porównuje mniej niż <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-220">Returns the next smallest value that compares less than <paramref name="x" />.</span></span></summary>
        <returns><span data-ttu-id="e585d-221">Następna najmniejsza wartość, która porównuje <paramref name="x" />mniej niż.</span><span class="sxs-lookup"><span data-stu-id="e585d-221">The next smallest value that compares less than <paramref name="x" />.</span></span>  
  
<span data-ttu-id="e585d-222">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-222">-or-</span></span> 
 <span data-ttu-id="e585d-223"><see cref="F:System.Double.NegativeInfinity" />Jeśli <paramref name="x" /> jest <see cref="F:System.Double.NegativeInfinity" />równe.</span><span class="sxs-lookup"><span data-stu-id="e585d-223"><see cref="F:System.Double.NegativeInfinity" /> if <paramref name="x" /> equals <see cref="F:System.Double.NegativeInfinity" />.</span></span>
  
<span data-ttu-id="e585d-224">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-224">-or-</span></span> 
 <span data-ttu-id="e585d-225"><see cref="F:System.Double.NaN" />Jeśli <paramref name="x" /> jest <see cref="F:System.Double.NaN" />równe.</span><span class="sxs-lookup"><span data-stu-id="e585d-225"><see cref="F:System.Double.NaN" /> if <paramref name="x" /> equals <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="BitIncrement">
      <MemberSignature Language="C#" Value="public static double BitIncrement (double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 BitIncrement(float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.BitIncrement(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitIncrement (x As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double BitIncrement(double x);" />
      <MemberSignature Language="F#" Value="static member BitIncrement : double -&gt; double" Usage="System.Math.BitIncrement x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="e585d-226">Wartość do zwiększenia.</span><span class="sxs-lookup"><span data-stu-id="e585d-226">The value to increment.</span></span></param>
        <summary><span data-ttu-id="e585d-227">Zwraca następną największą wartość, która porównuje <paramref name="x" />większe niż.</span><span class="sxs-lookup"><span data-stu-id="e585d-227">Returns the next largest value that compares greater than <paramref name="x" />.</span></span></summary>
        <returns><span data-ttu-id="e585d-228">Kolejna największa wartość, która porównuje <paramref name="x" />więcej niż.</span><span class="sxs-lookup"><span data-stu-id="e585d-228">The next largest value that compares greater than <paramref name="x" />.</span></span>  
  
<span data-ttu-id="e585d-229">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-229">-or-</span></span> 
 <span data-ttu-id="e585d-230"><see cref="F:System.Double.PositiveInfinity" />Jeśli <paramref name="x" /> jest <see cref="F:System.Double.PositiveInfinity" />równe.</span><span class="sxs-lookup"><span data-stu-id="e585d-230"><see cref="F:System.Double.PositiveInfinity" /> if <paramref name="x" /> equals <see cref="F:System.Double.PositiveInfinity" />.</span></span>
  
<span data-ttu-id="e585d-231">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-231">-or-</span></span> 
 <span data-ttu-id="e585d-232"><see cref="F:System.Double.NaN" />Jeśli <paramref name="x" /> jest <see cref="F:System.Double.NaN" />równe.</span><span class="sxs-lookup"><span data-stu-id="e585d-232"><see cref="F:System.Double.NaN" /> if <paramref name="x" /> equals <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt">
      <MemberSignature Language="C#" Value="public static double Cbrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cbrt(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cbrt(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cbrt (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cbrt(double d);" />
      <MemberSignature Language="F#" Value="static member Cbrt : double -&gt; double" Usage="System.Math.Cbrt d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-233">Liczba, dla której ma zostać odnaleziony katalog główny modułu.</span><span class="sxs-lookup"><span data-stu-id="e585d-233">The number whose cube root is to be found.</span></span></param>
        <summary><span data-ttu-id="e585d-234">Zwraca katalog główny modułu o podanej liczbie.</span><span class="sxs-lookup"><span data-stu-id="e585d-234">Returns the cube root of a specified number.</span></span></summary>
        <returns><span data-ttu-id="e585d-235">Katalog główny <paramref name="d" />modułu.</span><span class="sxs-lookup"><span data-stu-id="e585d-235">The cube root of <paramref name="d" />.</span></span>  
  
<span data-ttu-id="e585d-236">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-236">-or-</span></span> 
 <span data-ttu-id="e585d-237"><see cref="F:System.Double.NaN" />Jeśli <paramref name="x" /> jest <see cref="F:System.Double.NaN" />równe.</span><span class="sxs-lookup"><span data-stu-id="e585d-237"><see cref="F:System.Double.NaN" /> if <paramref name="x" /> equals <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Ceiling">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e585d-238">Zwraca najmniejszą wartość całkowitą większą lub równą podanej liczbie.</span><span class="sxs-lookup"><span data-stu-id="e585d-238">Returns the smallest integral value greater than or equal to the specified number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-239">Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="e585d-239">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="e585d-240">Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku plus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="e585d-240">This kind of rounding is sometimes called rounding toward positive infinity.</span></span>  

## Examples

[!INCLUDE[midpoint-rounding](~/includes/csharp-interactive-note.md)]

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static decimal Ceiling (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Ceiling(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Ceiling(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Ceiling : decimal -&gt; decimal" Usage="System.Math.Ceiling d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-241">Liczba dziesiętna.</span><span class="sxs-lookup"><span data-stu-id="e585d-241">A decimal number.</span></span></param>
        <summary><span data-ttu-id="e585d-242">Zwraca najmniejszą wartość całkowitą, która jest większa lub równa określonej liczbie dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="e585d-242">Returns the smallest integral value that is greater than or equal to the specified decimal number.</span></span></summary>
        <returns><span data-ttu-id="e585d-243">Najmniejsza wartość całkowita, która jest większa lub równa <paramref name="d" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-243">The smallest integral value that is greater than or equal to <paramref name="d" />.</span></span> <span data-ttu-id="e585d-244">Należy zauważyć, że ta metoda <see cref="T:System.Decimal" /> zwraca zamiast typu całkowitego.</span><span class="sxs-lookup"><span data-stu-id="e585d-244">Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-245">Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="e585d-245">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="e585d-246">Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku plus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="e585d-246">This kind of rounding is sometimes called rounding toward positive infinity.</span></span> <span data-ttu-id="e585d-247">Innymi słowy, jeśli `d` ma wartość dodatnią, obecność dowolnego częściowego składnika powoduje `d` Zaokrąglenie do najbliższej najwyższej wartości całkowitej.</span><span class="sxs-lookup"><span data-stu-id="e585d-247">In other words, if `d` is positive, the presence of any fractional component causes `d` to be rounded to the next highest integer.</span></span> <span data-ttu-id="e585d-248">Jeśli `d` jest ujemna, operacja zaokrąglania powoduje odrzucenie dowolnego `d` składnika ułamka.</span><span class="sxs-lookup"><span data-stu-id="e585d-248">If `d` is negative, the rounding operation causes any fractional component of `d` to be discarded.</span></span> <span data-ttu-id="e585d-249">Operacja tej metody różni się od <xref:System.Math.Floor%28System.Decimal%29> metody, która obsługuje zaokrąglenie w kierunku nieskończoności ujemnej.</span><span class="sxs-lookup"><span data-stu-id="e585d-249">The operation of this method differs from the <xref:System.Math.Floor%28System.Decimal%29> method, which supports rounding toward negative infinity.</span></span>  
  
## Examples  
 <span data-ttu-id="e585d-250">Poniższy przykład ilustruje <xref:System.Math.Ceiling%28System.Decimal%29?displayProperty=nameWithType> metodę i kontrastuje ją <xref:System.Math.Floor%28System.Decimal%29> z metodą.</span><span class="sxs-lookup"><span data-stu-id="e585d-250">The following example illustrates the <xref:System.Math.Ceiling%28System.Decimal%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Floor%28System.Decimal%29> method.</span></span>  
  
 [!code-csharp-interactive[System.Math.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#1)]
 [!code-vb[System.Math.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static double Ceiling (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Ceiling(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Ceiling(double a);" />
      <MemberSignature Language="F#" Value="static member Ceiling : double -&gt; double" Usage="System.Math.Ceiling a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="e585d-251">Liczba zmiennoprzecinkowa podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-251">A double-precision floating-point number.</span></span></param>
        <summary><span data-ttu-id="e585d-252">Zwraca najmniejszą wartość całkowitą, która jest większa lub równa określonej liczbie zmiennoprzecinkowej podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-252">Returns the smallest integral value that is greater than or equal to the specified double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="e585d-253">Najmniejsza wartość całkowita, która jest większa lub równa <paramref name="a" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-253">The smallest integral value that is greater than or equal to <paramref name="a" />.</span></span> <span data-ttu-id="e585d-254">Jeśli <paramref name="a" /> jest <see cref="F:System.Double.NaN" />równe ,<see cref="F:System.Double.NegativeInfinity" />, lub<see cref="F:System.Double.PositiveInfinity" />, ta wartość jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="e585d-254">If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, that value is returned.</span></span> <span data-ttu-id="e585d-255">Należy zauważyć, że ta metoda <see cref="T:System.Double" /> zwraca zamiast typu całkowitego.</span><span class="sxs-lookup"><span data-stu-id="e585d-255">Note that this method returns a <see cref="T:System.Double" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-256">Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="e585d-256">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="e585d-257">Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku plus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="e585d-257">This kind of rounding is sometimes called rounding toward positive infinity.</span></span> <span data-ttu-id="e585d-258">Innymi słowy, jeśli `a` ma wartość dodatnią, obecność dowolnego częściowego składnika powoduje `a` Zaokrąglenie do najbliższej najwyższej wartości całkowitej.</span><span class="sxs-lookup"><span data-stu-id="e585d-258">In other words, if `a` is positive, the presence of any fractional component causes `a` to be rounded to the next highest integer.</span></span> <span data-ttu-id="e585d-259">Jeśli `a` jest ujemna, operacja zaokrąglania powoduje odrzucenie dowolnego `a` składnika ułamka.</span><span class="sxs-lookup"><span data-stu-id="e585d-259">If `a` is negative, the rounding operation causes any fractional component of `a` to be discarded.</span></span> <span data-ttu-id="e585d-260">Operacja tej metody różni się od <xref:System.Math.Floor%28System.Double%29> metody, która obsługuje zaokrąglenie w kierunku nieskończoności ujemnej.</span><span class="sxs-lookup"><span data-stu-id="e585d-260">The operation of this method differs from the <xref:System.Math.Floor%28System.Double%29> method, which supports rounding toward negative infinity.</span></span>  
  
<span data-ttu-id="e585d-261">Począwszy od Visual Basic 15,8, wydajność konwersji podwójnej do liczby całkowitej jest zoptymalizowana, jeśli przekazujesz wartość zwróconą przez `Ceiling` metodę do którejkolwiek [funkcji konwersji całkowitej](~/docs/visual-basic/language-reference/functions/conversion-functions.md)lub jeśli wartość podwójna zwracana przez `Ceiling` jest automatycznie konwertowany na liczbę całkowitą z [opcją Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) ustawioną na wartość off.</span><span class="sxs-lookup"><span data-stu-id="e585d-261">Starting with Visual Basic 15.8, the performance of Double-to-integer conversion is optimized if you pass the value returned by the `Ceiling` method to the any of the [integral conversion functions](~/docs/visual-basic/language-reference/functions/conversion-functions.md), or if the Double value returned by `Ceiling` is automatically converted to an integer with [Option Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) set to Off.</span></span> <span data-ttu-id="e585d-262">Ta optymalizacja umożliwia szybsze uruchamianie kodu — maksymalnie dwa razy w przypadku kodu, który wykonuje dużą liczbę konwersji na typy całkowite.</span><span class="sxs-lookup"><span data-stu-id="e585d-262">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="e585d-263">Poniższy przykład ilustruje takie zoptymalizowane konwersje:</span><span class="sxs-lookup"><span data-stu-id="e585d-263">The following example illustrates such optimized conversions:</span></span>
   
```vb
Dim d1 As Double = 1043.75133
Dim i1 As Integer = CInt(Math.Ceiling(d1))        ' Result: 1044

Dim d2 As Double = 7968.4136
Dim i2 As Integer = CInt(Math.Ceiling(d2))        ' Result: 7969
```   

## Examples  
 <span data-ttu-id="e585d-264">Poniższy przykład ilustruje <xref:System.Math.Ceiling%28System.Double%29?displayProperty=nameWithType> metodę i kontrastuje ją <xref:System.Math.Floor%28System.Double%29> z metodą.</span><span class="sxs-lookup"><span data-stu-id="e585d-264">The following example illustrates the <xref:System.Math.Ceiling%28System.Double%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Floor%28System.Double%29> method.</span></span>  
  
 [!code-csharp-interactive[System.Math.Ceiling#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#2)]
 [!code-vb[System.Math.Ceiling#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static byte Clamp (byte value, byte min, byte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Clamp(unsigned int8 value, unsigned int8 min, unsigned int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Byte,System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Byte, min As Byte, max As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Clamp(System::Byte value, System::Byte min, System::Byte max);" />
      <MemberSignature Language="F#" Value="static member Clamp : byte * byte * byte -&gt; byte" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="min" Type="System.Byte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="max" Type="System.Byte" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-265">Wartość, która ma zostać zamocowana.</span><span class="sxs-lookup"><span data-stu-id="e585d-265">The value to be clamped.</span></span></param>
        <param name="min"><span data-ttu-id="e585d-266">Dolna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-266">The lower bound of the result.</span></span></param>
        <param name="max"><span data-ttu-id="e585d-267">Górna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-267">The upper bound of the result.</span></span></param>
        <summary><span data-ttu-id="e585d-268">Zwraca <paramref name="value" /> zamocowany do <paramref name="min" /> zakresu włącznie i <paramref name="max" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-268">Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</span></span></summary>
        <returns><span data-ttu-id="e585d-269"><paramref name="value" />Jeśli <paramref name="min" /> ≤ <paramref name="value" /> ≤ .<paramref name="max" /></span><span class="sxs-lookup"><span data-stu-id="e585d-269"><paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.</span></span>  
  
<span data-ttu-id="e585d-270">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-270">-or-</span></span> 
 <span data-ttu-id="e585d-271"><paramref name="min" />Jeśli <paramref name="value" /> .&lt; <paramref name="min" /></span><span class="sxs-lookup"><span data-stu-id="e585d-271"><paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.</span></span>
  
<span data-ttu-id="e585d-272">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-272">-or-</span></span> 
 <span data-ttu-id="e585d-273"><paramref name="max" />Jeśli <paramref name="max" /> .&lt; <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="e585d-273"><paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static decimal Clamp (decimal value, decimal min, decimal max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Clamp(valuetype System.Decimal value, valuetype System.Decimal min, valuetype System.Decimal max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Decimal,System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Decimal, min As Decimal, max As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Clamp(System::Decimal value, System::Decimal min, System::Decimal max);" />
      <MemberSignature Language="F#" Value="static member Clamp : decimal * decimal * decimal -&gt; decimal" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="min" Type="System.Decimal" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="max" Type="System.Decimal" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-274">Wartość, która ma zostać zamocowana.</span><span class="sxs-lookup"><span data-stu-id="e585d-274">The value to be clamped.</span></span></param>
        <param name="min"><span data-ttu-id="e585d-275">Dolna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-275">The lower bound of the result.</span></span></param>
        <param name="max"><span data-ttu-id="e585d-276">Górna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-276">The upper bound of the result.</span></span></param>
        <summary><span data-ttu-id="e585d-277">Zwraca <paramref name="value" /> zamocowany do <paramref name="min" /> zakresu włącznie i <paramref name="max" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-277">Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</span></span></summary>
        <returns><span data-ttu-id="e585d-278"><paramref name="value" />Jeśli <paramref name="min" /> ≤ <paramref name="value" /> ≤ .<paramref name="max" /></span><span class="sxs-lookup"><span data-stu-id="e585d-278"><paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.</span></span>
  
<span data-ttu-id="e585d-279">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-279">-or-</span></span> 
 <span data-ttu-id="e585d-280"><paramref name="min" />Jeśli <paramref name="value" /> .&lt; <paramref name="min" /></span><span class="sxs-lookup"><span data-stu-id="e585d-280"><paramref name="min" /> if <paramref name="value" /> &lt;<paramref name="min" />.</span></span>
  
<span data-ttu-id="e585d-281">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-281">-or-</span></span> 
 <span data-ttu-id="e585d-282"><paramref name="max" />Jeśli <paramref name="max" /> .&lt; <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="e585d-282"><paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static double Clamp (double value, double min, double max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Clamp(float64 value, float64 min, float64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Double, min As Double, max As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Clamp(double value, double min, double max);" />
      <MemberSignature Language="F#" Value="static member Clamp : double * double * double -&gt; double" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="min" Type="System.Double" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="max" Type="System.Double" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-283">Wartość, która ma zostać zamocowana.</span><span class="sxs-lookup"><span data-stu-id="e585d-283">The value to be clamped.</span></span></param>
        <param name="min"><span data-ttu-id="e585d-284">Dolna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-284">The lower bound of the result.</span></span></param>
        <param name="max"><span data-ttu-id="e585d-285">Górna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-285">The upper bound of the result.</span></span></param>
        <summary><span data-ttu-id="e585d-286">Zwraca <paramref name="value" /> zamocowany do <paramref name="min" /> zakresu włącznie i <paramref name="max" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-286">Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</span></span></summary>
        <returns><span data-ttu-id="e585d-287"><paramref name="value" />Jeśli <paramref name="min" /> ≤ <paramref name="value" /> ≤ .<paramref name="max" /></span><span class="sxs-lookup"><span data-stu-id="e585d-287"><paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.</span></span>
  
<span data-ttu-id="e585d-288">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-288">-or-</span></span> 
 <span data-ttu-id="e585d-289"><paramref name="min" />Jeśli <paramref name="value" /> .&lt; <paramref name="min" /></span><span class="sxs-lookup"><span data-stu-id="e585d-289"><paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.</span></span>
  
<span data-ttu-id="e585d-290">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-290">-or-</span></span> 
 <span data-ttu-id="e585d-291"><paramref name="max" />if <paramref name="max" /> &lt; . '<paramref name="value" />'</span><span class="sxs-lookup"><span data-stu-id="e585d-291"><paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.\`\`</span></span> 
<span data-ttu-id="e585d-292">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-292">-or-</span></span> 
  <span data-ttu-id="e585d-293"><see cref="F:System.Double.NaN" />Jeśli <paramref name="value" /> jest <see cref="F:System.Double.NaN" />równe.</span><span class="sxs-lookup"><span data-stu-id="e585d-293"><see cref="F:System.Double.NaN" /> if <paramref name="value" /> equals <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static short Clamp (short value, short min, short max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Clamp(int16 value, int16 min, int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int16,System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Short, min As Short, max As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Clamp(short value, short min, short max);" />
      <MemberSignature Language="F#" Value="static member Clamp : int16 * int16 * int16 -&gt; int16" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="min" Type="System.Int16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="max" Type="System.Int16" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-294">Wartość, która ma zostać zamocowana.</span><span class="sxs-lookup"><span data-stu-id="e585d-294">The value to be clamped.</span></span></param>
        <param name="min"><span data-ttu-id="e585d-295">Dolna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-295">The lower bound of the result.</span></span></param>
        <param name="max"><span data-ttu-id="e585d-296">Górna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-296">The upper bound of the result.</span></span></param>
        <summary><span data-ttu-id="e585d-297">Zwraca <paramref name="value" /> zamocowany do <paramref name="min" /> zakresu włącznie i <paramref name="max" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-297">Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</span></span></summary>
        <returns><span data-ttu-id="e585d-298"><paramref name="value" />Jeśli <paramref name="min" /> ≤ <paramref name="value" /> ≤ .<paramref name="max" /></span><span class="sxs-lookup"><span data-stu-id="e585d-298"><paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.</span></span>
  
<span data-ttu-id="e585d-299">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-299">-or-</span></span> 
 <span data-ttu-id="e585d-300"><paramref name="min" />Jeśli <paramref name="value" /> .&lt; <paramref name="min" /></span><span class="sxs-lookup"><span data-stu-id="e585d-300"><paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.</span></span>
  
<span data-ttu-id="e585d-301">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-301">-or-</span></span> 
 <span data-ttu-id="e585d-302"><paramref name="max" />Jeśli <paramref name="max" /> .&lt; <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="e585d-302"><paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static int Clamp (int value, int min, int max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Clamp(int32 value, int32 min, int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Integer, min As Integer, max As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Clamp(int value, int min, int max);" />
      <MemberSignature Language="F#" Value="static member Clamp : int * int * int -&gt; int" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="min" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="max" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-303">Wartość, która ma zostać zamocowana.</span><span class="sxs-lookup"><span data-stu-id="e585d-303">The value to be clamped.</span></span></param>
        <param name="min"><span data-ttu-id="e585d-304">Dolna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-304">The lower bound of the result.</span></span></param>
        <param name="max"><span data-ttu-id="e585d-305">Górna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-305">The upper bound of the result.</span></span></param>
        <summary><span data-ttu-id="e585d-306">Zwraca <paramref name="value" /> zamocowany do <paramref name="min" /> zakresu włącznie i <paramref name="max" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-306">Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</span></span></summary>
        <returns><span data-ttu-id="e585d-307"><paramref name="value" />Jeśli <paramref name="min" /> ≤ <paramref name="value" /> ≤ .<paramref name="max" /></span><span class="sxs-lookup"><span data-stu-id="e585d-307"><paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.</span></span>
  
<span data-ttu-id="e585d-308">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-308">-or-</span></span> 
 <span data-ttu-id="e585d-309"><paramref name="min" />Jeśli <paramref name="value" /> .&lt; <paramref name="min" /></span><span class="sxs-lookup"><span data-stu-id="e585d-309"><paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.</span></span>
  
<span data-ttu-id="e585d-310">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-310">-or-</span></span> 
 <span data-ttu-id="e585d-311"><paramref name="max" />Jeśli <paramref name="max" /> .&lt; <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="e585d-311"><paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static long Clamp (long value, long min, long max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Clamp(int64 value, int64 min, int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Long, min As Long, max As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Clamp(long value, long min, long max);" />
      <MemberSignature Language="F#" Value="static member Clamp : int64 * int64 * int64 -&gt; int64" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="min" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="max" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-312">Wartość, która ma zostać zamocowana.</span><span class="sxs-lookup"><span data-stu-id="e585d-312">The value to be clamped.</span></span></param>
        <param name="min"><span data-ttu-id="e585d-313">Dolna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-313">The lower bound of the result.</span></span></param>
        <param name="max"><span data-ttu-id="e585d-314">Górna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-314">The upper bound of the result.</span></span></param>
        <summary><span data-ttu-id="e585d-315">Zwraca <paramref name="value" /> zamocowany do <paramref name="min" /> zakresu włącznie i <paramref name="max" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-315">Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</span></span></summary>
        <returns><span data-ttu-id="e585d-316"><paramref name="value" />Jeśli <paramref name="min" /> ≤ <paramref name="value" /> ≤ .<paramref name="max" /></span><span class="sxs-lookup"><span data-stu-id="e585d-316"><paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.</span></span>
  
<span data-ttu-id="e585d-317">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-317">-or-</span></span> 
 <span data-ttu-id="e585d-318"><paramref name="min" />Jeśli <paramref name="value" /> .&lt; <paramref name="min" /></span><span class="sxs-lookup"><span data-stu-id="e585d-318"><paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.</span></span>
  
<span data-ttu-id="e585d-319">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-319">-or-</span></span> 
 <span data-ttu-id="e585d-320"><paramref name="max" />Jeśli <paramref name="max" /> .&lt; <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="e585d-320"><paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static sbyte Clamp (sbyte value, sbyte min, sbyte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Clamp(int8 value, int8 min, int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.SByte,System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As SByte, min As SByte, max As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Clamp(System::SByte value, System::SByte min, System::SByte max);" />
      <MemberSignature Language="F#" Value="static member Clamp : sbyte * sbyte * sbyte -&gt; sbyte" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="min" Type="System.SByte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="max" Type="System.SByte" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-321">Wartość, która ma zostać zamocowana.</span><span class="sxs-lookup"><span data-stu-id="e585d-321">The value to be clamped.</span></span></param>
        <param name="min"><span data-ttu-id="e585d-322">Dolna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-322">The lower bound of the result.</span></span></param>
        <param name="max"><span data-ttu-id="e585d-323">Górna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-323">The upper bound of the result.</span></span></param>
        <summary><span data-ttu-id="e585d-324">Zwraca <paramref name="value" /> zamocowany do <paramref name="min" /> zakresu włącznie i <paramref name="max" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-324">Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</span></span></summary>
        <returns><span data-ttu-id="e585d-325"><paramref name="value" />Jeśli <paramref name="min" /> ≤ <paramref name="value" /> ≤ .<paramref name="max" /></span><span class="sxs-lookup"><span data-stu-id="e585d-325"><paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.</span></span>
  
<span data-ttu-id="e585d-326">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-326">-or-</span></span> 
 <span data-ttu-id="e585d-327"><paramref name="min" />Jeśli <paramref name="value" /> .&lt; <paramref name="min" /></span><span class="sxs-lookup"><span data-stu-id="e585d-327"><paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.</span></span>
  
<span data-ttu-id="e585d-328">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-328">-or-</span></span> 
 <span data-ttu-id="e585d-329"><paramref name="max" />Jeśli <paramref name="max" /> .&lt; <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="e585d-329"><paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static float Clamp (float value, float min, float max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Clamp(float32 value, float32 min, float32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Single, min As Single, max As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Clamp(float value, float min, float max);" />
      <MemberSignature Language="F#" Value="static member Clamp : single * single * single -&gt; single" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="min" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="max" Type="System.Single" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-330">Wartość, która ma zostać zamocowana.</span><span class="sxs-lookup"><span data-stu-id="e585d-330">The value to be clamped.</span></span></param>
        <param name="min"><span data-ttu-id="e585d-331">Dolna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-331">The lower bound of the result.</span></span></param>
        <param name="max"><span data-ttu-id="e585d-332">Górna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-332">The upper bound of the result.</span></span></param>
        <summary><span data-ttu-id="e585d-333">Zwraca <paramref name="value" /> zamocowany do <paramref name="min" /> zakresu włącznie i <paramref name="max" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-333">Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</span></span></summary>
        <returns><span data-ttu-id="e585d-334"><paramref name="value" />Jeśli <paramref name="min" /> ≤ <paramref name="value" /> ≤ .<paramref name="max" /></span><span class="sxs-lookup"><span data-stu-id="e585d-334"><paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.</span></span>  
  
<span data-ttu-id="e585d-335">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-335">-or-</span></span> 
 <span data-ttu-id="e585d-336"><paramref name="min" />Jeśli <paramref name="value" /> .&lt; <paramref name="min" /></span><span class="sxs-lookup"><span data-stu-id="e585d-336"><paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.</span></span>
  
<span data-ttu-id="e585d-337">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-337">-or-</span></span> 
 <span data-ttu-id="e585d-338"><paramref name="max" />Jeśli <paramref name="max" /> .&lt; <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="e585d-338"><paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</span></span>
  
<span data-ttu-id="e585d-339">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-339">-or-</span></span> 
  <span data-ttu-id="e585d-340"><see cref="F:System.Single.NaN" />Jeśli <paramref name="value" /> jest <see cref="F:System.Single.NaN" />równe.</span><span class="sxs-lookup"><span data-stu-id="e585d-340"><see cref="F:System.Single.NaN" /> if <paramref name="value" /> equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ushort Clamp (ushort value, ushort min, ushort max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Clamp(unsigned int16 value, unsigned int16 min, unsigned int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt16,System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UShort, min As UShort, max As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Clamp(System::UInt16 value, System::UInt16 min, System::UInt16 max);" />
      <MemberSignature Language="F#" Value="static member Clamp : uint16 * uint16 * uint16 -&gt; uint16" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="min" Type="System.UInt16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="max" Type="System.UInt16" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-341">Wartość, która ma zostać zamocowana.</span><span class="sxs-lookup"><span data-stu-id="e585d-341">The value to be clamped.</span></span></param>
        <param name="min"><span data-ttu-id="e585d-342">Dolna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-342">The lower bound of the result.</span></span></param>
        <param name="max"><span data-ttu-id="e585d-343">Górna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-343">The upper bound of the result.</span></span></param>
        <summary><span data-ttu-id="e585d-344">Zwraca <paramref name="value" /> zamocowany do <paramref name="min" /> zakresu włącznie i <paramref name="max" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-344">Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</span></span></summary>
        <returns><span data-ttu-id="e585d-345"><paramref name="value" />Jeśli <paramref name="min" /> ≤ <paramref name="value" /> ≤ .<paramref name="max" /></span><span class="sxs-lookup"><span data-stu-id="e585d-345"><paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.</span></span>  
  
<span data-ttu-id="e585d-346">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-346">-or-</span></span> 
 <span data-ttu-id="e585d-347"><paramref name="min" />Jeśli <paramref name="value" /> .&lt; <paramref name="min" /></span><span class="sxs-lookup"><span data-stu-id="e585d-347"><paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.</span></span>
  
<span data-ttu-id="e585d-348">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-348">-or-</span></span> 
 <span data-ttu-id="e585d-349"><paramref name="max" />Jeśli <paramref name="max" /> .&lt; <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="e585d-349"><paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static uint Clamp (uint value, uint min, uint max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Clamp(unsigned int32 value, unsigned int32 min, unsigned int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt32,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UInteger, min As UInteger, max As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Clamp(System::UInt32 value, System::UInt32 min, System::UInt32 max);" />
      <MemberSignature Language="F#" Value="static member Clamp : uint32 * uint32 * uint32 -&gt; uint32" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="min" Type="System.UInt32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="max" Type="System.UInt32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-350">Wartość, która ma zostać zamocowana.</span><span class="sxs-lookup"><span data-stu-id="e585d-350">The value to be clamped.</span></span></param>
        <param name="min"><span data-ttu-id="e585d-351">Dolna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-351">The lower bound of the result.</span></span></param>
        <param name="max"><span data-ttu-id="e585d-352">Górna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-352">The upper bound of the result.</span></span></param>
        <summary><span data-ttu-id="e585d-353">Zwraca <paramref name="value" /> zamocowany do <paramref name="min" /> zakresu włącznie i <paramref name="max" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-353">Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</span></span></summary>
        <returns><span data-ttu-id="e585d-354"><paramref name="value" />Jeśli <paramref name="min" /> ≤ <paramref name="value" /> ≤ .<paramref name="max" /></span><span class="sxs-lookup"><span data-stu-id="e585d-354"><paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.</span></span>  
  
<span data-ttu-id="e585d-355">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-355">-or-</span></span> 
 <span data-ttu-id="e585d-356"><paramref name="min" />Jeśli <paramref name="value" /> .&lt; <paramref name="min" /></span><span class="sxs-lookup"><span data-stu-id="e585d-356"><paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.</span></span>
  
<span data-ttu-id="e585d-357">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-357">-or-</span></span> 
 <span data-ttu-id="e585d-358"><paramref name="max" />Jeśli <paramref name="max" /> .&lt; <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="e585d-358"><paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ulong Clamp (ulong value, ulong min, ulong max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Clamp(unsigned int64 value, unsigned int64 min, unsigned int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt64,System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As ULong, min As ULong, max As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Clamp(System::UInt64 value, System::UInt64 min, System::UInt64 max);" />
      <MemberSignature Language="F#" Value="static member Clamp : uint64 * uint64 * uint64 -&gt; uint64" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="min" Type="System.UInt64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="max" Type="System.UInt64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-359">Wartość, która ma zostać zamocowana.</span><span class="sxs-lookup"><span data-stu-id="e585d-359">The value to be clamped.</span></span></param>
        <param name="min"><span data-ttu-id="e585d-360">Dolna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-360">The lower bound of the result.</span></span></param>
        <param name="max"><span data-ttu-id="e585d-361">Górna granica wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-361">The upper bound of the result.</span></span></param>
        <summary><span data-ttu-id="e585d-362">Zwraca <paramref name="value" /> zamocowany do <paramref name="min" /> zakresu włącznie i <paramref name="max" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-362">Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</span></span></summary>
        <returns><span data-ttu-id="e585d-363"><paramref name="value" />Jeśli <paramref name="min" /> ≤ <paramref name="value" /> ≤ .<paramref name="max" /></span><span class="sxs-lookup"><span data-stu-id="e585d-363"><paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.</span></span>
  
<span data-ttu-id="e585d-364">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-364">-or-</span></span> 
 <span data-ttu-id="e585d-365"><paramref name="min" />Jeśli <paramref name="value" /> .&lt; <paramref name="min" /></span><span class="sxs-lookup"><span data-stu-id="e585d-365"><paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.</span></span>
  
<span data-ttu-id="e585d-366">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-366">-or-</span></span> 
 <span data-ttu-id="e585d-367"><paramref name="max" />Jeśli <paramref name="max" /> .&lt; <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="e585d-367"><paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySign">
      <MemberSignature Language="C#" Value="public static double CopySign (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CopySign(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.CopySign(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CopySign (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CopySign(double x, double y);" />
      <MemberSignature Language="F#" Value="static member CopySign : double * double -&gt; double" Usage="System.Math.CopySign (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="e585d-368">Liczba, której wartość jest używana w wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-368">A number whose magnitude is used in the result.</span></span></param>
        <param name="y"><span data-ttu-id="e585d-369">Liczba, której znak jest używany w wyniku.</span><span class="sxs-lookup"><span data-stu-id="e585d-369">A number whose sign is the used in the result.</span></span></param>
        <summary><span data-ttu-id="e585d-370">Zwraca wartość o wielkości <paramref name="x" /> i <paramref name="y" />znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-370">Returns a value with the magnitude of <paramref name="x" /> and the sign of <paramref name="y" />.</span></span></summary>
        <returns><span data-ttu-id="e585d-371">Wartość z wielkością <paramref name="x" /> i <paramref name="y" />znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-371">A value with the magnitude of <paramref name="x" /> and the sign of <paramref name="y" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static double Cos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cos(double d);" />
      <MemberSignature Language="F#" Value="static member Cos : double -&gt; double" Usage="System.Math.Cos d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-372">Kąt wyrażony w radianach.</span><span class="sxs-lookup"><span data-stu-id="e585d-372">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="e585d-373">Zwraca cosinus określonego kąta.</span><span class="sxs-lookup"><span data-stu-id="e585d-373">Returns the cosine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="e585d-374">Cosinus <paramref name="d" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-374">The cosine of <paramref name="d" />.</span></span> <span data-ttu-id="e585d-375">Jeśli <paramref name="d" /> <see cref="F:System.Double.NegativeInfinity" />jest <see cref="F:System.Double.PositiveInfinity" />równa <see cref="F:System.Double.NaN" />,, lub, ta metoda zwraca. <see cref="F:System.Double.NaN" /></span><span class="sxs-lookup"><span data-stu-id="e585d-375">If <paramref name="d" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-376">Kąt, `d`, musi być w radianach.</span><span class="sxs-lookup"><span data-stu-id="e585d-376">The angle, `d`, must be in radians.</span></span> <span data-ttu-id="e585d-377">Pomnóż przez <xref:System.Math.PI?displayProperty=nameWithType>/180, aby przekonwertować stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="e585d-377">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 <span data-ttu-id="e585d-378">Akceptowalne wartości `d` zakresu od około 9223372036854775295 do około 9223372036854775295.</span><span class="sxs-lookup"><span data-stu-id="e585d-378">Acceptable values of `d` range from approximately -9223372036854775295 to approximately 9223372036854775295.</span></span> <span data-ttu-id="e585d-379">W przypadku wartości spoza tego zakresu <xref:System.Math.Cos%2A> Metoda zwraca `d` niezmieniony, zamiast zgłaszać wyjątek.</span><span class="sxs-lookup"><span data-stu-id="e585d-379">For values outside this range, the <xref:System.Math.Cos%2A> method returns `d` unchanged rather than throwing an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-380">Poniższy przykład używa <xref:System.Math.Cos%2A> do obliczania niektórych kątów tożsamości dla wybranych kątów.</span><span class="sxs-lookup"><span data-stu-id="e585d-380">The following example uses <xref:System.Math.Cos%2A> to evaluate certain trigonometric identities for selected angles.</span></span>  
  
 [!code-cpp[System.Math.SinCos#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp#1)]
 [!code-csharp[System.Math.SinCos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs#1)]
 [!code-vb[System.Math.SinCos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static double Cosh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cosh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cosh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cosh(double value);" />
      <MemberSignature Language="F#" Value="static member Cosh : double -&gt; double" Usage="System.Math.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-381">Kąt wyrażony w radianach.</span><span class="sxs-lookup"><span data-stu-id="e585d-381">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="e585d-382">Zwraca cosinus hiperboliczny odpowiadający podanemu kątowi.</span><span class="sxs-lookup"><span data-stu-id="e585d-382">Returns the hyperbolic cosine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="e585d-383">Cosinus hiperboliczny <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-383">The hyperbolic cosine of <paramref name="value" />.</span></span> <span data-ttu-id="e585d-384">Jeśli <paramref name="value" /> jest <see cref="F:System.Double.PositiveInfinity" /> równa<see cref="F:System.Double.PositiveInfinity" />lub, jest zwracana. <see cref="F:System.Double.NegativeInfinity" /></span><span class="sxs-lookup"><span data-stu-id="e585d-384">If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" /> or <see cref="F:System.Double.PositiveInfinity" />, <see cref="F:System.Double.PositiveInfinity" /> is returned.</span></span> <span data-ttu-id="e585d-385">Jeśli <paramref name="value" /> jest <see cref="F:System.Double.NaN" /> równa, jest zwracana. <see cref="F:System.Double.NaN" /></span><span class="sxs-lookup"><span data-stu-id="e585d-385">If <paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-386">Kąt, `value`, musi być w radianach.</span><span class="sxs-lookup"><span data-stu-id="e585d-386">The angle, `value`, must be in radians.</span></span> <span data-ttu-id="e585d-387">Pomnóż przez <xref:System.Math.PI?displayProperty=nameWithType>/180, aby przekonwertować stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="e585d-387">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-388">Poniższy przykład używa <xref:System.Math.Cosh%2A> do obliczania niektórych tożsamości hiperbolicznych dla wybranych wartości.</span><span class="sxs-lookup"><span data-stu-id="e585d-388">The following example uses <xref:System.Math.Cosh%2A> to evaluate certain hyperbolic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.SinhCosh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp#1)]
 [!code-csharp[System.Math.SinhCosh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs#1)]
 [!code-vb[System.Math.SinhCosh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivRem">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e585d-389">Oblicza iloraz dwóch liczb, a także Zwraca resztę w parametrze wyjściowym.</span><span class="sxs-lookup"><span data-stu-id="e585d-389">Calculates the quotient of two numbers and also returns the remainder in an output parameter.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static int DivRem (int a, int b, out int result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 DivRem(int32 a, int32 b, [out] int32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (a As Integer, b As Integer, ByRef result As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int DivRem(int a, int b, [Runtime::InteropServices::Out] int % result);" />
      <MemberSignature Language="F#" Value="static member DivRem : int * int *  -&gt; int" Usage="System.Math.DivRem (a, b, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="b" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="e585d-390">Dzielna.</span><span class="sxs-lookup"><span data-stu-id="e585d-390">The dividend.</span></span></param>
        <param name="b"><span data-ttu-id="e585d-391">Dzielnik.</span><span class="sxs-lookup"><span data-stu-id="e585d-391">The divisor.</span></span></param>
        <param name="result"><span data-ttu-id="e585d-392">Resztę.</span><span class="sxs-lookup"><span data-stu-id="e585d-392">The remainder.</span></span></param>
        <summary><span data-ttu-id="e585d-393">Oblicza iloraz 2 32-bitowych liczb całkowitych ze znakiem, a także Zwraca resztę w parametrze wyjściowym.</span><span class="sxs-lookup"><span data-stu-id="e585d-393">Calculates the quotient of two 32-bit signed integers and also returns the remainder in an output parameter.</span></span></summary>
        <returns><span data-ttu-id="e585d-394">Iloraz określonych liczb.</span><span class="sxs-lookup"><span data-stu-id="e585d-394">The quotient of the specified numbers.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-395">Wartość reszty jest równa wynikowi [operatora](~/docs/csharp/language-reference/operators/remainder-operator.md)pozostałej części.</span><span class="sxs-lookup"><span data-stu-id="e585d-395">The remainder value equals the result of the [remainder operator](~/docs/csharp/language-reference/operators/remainder-operator.md).</span></span>  
   
## Examples  
 <span data-ttu-id="e585d-396">Poniższy przykład demonstruje <xref:System.Math.DivRem%28System.Int32%2CSystem.Int32%2CSystem.Int32%40%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="e585d-396">The following example demonstrates the <xref:System.Math.DivRem%28System.Int32%2CSystem.Int32%2CSystem.Int32%40%29> method.</span></span>  
  
 [!code-csharp[System.Math.DivRem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem1.cs#1)]
 [!code-vb[System.Math.DivRem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><span data-ttu-id="e585d-397"><paramref name="b" />ma wartość zero.</span><span class="sxs-lookup"><span data-stu-id="e585d-397"><paramref name="b" /> is zero.</span></span></exception>
        <altmember cref="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static long DivRem (long a, long b, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 DivRem(int64 a, int64 b, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (a As Long, b As Long, ByRef result As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long DivRem(long a, long b, [Runtime::InteropServices::Out] long % result);" />
      <MemberSignature Language="F#" Value="static member DivRem : int64 * int64 *  -&gt; int64" Usage="System.Math.DivRem (a, b, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="b" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Int64" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="e585d-398">Dzielna.</span><span class="sxs-lookup"><span data-stu-id="e585d-398">The dividend.</span></span></param>
        <param name="b"><span data-ttu-id="e585d-399">Dzielnik.</span><span class="sxs-lookup"><span data-stu-id="e585d-399">The divisor.</span></span></param>
        <param name="result"><span data-ttu-id="e585d-400">Resztę.</span><span class="sxs-lookup"><span data-stu-id="e585d-400">The remainder.</span></span></param>
        <summary><span data-ttu-id="e585d-401">Oblicza iloraz 2 64-bitowych liczb całkowitych ze znakiem, a także Zwraca resztę w parametrze wyjściowym.</span><span class="sxs-lookup"><span data-stu-id="e585d-401">Calculates the quotient of two 64-bit signed integers and also returns the remainder in an output parameter.</span></span></summary>
        <returns><span data-ttu-id="e585d-402">Iloraz określonych liczb.</span><span class="sxs-lookup"><span data-stu-id="e585d-402">The quotient of the specified numbers.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-403">Wartość reszty jest równa wynikowi [operatora](~/docs/csharp/language-reference/operators/remainder-operator.md)pozostałej części.</span><span class="sxs-lookup"><span data-stu-id="e585d-403">The remainder value equals the result of the [remainder operator](~/docs/csharp/language-reference/operators/remainder-operator.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-404">Poniższy przykład demonstruje <xref:System.Math.DivRem%28System.Int64%2CSystem.Int64%2CSystem.Int64%40%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="e585d-404">The following example demonstrates the <xref:System.Math.DivRem%28System.Int64%2CSystem.Int64%2CSystem.Int64%40%29> method.</span></span>  
  
 [!code-csharp[System.Math.DivRem#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem2.cs#2)]
 [!code-vb[System.Math.DivRem#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><span data-ttu-id="e585d-405"><paramref name="b" />ma wartość zero.</span><span class="sxs-lookup"><span data-stu-id="e585d-405"><paramref name="b" /> is zero.</span></span></exception>
        <altmember cref="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public const double E = 2.71828182845905;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 E = (2.71828182845905)" />
      <MemberSignature Language="DocId" Value="F:System.Math.E" />
      <MemberSignature Language="VB.NET" Value="Public Const E As Double  = 2.71828182845905" />
      <MemberSignature Language="C++ CLI" Value="public: double E = 2.71828182845905;" />
      <MemberSignature Language="F#" Value="val mutable E : double" Usage="System.Math.E" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>2.71828182845905</MemberValue>
      <Docs>
        <summary><span data-ttu-id="e585d-406">Reprezentuje logarytm naturalny, określony przez stałą, <see langword="e" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-406">Represents the natural logarithmic base, specified by the constant, <see langword="e" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-407">Wartość tego pola to 2.7182818284590451.</span><span class="sxs-lookup"><span data-stu-id="e585d-407">The value of this field is 2.7182818284590451.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-408">Poniższy przykład porównuje <xref:System.Math.E> z wartością obliczaną z serii potęgi.</span><span class="sxs-lookup"><span data-stu-id="e585d-408">The following example compares <xref:System.Math.E> with the value calculated from a power series.</span></span>  
  
 [!code-cpp[System.Math.E#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.E/CPP/efield.cpp#1)]
 [!code-csharp[System.Math.E#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.E/CS/efield.cs#1)]
 [!code-vb[System.Math.E#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.E/VB/efield.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static double Exp (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exp(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Exp(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exp(double d);" />
      <MemberSignature Language="F#" Value="static member Exp : double -&gt; double" Usage="System.Math.Exp d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-409">Liczba określająca potęgę.</span><span class="sxs-lookup"><span data-stu-id="e585d-409">A number specifying a power.</span></span></param>
        <summary><span data-ttu-id="e585d-410">Zwraca <see langword="e" /> wartość podniesioną do określonej potęgi.</span><span class="sxs-lookup"><span data-stu-id="e585d-410">Returns <see langword="e" /> raised to the specified power.</span></span></summary>
        <returns><span data-ttu-id="e585d-411">Liczba <see langword="e" /> podniesiona do potęgi <paramref name="d" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-411">The number <see langword="e" /> raised to the power <paramref name="d" />.</span></span> <span data-ttu-id="e585d-412">Jeśli <paramref name="d" /> jest <see cref="F:System.Double.NaN" /> równa lub <see cref="F:System.Double.PositiveInfinity" />, ta wartość jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="e585d-412">If <paramref name="d" /> equals <see cref="F:System.Double.NaN" /> or <see cref="F:System.Double.PositiveInfinity" />, that value is returned.</span></span> <span data-ttu-id="e585d-413">Jeśli <paramref name="d" /> jest <see cref="F:System.Double.NegativeInfinity" />równe, zwracana jest wartość 0.</span><span class="sxs-lookup"><span data-stu-id="e585d-413">If <paramref name="d" /> equals <see cref="F:System.Double.NegativeInfinity" />, 0 is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-414">`e`jest stałą matematyczną, której wartość wynosi około 2,71828.</span><span class="sxs-lookup"><span data-stu-id="e585d-414">`e` is a mathematical constant whose value is approximately 2.71828.</span></span>  
  
 <span data-ttu-id="e585d-415">Użyj metody <xref:System.Math.Pow%2A> , aby obliczyć kompetencje innych baz.</span><span class="sxs-lookup"><span data-stu-id="e585d-415">Use the <xref:System.Math.Pow%2A> method to calculate powers of other bases.</span></span>  
  
 <span data-ttu-id="e585d-416"><xref:System.Math.Exp%2A>jest odwrotnością <xref:System.Math.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="e585d-416"><xref:System.Math.Exp%2A> is the inverse of <xref:System.Math.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-417">Poniższy przykład używa <xref:System.Math.Exp%2A> do szacowania niektórych tożsamości wykładniczych i logarytmicznych dla wybranych wartości.</span><span class="sxs-lookup"><span data-stu-id="e585d-417">The following example uses <xref:System.Math.Exp%2A> to evaluate certain exponential and logarithmic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.Exp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Exp/CPP/exp.cpp#1)]
 [!code-csharp[System.Math.Exp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Exp/CS/exp.cs#1)]
 [!code-vb[System.Math.Exp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Exp/VB/exp.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Math.E" />
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
        <altmember cref="M:System.Math.Log(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Floor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e585d-418">Zwraca największą wartość całkowitą mniejszą lub równą podanej liczbie.</span><span class="sxs-lookup"><span data-stu-id="e585d-418">Returns the largest integral value less than or equal to the specified number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-419">Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="e585d-419">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="e585d-420">Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku minus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="e585d-420">This kind of rounding is sometimes called rounding toward negative infinity.</span></span>  

## Examples

[!INCLUDE[midpoint-rounding](~/includes/csharp-interactive-note.md)]

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static decimal Floor (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Floor(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Floor(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Floor : decimal -&gt; decimal" Usage="System.Math.Floor d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-421">Liczba dziesiętna.</span><span class="sxs-lookup"><span data-stu-id="e585d-421">A decimal number.</span></span></param>
        <summary><span data-ttu-id="e585d-422">Zwraca największą wartość całkowitą mniejszą lub równą określonej liczbie dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="e585d-422">Returns the largest integral value less than or equal to the specified decimal number.</span></span></summary>
        <returns><span data-ttu-id="e585d-423">Największa wartość całkowita mniejsza lub równa <paramref name="d" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-423">The largest integral value less than or equal to <paramref name="d" />.</span></span>  <span data-ttu-id="e585d-424">Należy zauważyć, że metoda zwraca wartość całkowitą typu <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-424">Note that the method returns an integral value of type <see cref="T:System.Decimal" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-425">Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="e585d-425">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="e585d-426">Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku minus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="e585d-426">This kind of rounding is sometimes called rounding toward negative infinity.</span></span> <span data-ttu-id="e585d-427">Innymi słowy, jeśli `d` ma wartość dodatnią, dowolny składnik częściowy zostanie obcięty.</span><span class="sxs-lookup"><span data-stu-id="e585d-427">In other words, if `d` is positive, any fractional component is truncated.</span></span> <span data-ttu-id="e585d-428">Jeśli `d` jest ujemna, obecność dowolnego komponentu ułamkowego powoduje Zaokrąglenie do mniejszej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="e585d-428">If `d` is negative, the presence of any fractional component causes it to be rounded to the smaller integer.</span></span> <span data-ttu-id="e585d-429">Operacja tej metody różni się od <xref:System.Math.Ceiling%2A> metody, która obsługuje zaokrąglanie w kierunku nieskończoności dodatniej.</span><span class="sxs-lookup"><span data-stu-id="e585d-429">The operation of this method differs from the <xref:System.Math.Ceiling%2A> method, which supports rounding toward positive infinity.</span></span>  

## Examples  
 <span data-ttu-id="e585d-430">Poniższy przykład ilustruje <xref:System.Math.Floor%28System.Decimal%29?displayProperty=nameWithType> metodę i kontrastuje ją <xref:System.Math.Ceiling%28System.Decimal%29> z metodą.</span><span class="sxs-lookup"><span data-stu-id="e585d-430">The following example illustrates the <xref:System.Math.Floor%28System.Decimal%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Ceiling%28System.Decimal%29> method.</span></span>  
  
 [!code-csharp-interactive[System.Math.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#1)]
 [!code-vb[System.Math.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Decimal.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static double Floor (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Floor(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Floor(double d);" />
      <MemberSignature Language="F#" Value="static member Floor : double -&gt; double" Usage="System.Math.Floor d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-431">Liczba zmiennoprzecinkowa podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-431">A double-precision floating-point number.</span></span></param>
        <summary><span data-ttu-id="e585d-432">Zwraca największą wartość całkowitą mniejszą lub równą podanej liczbie zmiennoprzecinkowej podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-432">Returns the largest integral value less than or equal to the specified double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="e585d-433">Największa wartość całkowita mniejsza lub równa <paramref name="d" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-433">The largest integral value less than or equal to <paramref name="d" />.</span></span> <span data-ttu-id="e585d-434">Jeśli <paramref name="d" /> jest <see cref="F:System.Double.NaN" />równe ,<see cref="F:System.Double.NegativeInfinity" />, lub<see cref="F:System.Double.PositiveInfinity" />, ta wartość jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="e585d-434">If <paramref name="d" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, that value is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-435">Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="e585d-435">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="e585d-436">Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku minus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="e585d-436">This kind of rounding is sometimes called rounding toward negative infinity.</span></span> <span data-ttu-id="e585d-437">Innymi słowy, jeśli `d` ma wartość dodatnią, dowolny składnik częściowy zostanie obcięty.</span><span class="sxs-lookup"><span data-stu-id="e585d-437">In other words, if `d` is positive, any fractional component is truncated.</span></span> <span data-ttu-id="e585d-438">Jeśli `d` jest ujemna, obecność dowolnego komponentu ułamkowego powoduje Zaokrąglenie do mniejszej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="e585d-438">If `d` is negative, the presence of any fractional component causes it to be rounded to the smaller integer.</span></span> <span data-ttu-id="e585d-439">Operacja tej metody różni się od <xref:System.Math.Ceiling%2A> metody, która obsługuje zaokrąglanie w kierunku nieskończoności dodatniej.</span><span class="sxs-lookup"><span data-stu-id="e585d-439">The operation of this method differs from the <xref:System.Math.Ceiling%2A> method, which supports rounding toward positive infinity.</span></span>  

<span data-ttu-id="e585d-440">Począwszy od Visual Basic 15,8, wydajność konwersji podwójnej do liczby całkowitej jest zoptymalizowana, jeśli przekazujesz wartość zwróconą przez `Floor` metodę do którejkolwiek [funkcji konwersji całkowitej](~/docs/visual-basic/language-reference/functions/conversion-functions.md)lub jeśli wartość podwójna zwracana przez `Floor` jest automatycznie konwertowany na liczbę całkowitą z [opcją Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) ustawioną na wartość off.</span><span class="sxs-lookup"><span data-stu-id="e585d-440">Starting with Visual Basic 15.8, the performance of Double-to-integer conversion is optimized if you pass the value returned by the `Floor` method to the any of the [integral conversion functions](~/docs/visual-basic/language-reference/functions/conversion-functions.md), or if the Double value returned by `Floor` is automatically converted to an integer with [Option Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) set to Off.</span></span> <span data-ttu-id="e585d-441">Ta optymalizacja umożliwia szybsze uruchamianie kodu — maksymalnie dwa razy w przypadku kodu, który wykonuje dużą liczbę konwersji na typy całkowite.</span><span class="sxs-lookup"><span data-stu-id="e585d-441">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="e585d-442">Poniższy przykład ilustruje takie zoptymalizowane konwersje:</span><span class="sxs-lookup"><span data-stu-id="e585d-442">The following example illustrates such optimized conversions:</span></span>
   
```vb
Dim d1 As Double = 1043.75133
Dim i1 As Integer = CInt(Math.Ceiling(d1))        ' Result: 1043

Dim d2 As Double = 7968.4136
Dim i2 As Integer = CInt(Math.Ceiling(d2))        ' Result: 7968
```

## Examples  
 <span data-ttu-id="e585d-443">Poniższy przykład ilustruje <xref:System.Math.Floor%28System.Double%29?displayProperty=nameWithType> metodę i kontrastuje ją <xref:System.Math.Ceiling%28System.Double%29> z metodą.</span><span class="sxs-lookup"><span data-stu-id="e585d-443">The following example illustrates the <xref:System.Math.Floor%28System.Double%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Ceiling%28System.Double%29> method.</span></span>  
  
 [!code-csharp-interactive[System.Math.Ceiling#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#2)]
 [!code-vb[System.Math.Ceiling#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FusedMultiplyAdd">
      <MemberSignature Language="C#" Value="public static double FusedMultiplyAdd (double x, double y, double z);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 FusedMultiplyAdd(float64 x, float64 y, float64 z) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.FusedMultiplyAdd(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FusedMultiplyAdd (x As Double, y As Double, z As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double FusedMultiplyAdd(double x, double y, double z);" />
      <MemberSignature Language="F#" Value="static member FusedMultiplyAdd : double * double * double -&gt; double" Usage="System.Math.FusedMultiplyAdd (x, y, z)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="z" Type="System.Double" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="e585d-444">Liczba, z <paramref name="y" />którą ma zostać pomnożona wartość.</span><span class="sxs-lookup"><span data-stu-id="e585d-444">The number to be multiplied with <paramref name="y" />.</span></span></param>
        <param name="y"><span data-ttu-id="e585d-445">Liczba, z <paramref name="x" />którą ma zostać pomnożona wartość.</span><span class="sxs-lookup"><span data-stu-id="e585d-445">The number to be multiplied with <paramref name="x" />.</span></span></param>
        <param name="z"><span data-ttu-id="e585d-446">Liczba, która ma zostać dodana do wyniku <paramref name="x" /> mnożenia przez. <paramref name="y" /></span><span class="sxs-lookup"><span data-stu-id="e585d-446">The number to be added to the result of <paramref name="x" /> multiplied by <paramref name="y" />.</span></span></param>
        <summary><span data-ttu-id="e585d-447">Zwraca (x \* y) + z, zaokrąglone jako jedna operacja Trzyelementowy.</span><span class="sxs-lookup"><span data-stu-id="e585d-447">Returns (x \* y) + z, rounded as one ternary operation.</span></span></summary>
        <returns><span data-ttu-id="e585d-448">(x \* y) + z, zaokrąglone jako jedna operacja Trzyelementowy.</span><span class="sxs-lookup"><span data-stu-id="e585d-448">(x \* y) + z, rounded as one ternary operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-449">Ta wartość jest `(x * y)` obliczana tak, jakby była nieskończona `z` precyzja, dodaje do tego wyniku tak, jakby była nieskończona precyzja, a wreszcie zaokrągla do najbliższej reprezentacji wartości.</span><span class="sxs-lookup"><span data-stu-id="e585d-449">This computes `(x * y)` as if to infinite precision, adds `z` to that result as if to infinite precision, and finally rounds to the nearest representable value.</span></span>
  
 <span data-ttu-id="e585d-450">Różni się to od odrzucanej sekwencji, która może `(x * y)` zostać obliczona tak, jakby była nieskończona precyzja, zaokrąglić wynik do najbliższej `z` wartości z możliwością zaprezentowania, dodać do zaokrąglonego wyniku, tak jakby miał nieskończoną precyzję, a wreszcie zaokrąglić do najbliższej wartość do zaprezentowania.</span><span class="sxs-lookup"><span data-stu-id="e585d-450">This differs from the non-fused sequence which would compute `(x * y)` as if to infinite precision, round the result to the nearest representable value, add `z` to the rounded result as if to infinite precision, and finally round to the nearest representable value.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IEEERemainder">
      <MemberSignature Language="C#" Value="public static double IEEERemainder (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 IEEERemainder(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IEEERemainder (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double IEEERemainder(double x, double y);" />
      <MemberSignature Language="F#" Value="static member IEEERemainder : double * double -&gt; double" Usage="System.Math.IEEERemainder (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="e585d-451">Dywidenda.</span><span class="sxs-lookup"><span data-stu-id="e585d-451">A dividend.</span></span></param>
        <param name="y"><span data-ttu-id="e585d-452">Dzielnik.</span><span class="sxs-lookup"><span data-stu-id="e585d-452">A divisor.</span></span></param>
        <summary><span data-ttu-id="e585d-453">Zwraca resztę z dzielenia przez określony numer przez inny określony numer.</span><span class="sxs-lookup"><span data-stu-id="e585d-453">Returns the remainder resulting from the division of a specified number by another specified number.</span></span></summary>
        <returns><span data-ttu-id="e585d-454">Liczba równa <paramref name="x" /> -( <paramref name="y" /> <paramref name="x" /> <paramref name="y" /> <paramref name="x" /> <paramref name="y" /> Q), gdzie  /  Q jest ilorazem zaokrąglonym do najbliższej liczby całkowitej (Jeśli  /  jest w połowie między dwoma liczbami całkowitymi, zwracana jest parzysta liczba całkowita).</span><span class="sxs-lookup"><span data-stu-id="e585d-454">A number equal to <paramref name="x" /> - (<paramref name="y" /> Q), where Q is the quotient of <paramref name="x" /> / <paramref name="y" /> rounded to the nearest integer (if <paramref name="x" /> / <paramref name="y" /> falls halfway between two integers, the even integer is returned).</span></span>  
  
<span data-ttu-id="e585d-455">Jeśli <paramref name="x" /> -(<paramref name="y" /> Q) jest zerem, wartość + 0 jest zwracana w przypadku <paramref name="x" /> wartości dodatnich lub-0, <paramref name="x" /> jeśli jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="e585d-455">If <paramref name="x" /> - (<paramref name="y" /> Q) is zero, the value +0 is returned if <paramref name="x" /> is positive, or -0 if <paramref name="x" /> is negative.</span></span>  
  
<span data-ttu-id="e585d-456">Jeśli <paramref name="y" /> wartość = 0 <see cref="F:System.Double.NaN" /> , jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="e585d-456">If <paramref name="y" /> = 0, <see cref="F:System.Double.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-457">Ta operacja jest zgodna z operacją reszty zdefiniowaną w sekcji 5,1 ANSI/IEEE Std 754-1985; IEEE Standard dla binarnej arytmetycznej liczby zmiennoprzecinkowej; Institute of Electrical and Electronics Engineers, Inc; 1985.</span><span class="sxs-lookup"><span data-stu-id="e585d-457">This operation complies with the remainder operation defined in Section 5.1 of ANSI/IEEE Std 754-1985; IEEE Standard for Binary Floating-Point Arithmetic; Institute of Electrical and Electronics Engineers, Inc; 1985.</span></span>  
  
 <span data-ttu-id="e585d-458">Metoda nie jest taka sama jak [operator reszty.](~/docs/csharp/language-reference/operators/remainder-operator.md) <xref:System.Math.IEEERemainder%2A></span><span class="sxs-lookup"><span data-stu-id="e585d-458">The <xref:System.Math.IEEERemainder%2A> method is not the same as the [remainder operator](~/docs/csharp/language-reference/operators/remainder-operator.md).</span></span> <span data-ttu-id="e585d-459">Mimo że obie zwracają resztę po dzielenie, używane formuły są różne.</span><span class="sxs-lookup"><span data-stu-id="e585d-459">Although both return the remainder after division, the formulas they use are different.</span></span> <span data-ttu-id="e585d-460">Formuła dla <xref:System.Math.IEEERemainder%2A> metody jest:</span><span class="sxs-lookup"><span data-stu-id="e585d-460">The formula for the <xref:System.Math.IEEERemainder%2A> method is:</span></span>  
  
```  
IEEERemainder = dividend - (divisor * Math.Round(dividend / divisor))  
```  
  
 <span data-ttu-id="e585d-461">W przeciwieństwie do formuły dla operatora reszty jest:</span><span class="sxs-lookup"><span data-stu-id="e585d-461">In contrast, the formula for the remainder operator is:</span></span>  
  
```  
Remainder = (Math.Abs(dividend) - (Math.Abs(divisor) *   
            (Math.Floor(Math.Abs(dividend) / Math.Abs(divisor))))) *   
            Math.Sign(dividend)  
```  
  
   
  
## Examples  
 <span data-ttu-id="e585d-462">Poniższy przykład kontrastuje resztę zwracaną przez <xref:System.Math.IEEERemainder%2A> metodę z resztą zwróconą przez [operator reszty](~/docs/csharp/language-reference/operators/remainder-operator.md).</span><span class="sxs-lookup"><span data-stu-id="e585d-462">The following example contrasts the remainder returned by the <xref:System.Math.IEEERemainder%2A> method with the remainder returned by the [remainder operator](~/docs/csharp/language-reference/operators/remainder-operator.md).</span></span>  
  
 [!code-csharp[System.Math.IEEERemainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.ieeeremainder/cs/ieeeremainder1.cs#1)]
 [!code-vb[System.Math.IEEERemainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.ieeeremainder/vb/ieeeremainder1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ILogB">
      <MemberSignature Language="C#" Value="public static int ILogB (double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ILogB(float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.ILogB(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ILogB (x As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ILogB(double x);" />
      <MemberSignature Language="F#" Value="static member ILogB : double -&gt; int" Usage="System.Math.ILogB x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="e585d-463">Liczba, której LOGARYTM ma zostać znaleziony.</span><span class="sxs-lookup"><span data-stu-id="e585d-463">The number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="e585d-464">Zwraca logarytm dziesiętny z podanej liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-464">Returns the base 2 integer logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="e585d-465">Jedna z wartości w tabeli poniżej.</span><span class="sxs-lookup"><span data-stu-id="e585d-465">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="e585d-466"><paramref name="x" />konstruktora</span><span class="sxs-lookup"><span data-stu-id="e585d-466"><paramref name="x" /> parameter</span></span> 
 </term><description> <span data-ttu-id="e585d-467">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-467">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="e585d-468">Domyślny</span><span class="sxs-lookup"><span data-stu-id="e585d-468">Default</span></span> 
 </term><description> <span data-ttu-id="e585d-469">Dziennik <paramref name="x" />w postaci liczby całkowitej 2, czyli (int) log2 — (<paramref name="x" />).</span><span class="sxs-lookup"><span data-stu-id="e585d-469">The base 2 integer log of <paramref name="x" />; that is, (int)log2(<paramref name="x" />).</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-470">Zero</span><span class="sxs-lookup"><span data-stu-id="e585d-470">Zero</span></span> 
 </term><description><see cref="F:System.Int32.MinValue" /></description></item><item><term> <span data-ttu-id="e585d-471"><see cref="F:System.Double.NaN" /> Równe lub lub<see cref="F:System.Double.PositiveInfinity" /><see cref="F:System.Double.NegativeInfinity" /></span><span class="sxs-lookup"><span data-stu-id="e585d-471">Equal to <see cref="F:System.Double.NaN" /> or <see cref="F:System.Double.PositiveInfinity" /> or <see cref="F:System.Double.NegativeInfinity" /></span></span></term><description><see cref="F:System.Int32.MaxValue" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-472">Parametr `x` jest określony jako numer podstawowy 10.</span><span class="sxs-lookup"><span data-stu-id="e585d-472">Parameter `x` is specified as a base 10 number.</span></span>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e585d-473">Zwraca wartość logarytmu określonej liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-473">Returns the logarithm of a specified number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(double d);" />
      <MemberSignature Language="F#" Value="static member Log : double -&gt; double" Usage="System.Math.Log d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-474">Liczba, której LOGARYTM ma zostać znaleziony.</span><span class="sxs-lookup"><span data-stu-id="e585d-474">The number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="e585d-475">Zwraca logarytm naturalny (podstawowy <see langword="e" />) podanej liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-475">Returns the natural (base <see langword="e" />) logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="e585d-476">Jedna z wartości w tabeli poniżej.</span><span class="sxs-lookup"><span data-stu-id="e585d-476">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="e585d-477"><paramref name="d" />konstruktora</span><span class="sxs-lookup"><span data-stu-id="e585d-477"><paramref name="d" /> parameter</span></span> 
 </term><description> <span data-ttu-id="e585d-478">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-478">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="e585d-479">Dodatnie</span><span class="sxs-lookup"><span data-stu-id="e585d-479">Positive</span></span> 
 </term><description> <span data-ttu-id="e585d-480">Logarytm naturalny z <paramref name="d" />; to jest, LN <paramref name="d" />lub log e<paramref name="d" /></span><span class="sxs-lookup"><span data-stu-id="e585d-480">The natural logarithm of <paramref name="d" />; that is, ln <paramref name="d" />, or log e <paramref name="d" /></span></span></description></item><item><term> <span data-ttu-id="e585d-481">Zero</span><span class="sxs-lookup"><span data-stu-id="e585d-481">Zero</span></span> 
 </term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> <span data-ttu-id="e585d-482">Ujemne</span><span class="sxs-lookup"><span data-stu-id="e585d-482">Negative</span></span> 
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term> <span data-ttu-id="e585d-483">Równa się<see cref="F:System.Double.NaN" /></span><span class="sxs-lookup"><span data-stu-id="e585d-483">Equal to <see cref="F:System.Double.NaN" /></span></span></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> <span data-ttu-id="e585d-484">Równa się<see cref="F:System.Double.PositiveInfinity" /></span><span class="sxs-lookup"><span data-stu-id="e585d-484">Equal to <see cref="F:System.Double.PositiveInfinity" /></span></span></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-485">Parametr `d` jest określony jako numer podstawowy 10.</span><span class="sxs-lookup"><span data-stu-id="e585d-485">Parameter `d` is specified as a base 10 number.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-486">Poniższy przykład ilustruje <xref:System.Math.Log%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="e585d-486">The following example illustrates the <xref:System.Math.Log%2A> method.</span></span>  
  
 [!code-csharp[System.Math.Log_Overloads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/log1.cs#2)]
 [!code-vb[System.Math.Log_Overloads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/log1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Math.E" />
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double a, double newBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 a, float64 newBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (a As Double, newBase As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(double a, double newBase);" />
      <MemberSignature Language="F#" Value="static member Log : double * double -&gt; double" Usage="System.Math.Log (a, newBase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
        <Parameter Name="newBase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="e585d-487">Liczba, której LOGARYTM ma zostać znaleziony.</span><span class="sxs-lookup"><span data-stu-id="e585d-487">The number whose logarithm is to be found.</span></span></param>
        <param name="newBase"><span data-ttu-id="e585d-488">Podstawa logarytmu.</span><span class="sxs-lookup"><span data-stu-id="e585d-488">The base of the logarithm.</span></span></param>
        <summary><span data-ttu-id="e585d-489">Zwraca logarytm o podanej liczbie w określonej bazie.</span><span class="sxs-lookup"><span data-stu-id="e585d-489">Returns the logarithm of a specified number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="e585d-490">Jedna z wartości w tabeli poniżej.</span><span class="sxs-lookup"><span data-stu-id="e585d-490">One of the values in the following table.</span></span> <span data-ttu-id="e585d-491">(+ Nieskończoność <see cref="F:System.Double.PositiveInfinity" />,-nieskończoność <see cref="F:System.Double.NegativeInfinity" /> <see cref="F:System.Double.NaN" />i Nan oznacza.)</span><span class="sxs-lookup"><span data-stu-id="e585d-491">(+Infinity denotes <see cref="F:System.Double.PositiveInfinity" />, -Infinity denotes <see cref="F:System.Double.NegativeInfinity" />, and NaN denotes <see cref="F:System.Double.NaN" />.)</span></span> 
 <list type="table"><listheader><term><paramref name="a" /></term><description><paramref name="newBase" /></description><description> <span data-ttu-id="e585d-492">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-492">Return value</span></span> 
 </description></listheader><item><term><span data-ttu-id="e585d-493"><paramref name="a" />&gt; 0</span><span class="sxs-lookup"><span data-stu-id="e585d-493"><paramref name="a" />&gt; 0</span></span> 
 </term><description> <span data-ttu-id="e585d-494">(0 &lt; <paramref name="newBase" /> 1)<paramref name="newBase" /> — lub-(&gt;1) &lt;</span><span class="sxs-lookup"><span data-stu-id="e585d-494">(0 &lt;<paramref name="newBase" />&lt; 1) -or-(<paramref name="newBase" />&gt; 1)</span></span> 
 </description><description> <span data-ttu-id="e585d-495">lognewBase (a)</span><span class="sxs-lookup"><span data-stu-id="e585d-495">lognewBase(a)</span></span> 
 </description></item><item><term><span data-ttu-id="e585d-496"><paramref name="a" />&lt; 0</span><span class="sxs-lookup"><span data-stu-id="e585d-496"><paramref name="a" />&lt; 0</span></span> 
 </term><description> <span data-ttu-id="e585d-497">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="e585d-497">(any value)</span></span> 
 </description><description> <span data-ttu-id="e585d-498">NaN</span><span class="sxs-lookup"><span data-stu-id="e585d-498">NaN</span></span> 
 </description></item><item><term> <span data-ttu-id="e585d-499">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="e585d-499">(any value)</span></span> 
 </term><description><span data-ttu-id="e585d-500"><paramref name="newBase" />&lt; 0</span><span class="sxs-lookup"><span data-stu-id="e585d-500"><paramref name="newBase" />&lt; 0</span></span> 
 </description><description> <span data-ttu-id="e585d-501">NaN</span><span class="sxs-lookup"><span data-stu-id="e585d-501">NaN</span></span> 
 </description></item><item><term><span data-ttu-id="e585d-502"><paramref name="a" /> != 1</span><span class="sxs-lookup"><span data-stu-id="e585d-502"><paramref name="a" /> != 1</span></span> 
 </term><description><span data-ttu-id="e585d-503"><paramref name="newBase" /> = 0</span><span class="sxs-lookup"><span data-stu-id="e585d-503"><paramref name="newBase" /> = 0</span></span> 
 </description><description> <span data-ttu-id="e585d-504">NaN</span><span class="sxs-lookup"><span data-stu-id="e585d-504">NaN</span></span> 
 </description></item><item><term><span data-ttu-id="e585d-505"><paramref name="a" /> != 1</span><span class="sxs-lookup"><span data-stu-id="e585d-505"><paramref name="a" /> != 1</span></span> 
 </term><description><span data-ttu-id="e585d-506"><paramref name="newBase" />= + Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="e585d-506"><paramref name="newBase" /> = +Infinity</span></span> 
 </description><description> <span data-ttu-id="e585d-507">NaN</span><span class="sxs-lookup"><span data-stu-id="e585d-507">NaN</span></span> 
 </description></item><item><term><span data-ttu-id="e585d-508"><paramref name="a" />= NaN</span><span class="sxs-lookup"><span data-stu-id="e585d-508"><paramref name="a" /> = NaN</span></span> 
 </term><description> <span data-ttu-id="e585d-509">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="e585d-509">(any value)</span></span> 
 </description><description> <span data-ttu-id="e585d-510">NaN</span><span class="sxs-lookup"><span data-stu-id="e585d-510">NaN</span></span> 
 </description></item><item><term> <span data-ttu-id="e585d-511">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="e585d-511">(any value)</span></span> 
 </term><description><span data-ttu-id="e585d-512"><paramref name="newBase" />= NaN</span><span class="sxs-lookup"><span data-stu-id="e585d-512"><paramref name="newBase" /> = NaN</span></span> 
 </description><description> <span data-ttu-id="e585d-513">NaN</span><span class="sxs-lookup"><span data-stu-id="e585d-513">NaN</span></span> 
 </description></item><item><term> <span data-ttu-id="e585d-514">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="e585d-514">(any value)</span></span> 
 </term><description><span data-ttu-id="e585d-515"><paramref name="newBase" /> = 1</span><span class="sxs-lookup"><span data-stu-id="e585d-515"><paramref name="newBase" /> = 1</span></span> 
 </description><description> <span data-ttu-id="e585d-516">NaN</span><span class="sxs-lookup"><span data-stu-id="e585d-516">NaN</span></span> 
 </description></item><item><term><span data-ttu-id="e585d-517"><paramref name="a" /> = 0</span><span class="sxs-lookup"><span data-stu-id="e585d-517"><paramref name="a" /> = 0</span></span> 
 </term><description> <span data-ttu-id="e585d-518">0 &lt; 1<paramref name="newBase" /> &lt;</span><span class="sxs-lookup"><span data-stu-id="e585d-518">0 &lt;<paramref name="newBase" />&lt; 1</span></span> 
 </description><description> <span data-ttu-id="e585d-519">+ Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="e585d-519">+Infinity</span></span> 
 </description></item><item><term><span data-ttu-id="e585d-520"><paramref name="a" /> = 0</span><span class="sxs-lookup"><span data-stu-id="e585d-520"><paramref name="a" /> = 0</span></span> 
 </term><description><span data-ttu-id="e585d-521"><paramref name="newBase" />&gt; 1</span><span class="sxs-lookup"><span data-stu-id="e585d-521"><paramref name="newBase" />&gt; 1</span></span> 
 </description><description> <span data-ttu-id="e585d-522">-Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="e585d-522">-Infinity</span></span> 
 </description></item><item><term><span data-ttu-id="e585d-523"><paramref name="a" />= + Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="e585d-523"><paramref name="a" /> =  +Infinity</span></span> 
 </term><description> <span data-ttu-id="e585d-524">0 &lt; 1<paramref name="newBase" /> &lt;</span><span class="sxs-lookup"><span data-stu-id="e585d-524">0 &lt;<paramref name="newBase" />&lt; 1</span></span> 
 </description><description> <span data-ttu-id="e585d-525">-Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="e585d-525">-Infinity</span></span> 
 </description></item><item><term><span data-ttu-id="e585d-526"><paramref name="a" />= + Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="e585d-526"><paramref name="a" /> =  +Infinity</span></span> 
 </term><description><span data-ttu-id="e585d-527"><paramref name="newBase" />&gt; 1</span><span class="sxs-lookup"><span data-stu-id="e585d-527"><paramref name="newBase" />&gt; 1</span></span> 
 </description><description> <span data-ttu-id="e585d-528">+ Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="e585d-528">+Infinity</span></span> 
 </description></item><item><term><span data-ttu-id="e585d-529"><paramref name="a" /> = 1</span><span class="sxs-lookup"><span data-stu-id="e585d-529"><paramref name="a" /> = 1</span></span> 
 </term><description><span data-ttu-id="e585d-530"><paramref name="newBase" /> = 0</span><span class="sxs-lookup"><span data-stu-id="e585d-530"><paramref name="newBase" /> = 0</span></span> 
 </description><description> <span data-ttu-id="e585d-531">0</span><span class="sxs-lookup"><span data-stu-id="e585d-531">0</span></span> 
 </description></item><item><term><span data-ttu-id="e585d-532"><paramref name="a" /> = 1</span><span class="sxs-lookup"><span data-stu-id="e585d-532"><paramref name="a" /> = 1</span></span> 
 </term><description><span data-ttu-id="e585d-533"><paramref name="newBase" />= + Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="e585d-533"><paramref name="newBase" /> = +Infinity</span></span> 
 </description><description> <span data-ttu-id="e585d-534">0</span><span class="sxs-lookup"><span data-stu-id="e585d-534">0</span></span> 
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-535">Poniższy przykład używa <xref:System.Math.Log%2A> do szacowania niektórych tożsamości logarytmicznych dla wybranych wartości.</span><span class="sxs-lookup"><span data-stu-id="e585d-535">The following example uses <xref:System.Math.Log%2A> to evaluate certain logarithmic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.Log_Overloads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CPP/loggen.cpp#1)]
 [!code-csharp[System.Math.Log_Overloads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/loggen.cs#1)]
 [!code-vb[System.Math.Log_Overloads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/loggen.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log10(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(double d);" />
      <MemberSignature Language="F#" Value="static member Log10 : double -&gt; double" Usage="System.Math.Log10 d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-536">Liczba, której LOGARYTM ma zostać znaleziony.</span><span class="sxs-lookup"><span data-stu-id="e585d-536">A number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="e585d-537">Zwraca logarytm dziesiętny z podanej liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-537">Returns the base 10 logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="e585d-538">Jedna z wartości w tabeli poniżej.</span><span class="sxs-lookup"><span data-stu-id="e585d-538">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="e585d-539"><paramref name="d" />konstruktora</span><span class="sxs-lookup"><span data-stu-id="e585d-539"><paramref name="d" /> parameter</span></span> 
 </term><description> <span data-ttu-id="e585d-540">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-540">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="e585d-541">Dodatnie</span><span class="sxs-lookup"><span data-stu-id="e585d-541">Positive</span></span> 
 </term><description> <span data-ttu-id="e585d-542">Dziennik <paramref name="d" />Base 10; oznacza to, że log 10<paramref name="d" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-542">The base 10 log of <paramref name="d" />; that is, log 10<paramref name="d" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-543">Zero</span><span class="sxs-lookup"><span data-stu-id="e585d-543">Zero</span></span> 
 </term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> <span data-ttu-id="e585d-544">Ujemne</span><span class="sxs-lookup"><span data-stu-id="e585d-544">Negative</span></span> 
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term> <span data-ttu-id="e585d-545">Równa się<see cref="F:System.Double.NaN" /></span><span class="sxs-lookup"><span data-stu-id="e585d-545">Equal to <see cref="F:System.Double.NaN" /></span></span></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> <span data-ttu-id="e585d-546">Równa się<see cref="F:System.Double.PositiveInfinity" /></span><span class="sxs-lookup"><span data-stu-id="e585d-546">Equal to <see cref="F:System.Double.PositiveInfinity" /></span></span></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-547">Parametr `d` jest określony jako numer podstawowy 10.</span><span class="sxs-lookup"><span data-stu-id="e585d-547">Parameter `d` is specified as a base 10 number.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-548">W poniższym przykładzie zastosowano <xref:System.Math.Log10%2A> metodę w celu zwrócenia logarytmu podstawowego 10 dla wybranych wartości.</span><span class="sxs-lookup"><span data-stu-id="e585d-548">The following example uses the <xref:System.Math.Log10%2A> method to return the base 10 logarithm for selected values.</span></span>  
  
 [!code-csharp[System.Math.Log10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log10/CS/log10.cs#1)]
 [!code-vb[System.Math.Log10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log10/VB/log10.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2">
      <MemberSignature Language="C#" Value="public static double Log2 (double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log2(float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log2(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log2 (x As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log2(double x);" />
      <MemberSignature Language="F#" Value="static member Log2 : double -&gt; double" Usage="System.Math.Log2 x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="e585d-549">Liczba, której LOGARYTM ma zostać znaleziony.</span><span class="sxs-lookup"><span data-stu-id="e585d-549">A number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="e585d-550">Zwraca logarytm o podstawie 2 dla podanej liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-550">Returns the base 2 logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="e585d-551">Jedna z wartości w tabeli poniżej.</span><span class="sxs-lookup"><span data-stu-id="e585d-551">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="e585d-552"><paramref name="x" />konstruktora</span><span class="sxs-lookup"><span data-stu-id="e585d-552"><paramref name="x" /> parameter</span></span> 
 </term><description> <span data-ttu-id="e585d-553">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-553">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="e585d-554">Dodatnie</span><span class="sxs-lookup"><span data-stu-id="e585d-554">Positive</span></span> 
 </term><description> <span data-ttu-id="e585d-555">Dziennik <paramref name="x" />Base 2, czyli dziennik 2<paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-555">The base 2 log of <paramref name="x" />; that is, log 2<paramref name="x" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-556">Zero</span><span class="sxs-lookup"><span data-stu-id="e585d-556">Zero</span></span> 
 </term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> <span data-ttu-id="e585d-557">Ujemne</span><span class="sxs-lookup"><span data-stu-id="e585d-557">Negative</span></span> 
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term> <span data-ttu-id="e585d-558">Równa się<see cref="F:System.Double.NaN" /></span><span class="sxs-lookup"><span data-stu-id="e585d-558">Equal to <see cref="F:System.Double.NaN" /></span></span></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> <span data-ttu-id="e585d-559">Równa się<see cref="F:System.Double.PositiveInfinity" /></span><span class="sxs-lookup"><span data-stu-id="e585d-559">Equal to <see cref="F:System.Double.PositiveInfinity" /></span></span></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-560">Parametr `x` jest określony jako numer podstawowy 10.</span><span class="sxs-lookup"><span data-stu-id="e585d-560">Parameter `x` is specified as a base 10 number.</span></span>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e585d-561">Zwraca większe z dwóch podanych liczb.</span><span class="sxs-lookup"><span data-stu-id="e585d-561">Returns the larger of two specified numbers.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static byte Max (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Max(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Byte, val2 As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Max(System::Byte val1, System::Byte val2);" />
      <MemberSignature Language="F#" Value="static member Max : byte * byte -&gt; byte" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-562">Pierwsze dwie 8-bitowe liczby całkowite bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-562">The first of two 8-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-563">Druga z dwóch 8-bitowych liczb całkowitych bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-563">The second of two 8-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-564">Zwraca większe z dwóch 8-bitowych liczb całkowitych bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-564">Returns the larger of two 8-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-565">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest większy.</span><span class="sxs-lookup"><span data-stu-id="e585d-565">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-566">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Max%2A> metody w celu zwrócenia i wyświetlenia większej liczby dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-566">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Decimal, val2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Max(System::Decimal val1, System::Decimal val2);" />
      <MemberSignature Language="F#" Value="static member Max : decimal * decimal -&gt; decimal" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-567">Pierwsze dwie liczby dziesiętne do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-567">The first of two decimal numbers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-568">Druga z dwóch liczb dziesiętnych do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-568">The second of two decimal numbers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-569">Zwraca większą z dwóch liczb dziesiętnych.</span><span class="sxs-lookup"><span data-stu-id="e585d-569">Returns the larger of two decimal numbers.</span></span></summary>
        <returns><span data-ttu-id="e585d-570">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest większy.</span><span class="sxs-lookup"><span data-stu-id="e585d-570">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-571">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Max%2A> metody w celu zwrócenia i wyświetlenia większej liczby dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-571">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Double, val2 As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Max(double val1, double val2);" />
      <MemberSignature Language="F#" Value="static member Max : double * double -&gt; double" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-572">Pierwsze dwie liczby zmiennoprzecinkowe podwójnej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-572">The first of two double-precision floating-point numbers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-573">Druga z dwóch liczb zmiennoprzecinkowych o podwójnej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-573">The second of two double-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-574">Zwraca więcej dwóch liczb zmiennoprzecinkowych o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-574">Returns the larger of two double-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="e585d-575">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest większy.</span><span class="sxs-lookup"><span data-stu-id="e585d-575">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span> <span data-ttu-id="e585d-576">Jeśli <paramref name="val1" /> <paramref name="val1" /> , <paramref name="val2" />, lub obiei<paramref name="val2" /> są równe ,<see cref="F:System.Double.NaN" />jestzwracanawartość. <see cref="F:System.Double.NaN" /></span><span class="sxs-lookup"><span data-stu-id="e585d-576">If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-577">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Max%2A> metody w celu zwrócenia i wyświetlenia większej liczby dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-577">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static short Max (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Max(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Short, val2 As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Max(short val1, short val2);" />
      <MemberSignature Language="F#" Value="static member Max : int16 * int16 -&gt; int16" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-578">Pierwsze z 2 16-bitowych liczb całkowitych ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-578">The first of two 16-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-579">Druga z 2 16-bitowych liczb całkowitych ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-579">The second of two 16-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-580">Zwraca większą z 2 16-bitowych liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-580">Returns the larger of two 16-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-581">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest większy.</span><span class="sxs-lookup"><span data-stu-id="e585d-581">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-582">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Max%2A> metody w celu zwrócenia i wyświetlenia większej liczby dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-582">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Integer, val2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Max(int val1, int val2);" />
      <MemberSignature Language="F#" Value="static member Max : int * int -&gt; int" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-583">Pierwsze z 2 32-bitowych liczb całkowitych ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-583">The first of two 32-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-584">Druga z 2 32-bitowych liczb całkowitych ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-584">The second of two 32-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-585">Zwraca większą z 2 32-bitowych liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-585">Returns the larger of two 32-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-586">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest większy.</span><span class="sxs-lookup"><span data-stu-id="e585d-586">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-587">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Max%2A> metody w celu zwrócenia i wyświetlenia większej liczby dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-587">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Long, val2 As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Max(long val1, long val2);" />
      <MemberSignature Language="F#" Value="static member Max : int64 * int64 -&gt; int64" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-588">Pierwsze z 2 64-bitowych liczb całkowitych ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-588">The first of two 64-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-589">Druga z 2 64-bitowych liczb całkowitych ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-589">The second of two 64-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-590">Zwraca większą z 2 64-bitowych liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-590">Returns the larger of two 64-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-591">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest większy.</span><span class="sxs-lookup"><span data-stu-id="e585d-591">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-592">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Max%2A> metody w celu zwrócenia i wyświetlenia większej liczby dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-592">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static sbyte Max (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Max(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As SByte, val2 As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Max(System::SByte val1, System::SByte val2);" />
      <MemberSignature Language="F#" Value="static member Max : sbyte * sbyte -&gt; sbyte" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-593">Pierwsze dwie 8-bitowe liczby całkowite ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-593">The first of two 8-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-594">Druga z dwóch 8-bitowych liczb całkowitych ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-594">The second of two 8-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-595">Zwraca większe z dwóch 8-bitowych liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-595">Returns the larger of two 8-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-596">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest większy.</span><span class="sxs-lookup"><span data-stu-id="e585d-596">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-597">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Max%2A> metody w celu zwrócenia i wyświetlenia większej liczby dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-597">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Single, val2 As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Max(float val1, float val2);" />
      <MemberSignature Language="F#" Value="static member Max : single * single -&gt; single" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-598">Pierwszy z dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-598">The first of two single-precision floating-point numbers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-599">Druga z dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-599">The second of two single-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-600">Zwraca więcej dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-600">Returns the larger of two single-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="e585d-601">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest większy.</span><span class="sxs-lookup"><span data-stu-id="e585d-601">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span> <span data-ttu-id="e585d-602">Opcja <paramref name="val1" />IF, <paramref name="val2" />or lub or <paramref name="val1" /> <paramref name="val2" /> jest równa <see cref="F:System.Single.NaN" /> ,<see cref="F:System.Single.NaN" /> jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="e585d-602">If <paramref name="val1" />, or <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-603">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Max%2A> metody w celu zwrócenia i wyświetlenia większej liczby dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-603">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ushort Max (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Max(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UShort, val2 As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Max(System::UInt16 val1, System::UInt16 val2);" />
      <MemberSignature Language="F#" Value="static member Max : uint16 * uint16 -&gt; uint16" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-604">Pierwszy z 2 16-bitowych liczb całkowitych bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-604">The first of two 16-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-605">Druga z 2 16-bitowych liczb całkowitych bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-605">The second of two 16-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-606">Zwraca większą z 2 16-bitowych liczb całkowitych bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-606">Returns the larger of two 16-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-607">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest większy.</span><span class="sxs-lookup"><span data-stu-id="e585d-607">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-608">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Max%2A> metody w celu zwrócenia i wyświetlenia większej liczby dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-608">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static uint Max (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Max(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UInteger, val2 As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Max(System::UInt32 val1, System::UInt32 val2);" />
      <MemberSignature Language="F#" Value="static member Max : uint32 * uint32 -&gt; uint32" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-609">Pierwszy z 2 32-bitowych liczb całkowitych bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-609">The first of two 32-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-610">Druga z 2 32-bitowych liczb całkowitych bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-610">The second of two 32-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-611">Zwraca większą z 2 32-bitowych liczb całkowitych bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-611">Returns the larger of two 32-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-612">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest większy.</span><span class="sxs-lookup"><span data-stu-id="e585d-612">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-613">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Max%2A> metody w celu zwrócenia i wyświetlenia większej liczby dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-613">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ulong Max (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Max(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As ULong, val2 As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Max(System::UInt64 val1, System::UInt64 val2);" />
      <MemberSignature Language="F#" Value="static member Max : uint64 * uint64 -&gt; uint64" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-614">Pierwszy z 2 64-bitowych liczb całkowitych bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-614">The first of two 64-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-615">Druga z 2 64-bitowych liczb całkowitych bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-615">The second of two 64-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-616">Zwraca większą z 2 64-bitowych liczb całkowitych bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-616">Returns the larger of two 64-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-617">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest większy.</span><span class="sxs-lookup"><span data-stu-id="e585d-617">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-618">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Max%2A> metody w celu zwrócenia i wyświetlenia większej liczby dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-618">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static double MaxMagnitude (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 MaxMagnitude(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.MaxMagnitude(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double MaxMagnitude(double x, double y);" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : double * double -&gt; double" Usage="System.Math.MaxMagnitude (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="e585d-619">Pierwsze dwie liczby zmiennoprzecinkowe podwójnej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-619">The first of two double-precision floating-point numbers to compare.</span></span></param>
        <param name="y"><span data-ttu-id="e585d-620">Druga z dwóch liczb zmiennoprzecinkowych o podwójnej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-620">The second of two double-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-621">Zwraca większą liczbę liczb zmiennoprzecinkowych o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-621">Returns the larger magnitude of two double-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="e585d-622">Parametr <paramref name="x" /> lub <paramref name="y" />, w zależności od tego, czy ma większą wielkość.</span><span class="sxs-lookup"><span data-stu-id="e585d-622">Parameter <paramref name="x" /> or <paramref name="y" />, whichever has the larger magnitude.</span></span> <span data-ttu-id="e585d-623">Opcja <paramref name="x" />IF, <paramref name="y" />or lub or <paramref name="x" /> <paramref name="y" /> jest równa <see cref="F:System.Double.NaN" /> ,<see cref="F:System.Double.NaN" /> jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="e585d-623">If <paramref name="x" />, or <paramref name="y" />, or both <paramref name="x" /> and <paramref name="y" /> are equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e585d-624">Zwraca mniejsze z dwóch liczb.</span><span class="sxs-lookup"><span data-stu-id="e585d-624">Returns the smaller of two numbers.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static byte Min (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Min(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Byte, val2 As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Min(System::Byte val1, System::Byte val2);" />
      <MemberSignature Language="F#" Value="static member Min : byte * byte -&gt; byte" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-625">Pierwsze dwie 8-bitowe liczby całkowite bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-625">The first of two 8-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-626">Druga z dwóch 8-bitowych liczb całkowitych bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-626">The second of two 8-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-627">Zwraca mniejsze z dwóch 8-bitowych liczb całkowitych bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-627">Returns the smaller of two 8-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-628">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest mniejszy.</span><span class="sxs-lookup"><span data-stu-id="e585d-628">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-629">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Min%2A> metody w celu zwrócenia i wyświetlenia mniejszych z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-629">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Decimal, val2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Min(System::Decimal val1, System::Decimal val2);" />
      <MemberSignature Language="F#" Value="static member Min : decimal * decimal -&gt; decimal" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-630">Pierwsze dwie liczby dziesiętne do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-630">The first of two decimal numbers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-631">Druga z dwóch liczb dziesiętnych do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-631">The second of two decimal numbers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-632">Zwraca mniejsze z dwóch liczb dziesiętnych.</span><span class="sxs-lookup"><span data-stu-id="e585d-632">Returns the smaller of two decimal numbers.</span></span></summary>
        <returns><span data-ttu-id="e585d-633">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest mniejszy.</span><span class="sxs-lookup"><span data-stu-id="e585d-633">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-634">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Min%2A> metody w celu zwrócenia i wyświetlenia mniejszych z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-634">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Double, val2 As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Min(double val1, double val2);" />
      <MemberSignature Language="F#" Value="static member Min : double * double -&gt; double" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-635">Pierwsze dwie liczby zmiennoprzecinkowe podwójnej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-635">The first of two double-precision floating-point numbers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-636">Druga z dwóch liczb zmiennoprzecinkowych o podwójnej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-636">The second of two double-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-637">Zwraca mniejsze z dwóch liczb zmiennoprzecinkowych o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-637">Returns the smaller of two double-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="e585d-638">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest mniejszy.</span><span class="sxs-lookup"><span data-stu-id="e585d-638">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span> <span data-ttu-id="e585d-639">Jeśli <paramref name="val1" /> <paramref name="val1" /> , <paramref name="val2" />, lub obiei<paramref name="val2" /> są równe ,<see cref="F:System.Double.NaN" />jestzwracanawartość. <see cref="F:System.Double.NaN" /></span><span class="sxs-lookup"><span data-stu-id="e585d-639">If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-640">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Min%2A> metody w celu zwrócenia i wyświetlenia mniejszych z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-640">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static short Min (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Min(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Short, val2 As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Min(short val1, short val2);" />
      <MemberSignature Language="F#" Value="static member Min : int16 * int16 -&gt; int16" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-641">Pierwsze z 2 16-bitowych liczb całkowitych ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-641">The first of two 16-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-642">Druga z 2 16-bitowych liczb całkowitych ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-642">The second of two 16-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-643">Zwraca mniejsze z 2 16-bitowych liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-643">Returns the smaller of two 16-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-644">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest mniejszy.</span><span class="sxs-lookup"><span data-stu-id="e585d-644">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-645">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Min%2A> metody w celu zwrócenia i wyświetlenia mniejszych z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-645">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Integer, val2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Min(int val1, int val2);" />
      <MemberSignature Language="F#" Value="static member Min : int * int -&gt; int" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-646">Pierwsze z 2 32-bitowych liczb całkowitych ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-646">The first of two 32-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-647">Druga z 2 32-bitowych liczb całkowitych ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-647">The second of two 32-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-648">Zwraca mniejsze z 2 32-bitowych liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-648">Returns the smaller of two 32-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-649">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest mniejszy.</span><span class="sxs-lookup"><span data-stu-id="e585d-649">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-650">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Min%2A> metody w celu zwrócenia i wyświetlenia mniejszych z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-650">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Long, val2 As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Min(long val1, long val2);" />
      <MemberSignature Language="F#" Value="static member Min : int64 * int64 -&gt; int64" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-651">Pierwsze z 2 64-bitowych liczb całkowitych ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-651">The first of two 64-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-652">Druga z 2 64-bitowych liczb całkowitych ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-652">The second of two 64-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-653">Zwraca mniejsze z 2 64-bitowych liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-653">Returns the smaller of two 64-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-654">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest mniejszy.</span><span class="sxs-lookup"><span data-stu-id="e585d-654">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-655">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Min%2A> metody w celu zwrócenia i wyświetlenia mniejszych z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-655">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static sbyte Min (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Min(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As SByte, val2 As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Min(System::SByte val1, System::SByte val2);" />
      <MemberSignature Language="F#" Value="static member Min : sbyte * sbyte -&gt; sbyte" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-656">Pierwsze dwie 8-bitowe liczby całkowite ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-656">The first of two 8-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-657">Druga z dwóch 8-bitowych liczb całkowitych ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-657">The second of two 8-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-658">Zwraca mniejsze z dwóch 8-bitowych liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-658">Returns the smaller of two 8-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-659">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest mniejszy.</span><span class="sxs-lookup"><span data-stu-id="e585d-659">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-660">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Min%2A> metody w celu zwrócenia i wyświetlenia mniejszych z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-660">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Single, val2 As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Min(float val1, float val2);" />
      <MemberSignature Language="F#" Value="static member Min : single * single -&gt; single" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-661">Pierwszy z dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-661">The first of two single-precision floating-point numbers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-662">Druga z dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-662">The second of two single-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-663">Zwraca mniejsze z dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-663">Returns the smaller of two single-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="e585d-664">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest mniejszy.</span><span class="sxs-lookup"><span data-stu-id="e585d-664">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span> <span data-ttu-id="e585d-665">Jeśli <paramref name="val1" /> <paramref name="val1" /> , <paramref name="val2" />, lub obiei<paramref name="val2" /> są równe ,<see cref="F:System.Single.NaN" />jestzwracanawartość. <see cref="F:System.Single.NaN" /></span><span class="sxs-lookup"><span data-stu-id="e585d-665">If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-666">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Min%2A> metody w celu zwrócenia i wyświetlenia mniejszych z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-666">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ushort Min (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Min(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UShort, val2 As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Min(System::UInt16 val1, System::UInt16 val2);" />
      <MemberSignature Language="F#" Value="static member Min : uint16 * uint16 -&gt; uint16" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-667">Pierwszy z 2 16-bitowych liczb całkowitych bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-667">The first of two 16-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-668">Druga z 2 16-bitowych liczb całkowitych bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-668">The second of two 16-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-669">Zwraca mniejsze z 2 16-bitowych liczb całkowitych bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-669">Returns the smaller of two 16-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-670">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest mniejszy.</span><span class="sxs-lookup"><span data-stu-id="e585d-670">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-671">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Min%2A> metody w celu zwrócenia i wyświetlenia mniejszych z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-671">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static uint Min (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Min(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UInteger, val2 As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Min(System::UInt32 val1, System::UInt32 val2);" />
      <MemberSignature Language="F#" Value="static member Min : uint32 * uint32 -&gt; uint32" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-672">Pierwszy z 2 32-bitowych liczb całkowitych bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-672">The first of two 32-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-673">Druga z 2 32-bitowych liczb całkowitych bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-673">The second of two 32-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-674">Zwraca mniejsze z 2 32-bitowych liczb całkowitych bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-674">Returns the smaller of two 32-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-675">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest mniejszy.</span><span class="sxs-lookup"><span data-stu-id="e585d-675">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-676">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Min%2A> metody w celu zwrócenia i wyświetlenia mniejszych z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-676">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ulong Min (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Min(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As ULong, val2 As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Min(System::UInt64 val1, System::UInt64 val2);" />
      <MemberSignature Language="F#" Value="static member Min : uint64 * uint64 -&gt; uint64" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="e585d-677">Pierwszy z 2 64-bitowych liczb całkowitych bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-677">The first of two 64-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="e585d-678">Druga z 2 64-bitowych liczb całkowitych bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-678">The second of two 64-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-679">Zwraca mniejsze z 2 64-bitowych liczb całkowitych bez znaku.</span><span class="sxs-lookup"><span data-stu-id="e585d-679">Returns the smaller of two 64-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="e585d-680">Parametr <paramref name="val1" /> lub<paramref name="val2" />, w zależności od tego, jest mniejszy.</span><span class="sxs-lookup"><span data-stu-id="e585d-680">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-681">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Min%2A> metody w celu zwrócenia i wyświetlenia mniejszych z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="e585d-681">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static double MinMagnitude (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 MinMagnitude(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.MinMagnitude(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double MinMagnitude(double x, double y);" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : double * double -&gt; double" Usage="System.Math.MinMagnitude (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="e585d-682">Pierwsze dwie liczby zmiennoprzecinkowe podwójnej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-682">The first of two double-precision floating-point numbers to compare.</span></span></param>
        <param name="y"><span data-ttu-id="e585d-683">Druga z dwóch liczb zmiennoprzecinkowych o podwójnej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="e585d-683">The second of two double-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="e585d-684">Zwraca mniejszy rozmiar dwóch liczb zmiennoprzecinkowych podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-684">Returns the smaller magnitude of two double-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="e585d-685">Parametr <paramref name="x" /> lub <paramref name="y" />, w zależności od tego, czy ma mniejszą wartość.</span><span class="sxs-lookup"><span data-stu-id="e585d-685">Parameter <paramref name="x" /> or <paramref name="y" />, whichever has the smaller magnitude.</span></span> <span data-ttu-id="e585d-686">Opcja <paramref name="x" />IF, <paramref name="y" />or lub or <paramref name="x" /> <paramref name="y" /> jest równa <see cref="F:System.Double.NaN" /> ,<see cref="F:System.Double.NaN" /> jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="e585d-686">If <paramref name="x" />, or <paramref name="y" />, or both <paramref name="x" /> and <paramref name="y" /> are equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="PI">
      <MemberSignature Language="C#" Value="public const double PI = 3.14159265358979;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PI = (3.14159265358979)" />
      <MemberSignature Language="DocId" Value="F:System.Math.PI" />
      <MemberSignature Language="VB.NET" Value="Public Const PI As Double  = 3.14159265358979" />
      <MemberSignature Language="C++ CLI" Value="public: double PI = 3.14159265358979;" />
      <MemberSignature Language="F#" Value="val mutable PI : double" Usage="System.Math.PI" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>3.14159265358979</MemberValue>
      <Docs>
        <summary><span data-ttu-id="e585d-687">Reprezentuje stosunek obwodu okręgu do jego średnicy, określonego przez stałą, π.</span><span class="sxs-lookup"><span data-stu-id="e585d-687">Represents the ratio of the circumference of a circle to its diameter, specified by the constant, π.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-688">Wartość tego pola to 3.1415926535897931.</span><span class="sxs-lookup"><span data-stu-id="e585d-688">The value of this field is 3.1415926535897931.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-689">Poniższy przykład używa <xref:System.Math.PI> , aby pomóc w obliczaniu kątów wewnętrznych danego trapezu.</span><span class="sxs-lookup"><span data-stu-id="e585d-689">The following example uses <xref:System.Math.PI> to assist in the computation of the inner angles of a given trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static double Pow (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Pow(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Pow(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Pow(double x, double y);" />
      <MemberSignature Language="F#" Value="static member Pow : double * double -&gt; double" Usage="System.Math.Pow (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="e585d-690">Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać podniesiona do potęgi.</span><span class="sxs-lookup"><span data-stu-id="e585d-690">A double-precision floating-point number to be raised to a power.</span></span></param>
        <param name="y"><span data-ttu-id="e585d-691">Liczba zmiennoprzecinkowa podwójnej precyzji, która określa potęgę.</span><span class="sxs-lookup"><span data-stu-id="e585d-691">A double-precision floating-point number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="e585d-692">Zwraca określoną liczbę podniesioną do określonej potęgi.</span><span class="sxs-lookup"><span data-stu-id="e585d-692">Returns a specified number raised to the specified power.</span></span></summary>
        <returns><span data-ttu-id="e585d-693">Liczba <paramref name="x" /> podniesiona do potęgi <paramref name="y" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-693">The number <paramref name="x" /> raised to the power <paramref name="y" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-694">Poniższa tabela wskazuje wartość zwracaną w przypadku określenia różnych wartości lub zakresów wartości dla `x` parametrów i. `y`</span><span class="sxs-lookup"><span data-stu-id="e585d-694">The following table indicates the return value when various values or ranges of values are specified for the `x` and `y` parameters.</span></span> <span data-ttu-id="e585d-695">Aby uzyskać więcej informacji, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>zobacz <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, i <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e585d-695">For more information, see <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="e585d-696">Parametry</span><span class="sxs-lookup"><span data-stu-id="e585d-696">Parameters</span></span>|<span data-ttu-id="e585d-697">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-697">Return value</span></span>|  
|----------------|------------------|  
|<span data-ttu-id="e585d-698">`x`lub `y` . =  `NaN`</span><span class="sxs-lookup"><span data-stu-id="e585d-698">`x` or `y` = `NaN`.</span></span>|`NaN`|  
|<span data-ttu-id="e585d-699">`x`= Dowolna wartość `NaN`z wyjątkiem; `y` = 0.</span><span class="sxs-lookup"><span data-stu-id="e585d-699">`x` = Any value except `NaN`; `y` = 0.</span></span>|<span data-ttu-id="e585d-700">1</span><span class="sxs-lookup"><span data-stu-id="e585d-700">1</span></span>|  
|<span data-ttu-id="e585d-701">`x` = `NegativeInfinity`; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="e585d-701">`x` = `NegativeInfinity`; `y` < 0.</span></span>|<span data-ttu-id="e585d-702">0</span><span class="sxs-lookup"><span data-stu-id="e585d-702">0</span></span>|  
|<span data-ttu-id="e585d-703">`x` = `NegativeInfinity`; `y` jest dodatnią nieparzystą liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="e585d-703">`x` = `NegativeInfinity`; `y` is a positive odd integer.</span></span>|`NegativeInfinity`|  
|<span data-ttu-id="e585d-704">`x` = `NegativeInfinity`; `y` jest dodatnia, ale nie jest parzystą liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="e585d-704">`x` = `NegativeInfinity`; `y` is positive but not an odd integer.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="e585d-705">`x`< 0, ale `NegativeInfinity`nie; nie jest liczbą całkowitą, `NegativeInfinity`lub `PositiveInfinity`. `y`</span><span class="sxs-lookup"><span data-stu-id="e585d-705">`x` < 0 but not `NegativeInfinity`; `y` is not an integer, `NegativeInfinity`, or `PositiveInfinity`.</span></span>|`NaN`|  
|<span data-ttu-id="e585d-706">`x`=-1; `y` lub.`PositiveInfinity`  =  `NegativeInfinity`</span><span class="sxs-lookup"><span data-stu-id="e585d-706">`x` = -1; `y` = `NegativeInfinity` or `PositiveInfinity`.</span></span>|`NaN`|  
|<span data-ttu-id="e585d-707">-1 < `x` < 1; `y` = `NegativeInfinity`.</span><span class="sxs-lookup"><span data-stu-id="e585d-707">-1 < `x` < 1; `y` = `NegativeInfinity`.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="e585d-708">-1 < `x` < 1; `y` = `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="e585d-708">-1 < `x` < 1; `y` = `PositiveInfinity`.</span></span>|<span data-ttu-id="e585d-709">0</span><span class="sxs-lookup"><span data-stu-id="e585d-709">0</span></span>|  
|<span data-ttu-id="e585d-710">`x`<-1 lub `x` > 1; `y` = `NegativeInfinity`.</span><span class="sxs-lookup"><span data-stu-id="e585d-710">`x` < -1 or `x` > 1; `y` = `NegativeInfinity`.</span></span>|<span data-ttu-id="e585d-711">0</span><span class="sxs-lookup"><span data-stu-id="e585d-711">0</span></span>|  
|<span data-ttu-id="e585d-712">`x`<-1 lub `x` > 1; `y` = `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="e585d-712">`x` < -1 or `x` > 1; `y` = `PositiveInfinity`.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="e585d-713">`x` = 0; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="e585d-713">`x` = 0; `y` < 0.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="e585d-714">`x`= 0; `y` > 0.</span><span class="sxs-lookup"><span data-stu-id="e585d-714">`x` = 0; `y` > 0.</span></span>|<span data-ttu-id="e585d-715">0</span><span class="sxs-lookup"><span data-stu-id="e585d-715">0</span></span>|  
|<span data-ttu-id="e585d-716">`x`= 1; jest dowolną wartością z `NaN`wyjątkiem. `y`</span><span class="sxs-lookup"><span data-stu-id="e585d-716">`x` = 1; `y` is any value except `NaN`.</span></span>|<span data-ttu-id="e585d-717">1</span><span class="sxs-lookup"><span data-stu-id="e585d-717">1</span></span>|  
|<span data-ttu-id="e585d-718">`x` = `PositiveInfinity`; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="e585d-718">`x` = `PositiveInfinity`; `y` < 0.</span></span>|<span data-ttu-id="e585d-719">0</span><span class="sxs-lookup"><span data-stu-id="e585d-719">0</span></span>|  
|<span data-ttu-id="e585d-720">`x` = `PositiveInfinity`; `y` > 0.</span><span class="sxs-lookup"><span data-stu-id="e585d-720">`x` = `PositiveInfinity`; `y` > 0.</span></span>|`PositiveInfinity`|  
  
   
  
## Examples  
 <span data-ttu-id="e585d-721">W poniższym przykładzie zastosowano <xref:System.Math.Pow%2A> metodę, aby obliczyć wartość będącą wynikiem podniesienia 2 do potęgi od 0 do 32.</span><span class="sxs-lookup"><span data-stu-id="e585d-721">The following example uses the <xref:System.Math.Pow%2A> method to calculate the value that results from raising 2 to a power ranging from 0 to 32.</span></span>  
  
 [!code-csharp[System.Math.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.pow/cs/pow1.cs#1)]
 [!code-vb[System.Math.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sqrt(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Round">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e585d-722">Zaokrągla wartość do najbliższej liczby całkowitej lub do określonej liczby cyfr ułamkowych.</span><span class="sxs-lookup"><span data-stu-id="e585d-722">Rounds a value to the nearest integer or to the specified number of fractional digits.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-round"></a> 
## Remarks 

<span data-ttu-id="e585d-723">W tej sekcji:</span><span class="sxs-lookup"><span data-stu-id="e585d-723">In this section:</span></span>

- [<span data-ttu-id="e585d-724">Którą metodę nazywam?</span><span class="sxs-lookup"><span data-stu-id="e585d-724">Which method do I call?</span></span>](#which-method-do-i-call)
- [<span data-ttu-id="e585d-725">Wartości punktu środkowego i konwencje zaokrąglania</span><span class="sxs-lookup"><span data-stu-id="e585d-725">Midpoint values and rounding conventions</span></span>](#midpoint-values-and-rounding-conventions)   
- [<span data-ttu-id="e585d-726">Zaokrąglenie i precyzja</span><span class="sxs-lookup"><span data-stu-id="e585d-726">Rounding and precision</span></span>](#rounding-and-precision) 
- [<span data-ttu-id="e585d-727">Zaokrąglanie wartości zmiennoprzecinkowych o pojedynczej precyzji</span><span class="sxs-lookup"><span data-stu-id="e585d-727">Rounding and single-precision floating point values</span></span>](#rounding-and-single-precision-floating-point-values)
- [<span data-ttu-id="e585d-728">Przykłady poszczególnych przeciążeń</span><span class="sxs-lookup"><span data-stu-id="e585d-728">Examples of individual overloads</span></span>](#round-examples)

### <a name="which-method-do-i-call"></a><span data-ttu-id="e585d-729">Jaką metodę wywołać?</span><span class="sxs-lookup"><span data-stu-id="e585d-729">Which method do I call?</span></span>

<span data-ttu-id="e585d-730">Aby wybrać odpowiednią metodę zaokrąglania, można użyć poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="e585d-730">You can use the following table to select an appropriate rounding method.</span></span> <span data-ttu-id="e585d-731">Oprócz `Math.Round` metod, zawiera <xref:System.Math.Ceiling%2A?displayProperty=nameWithType> również i <xref:System.Math.Floor%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e585d-731">In addition to the `Math.Round` methods, it also includes <xref:System.Math.Ceiling%2A?displayProperty=nameWithType> and <xref:System.Math.Floor%2A?displayProperty=nameWithType>.</span></span>

|<span data-ttu-id="e585d-732">Zadanie</span><span class="sxs-lookup"><span data-stu-id="e585d-732">To</span></span>|<span data-ttu-id="e585d-733">Połączeń</span><span class="sxs-lookup"><span data-stu-id="e585d-733">Call</span></span>|  
|--------|----------|  
|<span data-ttu-id="e585d-734">Zaokrąglij liczbę do liczby całkowitej, używając zaokrąglenia do najbliższej Konwencji.</span><span class="sxs-lookup"><span data-stu-id="e585d-734">Round a number to an integer by using the rounding to nearest convention.</span></span>|<xref:System.Math.Round%28System.Decimal%29><br /><br /> <span data-ttu-id="e585d-735">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-735">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%29>|  
|<span data-ttu-id="e585d-736">Zaokrąglij liczbę do liczby całkowitej przy użyciu określonej konwencji zaokrąglania.</span><span class="sxs-lookup"><span data-stu-id="e585d-736">Round a number to an integer by using a specified rounding convention.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <span data-ttu-id="e585d-737">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-737">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|  
|<span data-ttu-id="e585d-738">Zaokrąglij liczbę do określonej liczby cyfr ułamkowych, używając zaokrąglenia do najbliższej Konwencji.</span><span class="sxs-lookup"><span data-stu-id="e585d-738">Round a number to a specified number of fractional digits by using the rounding to nearest convention.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <span data-ttu-id="e585d-739">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-739">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|  
|<span data-ttu-id="e585d-740">Zaokrąglij liczbę do określonej liczby cyfr ułamkowych przy użyciu określonej konwencji zaokrąglania.</span><span class="sxs-lookup"><span data-stu-id="e585d-740">Round a number to a specified number of fractional digits by using a specified rounding convention.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <span data-ttu-id="e585d-741">—lub—</span><span class="sxs-lookup"><span data-stu-id="e585d-741">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<span data-ttu-id="e585d-742">Zaokrąglij <xref:System.Single> wartość do określonej liczby cyfr ułamkowych przy użyciu określonej konwencji zaokrąglania i minimalizując utratę precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-742">Round a <xref:System.Single> value to a specified number of fractional digits by using a specified rounding convention and minimizing the loss of precision.</span></span>|<span data-ttu-id="e585d-743">Przekonwertuj <xref:System.Single> <xref:System.Decimal> na wywołanie<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>i.</span><span class="sxs-lookup"><span data-stu-id="e585d-743">Convert the <xref:System.Single> to a <xref:System.Decimal> and call <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>.</span></span>|  
|<span data-ttu-id="e585d-744">Zaokrąglij liczbę do określonej liczby cyfr ułamkowych, jednocześnie minimalizując problemy dokładności w wartościach punktu środkowego.</span><span class="sxs-lookup"><span data-stu-id="e585d-744">Round a number to a specified number of fractional digits while minimizing problems of precision in rounding midpoint values.</span></span>|<span data-ttu-id="e585d-745">Wywołaj metodę rounding, która implementuje porównanie "większe niż lub w przybliżeniu równe".</span><span class="sxs-lookup"><span data-stu-id="e585d-745">Call a rounding method that implements a "greater than or approximately equal to" comparison.</span></span> <span data-ttu-id="e585d-746">Zobacz [zaokrąglenie i dokładność](#precision).</span><span class="sxs-lookup"><span data-stu-id="e585d-746">See [Rounding and precision](#precision).</span></span>|  
|<span data-ttu-id="e585d-747">Zaokrąglij wartość ułamkową do liczby całkowitej, która jest większa niż wartość ułamkowa.</span><span class="sxs-lookup"><span data-stu-id="e585d-747">Round a fractional value to an integer that is greater than the fractional value.</span></span> <span data-ttu-id="e585d-748">Na przykład Zaokrąglij 3,1 do 4.</span><span class="sxs-lookup"><span data-stu-id="e585d-748">For example, round 3.1 to 4.</span></span>|<xref:System.Math.Ceiling%2A>|  
|<span data-ttu-id="e585d-749">Zaokrąglij wartość ułamkową do liczby całkowitej, która jest mniejsza niż wartość ułamkowa.</span><span class="sxs-lookup"><span data-stu-id="e585d-749">Round a fractional value to an integer that is less than the fractional value.</span></span> <span data-ttu-id="e585d-750">Na przykład Zaokrąglij 3,9 do 3.</span><span class="sxs-lookup"><span data-stu-id="e585d-750">For example, round 3.9 to 3.</span></span>|<xref:System.Math.Floor%2A>|  

### <a name="midpoint-values-and-rounding-conventions"></a><span data-ttu-id="e585d-751">Wartości punktu środkowego i konwencje zaokrąglania</span><span class="sxs-lookup"><span data-stu-id="e585d-751">Midpoint values and rounding conventions</span></span> 

<span data-ttu-id="e585d-752">Zaokrąglenie obejmuje konwersję wartości liczbowej z określoną dokładnością do najbliższej wartości z mniejszą dokładnością.</span><span class="sxs-lookup"><span data-stu-id="e585d-752">Rounding involves converting a numeric value with a specified precision to the nearest value with less precision.</span></span> <span data-ttu-id="e585d-753">Na przykład można użyć metody, <xref:System.Math.Round%28System.Double%29> Aby zaokrąglić wartość 3,4 do 3,0 <xref:System.Math.Round%28System.Double%2CSystem.Int32%29> i metodę zaokrąglania wartości 3,579 do 3,58.</span><span class="sxs-lookup"><span data-stu-id="e585d-753">For example, you can use the <xref:System.Math.Round%28System.Double%29> method to round a value of 3.4 to 3.0, and the <xref:System.Math.Round%28System.Double%2CSystem.Int32%29> method to round a value of 3.579 to 3.58.</span></span>  
  
<span data-ttu-id="e585d-754">W wartości punktu środkowego wartość po najmniejszej liczbie znaczących w wyniku jest dokładnie połowa między dwoma liczbami.</span><span class="sxs-lookup"><span data-stu-id="e585d-754">In a midpoint value, the value after the least significant digit in the result is precisely half way between two numbers.</span></span> <span data-ttu-id="e585d-755">Na przykład 3,47500 jest wartością punktu środkowego, jeśli ma zostać zaokrąglona dwóch miejsc dziesiętnych, a 7,500 jest wartością punktu środkowego, jeśli ma zostać zaokrąglona do liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="e585d-755">For example, 3.47500 is a midpoint value if it is to be rounded two decimal places, and 7.500 is a midpoint value if it is to be rounded to an integer.</span></span> <span data-ttu-id="e585d-756">W takich przypadkach Najbliższa wartość nie może być łatwo zidentyfikowana bez konwencji zaokrąglania.</span><span class="sxs-lookup"><span data-stu-id="e585d-756">In these cases, the nearest value can't be easily identified without a rounding convention.</span></span>  
  
<span data-ttu-id="e585d-757"><xref:System.Math.Round%2A> Metoda obsługuje dwie konwencje zaokrągleń do obsługi wartości punktu środkowego:</span><span class="sxs-lookup"><span data-stu-id="e585d-757">The <xref:System.Math.Round%2A> method supports two rounding conventions for handling midpoint values:</span></span>  
  
- <span data-ttu-id="e585d-758">**Zaokrąglenie w kierunku od zera**</span><span class="sxs-lookup"><span data-stu-id="e585d-758">**Rounding away from zero**</span></span>  

   <span data-ttu-id="e585d-759">Wartości punktu środkowego są zaokrąglane do kolejnej liczby z dala od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-759">Midpoint values are rounded to the next number away from zero.</span></span> <span data-ttu-id="e585d-760">Na przykład 3,75 zaokrągla do 3,8, 3,85 zaokrągla do 3,9,-3,75 zaokrągla do-3,8, a-3,85 zaokrągla do-3,9.</span><span class="sxs-lookup"><span data-stu-id="e585d-760">For example, 3.75 rounds to 3.8, 3.85 rounds to 3.9, -3.75 rounds to -3.8, and -3.85 rounds to -3.9.</span></span> <span data-ttu-id="e585d-761">Ta forma zaokrąglania jest reprezentowana przez <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> element członkowski wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="e585d-761">This form of rounding is represented by the <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> enumeration member.</span></span>  
  
   <span data-ttu-id="e585d-762">Zaokrąglanie od zera to najczęściej znana postać zaokrąglania.</span><span class="sxs-lookup"><span data-stu-id="e585d-762">Rounding away from zero is the most widely known form of rounding.</span></span>  
  
- <span data-ttu-id="e585d-763">**Zaokrąglenie do najbliższej lub zaokrąglania w banku**</span><span class="sxs-lookup"><span data-stu-id="e585d-763">**Rounding to nearest, or banker's rounding**</span></span>  

   <span data-ttu-id="e585d-764">Wartości punktu środkowego są zaokrąglane do najbliższej parzystej liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-764">Midpoint values are rounded to the nearest even number.</span></span> <span data-ttu-id="e585d-765">Na przykład zarówno 3,75, jak i 3,85, do 3,8 i oba-3,75 i-3,85 zaokrąglić do-3,8.</span><span class="sxs-lookup"><span data-stu-id="e585d-765">For example, both 3.75 and 3.85 round to 3.8, and both -3.75 and -3.85 round to -3.8.</span></span> <span data-ttu-id="e585d-766">Ta forma zaokrąglania jest reprezentowana przez <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> element członkowski wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="e585d-766">This form of rounding is represented by the <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> enumeration member.</span></span>  
  
  <span data-ttu-id="e585d-767">Zaokrąglanie do najbliższe jest standardowym formą zaokrąglania używanego w operacjach finansowych i statystycznych.</span><span class="sxs-lookup"><span data-stu-id="e585d-767">Rounding to nearest is the standard form of rounding used in financial and statistical operations.</span></span> <span data-ttu-id="e585d-768">Jest zgodna ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="e585d-768">It conforms to IEEE Standard 754, section 4.</span></span> <span data-ttu-id="e585d-769">Gdy jest używany w wielu operacjach zaokrąglania, zmniejsza to błąd zaokrąglania, który jest spowodowany przez spójne Zaokrąglanie wartości punktu środkowego w jednym kierunku.</span><span class="sxs-lookup"><span data-stu-id="e585d-769">When used in multiple rounding operations, it reduces the rounding error that is caused by consistently rounding midpoint values in a single direction.</span></span> <span data-ttu-id="e585d-770">W niektórych przypadkach ten błąd zaokrąglania może być znaczący.</span><span class="sxs-lookup"><span data-stu-id="e585d-770">In some cases, this rounding error can be significant.</span></span>  
  
  <span data-ttu-id="e585d-771">Poniższy przykład ilustruje odchylenia, które mogą wynikać ze spójnego zaokrąglania wartości punktu środkowego w jednym kierunku.</span><span class="sxs-lookup"><span data-stu-id="e585d-771">The following example illustrates the bias that can result from consistently rounding midpoint values in a single direction.</span></span> <span data-ttu-id="e585d-772">W przykładzie jest obliczana wartość rzeczywista średniej tablicy <xref:System.Decimal> wartości, a następnie obliczana jest średnia, gdy wartości w tablicy są zaokrąglane przy użyciu dwóch Konwencji.</span><span class="sxs-lookup"><span data-stu-id="e585d-772">The example computes the true mean of an array of <xref:System.Decimal> values, and then computes the mean when the values in the array are rounded by using the two conventions.</span></span> <span data-ttu-id="e585d-773">W tym przykładzie prawdziwe znaczenie i średni wynik, gdy Zaokrąglenie do najbliższej jest takie samo.</span><span class="sxs-lookup"><span data-stu-id="e585d-773">In this example, the true mean and the mean that results when rounding to nearest are the same.</span></span> <span data-ttu-id="e585d-774">Jednak oznacza to, że wartość jest zaokrąglana w kierunku od zera do .05 (lub przez 3,6%) od prawdziwego znaczenia.</span><span class="sxs-lookup"><span data-stu-id="e585d-774">However, the mean that results when rounding away from zero differs by .05 (or by 3.6%) from the true mean.</span></span>  
  
  [!code-csharp-interactive[System.Math.Round.Overload#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mean1.cs#2)]
  [!code-vb[System.Math.Round.Overload#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mean1.vb#2)]  
  
<span data-ttu-id="e585d-775">Domyślnie <xref:System.Math.Round%2A> Metoda używa zaokrąglania do najbliższej Konwencji.</span><span class="sxs-lookup"><span data-stu-id="e585d-775">By default, the <xref:System.Math.Round%2A> method uses the rounding to nearest convention.</span></span> <span data-ttu-id="e585d-776">Poniższa tabela zawiera listę przeciążeń <xref:System.Math.Round%2A> metody i konwencji zaokrąglania, które są używane przez poszczególne z nich.</span><span class="sxs-lookup"><span data-stu-id="e585d-776">The following table lists the overloads of the <xref:System.Math.Round%2A> method and the rounding convention that each uses.</span></span>  
  
|<span data-ttu-id="e585d-777">Występują</span><span class="sxs-lookup"><span data-stu-id="e585d-777">Overload</span></span>|<span data-ttu-id="e585d-778">Konwencja zaokrąglania</span><span class="sxs-lookup"><span data-stu-id="e585d-778">Rounding convention</span></span>|  
|--------------|-------------------------|  
|<xref:System.Math.Round%28System.Decimal%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29>|<span data-ttu-id="e585d-779">Określone przez `mode` parametr.</span><span class="sxs-lookup"><span data-stu-id="e585d-779">Determined by `mode` parameter.</span></span>|  
|<xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|<span data-ttu-id="e585d-780">Określone przez `mode` parametr</span><span class="sxs-lookup"><span data-stu-id="e585d-780">Determined by `mode` parameter</span></span>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>|<span data-ttu-id="e585d-781">Określone przez `mode` parametr</span><span class="sxs-lookup"><span data-stu-id="e585d-781">Determined by `mode` parameter</span></span>|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|<span data-ttu-id="e585d-782">Określone przez `mode` parametr</span><span class="sxs-lookup"><span data-stu-id="e585d-782">Determined by `mode` parameter</span></span>|  

<a name="precision"></a>
### <a name="rounding-and-precision"></a><span data-ttu-id="e585d-783">Zaokrąglenia i dokładność</span><span class="sxs-lookup"><span data-stu-id="e585d-783">Rounding and precision</span></span>  

<span data-ttu-id="e585d-784">Aby określić, czy operacja zaokrąglania obejmuje wartość punktu środkowego, <xref:System.Math.Round%2A> Metoda mnoży oryginalną wartość do zaokrąglenia o 10<sup>n</sup>, gdzie *n* to wymagana liczba ułamkowych cyfr w wartości zwracanej, a następnie Określa, czy pozostała część ułamkowa wartości jest większa lub równa. 5.</span><span class="sxs-lookup"><span data-stu-id="e585d-784">In order to determine whether a rounding operation involves a midpoint value, the <xref:System.Math.Round%2A> method multiplies the original value to be rounded by 10<sup>n</sup>, where *n* is the desired number of fractional digits in the return value, and then determines whether the remaining fractional portion of the value is greater than or equal to .5.</span></span> <span data-ttu-id="e585d-785">Jest to niewielka odmiana testu pod kątem równości i opisana w sekcji <xref:System.Double> "testowanie pod kątem równości" tematu referencyjnego testy pod kątem równości z wartościami zmiennoprzecinkowymi są problematyczne ze względu na problemy z plikiem binarnym w formacie zmiennoprzecinkowym Reprezentacja i dokładność.</span><span class="sxs-lookup"><span data-stu-id="e585d-785">This is a slight variation on a test for equality, and as discussed in the "Testing for Equality" section of the <xref:System.Double> reference topic, tests for equality with floating-point values are problematic because of the floating-point format's issues with binary representation and precision.</span></span> <span data-ttu-id="e585d-786">Oznacza to, że każda część ułamkowa liczby, która jest nieco mniejsza niż .5 (ze względu na utratę precyzji) nie zostanie zaokrąglona w górę.</span><span class="sxs-lookup"><span data-stu-id="e585d-786">This means that any fractional portion of a number that is slightly less than .5 (because of a loss of precision) will not be rounded upward.</span></span>  

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<span data-ttu-id="e585d-787">Poniższy przykład ilustruje ten problem.</span><span class="sxs-lookup"><span data-stu-id="e585d-787">The following example illustrates the problem.</span></span> <span data-ttu-id="e585d-788">Wielokrotnie dodaje liczbę do 11,0 i zaokrągla wynik do najbliższej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="e585d-788">It repeatedly adds .1 to 11.0 and rounds the result to the nearest integer.</span></span> <span data-ttu-id="e585d-789">Niezależnie od konwencji zaokrąglania 11,5 powinna być zaokrąglana do 12.</span><span class="sxs-lookup"><span data-stu-id="e585d-789">Regardless of the rounding convention, 11.5 should round to 12.</span></span> <span data-ttu-id="e585d-790">Jednak jako dane wyjściowe z przykładu są wyświetlane, nie.</span><span class="sxs-lookup"><span data-stu-id="e585d-790">However, as the output from the example shows, it does not.</span></span> <span data-ttu-id="e585d-791">W przykładzie użyto [standardowego ciągu formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) "R", aby wyświetlić pełną precyzję wartości zmiennoprzecinkowej i pokazuje, że wartość, która ma zostać zaokrąglona, ma utraconą precyzję podczas kolejnych operacji dodawania, a jej wartość jest rzeczywiście 11.499999999999998.</span><span class="sxs-lookup"><span data-stu-id="e585d-791">The example uses the "R" [standard numeric format string](~/docs/standard/base-types/standard-numeric-format-strings.md) to display the floating point value's full precision, and shows that the value to be rounded has lost precision during repeated additions, and its value is actually 11.499999999999998.</span></span> <span data-ttu-id="e585d-792">Ponieważ. 499999999999998 jest mniejsza niż .5, wartość nie jest zaokrąglana do najbliższej najwyższej wartości całkowitej.</span><span class="sxs-lookup"><span data-stu-id="e585d-792">Because .499999999999998 is less than .5, the value is not rounded to the next highest integer.</span></span> <span data-ttu-id="e585d-793">Jak pokazano na przykładzie, ten problem nie występuje, jeśli po prostu przypiszemy wartość stałą 11,5 do <xref:System.Double> zmiennej.</span><span class="sxs-lookup"><span data-stu-id="e585d-793">As the example also shows, this problem does not occur if we simply assign the constant value 11.5 to a <xref:System.Double> variable.</span></span>  
  
[!code-csharp[System.Math.Round.Overload#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision1.cs#7)]
[!code-vb[System.Math.Round.Overload#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision1.vb#7)]  
  
<span data-ttu-id="e585d-794">Problemy z dokładnością w zaokrągleniu wartości punktu środkowego najprawdopodobniej wystąpią w następujących warunkach:</span><span class="sxs-lookup"><span data-stu-id="e585d-794">Problems of precision in rounding midpoint values are most likely to arise in the following conditions:</span></span>  
  
- <span data-ttu-id="e585d-795">Gdy wartość ułamkowa nie może być wyrażona dokładnie w formacie binarnym typu zmiennoprzecinkowego.</span><span class="sxs-lookup"><span data-stu-id="e585d-795">When a fractional value cannot be expressed precisely in the floating-point type's binary format.</span></span>  
  
- <span data-ttu-id="e585d-796">Gdy wartość do zaokrąglenia jest obliczana na podstawie co najmniej jednej operacji zmiennoprzecinkowej.</span><span class="sxs-lookup"><span data-stu-id="e585d-796">When the value to be rounded is calculated from one or more floating-point operations.</span></span>  
  
- <span data-ttu-id="e585d-797">Gdy wartość do zaokrąglenia jest <xref:System.Single> zamiast <xref:System.Double> lub <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="e585d-797">When the value to be rounded is a <xref:System.Single> rather than a <xref:System.Double> or <xref:System.Decimal>.</span></span> <span data-ttu-id="e585d-798">Aby uzyskać więcej informacji, zobacz następną [wartości zmiennoprzecinkowe zaokrąglania i pojedynczej precyzji](#rounding-and-single-precision-floating-point-values).</span><span class="sxs-lookup"><span data-stu-id="e585d-798">For more information, see the next section, [Rounding and single-precision floating-point values](#rounding-and-single-precision-floating-point-values).</span></span>  
  
 <span data-ttu-id="e585d-799">W przypadkach, gdy brak dokładności operacji zaokrąglania jest problematyczny, można wykonać następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="e585d-799">In cases where the lack of precision in rounding operations is problematic, you can do the following:</span></span>  
  
- <span data-ttu-id="e585d-800">Jeśli operacja zaokrąglania wywołuje Przeciążenie, które zaokrągla <xref:System.Double> wartość, można <xref:System.Double> zmienić na <xref:System.Decimal> <xref:System.Decimal> wartość i wywoływać przeciążenie, które w zamian zaokrągli wartość.</span><span class="sxs-lookup"><span data-stu-id="e585d-800">If the rounding operation calls an overload that rounds a <xref:System.Double> value, you can change the <xref:System.Double> to a <xref:System.Decimal> value and call an overload that rounds a <xref:System.Decimal> value instead.</span></span> <span data-ttu-id="e585d-801">Chociaż typ <xref:System.Decimal> danych ma również problemy z reprezentacją i utratą dokładności, te problemy są znacznie mniej popularne.</span><span class="sxs-lookup"><span data-stu-id="e585d-801">Although the <xref:System.Decimal> data type also has problems of representation and loss of precision, these issues are far less common.</span></span>  
  
- <span data-ttu-id="e585d-802">Zdefiniuj niestandardowy algorytm zaokrąglania, który wykonuje "niemal równe" testy, aby określić, czy wartość, która ma zostać zaokrąglona, jest zadowalająco blisko wartości punktu środkowego.</span><span class="sxs-lookup"><span data-stu-id="e585d-802">Define a custom rounding algorithm that performs a "nearly equal" test to determine whether the value to be rounded is acceptably close to a midpoint value.</span></span> <span data-ttu-id="e585d-803">W poniższym przykładzie zdefiniowano `RoundApproximate` metodę, która bada, czy wartość ułamkowa jest wystarczająco blisko wartości punktu środkowego, która ma podlegać zaokrągleniu do punktu środkowego.</span><span class="sxs-lookup"><span data-stu-id="e585d-803">The following example defines a `RoundApproximate` method that examines whether a fractional value is sufficiently near to a midpoint value to be subject to midpoint rounding.</span></span> <span data-ttu-id="e585d-804">Dane wyjściowe z przykładu pokazują, że rozwiązuje problem z zaokrąglaniem pokazanym w poprzednim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="e585d-804">As the output from the example shows, it corrects the rounding problem shown in the previous example.</span></span>  
  
     [!code-csharp[System.Math.Round.Overload#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision2.cs#8)]
     [!code-vb[System.Math.Round.Overload#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision2.vb#8)]  
  
#### <a name="rounding-and-single-precision-floating-point-values"></a><span data-ttu-id="e585d-805">Zaokrąglenia i pojedyncza precyzja wartości zmiennoprzecinkowych</span><span class="sxs-lookup"><span data-stu-id="e585d-805">Rounding and single-precision floating-point values</span></span>  

<span data-ttu-id="e585d-806">Metoda obejmuje przeciążenia, które akceptują argumenty typu <xref:System.Decimal> i <xref:System.Double>. <xref:System.Math.Round%2A></span><span class="sxs-lookup"><span data-stu-id="e585d-806">The <xref:System.Math.Round%2A> method includes overloads that accept arguments of type <xref:System.Decimal> and <xref:System.Double>.</span></span> <span data-ttu-id="e585d-807">Nie ma metod, które zaokrąglają wartości typu <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="e585d-807">There are no methods that round values of type <xref:System.Single>.</span></span> <span data-ttu-id="e585d-808">W <xref:System.Single> przypadku przekazania wartości do jednego z przeciążeń <xref:System.Math.Round%2A> metody są one rzutowane (w programie C#) lub <xref:System.Double>konwertowane (w Visual Basic) na, i zostanie wywołane odpowiednie <xref:System.Math.Round%2A> Przeciążenie z <xref:System.Double> parametrem.</span><span class="sxs-lookup"><span data-stu-id="e585d-808">If you pass a <xref:System.Single> value to one of the overloads of the <xref:System.Math.Round%2A> method, it is cast (in C#) or converted (in Visual Basic) to a <xref:System.Double>, and the corresponding <xref:System.Math.Round%2A> overload with a <xref:System.Double> parameter is called.</span></span> <span data-ttu-id="e585d-809">Chociaż jest to konwersja rozszerzająca, często wiąże się z utratą precyzji, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="e585d-809">Although this is a widening conversion, it often involves a loss of precision, as the following example illustrates.</span></span> <span data-ttu-id="e585d-810">Gdy wartość 16,325 jest przekazywany <xref:System.Math.Round%2A> do metody i zaokrąglana do dwóch miejsc dziesiętnych przy użyciu zaokrąglenia do najbliższej Konwencji, wynik wynosi 16,33, a nie oczekiwany wynik 16,32. <xref:System.Single></span><span class="sxs-lookup"><span data-stu-id="e585d-810">When a <xref:System.Single> value of 16.325 is passed to the <xref:System.Math.Round%2A> method and rounded to two decimal places using the rounding to nearest convention, the result is 16.33 and not the expected result of 16.32.</span></span>  
  
[!code-csharp[System.Math.Round.Overload#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/single1.cs#1)]
[!code-vb[System.Math.Round.Overload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/single1.vb#1)]  
  
<span data-ttu-id="e585d-811">Nieoczekiwany wynik wynika z utraty dokładności konwersji <xref:System.Single> wartości <xref:System.Double>na.</span><span class="sxs-lookup"><span data-stu-id="e585d-811">This unexpected result is due to a loss of precision in the conversion of the <xref:System.Single> value to a <xref:System.Double>.</span></span> <span data-ttu-id="e585d-812"><xref:System.Double> Ponieważ wartość 16.325000762939453 nie jest wartością punktu środkowego i jest większa niż 16,325, jest zawsze zaokrąglana w górę.</span><span class="sxs-lookup"><span data-stu-id="e585d-812">Because the resulting <xref:System.Double> value of 16.325000762939453 is not a midpoint value and is greater than 16.325, it is always rounded upward.</span></span>  
  
<span data-ttu-id="e585d-813">W wielu przypadkach, jak pokazano w przykładzie, ubytek dokładności może być zminimalizowany lub eliminowany przez rzutowanie lub przekonwertowanie <xref:System.Single> wartości <xref:System.Decimal>na.</span><span class="sxs-lookup"><span data-stu-id="e585d-813">In many cases, as the example illustrates, the loss of precision can be minimized or eliminated by casting or converting the <xref:System.Single> value to a <xref:System.Decimal>.</span></span> <span data-ttu-id="e585d-814">Należy zauważyć, że ponieważ jest to zawężana konwersja, wymaga użycia operatora rzutowania lub wywołania metody konwersji.</span><span class="sxs-lookup"><span data-stu-id="e585d-814">Note that, because this is a narrowing conversion, it requires using a cast operator or calling a conversion method.</span></span>  

<a name="round-examples"></a>  
## Examples 

<span data-ttu-id="e585d-815">Oprócz przykładów w sekcji [uwagi](#remarks-round) ten artykuł zawiera przykłady ilustrujące następujące przeciążenia `Math.Round` metody:</span><span class="sxs-lookup"><span data-stu-id="e585d-815">In addition to the examples in the [Remarks](#remarks-round) section, this article includes examples that illustrate the following overloads of the `Math.Round` method:</span></span>

[<span data-ttu-id="e585d-816">Math. Round (Decimal)</span><span class="sxs-lookup"><span data-stu-id="e585d-816">Math.Round(Decimal)</span></span>](#Round1_Example)  
[<span data-ttu-id="e585d-817">Math. Round (Double)</span><span class="sxs-lookup"><span data-stu-id="e585d-817">Math.Round(Double)</span></span>](#Round2_Example)  
[<span data-ttu-id="e585d-818">Math. Round (Decimal, Int32)</span><span class="sxs-lookup"><span data-stu-id="e585d-818">Math.Round(Decimal, Int32)</span></span>](#Round3_Example)  
[<span data-ttu-id="e585d-819">Math. Round (Decimal, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="e585d-819">Math.Round(Decimal, MidpointRounding)</span></span>](#Round4_Example)  
[<span data-ttu-id="e585d-820">Math. Round (Double, Int32)</span><span class="sxs-lookup"><span data-stu-id="e585d-820">Math.Round(Double, Int32)</span></span>](#Round5_Example)  
[<span data-ttu-id="e585d-821">Math. Round (Double, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="e585d-821">Math.Round(Double, MidpointRounding)</span></span>](#Round6_Example)  
[<span data-ttu-id="e585d-822">Math. Round (Decimal, Int32, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="e585d-822">Math.Round(Decimal, Int32, MidpointRounding)</span></span>](#Round7_Example)  
[<span data-ttu-id="e585d-823">Math. Round (Double, Int32, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="e585d-823">Math.Round(Double, Int32, MidpointRounding)</span></span>](#Round8_Example)  

[!INCLUDE[midpoint-rounding](~/includes/csharp-interactive-note.md)]

       ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
        <altmember cref="M:System.Math.Truncate(System.Decimal)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Round : decimal -&gt; decimal" Usage="System.Math.Round d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-824">Liczba dziesiętna ma zostać zaokrąglona.</span><span class="sxs-lookup"><span data-stu-id="e585d-824">A decimal number to be rounded.</span></span></param>
        <summary><span data-ttu-id="e585d-825">Zaokrągla wartość dziesiętną do najbliższej wartości całkowitej i zaokrągla wartości punktu środkowego do najbliższej parzystej liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-825">Rounds a decimal value to the nearest integral value, and rounds midpoint values to the nearest even number.</span></span></summary>
        <returns><span data-ttu-id="e585d-826">Liczba całkowita najbliżej <paramref name="d" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="e585d-826">The integer nearest the <paramref name="d" /> parameter.</span></span> <span data-ttu-id="e585d-827">Jeśli składnik <paramref name="d" /> częściowy jest w połowie między dwoma liczbami całkowitymi, a jednym z nich jest parzystość, a druga nieparzysta, zwracana jest liczba parzysta.</span><span class="sxs-lookup"><span data-stu-id="e585d-827">If the fractional component of <paramref name="d" /> is halfway between two integers, one of which is even and the other odd, the even number is returned.</span></span> <span data-ttu-id="e585d-828">Należy zauważyć, że ta metoda <see cref="T:System.Decimal" /> zwraca zamiast typu całkowitego.</span><span class="sxs-lookup"><span data-stu-id="e585d-828">Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
  
<span data-ttu-id="e585d-829">Ta metoda używa domyślnej Konwencji <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>zaokrąglania.</span><span class="sxs-lookup"><span data-stu-id="e585d-829">This method uses the default rounding convention of <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e585d-830">Zobacz [wartości punktu środkowego i konwencje zaokrąglania,](#midpoint-values-and-rounding-conventions) Aby uzyskać informacje na temat zaokrąglania liczb z wartościami punktów środkowych.</span><span class="sxs-lookup"><span data-stu-id="e585d-830">See [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions) for information about rounding numbers with midpoint values.</span></span>

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<a name="Round1_Example"></a> 
## <a name="example"></a><span data-ttu-id="e585d-831">Przykład</span><span class="sxs-lookup"><span data-stu-id="e585d-831">Example</span></span>

<span data-ttu-id="e585d-832">Poniższy przykład demonstruje <xref:System.Math.Round%28System.Decimal%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="e585d-832">The following example demonstrates the <xref:System.Math.Round%28System.Decimal%29> method.</span></span> <span data-ttu-id="e585d-833">Należy zauważyć, <xref:System.Decimal> że wartość 4,5 jest zaokrąglana do 4 zamiast 5, ponieważ to Przeciążenie używa standardowej <xref:System.MidpointRounding.ToEven> Konwencji.</span><span class="sxs-lookup"><span data-stu-id="e585d-833">Note that the <xref:System.Decimal> value of 4.5 rounds to 4 rather than 5, because this overload uses the default <xref:System.MidpointRounding.ToEven> convention.</span></span>  
  
[!code-csharp-interactive[System.Math.Round#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/rounddecimal1.cs#6)]
[!code-vb[System.Math.Round#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/rounddecimal1.vb#6)]  

       ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="e585d-834">Wynik jest spoza zakresu <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-834">The result is outside the range of a <see cref="T:System.Decimal" />.</span></span></exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double a);" />
      <MemberSignature Language="F#" Value="static member Round : double -&gt; double" Usage="System.Math.Round a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="e585d-835">Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać zaokrąglona.</span><span class="sxs-lookup"><span data-stu-id="e585d-835">A double-precision floating-point number to be rounded.</span></span></param>
        <summary><span data-ttu-id="e585d-836">Zaokrągla wartość zmiennoprzecinkową o podwójnej precyzji do najbliższej wartości całkowitej i zaokrągla wartości punktu środkowego do najbliższej parzystej liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-836">Rounds a double-precision floating-point value to the nearest integral value, and rounds midpoint values to the nearest even number.</span></span></summary>
        <returns><span data-ttu-id="e585d-837">Najbliższa <paramref name="a" />liczba całkowita.</span><span class="sxs-lookup"><span data-stu-id="e585d-837">The integer nearest <paramref name="a" />.</span></span> <span data-ttu-id="e585d-838">Jeśli składnik <paramref name="a" /> częściowy jest w połowie między dwoma liczbami całkowitymi, a jednym z nich jest parzystość, a druga nieparzysta, zwracana jest liczba parzysta.</span><span class="sxs-lookup"><span data-stu-id="e585d-838">If the fractional component of <paramref name="a" /> is halfway between two integers, one of which is even and the other odd, then the even number is returned.</span></span> <span data-ttu-id="e585d-839">Należy zauważyć, że ta metoda <see cref="T:System.Double" /> zwraca zamiast typu całkowitego.</span><span class="sxs-lookup"><span data-stu-id="e585d-839">Note that this method returns a <see cref="T:System.Double" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="e585d-840">Ta metoda używa domyślnej Konwencji <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>zaokrąglania.</span><span class="sxs-lookup"><span data-stu-id="e585d-840">This method uses the default rounding convention of <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e585d-841">Zobacz [wartości punktu środkowego i konwencje zaokrąglania,](#midpoint-values-and-rounding-conventions) Aby uzyskać informacje na temat zaokrąglania liczb z wartościami punktów środkowych.</span><span class="sxs-lookup"><span data-stu-id="e585d-841">See [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions) for information about rounding numbers with midpoint values.</span></span>

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<span data-ttu-id="e585d-842">Jeśli wartość `a` argumentu to <xref:System.Double.NaN?displayProperty=nameWithType>, metoda zwraca <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e585d-842">If the value of the `a` argument is <xref:System.Double.NaN?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e585d-843">Jeśli `a` jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub ,<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>Metoda zwraca<xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="e585d-843">If `a` is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  

<span data-ttu-id="e585d-844">Począwszy od Visual Basic 15,8, wydajność konwersji podwójnej do liczby całkowitej jest zoptymalizowana, jeśli przekazujesz wartość zwróconą przez `Round` metodę do którejkolwiek [funkcji konwersji całkowitej](~/docs/visual-basic/language-reference/functions/conversion-functions.md)lub jeśli wartość podwójna zwracana przez `Round` jest automatycznie konwertowany na liczbę całkowitą z [opcją Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) ustawioną na wartość off.</span><span class="sxs-lookup"><span data-stu-id="e585d-844">Starting with Visual Basic 15.8, the performance of Double-to-integer conversion is optimized if you pass the value returned by the `Round` method to the any of the [integral conversion functions](~/docs/visual-basic/language-reference/functions/conversion-functions.md), or if the Double value returned by `Round` is automatically converted to an integer with [Option Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) set to Off.</span></span> <span data-ttu-id="e585d-845">Ta optymalizacja umożliwia szybsze uruchamianie kodu — maksymalnie dwa razy w przypadku kodu, który wykonuje dużą liczbę konwersji na typy całkowite.</span><span class="sxs-lookup"><span data-stu-id="e585d-845">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="e585d-846">Poniższy przykład ilustruje takie zoptymalizowane konwersje:</span><span class="sxs-lookup"><span data-stu-id="e585d-846">The following example illustrates such optimized conversions:</span></span>
   
```vb
Dim d1 As Double = 1043.75133
Dim i1 As Integer = CInt(Math.Ceiling(d1))        ' Result: 1044

Dim d2 As Double = 7968.4136
Dim i2 As Integer = CInt(Math.Ceiling(d2))        ' Result: 7968
```

<a name="Round2_Example"></a>   
## <a name="example"></a><span data-ttu-id="e585d-847">Przykład</span><span class="sxs-lookup"><span data-stu-id="e585d-847">Example</span></span>  

<span data-ttu-id="e585d-848">Poniższy przykład ilustruje Zaokrąglenie do najbliższej wartości całkowitej.</span><span class="sxs-lookup"><span data-stu-id="e585d-848">The following example demonstrates rounding to the nearest integer value.</span></span>  
  
[!code-cpp[Classic Math.Round Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round Example/CPP/source.cpp#1)]
[!code-csharp-interactive[Classic Math.Round Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round Example/CS/source.cs#1)]
[!code-vb[Classic Math.Round Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round Example/VB/source.vb#1)]  

       ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="e585d-849">Ze względu na utratę precyzji, która może wynikać z reprezentowania wartości dziesiętnych jako liczby zmiennoprzecinkowe lub wykonywania operacji arytmetycznych na wartościach zmiennoprzecinkowych, <see cref="M:System.Math.Round(System.Double)" /> w niektórych przypadkach Metoda może nie być widoczna w celu zaokrąglania wartości punktu środkowego do Najbliższa parzysta liczba całkowita.</span><span class="sxs-lookup"><span data-stu-id="e585d-849">Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double)" /> method may not appear to round midpoint values to the nearest even integer.</span></span> <span data-ttu-id="e585d-850">W poniższym przykładzie, ponieważ wartość zmiennoprzecinkowa nie ma skończonej reprezentacji binarnej, pierwsze wywołanie <see cref="M:System.Math.Round(System.Double)" /> metody z wartością 11,5 zwraca wartość 11 zamiast 12.</span><span class="sxs-lookup"><span data-stu-id="e585d-850">In the following example, because the floating-point value .1 has no finite binary representation, the first call to the <see cref="M:System.Math.Round(System.Double)" /> method with a value of 11.5 returns 11 instead of 12.</span></span>  
  
<span data-ttu-id="e585d-851">[! code-CSharp[System. Math. Round # 1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round2.cs#1)] [! code — VB[System. Math. Round # 1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round2.vb#1)]</span><span class="sxs-lookup"><span data-stu-id="e585d-851">[!code-csharp[System.Math.Round#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round2.cs#1)] [!code-vb[System.Math.Round#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round2.vb#1)]</span></span></para></block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals);" />
      <MemberSignature Language="F#" Value="static member Round : decimal * int -&gt; decimal" Usage="System.Math.Round (d, decimals)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-852">Liczba dziesiętna ma zostać zaokrąglona.</span><span class="sxs-lookup"><span data-stu-id="e585d-852">A decimal number to be rounded.</span></span></param>
        <param name="decimals"><span data-ttu-id="e585d-853">Liczba miejsc dziesiętnych w wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="e585d-853">The number of decimal places in the return value.</span></span></param>
        <summary><span data-ttu-id="e585d-854">Zaokrągla wartość dziesiętną do określonej liczby cyfr ułamkowych i zaokrągla wartości punktu środkowego do najbliższej parzystej liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-854">Rounds a decimal value to a specified number of fractional digits, and rounds midpoint values to the nearest even number.</span></span></summary>
        <returns><span data-ttu-id="e585d-855">Liczba znajdująca się <paramref name="d" /> najbliżej, która zawiera liczbę cyfr dziesiętnych <paramref name="decimals" />równą.</span><span class="sxs-lookup"><span data-stu-id="e585d-855">The number nearest to <paramref name="d" /> that contains a number of fractional digits equal to <paramref name="decimals" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<span data-ttu-id="e585d-856">Wartość `decimals` argumentu może być z zakresu od 0 do 28.</span><span class="sxs-lookup"><span data-stu-id="e585d-856">The value of the `decimals` argument can range from 0 to 28.</span></span>

<span data-ttu-id="e585d-857">Ta metoda używa domyślnej Konwencji <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>zaokrąglania.</span><span class="sxs-lookup"><span data-stu-id="e585d-857">This method uses the default rounding convention of <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e585d-858">Zobacz [wartości punktu środkowego i konwencje zaokrąglania,](#midpoint-values-and-rounding-conventions) Aby uzyskać informacje na temat zaokrąglania liczb z wartościami punktów środkowych.</span><span class="sxs-lookup"><span data-stu-id="e585d-858">See [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions) for information about rounding numbers with midpoint values.</span></span>

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<a name="Round3_Example"></a>   
## <a name="example"></a><span data-ttu-id="e585d-859">Przykład</span><span class="sxs-lookup"><span data-stu-id="e585d-859">Example</span></span>  

<span data-ttu-id="e585d-860">Poniższy przykład zaokrągla wartości dziesiętne o dwie cyfry ułamkowe do wartości, które mają jedną cyfrę ułamkową.</span><span class="sxs-lookup"><span data-stu-id="e585d-860">The following example rounds decimal values with two fractional digits to values that have a single fractional digit.</span></span>  
  
[!code-csharp-interactive[System.Math.Round.Overload#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/source.cs#3)]
[!code-vb[System.Math.Round.Overload#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/source.vb#3)]  
  
      ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e585d-861"><paramref name="decimals" />jest mniejsza niż 0 lub większa niż 28.</span><span class="sxs-lookup"><span data-stu-id="e585d-861"><paramref name="decimals" /> is less than 0 or greater than 28.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="e585d-862">Wynik jest spoza zakresu <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-862">The result is outside the range of a <see cref="T:System.Decimal" />.</span></span></exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : decimal * MidpointRounding -&gt; decimal" Usage="System.Math.Round (d, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.MidpointRounding" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-863">Liczba dziesiętna ma zostać zaokrąglona.</span><span class="sxs-lookup"><span data-stu-id="e585d-863">A decimal number to be rounded.</span></span></param>
        <param name="mode"><span data-ttu-id="e585d-864">Specyfikacja, w której ma <paramref name="d" /> zostać zaokrąglona wartość w połowie między dwiema innymi liczbami.</span><span class="sxs-lookup"><span data-stu-id="e585d-864">Specification for how to round <paramref name="d" /> if it is midway between two other numbers.</span></span></param>
        <summary><span data-ttu-id="e585d-865">Zaokrągla wartość dziesiętną do najbliższej liczby całkowitej i używa określonej konwencji zaokrąglania dla wartości punktu środkowego.</span><span class="sxs-lookup"><span data-stu-id="e585d-865">Rounds a decimal value to the nearest integer, and uses the specified rounding convention for midpoint values.</span></span></summary>
        <returns><span data-ttu-id="e585d-866">Najbliższa <paramref name="d" />liczba całkowita.</span><span class="sxs-lookup"><span data-stu-id="e585d-866">The integer nearest <paramref name="d" />.</span></span> <span data-ttu-id="e585d-867">Jeśli <paramref name="d" /> jest w połowie między dwiema liczbami, a jedna z nich jest parzysta, a <paramref name="mode" /> druga nieparzysta, a następnie określa, które z dwóch wartości są zwracane.</span><span class="sxs-lookup"><span data-stu-id="e585d-867">If <paramref name="d" /> is halfway between two numbers, one of which is even and the other odd, then <paramref name="mode" /> determines which of the two is returned.</span></span> <span data-ttu-id="e585d-868">Należy zauważyć, że ta metoda <see cref="T:System.Decimal" /> zwraca zamiast typu całkowitego.</span><span class="sxs-lookup"><span data-stu-id="e585d-868">Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="e585d-869">Zobacz [wartości punktu środkowego i konwencje zaokrąglania,](#midpoint-values-and-rounding-conventions) Aby uzyskać informacje na temat zaokrąglania liczb z wartościami punktów środkowych.</span><span class="sxs-lookup"><span data-stu-id="e585d-869">See [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions) for information about rounding numbers with midpoint values.</span></span>

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<a name="Round5_Example"></a>   
## <a name="example"></a><span data-ttu-id="e585d-870">Przykład</span><span class="sxs-lookup"><span data-stu-id="e585d-870">Example</span></span>  

<span data-ttu-id="e585d-871">Poniższy przykład wyświetla <xref:System.Math.Round%28System.Decimal%29> wartości zwracane przez metodę <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> , <xref:System.MidpointRounding.ToEven>metodę z `mode` <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> <xref:System.MidpointRounding.AwayFromZero>argumentem i metodę z argumentem.`mode`</span><span class="sxs-lookup"><span data-stu-id="e585d-871">The following example displays values returned by the <xref:System.Math.Round%28System.Decimal%29> method, the <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.ToEven>, and the <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.AwayFromZero>.</span></span>  
  
[!code-csharp-interactive[System.Math.Round.Overload#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint1.cs#5)]
[!code-vb[System.Math.Round.Overload#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint1.vb#5)]  
  
       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e585d-872"><paramref name="mode" />nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-872"><paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="e585d-873">Wynik jest spoza zakresu <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-873">The result is outside the range of a <see cref="T:System.Decimal" />.</span></span></exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, digits As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, int digits);" />
      <MemberSignature Language="F#" Value="static member Round : double * int -&gt; double" Usage="System.Math.Round (value, digits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-874">Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać zaokrąglona.</span><span class="sxs-lookup"><span data-stu-id="e585d-874">A double-precision floating-point number to be rounded.</span></span></param>
        <param name="digits"><span data-ttu-id="e585d-875">Liczba cyfr ułamkowych w wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="e585d-875">The number of fractional digits in the return value.</span></span></param>
        <summary><span data-ttu-id="e585d-876">Zaokrągla wartość zmiennoprzecinkową o podwójnej precyzji do określonej liczby cyfr ułamkowych i zaokrągla wartości punktu środkowego do najbliższej parzystej liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-876">Rounds a double-precision floating-point value to a specified number of fractional digits, and rounds midpoint values to the nearest even number.</span></span></summary>
        <returns><span data-ttu-id="e585d-877">Liczba znajdująca się <paramref name="value" /> najbliżej, która zawiera liczbę cyfr dziesiętnych <paramref name="digits" />równą.</span><span class="sxs-lookup"><span data-stu-id="e585d-877">The number nearest to <paramref name="value" /> that contains a number of fractional digits equal to <paramref name="digits" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<span data-ttu-id="e585d-878">Wartość `digits` argumentu może być z zakresu od 0 do 15.</span><span class="sxs-lookup"><span data-stu-id="e585d-878">The value of the `digits` argument can range from 0 to 15.</span></span> <span data-ttu-id="e585d-879">Należy zauważyć, że 15 to maksymalna liczba cyfr całkowitych i ułamkowych obsługiwanych przez <xref:System.Double> typ.</span><span class="sxs-lookup"><span data-stu-id="e585d-879">Note that 15 is the maximum number of integral and fractional digits supported by the <xref:System.Double> type.</span></span>

<span data-ttu-id="e585d-880">Ta metoda używa domyślnej Konwencji <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>zaokrąglania.</span><span class="sxs-lookup"><span data-stu-id="e585d-880">This method uses the default rounding convention of <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e585d-881">Zobacz [wartości punktu środkowego i konwencje zaokrąglania,](#midpoint-values-and-rounding-conventions) Aby uzyskać informacje na temat zaokrąglania liczb z wartościami punktów środkowych.</span><span class="sxs-lookup"><span data-stu-id="e585d-881">See [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions) for information about rounding numbers with midpoint values.</span></span>

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<span data-ttu-id="e585d-882">Jeśli wartość `value` argumentu to <xref:System.Double.NaN?displayProperty=nameWithType>, metoda zwraca <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e585d-882">If the value of the `value` argument is <xref:System.Double.NaN?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e585d-883">Jeśli `value` jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub ,<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>Metoda zwraca<xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="e585d-883">If `value` is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  

<a name="Round4_Example"></a>   
## <a name="example"></a><span data-ttu-id="e585d-884">Przykład</span><span class="sxs-lookup"><span data-stu-id="e585d-884">Example</span></span>  

<span data-ttu-id="e585d-885">W poniższym przykładzie są zaokrąglane podwójne wartości z dwiema cyframi dwubajtowymi, które mają pojedynczą cyfrę.</span><span class="sxs-lookup"><span data-stu-id="e585d-885">The following example rounds double values with two fractional digits to doubles that have a single fractional digit.</span></span>  
  
[!code-cpp[Classic Math.Round2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CPP/source.cpp#1)]
[!code-csharp[Classic Math.Round2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CS/source.cs#1)]
[!code-vb[Classic Math.Round2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round2 Example/VB/source.vb#1)]  
  
       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e585d-886"><paramref name="digits" />jest mniejsza niż 0 lub większa niż 15.</span><span class="sxs-lookup"><span data-stu-id="e585d-886"><paramref name="digits" /> is less than 0 or greater than 15.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="e585d-887">Ze względu na utratę precyzji, która może wynikać z reprezentowania wartości dziesiętnych jako liczby zmiennoprzecinkowe lub wykonywania operacji arytmetycznych na wartościach zmiennoprzecinkowych, <see cref="M:System.Math.Round(System.Double,System.Int32)" /> w niektórych przypadkach Metoda może nie być widoczna w celu zaokrąglania wartości punktu środkowego do Najbliższa wartość parzystą <paramref name="digits" /> w pozycji dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="e585d-887">Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.Int32)" /> method may not appear to round midpoint values to the nearest even value in the <paramref name="digits" /> decimal position.</span></span> <span data-ttu-id="e585d-888">Jest to zilustrowane w poniższym przykładzie, gdzie 2,135 jest zaokrąglana do 2,13 zamiast 2,14.</span><span class="sxs-lookup"><span data-stu-id="e585d-888">This is illustrated in the following example, where 2.135 is rounded to 2.13 instead of 2.14.</span></span> <span data-ttu-id="e585d-889">Dzieje się tak, ponieważ wewnętrznie metoda mnoży <paramref name="value" /> przez 10<sup>cyfr</sup>, a operacja mnożenia w tym przypadku spada z utraty dokładności.</span><span class="sxs-lookup"><span data-stu-id="e585d-889">This occurs because internally the method multiplies <paramref name="value" /> by 10<sup>digits</sup>, and the multiplication operation in this case suffers from a loss of precision.</span></span>  
  
<span data-ttu-id="e585d-890">[! code-CSharp[System. Math. Round # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round3.cs#2)] [! code — VB[System. Math. Round # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round3.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="e585d-890">[!code-csharp[System.Math.Round#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round3.cs#2)] [!code-vb[System.Math.Round#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round3.vb#2)]</span></span></para></block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, mode As MidpointRounding) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : double * MidpointRounding -&gt; double" Usage="System.Math.Round (value, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.MidpointRounding" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-891">Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać zaokrąglona.</span><span class="sxs-lookup"><span data-stu-id="e585d-891">A double-precision floating-point number to be rounded.</span></span></param>
        <param name="mode"><span data-ttu-id="e585d-892">Specyfikacja, w której ma <paramref name="value" /> zostać zaokrąglona wartość w połowie między dwiema innymi liczbami.</span><span class="sxs-lookup"><span data-stu-id="e585d-892">Specification for how to round <paramref name="value" /> if it is midway between two other numbers.</span></span></param>
        <summary><span data-ttu-id="e585d-893">Zaokrągla wartość zmiennoprzecinkową o podwójnej precyzji do najbliższej liczby całkowitej i używa określonej konwencji zaokrąglania dla wartości środkowych.</span><span class="sxs-lookup"><span data-stu-id="e585d-893">Rounds a double-precision floating-point value to the nearest integer, and uses the specified rounding convention for midpoint values.</span></span></summary>
        <returns><span data-ttu-id="e585d-894">Najbliższa <paramref name="value" />liczba całkowita.</span><span class="sxs-lookup"><span data-stu-id="e585d-894">The integer nearest <paramref name="value" />.</span></span> <span data-ttu-id="e585d-895">Jeśli <paramref name="value" /> jest w połowie między dwoma liczbami całkowitymi, a jedna z nich jest parzysta, <paramref name="mode" /> a druga nieparzysta, a następnie określa, które z dwóch wartości są zwracane.</span><span class="sxs-lookup"><span data-stu-id="e585d-895">If <paramref name="value" /> is halfway between two integers, one of which is even and the other odd, then <paramref name="mode" /> determines which of the two is returned.</span></span> <span data-ttu-id="e585d-896">Należy zauważyć, że ta metoda <see cref="T:System.Double" /> zwraca zamiast typu całkowitego.</span><span class="sxs-lookup"><span data-stu-id="e585d-896">Note that this method returns a <see cref="T:System.Double" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="e585d-897">Zobacz [wartości punktu środkowego i konwencje zaokrąglania,](#midpoint-values-and-rounding-conventions) Aby uzyskać informacje na temat zaokrąglania liczb z wartościami punktów środkowych.</span><span class="sxs-lookup"><span data-stu-id="e585d-897">See [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions) for information about rounding numbers with midpoint values.</span></span>

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<span data-ttu-id="e585d-898">Jeśli wartość `value` argumentu to <xref:System.Double.NaN?displayProperty=nameWithType>, metoda zwraca <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e585d-898">If the value of the `value` argument is <xref:System.Double.NaN?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e585d-899">Jeśli `value` jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub ,<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>Metoda zwraca<xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="e585d-899">If `value` is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  

<a name="Round6_Example"></a>   
## <a name="example"></a><span data-ttu-id="e585d-900">Przykład</span><span class="sxs-lookup"><span data-stu-id="e585d-900">Example</span></span>  
<span data-ttu-id="e585d-901">Poniższy przykład wyświetla <xref:System.Math.Round%28System.Double%29> wartości zwracane przez metodę <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> , <xref:System.MidpointRounding.ToEven>metodę z `mode` <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> <xref:System.MidpointRounding.AwayFromZero>argumentem i metodę z argumentem.`mode`</span><span class="sxs-lookup"><span data-stu-id="e585d-901">The following example displays values returned by the <xref:System.Math.Round%28System.Double%29> method, the <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.ToEven>, and the <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.AwayFromZero>.</span></span>  
  
[!code-csharp[System.Math.Round.Overload#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint2.cs#6)]
[!code-vb[System.Math.Round.Overload#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint2.vb#6)]  
  
       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e585d-902"><paramref name="mode" />nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-902"><paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="e585d-903">Ze względu na utratę precyzji, która może wynikać z reprezentowania wartości dziesiętnych jako liczby zmiennoprzecinkowe lub wykonywania operacji arytmetycznych na wartościach zmiennoprzecinkowych, <see cref="M:System.Math.Round(System.Double,System.MidpointRounding)" /> w niektórych przypadkach Metoda może nie być widoczna w celu zaokrąglania wartości punktu środkowego do Najbliższa parzysta liczba całkowita.</span><span class="sxs-lookup"><span data-stu-id="e585d-903">Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.MidpointRounding)" /> method may not appear to round midpoint values to the nearest even integer.</span></span> <span data-ttu-id="e585d-904">W poniższym przykładzie, ponieważ wartość zmiennoprzecinkowa nie ma skończonej reprezentacji binarnej, pierwsze wywołanie <see cref="M:System.Math.Round(System.Double)" /> metody z wartością 11,5 zwraca wartość 11 zamiast 12.</span><span class="sxs-lookup"><span data-stu-id="e585d-904">In the following example, because the floating-point value .1 has no finite binary representation, the first call to the <see cref="M:System.Math.Round(System.Double)" /> method with a value of 11.5 returns 11 instead of 12.</span></span>  
  
<span data-ttu-id="e585d-905">[! code-CSharp[System. Math. Round # 4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round5.cs#4)] [! code — VB[System. Math. Round # 4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round5.vb#4)]</span><span class="sxs-lookup"><span data-stu-id="e585d-905">[!code-csharp[System.Math.Round#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round5.cs#4)] [!code-vb[System.Math.Round#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round5.vb#4)]</span></span></para></block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : decimal * int * MidpointRounding -&gt; decimal" Usage="System.Math.Round (d, decimals, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decimals" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.MidpointRounding" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-906">Liczba dziesiętna ma zostać zaokrąglona.</span><span class="sxs-lookup"><span data-stu-id="e585d-906">A decimal number to be rounded.</span></span></param>
        <param name="decimals"><span data-ttu-id="e585d-907">Liczba miejsc dziesiętnych w wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="e585d-907">The number of decimal places in the return value.</span></span></param>
        <param name="mode"><span data-ttu-id="e585d-908">Specyfikacja, w której ma <paramref name="d" /> zostać zaokrąglona wartość w połowie między dwiema innymi liczbami.</span><span class="sxs-lookup"><span data-stu-id="e585d-908">Specification for how to round <paramref name="d" /> if it is midway between two other numbers.</span></span></param>
        <summary><span data-ttu-id="e585d-909">Zaokrągla wartość dziesiętną do określonej liczby cyfr ułamkowych i używa określonej konwencji zaokrąglania dla wartości punktu środkowego.</span><span class="sxs-lookup"><span data-stu-id="e585d-909">Rounds a decimal value to a specified number of fractional digits, and uses the specified rounding convention for midpoint values.</span></span></summary>
        <returns><span data-ttu-id="e585d-910">Liczba znajdująca się <paramref name="d" /> najbliżej, która zawiera liczbę cyfr dziesiętnych <paramref name="decimals" />równą.</span><span class="sxs-lookup"><span data-stu-id="e585d-910">The number nearest to <paramref name="d" /> that contains a number of fractional digits equal to <paramref name="decimals" />.</span></span> <span data-ttu-id="e585d-911">Jeśli <paramref name="d" /> ma mniejszą liczbę cyfr ułamkowych <paramref name="decimals" />niż <paramref name="d" /> , jest zwracana bez zmian.</span><span class="sxs-lookup"><span data-stu-id="e585d-911">If <paramref name="d" /> has fewer fractional digits than <paramref name="decimals" />, <paramref name="d" /> is returned unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e585d-912">Zobacz [wartości punktu środkowego i konwencje zaokrąglania,](#midpoint-values-and-rounding-conventions) Aby uzyskać informacje na temat zaokrąglania liczb z wartościami punktów środkowych.</span><span class="sxs-lookup"><span data-stu-id="e585d-912">See [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions) for information about rounding numbers with midpoint values.</span></span>

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]  

<span data-ttu-id="e585d-913">Wartość `decimals` argumentu może być z zakresu od 0 do 28.</span><span class="sxs-lookup"><span data-stu-id="e585d-913">The value of the `decimals` argument can range from 0 to 28.</span></span>

<a name="Round7_Example"></a>   
## <a name="example"></a><span data-ttu-id="e585d-914">Przykład</span><span class="sxs-lookup"><span data-stu-id="e585d-914">Example</span></span>  

<span data-ttu-id="e585d-915">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Round%2A> metody <xref:System.MidpointRounding> z wyliczeniem.</span><span class="sxs-lookup"><span data-stu-id="e585d-915">The following example demonstrates how to use the <xref:System.Math.Round%2A> method with the <xref:System.MidpointRounding> enumeration.</span></span>  
  
[!code-cpp[math.midpointrounding#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.midpointrounding/cpp/mpr.cpp#1)]
[!code-csharp-interactive[math.midpointrounding#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.midpointrounding/CS/mpr.cs#1)]
[!code-vb[math.midpointrounding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.midpointrounding/VB/mpr.vb#1)]  

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e585d-916"><paramref name="decimals" />jest mniejsza niż 0 lub większa niż 28.</span><span class="sxs-lookup"><span data-stu-id="e585d-916"><paramref name="decimals" /> is less than 0 or greater than 28.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e585d-917"><paramref name="mode" />nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-917"><paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="e585d-918">Wynik jest spoza zakresu <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-918">The result is outside the range of a <see cref="T:System.Decimal" />.</span></span></exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, digits As Integer, mode As MidpointRounding) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, int digits, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : double * int * MidpointRounding -&gt; double" Usage="System.Math.Round (value, digits, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="digits" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.MidpointRounding" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-919">Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać zaokrąglona.</span><span class="sxs-lookup"><span data-stu-id="e585d-919">A double-precision floating-point number to be rounded.</span></span></param>
        <param name="digits"><span data-ttu-id="e585d-920">Liczba cyfr ułamkowych w wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="e585d-920">The number of fractional digits in the return value.</span></span></param>
        <param name="mode"><span data-ttu-id="e585d-921">Specyfikacja, w której ma <paramref name="value" /> zostać zaokrąglona wartość w połowie między dwiema innymi liczbami.</span><span class="sxs-lookup"><span data-stu-id="e585d-921">Specification for how to round <paramref name="value" /> if it is midway between two other numbers.</span></span></param>
        <summary><span data-ttu-id="e585d-922">Zaokrągla wartość zmiennoprzecinkową o podwójnej precyzji do określonej liczby cyfr ułamkowych i używa określonej konwencji zaokrąglania dla wartości punktu środkowego.</span><span class="sxs-lookup"><span data-stu-id="e585d-922">Rounds a double-precision floating-point value to a specified number of fractional digits, and uses the specified rounding convention for midpoint values.</span></span></summary>
        <returns><span data-ttu-id="e585d-923">Liczba <paramref name="value" /> znajdująca się najbliżej, która ma liczbę cyfr dziesiętnych <paramref name="digits" />równą.</span><span class="sxs-lookup"><span data-stu-id="e585d-923">The number nearest to <paramref name="value" /> that has a number of fractional digits equal to <paramref name="digits" />.</span></span> <span data-ttu-id="e585d-924">Jeśli <paramref name="value" /> ma mniejszą liczbę cyfr ułamkowych <paramref name="digits" />niż <paramref name="value" /> , jest zwracana bez zmian.</span><span class="sxs-lookup"><span data-stu-id="e585d-924">If <paramref name="value" /> has fewer fractional digits than <paramref name="digits" />, <paramref name="value" /> is returned unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="e585d-925">Wartość `digits` argumentu może być z zakresu od 0 do 15.</span><span class="sxs-lookup"><span data-stu-id="e585d-925">The value of the `digits` argument can range from 0 to 15.</span></span> <span data-ttu-id="e585d-926">Należy zauważyć, że 15 to maksymalna liczba cyfr całkowitych i ułamkowych obsługiwanych przez <xref:System.Double> typ.</span><span class="sxs-lookup"><span data-stu-id="e585d-926">Note that 15 is the maximum number of integral and fractional digits supported by the <xref:System.Double> type.</span></span>

<span data-ttu-id="e585d-927">Zobacz [wartości punktu środkowego i konwencje zaokrąglania,](#midpoint-values-and-rounding-conventions) Aby uzyskać informacje na temat zaokrąglania liczb z wartościami punktów środkowych.</span><span class="sxs-lookup"><span data-stu-id="e585d-927">See [Midpoint values and rounding conventions](#midpoint-values-and-rounding-conventions) for information about rounding numbers with midpoint values.</span></span>

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<span data-ttu-id="e585d-928">Jeśli wartość `value` argumentu to <xref:System.Double.NaN?displayProperty=nameWithType>, metoda zwraca <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e585d-928">If the value of the `value` argument is <xref:System.Double.NaN?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e585d-929">Jeśli `value` jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub ,<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>Metoda zwraca<xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="e585d-929">If `value` is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  

<a name="Round8_Example"></a>   
## <a name="example"></a><span data-ttu-id="e585d-930">Przykład</span><span class="sxs-lookup"><span data-stu-id="e585d-930">Example</span></span>  

<span data-ttu-id="e585d-931">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29> metody <xref:System.MidpointRounding> z wyliczeniem.</span><span class="sxs-lookup"><span data-stu-id="e585d-931">The following example demonstrates how to use the <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29> method with the <xref:System.MidpointRounding> enumeration.</span></span>  
  
[!code-csharp[System.Math.Round.Overload#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mpr.cs#4)]
[!code-vb[System.Math.Round.Overload#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mpr.vb#4)]  
  
       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e585d-932"><paramref name="digits" />jest mniejsza niż 0 lub większa niż 15.</span><span class="sxs-lookup"><span data-stu-id="e585d-932"><paramref name="digits" /> is less than 0 or greater than 15.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e585d-933"><paramref name="mode" />nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-933"><paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="e585d-934">Ze względu na utratę precyzji, która może wynikać z reprezentowania wartości dziesiętnych jako liczby zmiennoprzecinkowe lub wykonywania operacji arytmetycznych na wartościach zmiennoprzecinkowych, <see cref="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" /> w niektórych przypadkach Metoda może nie być widoczna, aby zaokrąglić wartości punktu środkowego w określony sposób. <paramref name="mode" /> przez parametr.</span><span class="sxs-lookup"><span data-stu-id="e585d-934">Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" /> method may not appear to round midpoint values as specified by the <paramref name="mode" /> parameter.</span></span> <span data-ttu-id="e585d-935">Jest to zilustrowane w poniższym przykładzie, gdzie 2,135 jest zaokrąglana do 2,13 zamiast 2,14.</span><span class="sxs-lookup"><span data-stu-id="e585d-935">This is illustrated in the following example, where 2.135 is rounded to 2.13 instead of 2.14.</span></span> <span data-ttu-id="e585d-936">Dzieje się tak, ponieważ wewnętrznie metoda mnoży <paramref name="value" /> przez 10<sup>cyfr</sup>, a operacja mnożenia w tym przypadku spada z utraty dokładności.</span><span class="sxs-lookup"><span data-stu-id="e585d-936">This occurs because internally the method multiplies <paramref name="value" /> by 10<sup>digits</sup>, and the multiplication operation in this case suffers from a loss of precision.</span></span>  
  
<span data-ttu-id="e585d-937">[! code-CSharp[System. Math. Round # 3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round4.cs#3)] [! code — VB[System. Math. Round # 3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round4.vb#3)]</span><span class="sxs-lookup"><span data-stu-id="e585d-937">[!code-csharp[System.Math.Round#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round4.cs#3)] [!code-vb[System.Math.Round#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round4.vb#3)]</span></span></para></block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleB">
      <MemberSignature Language="C#" Value="public static double ScaleB (double x, int n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ScaleB(float64 x, int32 n) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.ScaleB(System.Double,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ScaleB (x As Double, n As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double ScaleB(double x, int n);" />
      <MemberSignature Language="F#" Value="static member ScaleB : double * int -&gt; double" Usage="System.Math.ScaleB (x, n)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="n" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="e585d-938">Liczba zmiennoprzecinkowa o pojedynczej precyzji, która określa wartość bazową.</span><span class="sxs-lookup"><span data-stu-id="e585d-938">A single-precision floating-point number that specifies the base value.</span></span></param>
        <param name="n"><span data-ttu-id="e585d-939">Liczba zmiennoprzecinkowa o pojedynczej precyzji, która określa moc.</span><span class="sxs-lookup"><span data-stu-id="e585d-939">A single-precision floating-point number that specifies the power.</span></span></param>
        <summary><span data-ttu-id="e585d-940">Zwraca wartość x \* 2 ^ n obliczoną efektywnie.</span><span class="sxs-lookup"><span data-stu-id="e585d-940">Returns x \* 2^n computed efficiently.</span></span></summary>
        <returns><span data-ttu-id="e585d-941">x \* 2 ^ n obliczono efektywnie.</span><span class="sxs-lookup"><span data-stu-id="e585d-941">x \* 2^n computed efficiently.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sign">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e585d-942">Zwraca liczbę całkowitą, która wskazuje znak liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-942">Returns an integer that indicates the sign of a number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Sign : decimal -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-943">Liczba dziesiętna ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-943">A signed decimal number.</span></span></param>
        <summary><span data-ttu-id="e585d-944">Zwraca liczbę całkowitą, która wskazuje znak liczby dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="e585d-944">Returns an integer that indicates the sign of a decimal number.</span></span></summary>
        <returns><span data-ttu-id="e585d-945">Liczba, która wskazuje znak <paramref name="value" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="e585d-945">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="e585d-946">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-946">Return value</span></span> 
 </term><description> <span data-ttu-id="e585d-947">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="e585d-947">Meaning</span></span> 
 </description></listheader><item><term> <span data-ttu-id="e585d-948">-1</span><span class="sxs-lookup"><span data-stu-id="e585d-948">-1</span></span> 
 </term><description><span data-ttu-id="e585d-949"><paramref name="value" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-949"><paramref name="value" /> is less than zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-950">0</span><span class="sxs-lookup"><span data-stu-id="e585d-950">0</span></span> 
 </term><description><span data-ttu-id="e585d-951"><paramref name="value" />jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="e585d-951"><paramref name="value" /> is equal to zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-952">1</span><span class="sxs-lookup"><span data-stu-id="e585d-952">1</span></span> 
 </term><description><span data-ttu-id="e585d-953"><paramref name="value" />jest większa od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-953"><paramref name="value" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-954">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Sign%28System.Decimal%29> metody do określenia znaku <xref:System.Decimal> wartości i wyświetlenia go w konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="e585d-954">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Decimal%29> method to determine the sign of a <xref:System.Decimal> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(double value);" />
      <MemberSignature Language="F#" Value="static member Sign : double -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-955">Liczba oznaczona.</span><span class="sxs-lookup"><span data-stu-id="e585d-955">A signed number.</span></span></param>
        <summary><span data-ttu-id="e585d-956">Zwraca liczbę całkowitą, która wskazuje znak liczby zmiennoprzecinkowej podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-956">Returns an integer that indicates the sign of a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="e585d-957">Liczba, która wskazuje znak <paramref name="value" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="e585d-957">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="e585d-958">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-958">Return value</span></span> 
 </term><description> <span data-ttu-id="e585d-959">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="e585d-959">Meaning</span></span> 
 </description></listheader><item><term> <span data-ttu-id="e585d-960">-1</span><span class="sxs-lookup"><span data-stu-id="e585d-960">-1</span></span> 
 </term><description><span data-ttu-id="e585d-961"><paramref name="value" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-961"><paramref name="value" /> is less than zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-962">0</span><span class="sxs-lookup"><span data-stu-id="e585d-962">0</span></span> 
 </term><description><span data-ttu-id="e585d-963"><paramref name="value" />jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="e585d-963"><paramref name="value" /> is equal to zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-964">1</span><span class="sxs-lookup"><span data-stu-id="e585d-964">1</span></span> 
 </term><description><span data-ttu-id="e585d-965"><paramref name="value" />jest większa od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-965"><paramref name="value" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-966">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Sign%28System.Double%29> metody do określenia znaku <xref:System.Double> wartości i wyświetlenia go w konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="e585d-966">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Double%29> method to determine the sign of a <xref:System.Double> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException"><span data-ttu-id="e585d-967"><paramref name="value" />jest równe <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-967"><paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Short) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(short value);" />
      <MemberSignature Language="F#" Value="static member Sign : int16 -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-968">Liczba oznaczona.</span><span class="sxs-lookup"><span data-stu-id="e585d-968">A signed number.</span></span></param>
        <summary><span data-ttu-id="e585d-969">Zwraca liczbę całkowitą wskazującą znak 16-bitowej podpisanej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="e585d-969">Returns an integer that indicates the sign of a 16-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="e585d-970">Liczba, która wskazuje znak <paramref name="value" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="e585d-970">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="e585d-971">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-971">Return value</span></span> 
 </term><description> <span data-ttu-id="e585d-972">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="e585d-972">Meaning</span></span> 
 </description></listheader><item><term> <span data-ttu-id="e585d-973">-1</span><span class="sxs-lookup"><span data-stu-id="e585d-973">-1</span></span> 
 </term><description><span data-ttu-id="e585d-974"><paramref name="value" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-974"><paramref name="value" /> is less than zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-975">0</span><span class="sxs-lookup"><span data-stu-id="e585d-975">0</span></span> 
 </term><description><span data-ttu-id="e585d-976"><paramref name="value" />jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="e585d-976"><paramref name="value" /> is equal to zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-977">1</span><span class="sxs-lookup"><span data-stu-id="e585d-977">1</span></span> 
 </term><description><span data-ttu-id="e585d-978"><paramref name="value" />jest większa od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-978"><paramref name="value" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-979">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Sign%28System.Int16%29> metody do określenia znaku <xref:System.Int16> wartości i wyświetlenia go w konsoli.</span><span class="sxs-lookup"><span data-stu-id="e585d-979">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int16%29> method to determine the sign of an <xref:System.Int16> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(int value);" />
      <MemberSignature Language="F#" Value="static member Sign : int -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-980">Liczba oznaczona.</span><span class="sxs-lookup"><span data-stu-id="e585d-980">A signed number.</span></span></param>
        <summary><span data-ttu-id="e585d-981">Zwraca liczbę całkowitą wskazującą znak 32-bitową liczbę całkowitą ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-981">Returns an integer that indicates the sign of a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="e585d-982">Liczba, która wskazuje znak <paramref name="value" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="e585d-982">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="e585d-983">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-983">Return value</span></span> 
 </term><description> <span data-ttu-id="e585d-984">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="e585d-984">Meaning</span></span> 
 </description></listheader><item><term> <span data-ttu-id="e585d-985">-1</span><span class="sxs-lookup"><span data-stu-id="e585d-985">-1</span></span> 
 </term><description><span data-ttu-id="e585d-986"><paramref name="value" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-986"><paramref name="value" /> is less than zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-987">0</span><span class="sxs-lookup"><span data-stu-id="e585d-987">0</span></span> 
 </term><description><span data-ttu-id="e585d-988"><paramref name="value" />jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="e585d-988"><paramref name="value" /> is equal to zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-989">1</span><span class="sxs-lookup"><span data-stu-id="e585d-989">1</span></span> 
 </term><description><span data-ttu-id="e585d-990"><paramref name="value" />jest większa od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-990"><paramref name="value" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-991">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Sign%28System.Int32%29> metody do określenia znaku <xref:System.Int32> wartości i wyświetlenia go w konsoli.</span><span class="sxs-lookup"><span data-stu-id="e585d-991">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int32%29> method to determine the sign of an <xref:System.Int32> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(long value);" />
      <MemberSignature Language="F#" Value="static member Sign : int64 -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-992">Liczba oznaczona.</span><span class="sxs-lookup"><span data-stu-id="e585d-992">A signed number.</span></span></param>
        <summary><span data-ttu-id="e585d-993">Zwraca liczbę całkowitą wskazującą znak 64-bitową liczbę całkowitą ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="e585d-993">Returns an integer that indicates the sign of a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="e585d-994">Liczba, która wskazuje znak <paramref name="value" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="e585d-994">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="e585d-995">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-995">Return value</span></span> 
 </term><description> <span data-ttu-id="e585d-996">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="e585d-996">Meaning</span></span> 
 </description></listheader><item><term> <span data-ttu-id="e585d-997">-1</span><span class="sxs-lookup"><span data-stu-id="e585d-997">-1</span></span> 
 </term><description><span data-ttu-id="e585d-998"><paramref name="value" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-998"><paramref name="value" /> is less than zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-999">0</span><span class="sxs-lookup"><span data-stu-id="e585d-999">0</span></span> 
 </term><description><span data-ttu-id="e585d-1000"><paramref name="value" />jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="e585d-1000"><paramref name="value" /> is equal to zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-1001">1</span><span class="sxs-lookup"><span data-stu-id="e585d-1001">1</span></span> 
 </term><description><span data-ttu-id="e585d-1002"><paramref name="value" />jest większa od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-1002"><paramref name="value" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-1003">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Sign%28System.Int64%29> metody do określenia znaku <xref:System.Int64> wartości i wyświetlenia go w konsoli.</span><span class="sxs-lookup"><span data-stu-id="e585d-1003">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int64%29> method to determine the sign of an <xref:System.Int64> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As SByte) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member Sign : sbyte -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-1004">Liczba oznaczona.</span><span class="sxs-lookup"><span data-stu-id="e585d-1004">A signed number.</span></span></param>
        <summary><span data-ttu-id="e585d-1005">Zwraca liczbę całkowitą wskazującą znak 8-bitowej podpisanej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="e585d-1005">Returns an integer that indicates the sign of an 8-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="e585d-1006">Liczba, która wskazuje znak <paramref name="value" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="e585d-1006">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="e585d-1007">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-1007">Return value</span></span> 
 </term><description> <span data-ttu-id="e585d-1008">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="e585d-1008">Meaning</span></span> 
 </description></listheader><item><term> <span data-ttu-id="e585d-1009">-1</span><span class="sxs-lookup"><span data-stu-id="e585d-1009">-1</span></span> 
 </term><description><span data-ttu-id="e585d-1010"><paramref name="value" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-1010"><paramref name="value" /> is less than zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-1011">0</span><span class="sxs-lookup"><span data-stu-id="e585d-1011">0</span></span> 
 </term><description><span data-ttu-id="e585d-1012"><paramref name="value" />jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="e585d-1012"><paramref name="value" /> is equal to zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-1013">1</span><span class="sxs-lookup"><span data-stu-id="e585d-1013">1</span></span> 
 </term><description><span data-ttu-id="e585d-1014"><paramref name="value" />jest większa od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-1014"><paramref name="value" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-1015">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Sign%28System.SByte%29> metody do określenia znaku <xref:System.SByte> wartości i wyświetlenia go w konsoli.</span><span class="sxs-lookup"><span data-stu-id="e585d-1015">The following example demonstrates how to use the <xref:System.Math.Sign%28System.SByte%29> method to determine the sign of an <xref:System.SByte> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(float value);" />
      <MemberSignature Language="F#" Value="static member Sign : single -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-1016">Liczba oznaczona.</span><span class="sxs-lookup"><span data-stu-id="e585d-1016">A signed number.</span></span></param>
        <summary><span data-ttu-id="e585d-1017">Zwraca liczbę całkowitą wskazującą znak liczby zmiennoprzecinkowej o pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-1017">Returns an integer that indicates the sign of a single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="e585d-1018">Liczba, która wskazuje znak <paramref name="value" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="e585d-1018">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="e585d-1019">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-1019">Return value</span></span> 
 </term><description> <span data-ttu-id="e585d-1020">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="e585d-1020">Meaning</span></span> 
 </description></listheader><item><term> <span data-ttu-id="e585d-1021">-1</span><span class="sxs-lookup"><span data-stu-id="e585d-1021">-1</span></span> 
 </term><description><span data-ttu-id="e585d-1022"><paramref name="value" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-1022"><paramref name="value" /> is less than zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-1023">0</span><span class="sxs-lookup"><span data-stu-id="e585d-1023">0</span></span> 
 </term><description><span data-ttu-id="e585d-1024"><paramref name="value" />jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="e585d-1024"><paramref name="value" /> is equal to zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-1025">1</span><span class="sxs-lookup"><span data-stu-id="e585d-1025">1</span></span> 
 </term><description><span data-ttu-id="e585d-1026"><paramref name="value" />jest większa od zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-1026"><paramref name="value" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-1027">Poniższy przykład ilustruje sposób użycia <xref:System.Math.Sign%28System.Single%29> metody do określenia znaku <xref:System.Single> wartości i wyświetlenia go w konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="e585d-1027">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Single%29> method to determine the sign of a <xref:System.Single> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException"><span data-ttu-id="e585d-1028"><paramref name="value" />jest równe <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-1028"><paramref name="value" /> is equal to <see cref="F:System.Single.NaN" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static double Sin (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sin(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sin(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sin(double a);" />
      <MemberSignature Language="F#" Value="static member Sin : double -&gt; double" Usage="System.Math.Sin a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="e585d-1029">Kąt wyrażony w radianach.</span><span class="sxs-lookup"><span data-stu-id="e585d-1029">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="e585d-1030">Zwraca sinus określonego kąta.</span><span class="sxs-lookup"><span data-stu-id="e585d-1030">Returns the sine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="e585d-1031">Sinus <paramref name="a" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-1031">The sine of <paramref name="a" />.</span></span> <span data-ttu-id="e585d-1032">Jeśli <paramref name="a" /> <see cref="F:System.Double.NegativeInfinity" />jest <see cref="F:System.Double.PositiveInfinity" />równa <see cref="F:System.Double.NaN" />,, lub, ta metoda zwraca. <see cref="F:System.Double.NaN" /></span><span class="sxs-lookup"><span data-stu-id="e585d-1032">If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-1033">Kąt, `a`, musi być w radianach.</span><span class="sxs-lookup"><span data-stu-id="e585d-1033">The angle, `a`, must be in radians.</span></span> <span data-ttu-id="e585d-1034">Pomnóż przez <xref:System.Math.PI?displayProperty=nameWithType>/180, aby przekonwertować stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="e585d-1034">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 <span data-ttu-id="e585d-1035">Akceptowalne wartości `a` zakresu od około 9223372036854775295 do około 9223372036854775295.</span><span class="sxs-lookup"><span data-stu-id="e585d-1035">Acceptable values of `a` range from approximately -9223372036854775295 to approximately 9223372036854775295.</span></span> <span data-ttu-id="e585d-1036">W przypadku wartości spoza tego zakresu <xref:System.Math.Sin%2A> Metoda zwraca `a` niezmieniony, zamiast zgłaszać wyjątek.</span><span class="sxs-lookup"><span data-stu-id="e585d-1036">For values outside of this range, the <xref:System.Math.Sin%2A> method returns `a` unchanged rather than throwing an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-1037">Poniższy przykład używa <xref:System.Math.Sin%2A> do obliczania niektórych kątów tożsamości dla wybranych kątów.</span><span class="sxs-lookup"><span data-stu-id="e585d-1037">The following example uses <xref:System.Math.Sin%2A> to evaluate certain trigonometric identities for selected angles.</span></span>  
  
 [!code-cpp[System.Math.SinCos#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp#1)]
 [!code-csharp[System.Math.SinCos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs#1)]
 [!code-vb[System.Math.SinCos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static double Sinh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sinh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sinh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sinh(double value);" />
      <MemberSignature Language="F#" Value="static member Sinh : double -&gt; double" Usage="System.Math.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-1038">Kąt wyrażony w radianach.</span><span class="sxs-lookup"><span data-stu-id="e585d-1038">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="e585d-1039">Zwraca sinus hiperboliczny odpowiadający podanemu kątowi.</span><span class="sxs-lookup"><span data-stu-id="e585d-1039">Returns the hyperbolic sine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="e585d-1040">Sinus hiperboliczny <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-1040">The hyperbolic sine of <paramref name="value" />.</span></span> <span data-ttu-id="e585d-1041">Jeśli <paramref name="value" /> jest <see cref="F:System.Double.NegativeInfinity" />równe, <see cref="F:System.Double.PositiveInfinity" />, <see cref="T:System.Double" /> lub ,<see cref="F:System.Double.NaN" />ta metoda zwraca wartość równą. <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="e585d-1041">If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" />, <see cref="F:System.Double.PositiveInfinity" />, or <see cref="F:System.Double.NaN" />, this method returns a <see cref="T:System.Double" /> equal to <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-1042">Kąt, `value`, musi być w radianach.</span><span class="sxs-lookup"><span data-stu-id="e585d-1042">The angle, `value`, must be in radians.</span></span> <span data-ttu-id="e585d-1043">Pomnóż przez <xref:System.Math.PI?displayProperty=nameWithType>/180, aby przekonwertować stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="e585d-1043">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-1044">Poniższy przykład używa <xref:System.Math.Sinh%2A> do obliczania niektórych tożsamości hiperbolicznych dla wybranych wartości.</span><span class="sxs-lookup"><span data-stu-id="e585d-1044">The following example uses <xref:System.Math.Sinh%2A> to evaluate certain hyperbolic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.SinhCosh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp#1)]
 [!code-csharp[System.Math.SinhCosh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs#1)]
 [!code-vb[System.Math.SinhCosh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static double Sqrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sqrt(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sqrt(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sqrt(double d);" />
      <MemberSignature Language="F#" Value="static member Sqrt : double -&gt; double" Usage="System.Math.Sqrt d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-1045">Liczba, której pierwiastek kwadratowy ma zostać znaleziony.</span><span class="sxs-lookup"><span data-stu-id="e585d-1045">The number whose square root is to be found.</span></span></param>
        <summary><span data-ttu-id="e585d-1046">Zwraca pierwiastek kwadratowy z podanej liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-1046">Returns the square root of a specified number.</span></span></summary>
        <returns><span data-ttu-id="e585d-1047">Jedna z wartości w tabeli poniżej.</span><span class="sxs-lookup"><span data-stu-id="e585d-1047">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="e585d-1048"><paramref name="d" />konstruktora</span><span class="sxs-lookup"><span data-stu-id="e585d-1048"><paramref name="d" /> parameter</span></span> 
 </term><description> <span data-ttu-id="e585d-1049">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-1049">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="e585d-1050">Zero lub dodatnie</span><span class="sxs-lookup"><span data-stu-id="e585d-1050">Zero or positive</span></span> 
 </term><description> <span data-ttu-id="e585d-1051">Pierwiastek kwadratowy z <paramref name="d" />wartością dodatnią.</span><span class="sxs-lookup"><span data-stu-id="e585d-1051">The positive square root of <paramref name="d" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="e585d-1052">Ujemne</span><span class="sxs-lookup"><span data-stu-id="e585d-1052">Negative</span></span> 
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term> <span data-ttu-id="e585d-1053">Ubiegł<see cref="F:System.Double.NaN" /></span><span class="sxs-lookup"><span data-stu-id="e585d-1053">Equals <see cref="F:System.Double.NaN" /></span></span></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> <span data-ttu-id="e585d-1054">Ubiegł<see cref="F:System.Double.PositiveInfinity" /></span><span class="sxs-lookup"><span data-stu-id="e585d-1054">Equals <see cref="F:System.Double.PositiveInfinity" /></span></span></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e585d-1055">Pierwiastek kwadratowy obszaru kwadratu reprezentuje długość dowolnej strony kwadratu.</span><span class="sxs-lookup"><span data-stu-id="e585d-1055">The square root of the area of a square represents the length of any side of the square.</span></span> <span data-ttu-id="e585d-1056">Poniższy przykład wyświetla obszar niektórych miast w Stany Zjednoczone i daje wrażenie, że rozmiar poszczególnych miast jest reprezentowany przez kwadrat.</span><span class="sxs-lookup"><span data-stu-id="e585d-1056">The following example displays the area of some cities in the United States and gives an impression of each city's size if it were represented by a square.</span></span>  
  
 [!code-csharp[System.Math.Sqrt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.sqrt/cs/sqrt1.cs#1)]
 [!code-vb[System.Math.Sqrt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.sqrt/vb/sqrt1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static double Tan (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tan(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tan(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Tan(double a);" />
      <MemberSignature Language="F#" Value="static member Tan : double -&gt; double" Usage="System.Math.Tan a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="e585d-1057">Kąt wyrażony w radianach.</span><span class="sxs-lookup"><span data-stu-id="e585d-1057">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="e585d-1058">Zwraca tangens podanego kąta.</span><span class="sxs-lookup"><span data-stu-id="e585d-1058">Returns the tangent of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="e585d-1059">Tangens <paramref name="a" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-1059">The tangent of <paramref name="a" />.</span></span> <span data-ttu-id="e585d-1060">Jeśli <paramref name="a" /> <see cref="F:System.Double.NegativeInfinity" />jest <see cref="F:System.Double.PositiveInfinity" />równa <see cref="F:System.Double.NaN" />,, lub, ta metoda zwraca. <see cref="F:System.Double.NaN" /></span><span class="sxs-lookup"><span data-stu-id="e585d-1060">If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-1061">Kąt, `a`, musi być w radianach.</span><span class="sxs-lookup"><span data-stu-id="e585d-1061">The angle, `a`, must be in radians.</span></span> <span data-ttu-id="e585d-1062">Pomnóż przez <xref:System.Math.PI?displayProperty=nameWithType>/180, aby przekonwertować stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="e585d-1062">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-1063">W poniższym przykładzie pokazano, jak obliczyć tangens kąta i wyświetlić go w konsoli.</span><span class="sxs-lookup"><span data-stu-id="e585d-1063">The following example demonstrates how to calculate the tangent of an angle and display it to the console.</span></span>  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static double Tanh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tanh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tanh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Tanh(double value);" />
      <MemberSignature Language="F#" Value="static member Tanh : double -&gt; double" Usage="System.Math.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e585d-1064">Kąt wyrażony w radianach.</span><span class="sxs-lookup"><span data-stu-id="e585d-1064">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="e585d-1065">Zwraca tangens hiperboliczny odpowiadający podanemu kątowi.</span><span class="sxs-lookup"><span data-stu-id="e585d-1065">Returns the hyperbolic tangent of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="e585d-1066">Tangens hiperboliczny <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e585d-1066">The hyperbolic tangent of <paramref name="value" />.</span></span> <span data-ttu-id="e585d-1067">Jeśli <paramref name="value" /> jest<see cref="F:System.Double.NegativeInfinity" />równa, ta metoda zwraca wartość-1.</span><span class="sxs-lookup"><span data-stu-id="e585d-1067">If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" />, this method returns -1.</span></span> <span data-ttu-id="e585d-1068">Jeśli wartość jest równa <see cref="F:System.Double.PositiveInfinity" />, ta metoda zwraca 1.</span><span class="sxs-lookup"><span data-stu-id="e585d-1068">If value is equal to <see cref="F:System.Double.PositiveInfinity" />, this method returns 1.</span></span> <span data-ttu-id="e585d-1069">Jeśli <paramref name="value" /> jest <see cref="F:System.Double.NaN" />równa, ta metoda zwraca. <see cref="F:System.Double.NaN" /></span><span class="sxs-lookup"><span data-stu-id="e585d-1069">If <paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />, this method returns <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-1070">Kąt, `value`, musi być w radianach.</span><span class="sxs-lookup"><span data-stu-id="e585d-1070">The angle, `value`, must be in radians.</span></span> <span data-ttu-id="e585d-1071">Pomnóż przez <xref:System.Math.PI?displayProperty=nameWithType>/180, aby przekonwertować stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="e585d-1071">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-1072">Poniższy przykład używa <xref:System.Math.Tanh%2A> do szacowania niektórych tożsamości hiperbolicznych tangens dla wybranych wartości.</span><span class="sxs-lookup"><span data-stu-id="e585d-1072">The following example uses <xref:System.Math.Tanh%2A> to evaluate certain hyperbolic tangent identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.Tanh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Tanh/CPP/tanh.cpp#1)]
 [!code-csharp[System.Math.Tanh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Tanh/CS/tanh.cs#1)]
 [!code-vb[System.Math.Tanh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Tanh/VB/tanh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Truncate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e585d-1073">Oblicza integralną część liczby.</span><span class="sxs-lookup"><span data-stu-id="e585d-1073">Calculates the integral part of a number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-1074">Liczba jest zaokrąglana do najbliższej liczby całkowitej w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-1074">The number is rounded to the nearest integer towards zero.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static decimal Truncate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Truncate(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Truncate(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Truncate : decimal -&gt; decimal" Usage="System.Math.Truncate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-1075">Liczba do obcięcia.</span><span class="sxs-lookup"><span data-stu-id="e585d-1075">A number to truncate.</span></span></param>
        <summary><span data-ttu-id="e585d-1076">Oblicza integralną część określonej liczby dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="e585d-1076">Calculates the integral part of a specified decimal number.</span></span></summary>
        <returns><span data-ttu-id="e585d-1077">Integralna część <paramref name="d" />, czyli liczba, która pozostanie po odrzuceniu cyfr ułamkowych.</span><span class="sxs-lookup"><span data-stu-id="e585d-1077">The integral part of <paramref name="d" />; that is, the number that remains after any fractional digits have been discarded.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e585d-1078"><xref:System.Math.Truncate%2A>zaokrągla `d` do najbliższej liczby całkowitej w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-1078"><xref:System.Math.Truncate%2A> rounds `d` to the nearest integer towards zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e585d-1079">Poniższy przykład wywołuje <xref:System.Math.Truncate%28System.Decimal%29> metodę w celu obcięcia wartości dodatnich i ujemnych <xref:System.Decimal> .</span><span class="sxs-lookup"><span data-stu-id="e585d-1079">The following example calls the <xref:System.Math.Truncate%28System.Decimal%29> method to truncate both a positive and a negative <xref:System.Decimal> value.</span></span>  
  
 [!code-csharp[System.Math.Truncate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs#2)]
 [!code-vb[System.Math.Truncate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static double Truncate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Truncate(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Truncate(double d);" />
      <MemberSignature Language="F#" Value="static member Truncate : double -&gt; double" Usage="System.Math.Truncate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="e585d-1080">Liczba do obcięcia.</span><span class="sxs-lookup"><span data-stu-id="e585d-1080">A number to truncate.</span></span></param>
        <summary><span data-ttu-id="e585d-1081">Oblicza integralną część określonej liczby zmiennoprzecinkowej podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="e585d-1081">Calculates the integral part of a specified double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="e585d-1082">Integralna część <paramref name="d" />, czyli liczba, która pozostaje po odrzuceniu cyfr ułamkowych, lub jedna z wartości wymienionych w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="e585d-1082">The integral part of <paramref name="d" />; that is, the number that remains after any fractional digits have been discarded, or one of the values listed in the following table.</span></span>  
  
 <list type="table"><listheader><term><paramref name="d" /></term><description> <span data-ttu-id="e585d-1083">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="e585d-1083">Return value</span></span> 
 </description></listheader><item><term><see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term><see cref="F:System.Double.NegativeInfinity" /></term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term><see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="e585d-1084"><xref:System.Math.Truncate%2A>zaokrągla `d` do najbliższej liczby całkowitej w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="e585d-1084"><xref:System.Math.Truncate%2A> rounds `d` to the nearest integer towards zero.</span></span>  
  
<span data-ttu-id="e585d-1085">Począwszy od Visual Basic 15,8, wydajność konwersji podwójnej do liczby całkowitej jest zoptymalizowana, jeśli przekazujesz wartość zwróconą przez `Truncate` metodę do którejkolwiek [funkcji konwersji całkowitej](~/docs/visual-basic/language-reference/functions/conversion-functions.md)lub jeśli wartość podwójna zwracana przez `Truncate` jest automatycznie konwertowany na liczbę całkowitą z [opcją Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) ustawioną na wartość off.</span><span class="sxs-lookup"><span data-stu-id="e585d-1085">Starting with Visual Basic 15.8, the performance of Double-to-integer conversion is optimized if you pass the value returned by the `Truncate` method to the any of the [integral conversion functions](~/docs/visual-basic/language-reference/functions/conversion-functions.md), or if the Double value returned by `Truncate` is automatically converted to an integer with [Option Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) set to Off.</span></span> <span data-ttu-id="e585d-1086">Ta optymalizacja umożliwia szybsze uruchamianie kodu — maksymalnie dwa razy w przypadku kodu, który wykonuje dużą liczbę konwersji na typy całkowite.</span><span class="sxs-lookup"><span data-stu-id="e585d-1086">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="e585d-1087">Poniższy przykład ilustruje taką zoptymalizowaną konwersję:</span><span class="sxs-lookup"><span data-stu-id="e585d-1087">The following example illustrates such an optimized conversion:</span></span>
   
```vb
Dim d As Double = 164.7194
Dim i As Integer = CInt(Math.Truncate(d))     ' Result: 164
```

## Examples  
 <span data-ttu-id="e585d-1088">Poniższy przykład wywołuje <xref:System.Math.Truncate%28System.Double%29> metodę w celu obcięcia wartości dodatnich i ujemnych <xref:System.Double> .</span><span class="sxs-lookup"><span data-stu-id="e585d-1088">The following example calls the <xref:System.Math.Truncate%28System.Double%29> method to truncate both a positive and a negative <xref:System.Double> value.</span></span>  
  
 [!code-csharp[System.Math.Truncate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs#1)]
 [!code-vb[System.Math.Truncate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
      </Docs>
    </Member>
  </Members>
</Type>

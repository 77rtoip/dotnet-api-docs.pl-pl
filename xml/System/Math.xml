<Type Name="Math" FullName="System.Math">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="30654c2b9c7c01a5cb963f5bfd2f32a1328d6137" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36430237" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Math" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Math extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Math" />
  <TypeSignature Language="VB.NET" Value="Public Class Math" />
  <TypeSignature Language="C++ CLI" Value="public ref class Math abstract sealed" />
  <TypeSignature Language="F#" Value="type Math = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="92e45-101">Udostępnia stałe i metod statycznych dla trygonometryczne logarytmicznej i inne typowe funkcje matematyczne.</span>
      <span class="sxs-lookup">
        <span data-stu-id="92e45-101">Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-102">W poniższym przykładzie użyto kilka funkcje matematyczne i trygonometryczne z <xref:System.Math> klasy do obliczenia wewnętrzny kąty trapezu.</span><span class="sxs-lookup"><span data-stu-id="92e45-102">The following example uses several mathematical and trigonometric functions from the <xref:System.Math> class to calculate the inner angles of a trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Abs">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="92e45-103">Zwraca wartość bezwzględną podanej liczby.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-103">Returns the absolute value of a specified number.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static decimal Abs (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Abs(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Abs(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Abs : decimal -&gt; decimal" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-104">Liczby, która jest większa niż lub równa <see cref="F:System.Decimal.MinValue" />, ale mniejsze niż lub równe <see cref="F:System.Decimal.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-104">A number that is greater than or equal to <see cref="F:System.Decimal.MinValue" />, but less than or equal to <see cref="F:System.Decimal.MaxValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-105">Zwraca wartość bezwzględną liczby <see cref="T:System.Decimal" /> numer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-105">Returns the absolute value of a <see cref="T:System.Decimal" /> number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-106">Liczby dziesiętnej, x, że x ≤ 0 ≤<see cref="F:System.Decimal.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-106">A decimal number, x, such that 0 ≤ x ≤<see cref="F:System.Decimal.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-107">Wartość bezwzględna <xref:System.Decimal> jest jego wartość liczbową bez znaku.</span><span class="sxs-lookup"><span data-stu-id="92e45-107">The absolute value of a <xref:System.Decimal> is its numeric value without its sign.</span></span> <span data-ttu-id="92e45-108">Na przykład wartość bezwzględna 1.2 i -1,2 jest 1.2.</span><span class="sxs-lookup"><span data-stu-id="92e45-108">For example, the absolute value of both 1.2 and -1.2 is 1.2.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-109">W poniższym przykładzie użyto <xref:System.Math.Abs%28System.Decimal%29> metodę, aby uzyskać wartość bezwzględną liczby <xref:System.Decimal> wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-109">The following example uses the <xref:System.Math.Abs%28System.Decimal%29> method to get the absolute value of a number of <xref:System.Decimal> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Math.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(double value);" />
      <MemberSignature Language="F#" Value="static member Abs : double -&gt; double" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-110">Liczby, która jest większa niż lub równa <see cref="F:System.Double.MinValue" />, ale mniejsze niż lub równe <see cref="F:System.Double.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-110">A number that is greater than or equal to <see cref="F:System.Double.MinValue" />, but less than or equal to <see cref="F:System.Double.MaxValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-111">Zwraca wartość bezwzględną liczby zmiennoprzecinkowej podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-111">Returns the absolute value of a double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-112">Liczby zmiennoprzecinkowe podwójnej precyzji x, że x ≤ 0 ≤<see cref="F:System.Double.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-112">A double-precision floating-point number, x, such that 0 ≤ x ≤<see cref="F:System.Double.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-113">Wartość bezwzględna <xref:System.Double> jest jego wartość liczbową bez znaku.</span><span class="sxs-lookup"><span data-stu-id="92e45-113">The absolute value of a <xref:System.Double> is its numeric value without its sign.</span></span> <span data-ttu-id="92e45-114">Na przykład 1.2e03 ma wartość bezwzględna 1.2e03 i - 1.2e03.</span><span class="sxs-lookup"><span data-stu-id="92e45-114">For example, the absolute value of both 1.2e03 and -1.2e03 is 1.2e03.</span></span>  
  
 <span data-ttu-id="92e45-115">Jeśli `value` jest równa <xref:System.Double.NegativeInfinity> lub <xref:System.Double.PositiveInfinity>, jest zwracana wartość <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="92e45-115">If `value` is equal to <xref:System.Double.NegativeInfinity> or <xref:System.Double.PositiveInfinity>, the return value is <xref:System.Double.PositiveInfinity>.</span></span> <span data-ttu-id="92e45-116">Jeśli `value` jest równa <xref:System.Double.NaN>, jest zwracana wartość <xref:System.Double.NaN>.</span><span class="sxs-lookup"><span data-stu-id="92e45-116">If `value` is equal to <xref:System.Double.NaN>, the return value is <xref:System.Double.NaN>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-117">W poniższym przykładzie użyto <xref:System.Math.Abs%28System.Double%29> metodę, aby uzyskać wartość bezwzględną liczby <xref:System.Double> wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-117">The following example uses the <xref:System.Math.Abs%28System.Double%29> method to get the absolute value of a number of <xref:System.Double> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs2.cs#2)]
 [!code-vb[System.Math.Abs#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static short Abs (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Abs(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Abs(short value);" />
      <MemberSignature Language="F#" Value="static member Abs : int16 -&gt; int16" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-118">Liczba, która jest większa niż <see cref="F:System.Int16.MinValue" />, ale mniejsze niż lub równe <see cref="F:System.Int16.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-118">A number that is greater than <see cref="F:System.Int16.MinValue" />, but less than or equal to <see cref="F:System.Int16.MaxValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-119">Zwraca wartość bezwzględną liczby 16-bitową liczbę całkowitą ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-119">Returns the absolute value of a 16-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-120">16-bitową liczbę całkowitą ze znakiem, x, że x ≤ 0 ≤<see cref="F:System.Int16.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-120">A 16-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.Int16.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-121">Wartość bezwzględna <xref:System.Int16> jest jego wartość liczbową bez znaku.</span><span class="sxs-lookup"><span data-stu-id="92e45-121">The absolute value of an <xref:System.Int16> is its numeric value without its sign.</span></span> <span data-ttu-id="92e45-122">Na przykład 123 ma wartość bezwzględna 123 i-123.</span><span class="sxs-lookup"><span data-stu-id="92e45-122">For example, the absolute value of both 123 and -123 is 123.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-123">W poniższym przykładzie użyto <xref:System.Math.Abs%28System.Int16%29> metodę, aby uzyskać wartość bezwzględną liczby <xref:System.Int16> wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-123">The following example uses the <xref:System.Math.Abs%28System.Int16%29> method to get the absolute value of a number of <xref:System.Int16> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs3.cs#3)]
 [!code-vb[System.Math.Abs#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="92e45-124">
            <paramref name="value" /> Equals <see cref="F:System.Int16.MinValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-124">
              <paramref name="value" /> equals <see cref="F:System.Int16.MinValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static int Abs (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Abs(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Abs(int value);" />
      <MemberSignature Language="F#" Value="static member Abs : int -&gt; int" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-125">Liczba, która jest większa niż <see cref="F:System.Int32.MinValue" />, ale mniejsze niż lub równe <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-125">A number that is greater than <see cref="F:System.Int32.MinValue" />, but less than or equal to <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-126">Zwraca wartość bezwzględną liczby całkowita 32-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-126">Returns the absolute value of a 32-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-127">32-bitowe podpisane liczby całkowite, x, że x ≤ 0 ≤<see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-127">A 32-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-128">Wartość bezwzględna <xref:System.Int32> jest jego wartość liczbową bez znaku.</span><span class="sxs-lookup"><span data-stu-id="92e45-128">The absolute value of an <xref:System.Int32> is its numeric value without its sign.</span></span> <span data-ttu-id="92e45-129">Na przykład 123 ma wartość bezwzględna 123 i-123.</span><span class="sxs-lookup"><span data-stu-id="92e45-129">For example, the absolute value of both 123 and -123 is 123.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-130">W poniższym przykładzie użyto <xref:System.Math.Abs%28System.Int32%29> metodę, aby uzyskać wartość bezwzględną liczby <xref:System.Int32> wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-130">The following example uses the <xref:System.Math.Abs%28System.Int32%29> method to get the absolute value of a number of <xref:System.Int32> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs4.cs#4)]
 [!code-vb[System.Math.Abs#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="92e45-131">
            <paramref name="value" /> Equals <see cref="F:System.Int32.MinValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-131">
              <paramref name="value" /> equals <see cref="F:System.Int32.MinValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static long Abs (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Abs(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Abs(long value);" />
      <MemberSignature Language="F#" Value="static member Abs : int64 -&gt; int64" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-132">Liczba, która jest większa niż <see cref="F:System.Int64.MinValue" />, ale mniejsze niż lub równe <see cref="F:System.Int64.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-132">A number that is greater than <see cref="F:System.Int64.MinValue" />, but less than or equal to <see cref="F:System.Int64.MaxValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-133">Zwraca wartość bezwzględną liczby 64-bitowej podpisanej liczby całkowitej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-133">Returns the absolute value of a 64-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-134">64-bitowych podpisane liczby całkowite, x, że x ≤ 0 ≤<see cref="F:System.Int64.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-134">A 64-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.Int64.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-135">Wartość bezwzględna <xref:System.Int64> jest jego wartość liczbową bez znaku.</span><span class="sxs-lookup"><span data-stu-id="92e45-135">The absolute value of an <xref:System.Int64> is its numeric value without its sign.</span></span> <span data-ttu-id="92e45-136">Na przykład 123 ma wartość bezwzględna 123 i-123.</span><span class="sxs-lookup"><span data-stu-id="92e45-136">For example, the absolute value of both 123 and -123 is 123.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-137">W poniższym przykładzie użyto <xref:System.Math.Abs%28System.Int64%29> metodę, aby uzyskać wartość bezwzględną liczby <xref:System.Int64> wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-137">The following example uses the <xref:System.Math.Abs%28System.Int64%29> method to get the absolute value of a number of <xref:System.Int64> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs5.cs#5)]
 [!code-vb[System.Math.Abs#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="92e45-138">
            <paramref name="value" /> Equals <see cref="F:System.Int64.MinValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-138">
              <paramref name="value" /> equals <see cref="F:System.Int64.MinValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static sbyte Abs (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Abs(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Abs(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member Abs : sbyte -&gt; sbyte" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-139">Liczba, która jest większa niż <see cref="F:System.SByte.MinValue" />, ale mniejsze niż lub równe <see cref="F:System.SByte.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-139">A number that is greater than <see cref="F:System.SByte.MinValue" />, but less than or equal to <see cref="F:System.SByte.MaxValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-140">Zwraca wartość bezwzględną liczby 8-bitową liczbę całkowitą ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-140">Returns the absolute value of an 8-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-141">8-bitową liczbę całkowitą ze znakiem, x, że x ≤ 0 ≤<see cref="F:System.SByte.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-141">An 8-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.SByte.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-142">Wartość bezwzględna bajtu ze znakiem jest jego wartość liczbową bez znaku.</span><span class="sxs-lookup"><span data-stu-id="92e45-142">The absolute value of a signed byte is its numeric value without its sign.</span></span> <span data-ttu-id="92e45-143">Na przykład 12 ma wartość bezwzględna 12 i -12.</span><span class="sxs-lookup"><span data-stu-id="92e45-143">For example, the absolute value of both 12 and -12 is 12.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-144">W poniższym przykładzie użyto <xref:System.Math.Abs%28System.SByte%29> metodę, aby uzyskać wartość bezwzględną liczby <xref:System.SByte> wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-144">The following example uses the <xref:System.Math.Abs%28System.SByte%29> method to get the absolute value of a number of <xref:System.SByte> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs6.cs#6)]
 [!code-vb[System.Math.Abs#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="92e45-145">
            <paramref name="value" /> Equals <see cref="F:System.SByte.MinValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-145">
              <paramref name="value" /> equals <see cref="F:System.SByte.MinValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static float Abs (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Abs(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Abs(float value);" />
      <MemberSignature Language="F#" Value="static member Abs : single -&gt; single" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-146">Liczby, która jest większa niż lub równa <see cref="F:System.Single.MinValue" />, ale mniejsze niż lub równe <see cref="F:System.Single.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-146">A number that is greater than or equal to <see cref="F:System.Single.MinValue" />, but less than or equal to <see cref="F:System.Single.MaxValue" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-147">Zwraca wartość bezwzględną liczby zmiennoprzecinkowej pojedynczej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-147">Returns the absolute value of a single-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-148">Liczba zmiennoprzecinkowa pojedynczej precyzji, x, że x ≤ 0 ≤<see cref="F:System.Single.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-148">A single-precision floating-point number, x, such that 0 ≤ x ≤<see cref="F:System.Single.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-149">Wartość bezwzględna <xref:System.Single> jest jego wartość liczbową bez znaku.</span><span class="sxs-lookup"><span data-stu-id="92e45-149">The absolute value of a <xref:System.Single> is its numeric value without its sign.</span></span> <span data-ttu-id="92e45-150">Na przykład wartość bezwzględna zarówno 1.2e-03 i - 1.2e03 jest 1.2e03.</span><span class="sxs-lookup"><span data-stu-id="92e45-150">For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.</span></span>  
  
 <span data-ttu-id="92e45-151">Jeśli `value` jest równa <xref:System.Single.NegativeInfinity> lub <xref:System.Single.PositiveInfinity>, jest zwracana wartość <xref:System.Single.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="92e45-151">If `value` is equal to <xref:System.Single.NegativeInfinity> or <xref:System.Single.PositiveInfinity>, the return value is <xref:System.Single.PositiveInfinity>.</span></span> <span data-ttu-id="92e45-152">Jeśli `value` jest równa <xref:System.Single.NaN>, jest zwracana wartość <xref:System.Single.NaN>.</span><span class="sxs-lookup"><span data-stu-id="92e45-152">If `value` is equal to <xref:System.Single.NaN>, the return value is <xref:System.Single.NaN>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-153">W poniższym przykładzie użyto <xref:System.Math.Abs%28System.Single%29> metodę, aby uzyskać wartość bezwzględną liczby <xref:System.Single> wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-153">The following example uses the <xref:System.Math.Abs%28System.Single%29> method to get the absolute value of a number of <xref:System.Single> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs7.cs#7)]
 [!code-vb[System.Math.Abs#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static double Acos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Acos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Acos(double d);" />
      <MemberSignature Language="F#" Value="static member Acos : double -&gt; double" Usage="System.Math.Acos d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-154">Liczba reprezentująca cosinus, gdzie <c>d</c> musi być większa niż lub równy -1, ale mniejsze niż lub równa 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-154">A number representing a cosine, where <c>d</c> must be greater than or equal to -1, but less than or equal to 1.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-155">Zwraca kąt, którego cosinus jest równy podanej liczbie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-155">Returns the angle whose cosine is the specified number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-156">Kąt, θ mierzony w radianach, tak, aby 0 ≤θ≤π - lub - <see cref="F:System.Double.NaN" /> Jeśli <paramref name="d" /> &lt; -1 lub <paramref name="d" /> &gt; 1 lub <paramref name="d" /> jest równe <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-156">An angle, θ, measured in radians, such that 0 ≤θ≤π  -or-  <see cref="F:System.Double.NaN" /> if <paramref name="d" /> &lt; -1 or <paramref name="d" /> &gt; 1 or <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-157">Należy pomnożyć wartość zwracaną przez 180 /<xref:System.Math.PI?displayProperty=nameWithType> aby z radianów w stopniach.</span><span class="sxs-lookup"><span data-stu-id="92e45-157">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-158">W poniższym przykładzie użyto <xref:System.Math.Acos%2A> metodę, aby ułatwić obliczenia wewnętrzny kąty danego Trapez.</span><span class="sxs-lookup"><span data-stu-id="92e45-158">The following example uses the <xref:System.Math.Acos%2A> method to assist in the computation of the inner angles of a given trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh">
      <MemberSignature Language="C#" Value="public static double Acosh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acosh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Acosh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acosh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Acosh(double d);" />
      <MemberSignature Language="F#" Value="static member Acosh : double -&gt; double" Usage="System.Math.Acosh d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static double Asin (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asin(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Asin(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Asin(double d);" />
      <MemberSignature Language="F#" Value="static member Asin : double -&gt; double" Usage="System.Math.Asin d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-159">Liczba reprezentująca sinusa, gdzie <c>d</c> musi być większa niż lub równy -1, ale mniejsze niż lub równa 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-159">A number representing a sine, where <c>d</c> must be greater than or equal to -1, but less than or equal to 1.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-160">Zwraca kąt, którego sinus jest równy podanej liczbie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-160">Returns the angle whose sine is the specified number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-161">Kąt, θ mierzony w radianach, tak, aby ≤θ≤π - π/2/2 - lub - <see cref="F:System.Double.NaN" /> Jeśli <paramref name="d" /> &lt; -1 lub <paramref name="d" /> &gt; 1 lub <paramref name="d" /> jest równe <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-161">An angle, θ, measured in radians, such that -π/2 ≤θ≤π/2  -or-  <see cref="F:System.Double.NaN" /> if <paramref name="d" /> &lt; -1 or <paramref name="d" /> &gt; 1 or <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-162">Dodatnia wartość zwracany reprezentuje kątowi od osi x; zwracane wartości ujemnej reprezentuje kąt do ruchu wskazówek zegara.</span><span class="sxs-lookup"><span data-stu-id="92e45-162">A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.</span></span>  
  
 <span data-ttu-id="92e45-163">Należy pomnożyć wartość zwracaną przez 180 /<xref:System.Math.PI?displayProperty=nameWithType> aby z radianów w stopniach.</span><span class="sxs-lookup"><span data-stu-id="92e45-163">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-164">W poniższym przykładzie użyto <xref:System.Math.Asin%2A> ułatwiających obliczenia wewnętrzny kąty danego Trapez.</span><span class="sxs-lookup"><span data-stu-id="92e45-164">The following example uses <xref:System.Math.Asin%2A> to assist in the computation of the inner angles of a given trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh">
      <MemberSignature Language="C#" Value="public static double Asinh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asinh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Asinh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asinh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Asinh(double d);" />
      <MemberSignature Language="F#" Value="static member Asinh : double -&gt; double" Usage="System.Math.Asinh d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static double Atan (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atan(double d);" />
      <MemberSignature Language="F#" Value="static member Atan : double -&gt; double" Usage="System.Math.Atan d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-165">Liczba reprezentująca stycznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-165">A number representing a tangent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-166">Zwraca kąt, którego tangens jest równy podanej liczbie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-166">Returns the angle whose tangent is the specified number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-167">Kąt, θ mierzony w radianach, tak, aby ≤θ≤π - π/2/2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-167">An angle, θ, measured in radians, such that -π/2 ≤θ≤π/2.</span>
          </span>
          <span data-ttu-id="92e45-168">- lub - <see cref="F:System.Double.NaN" /> Jeśli <paramref name="d" /> jest równe <see cref="F:System.Double.NaN" />, - π/2 zaokrąglana do podwójnej precyzji (-1.5707963267949), jeśli <paramref name="d" /> jest równe <see cref="F:System.Double.NegativeInfinity" />, lub π/2 zaokrąglana do podwójnej precyzji (1.5707963267949), jeśli <paramref name="d" /> jest równe <see cref="F:System.Double.PositiveInfinity" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-168">-or-  <see cref="F:System.Double.NaN" /> if <paramref name="d" /> equals <see cref="F:System.Double.NaN" />, -π/2 rounded to double precision (-1.5707963267949) if <paramref name="d" /> equals <see cref="F:System.Double.NegativeInfinity" />, or π/2 rounded to double precision (1.5707963267949) if <paramref name="d" /> equals <see cref="F:System.Double.PositiveInfinity" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-169">Dodatnia wartość zwracany reprezentuje kątowi od osi x; zwracane wartości ujemnej reprezentuje kąt do ruchu wskazówek zegara.</span><span class="sxs-lookup"><span data-stu-id="92e45-169">A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.</span></span>  
  
 <span data-ttu-id="92e45-170">Należy pomnożyć wartość zwracaną przez 180 /<xref:System.Math.PI?displayProperty=nameWithType> aby z radianów w stopniach.</span><span class="sxs-lookup"><span data-stu-id="92e45-170">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-171">W poniższym przykładzie pokazano sposób obliczania wartości arcus tangens i wyświetl ją do konsoli.</span><span class="sxs-lookup"><span data-stu-id="92e45-171">The following example demonstrates how to calculate the arctangent of a value and display it to the console.</span></span>  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static double Atan2 (double y, double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan2(float64 y, float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan2(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2 (y As Double, x As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atan2(double y, double x);" />
      <MemberSignature Language="F#" Value="static member Atan2 : double * double -&gt; double" Usage="System.Math.Atan2 (y, x)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Double" />
        <Parameter Name="x" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="y">
          <span data-ttu-id="92e45-172">Współrzędna y punktu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-172">The y coordinate of a point.</span>
          </span>
        </param>
        <param name="x">
          <span data-ttu-id="92e45-173">Współrzędna x punktu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-173">The x coordinate of a point.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-174">Zwraca kąt, którego tangens jest równy ilorazowi dwóch podanych liczb.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-174">Returns the angle whose tangent is the quotient of two specified numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-175">Kąt, θ mierzony w radianach, tak, aby - π≤θ≤π i tan(θ) = <paramref name="y" />  /  <paramref name="x" />, gdzie (<paramref name="x" />, <paramref name="y" />) jest punktem w płaszczyźnie kartezjański.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-175">An angle, θ, measured in radians, such that -π≤θ≤π, and tan(θ) = <paramref name="y" /> / <paramref name="x" />, where (<paramref name="x" />, <paramref name="y" />) is a point in the Cartesian plane.</span>
          </span>
          <span data-ttu-id="92e45-176">Sprawdź następujące: - (<paramref name="x" />, <paramref name="y" />) w wiązania kwadrantu 1, 0 &lt; θ &lt; π/2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-176">Observe the following:  -   For (<paramref name="x" />, <paramref name="y" />) in quadrant 1, 0 &lt; θ &lt; π/2.</span>
          </span>
          <span data-ttu-id="92e45-177">— Dla (<paramref name="x" />, <paramref name="y" />) w wiązania kwadrantu 2, π/2 &lt; θ≤π.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-177">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 2, π/2 &lt; θ≤π.</span>
          </span>
          <span data-ttu-id="92e45-178">— Dla (<paramref name="x" />, <paramref name="y" />) w wiązania kwadrantu 3, - π &lt; θ &lt; - π/2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-178">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 3, -π &lt; θ &lt; -π/2.</span>
          </span>
          <span data-ttu-id="92e45-179">— Dla (<paramref name="x" />, <paramref name="y" />) w wiązania kwadrantu 4, - π/2 &lt; θ &lt; 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-179">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 4, -π/2 &lt; θ &lt; 0.</span>
          </span>
          <span data-ttu-id="92e45-180">Dla punktów na granice ćwiartkach, zwracana wartość jest następujące: - Jeśli y 0 i nie jest ujemna, x θ = 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-180">For points on the boundaries of the quadrants, the return value is the following:  -   If y is 0 and x is not negative, θ = 0.</span>
          </span>
          <span data-ttu-id="92e45-181">— Jeśli y jest równa 0, a x ma wartość ujemną, θ = π.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-181">-   If y is 0 and x is negative, θ = π.</span>
          </span>
          <span data-ttu-id="92e45-182">— Jeśli y jest dodatnia i x ma wartość 0, θ = π/2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-182">-   If y is positive and x is 0, θ = π/2.</span>
          </span>
          <span data-ttu-id="92e45-183">— Jeśli y jest ujemna, a x ma wartość 0, θ = - π/2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-183">-   If y is negative and x is 0, θ = -π/2.</span>
          </span>
          <span data-ttu-id="92e45-184">— Jeśli y jest równa 0, a x ma wartość 0, θ = 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-184">-   If y is 0 and x is 0, θ = 0.</span>
          </span>
          <span data-ttu-id="92e45-185">Jeśli <paramref name="x" /> lub <paramref name="y" /> jest <see cref="F:System.Double.NaN" />, lub jeśli <paramref name="x" /> i <paramref name="y" /> są <see cref="F:System.Double.PositiveInfinity" /> lub <see cref="F:System.Double.NegativeInfinity" />, metoda zwraca <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-185">If <paramref name="x" /> or <paramref name="y" /> is <see cref="F:System.Double.NaN" />, or if <paramref name="x" /> and <paramref name="y" /> are either <see cref="F:System.Double.PositiveInfinity" /> or <see cref="F:System.Double.NegativeInfinity" />, the method returns <see cref="F:System.Double.NaN" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-186">Wartość zwracana jest kąt płaszczyźnie kartezjański utworzone przez osi x i wektor uruchamianie ze źródła (0,0) oraz przerywanie punktu, (x, y).</span><span class="sxs-lookup"><span data-stu-id="92e45-186">The return value is the angle in the Cartesian plane formed by the x-axis, and a vector starting from the origin, (0,0), and terminating at the point, (x,y).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-187">W poniższym przykładzie pokazano sposób obliczania tangens kąta i wektora.</span><span class="sxs-lookup"><span data-stu-id="92e45-187">The following example demonstrates how to calculate the arctangent of an angle and a vector.</span></span> <span data-ttu-id="92e45-188">Wartość wynikową jest wyświetlana w konsoli.</span><span class="sxs-lookup"><span data-stu-id="92e45-188">The resulting value is displayed in the console.</span></span>  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh">
      <MemberSignature Language="C#" Value="public static double Atanh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atanh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atanh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atanh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atanh(double d);" />
      <MemberSignature Language="F#" Value="static member Atanh : double -&gt; double" Usage="System.Math.Atanh d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BigMul">
      <MemberSignature Language="C#" Value="public static long BigMul (int a, int b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 BigMul(int32 a, int32 b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.BigMul(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BigMul (a As Integer, b As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long BigMul(int a, int b);" />
      <MemberSignature Language="F#" Value="static member BigMul : int * int -&gt; int64" Usage="System.Math.BigMul (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="92e45-189">Pierwszy liczbę Aby pomnożyć.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-189">The first number to multiply.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="92e45-190">Druga liczba do wielokrotnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-190">The second number to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-191">Zwraca pełny iloczyn dwóch liczb 32-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-191">Produces the full product of two 32-bit numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-192">Liczba zawierający produktu podanych liczb.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-192">The number containing the product of the specified numbers.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-193">W poniższym przykładzie pokazano użycie <xref:System.Math.BigMul%2A> metodę obliczania iloczyn dwóch wartości całkowite.</span><span class="sxs-lookup"><span data-stu-id="92e45-193">The following example demonstrates the use of the <xref:System.Math.BigMul%2A> method to calculate the product of two integer values.</span></span>  
  
 [!code-cpp[math.bigmul#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.bigmul/CPP/bigmul.cpp#1)]
 [!code-csharp[math.bigmul#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.bigmul/CS/bigmul.cs#1)]
 [!code-vb[math.bigmul#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.bigmul/VB/bigmul.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt">
      <MemberSignature Language="C#" Value="public static double Cbrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cbrt(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cbrt(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cbrt (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cbrt(double d);" />
      <MemberSignature Language="F#" Value="static member Cbrt : double -&gt; double" Usage="System.Math.Cbrt d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ceiling">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="92e45-194">Zwraca najmniejszą wartość całkowitą, większa lub równa podanej liczbie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-194">Returns the smallest integral value greater than or equal to the specified number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-195">Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="92e45-195">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="92e45-196">Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku plus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="92e45-196">This kind of rounding is sometimes called rounding toward positive infinity.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static decimal Ceiling (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Ceiling(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Ceiling(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Ceiling : decimal -&gt; decimal" Usage="System.Math.Ceiling d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-197">Liczba dziesiętna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-197">A decimal number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-198">Zwraca najmniejszą wartość całkowitą, która jest większa niż lub równa określonej liczby dziesiętnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-198">Returns the smallest integral value that is greater than or equal to the specified decimal number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-199">Najmniejsza wartość całkowitą, którą jest większa niż lub równa <paramref name="d" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-199">The smallest integral value that is greater than or equal to <paramref name="d" />.</span>
          </span>
          <span data-ttu-id="92e45-200">Należy pamiętać, że ta metoda zwraca <see cref="T:System.Decimal" /> zamiast typ całkowity.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-200">Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-201">Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="92e45-201">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="92e45-202">Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku plus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="92e45-202">This kind of rounding is sometimes called rounding toward positive infinity.</span></span> <span data-ttu-id="92e45-203">Innymi słowy Jeśli `d` jest dodatnia, obecności dowolnej przyczyny ułamkowych części `d` ma zostać zaokrąglona do następną największą liczbę całkowitą.</span><span class="sxs-lookup"><span data-stu-id="92e45-203">In other words, if `d` is positive, the presence of any fractional component causes `d` to be rounded to the next highest integer.</span></span> <span data-ttu-id="92e45-204">Jeśli `d` jest ujemna, zaokrąglania operacja powoduje dowolnego składnika ułamkowych `d` być odrzucony.</span><span class="sxs-lookup"><span data-stu-id="92e45-204">If `d` is negative, the rounding operation causes any fractional component of `d` to be discarded.</span></span> <span data-ttu-id="92e45-205">Operacja ta metoda różni się od <xref:System.Math.Floor%28System.Decimal%29> metodę, która obsługuje zaokrąglania kierunku nieskończoności ujemnej.</span><span class="sxs-lookup"><span data-stu-id="92e45-205">The operation of this method differs from the <xref:System.Math.Floor%28System.Decimal%29> method, which supports rounding toward negative infinity.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-206">Poniższy przykład przedstawia <xref:System.Math.Ceiling%28System.Decimal%29?displayProperty=nameWithType> metody różnic między go przy użyciu <xref:System.Math.Floor%28System.Decimal%29> metody.</span><span class="sxs-lookup"><span data-stu-id="92e45-206">The following example illustrates the <xref:System.Math.Ceiling%28System.Decimal%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Floor%28System.Decimal%29> method.</span></span>  
  
 [!code-csharp[System.Math.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#1)]
 [!code-vb[System.Math.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static double Ceiling (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Ceiling(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Ceiling(double a);" />
      <MemberSignature Language="F#" Value="static member Ceiling : double -&gt; double" Usage="System.Math.Ceiling a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="92e45-207">Liczba zmiennoprzecinkowa podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-207">A double-precision floating-point number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-208">Zwraca najmniejszą wartość całkowitą, która jest większa niż lub równa podanej liczbie zmiennoprzecinkowej podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-208">Returns the smallest integral value that is greater than or equal to the specified double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-209">Najmniejsza wartość całkowitą, którą jest większa niż lub równa <paramref name="a" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-209">The smallest integral value that is greater than or equal to <paramref name="a" />.</span>
          </span>
          <span data-ttu-id="92e45-210">Jeśli <paramref name="a" /> jest równa <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, lub <see cref="F:System.Double.PositiveInfinity" />, jest zwracana wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-210">If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, that value is returned.</span>
          </span>
          <span data-ttu-id="92e45-211">Należy pamiętać, że ta metoda zwraca <see cref="T:System.Double" /> zamiast typ całkowity.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-211">Note that this method returns a <see cref="T:System.Double" /> instead of an integral type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-212">Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="92e45-212">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="92e45-213">Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku plus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="92e45-213">This kind of rounding is sometimes called rounding toward positive infinity.</span></span> <span data-ttu-id="92e45-214">Innymi słowy Jeśli `a` jest dodatnia, obecności dowolnej przyczyny ułamkowych części `a` ma zostać zaokrąglona do następną największą liczbę całkowitą.</span><span class="sxs-lookup"><span data-stu-id="92e45-214">In other words, if `a` is positive, the presence of any fractional component causes `a` to be rounded to the next highest integer.</span></span> <span data-ttu-id="92e45-215">Jeśli `a` jest ujemna, zaokrąglania operacja powoduje dowolnego składnika ułamkowych `a` być odrzucony.</span><span class="sxs-lookup"><span data-stu-id="92e45-215">If `a` is negative, the rounding operation causes any fractional component of `a` to be discarded.</span></span> <span data-ttu-id="92e45-216">Operacja ta metoda różni się od <xref:System.Math.Floor%28System.Double%29> metodę, która obsługuje zaokrąglania kierunku nieskończoności ujemnej.</span><span class="sxs-lookup"><span data-stu-id="92e45-216">The operation of this method differs from the <xref:System.Math.Floor%28System.Double%29> method, which supports rounding toward negative infinity.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-217">Poniższy przykład przedstawia <xref:System.Math.Ceiling%28System.Double%29?displayProperty=nameWithType> metody różnic między go przy użyciu <xref:System.Math.Floor%28System.Double%29> metody.</span><span class="sxs-lookup"><span data-stu-id="92e45-217">The following example illustrates the <xref:System.Math.Ceiling%28System.Double%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Floor%28System.Double%29> method.</span></span>  
  
 [!code-csharp[System.Math.Ceiling#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#2)]
 [!code-vb[System.Math.Ceiling#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static byte Clamp (byte value, byte min, byte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Clamp(unsigned int8 value, unsigned int8 min, unsigned int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Byte,System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Byte, min As Byte, max As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Clamp(System::Byte value, System::Byte min, System::Byte max);" />
      <MemberSignature Language="F#" Value="static member Clamp : byte * byte * byte -&gt; byte" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
        <Parameter Name="min" Type="System.Byte" />
        <Parameter Name="max" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static decimal Clamp (decimal value, decimal min, decimal max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Clamp(valuetype System.Decimal value, valuetype System.Decimal min, valuetype System.Decimal max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Decimal,System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Decimal, min As Decimal, max As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Clamp(System::Decimal value, System::Decimal min, System::Decimal max);" />
      <MemberSignature Language="F#" Value="static member Clamp : decimal * decimal * decimal -&gt; decimal" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
        <Parameter Name="min" Type="System.Decimal" />
        <Parameter Name="max" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static double Clamp (double value, double min, double max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Clamp(float64 value, float64 min, float64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Double, min As Double, max As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Clamp(double value, double min, double max);" />
      <MemberSignature Language="F#" Value="static member Clamp : double * double * double -&gt; double" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="min" Type="System.Double" />
        <Parameter Name="max" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static short Clamp (short value, short min, short max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Clamp(int16 value, int16 min, int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int16,System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Short, min As Short, max As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Clamp(short value, short min, short max);" />
      <MemberSignature Language="F#" Value="static member Clamp : int16 * int16 * int16 -&gt; int16" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
        <Parameter Name="min" Type="System.Int16" />
        <Parameter Name="max" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static int Clamp (int value, int min, int max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Clamp(int32 value, int32 min, int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Integer, min As Integer, max As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Clamp(int value, int min, int max);" />
      <MemberSignature Language="F#" Value="static member Clamp : int * int * int -&gt; int" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="min" Type="System.Int32" />
        <Parameter Name="max" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static long Clamp (long value, long min, long max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Clamp(int64 value, int64 min, int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Long, min As Long, max As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Clamp(long value, long min, long max);" />
      <MemberSignature Language="F#" Value="static member Clamp : int64 * int64 * int64 -&gt; int64" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="min" Type="System.Int64" />
        <Parameter Name="max" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static sbyte Clamp (sbyte value, sbyte min, sbyte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Clamp(int8 value, int8 min, int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.SByte,System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As SByte, min As SByte, max As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Clamp(System::SByte value, System::SByte min, System::SByte max);" />
      <MemberSignature Language="F#" Value="static member Clamp : sbyte * sbyte * sbyte -&gt; sbyte" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
        <Parameter Name="min" Type="System.SByte" />
        <Parameter Name="max" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static float Clamp (float value, float min, float max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Clamp(float32 value, float32 min, float32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Single, min As Single, max As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Clamp(float value, float min, float max);" />
      <MemberSignature Language="F#" Value="static member Clamp : single * single * single -&gt; single" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="min" Type="System.Single" />
        <Parameter Name="max" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ushort Clamp (ushort value, ushort min, ushort max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Clamp(unsigned int16 value, unsigned int16 min, unsigned int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt16,System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UShort, min As UShort, max As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Clamp(System::UInt16 value, System::UInt16 min, System::UInt16 max);" />
      <MemberSignature Language="F#" Value="static member Clamp : uint16 * uint16 * uint16 -&gt; uint16" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
        <Parameter Name="min" Type="System.UInt16" />
        <Parameter Name="max" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static uint Clamp (uint value, uint min, uint max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Clamp(unsigned int32 value, unsigned int32 min, unsigned int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt32,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UInteger, min As UInteger, max As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Clamp(System::UInt32 value, System::UInt32 min, System::UInt32 max);" />
      <MemberSignature Language="F#" Value="static member Clamp : uint32 * uint32 * uint32 -&gt; uint32" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
        <Parameter Name="min" Type="System.UInt32" />
        <Parameter Name="max" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ulong Clamp (ulong value, ulong min, ulong max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Clamp(unsigned int64 value, unsigned int64 min, unsigned int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt64,System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As ULong, min As ULong, max As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Clamp(System::UInt64 value, System::UInt64 min, System::UInt64 max);" />
      <MemberSignature Language="F#" Value="static member Clamp : uint64 * uint64 * uint64 -&gt; uint64" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
        <Parameter Name="min" Type="System.UInt64" />
        <Parameter Name="max" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static double Cos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cos(double d);" />
      <MemberSignature Language="F#" Value="static member Cos : double -&gt; double" Usage="System.Math.Cos d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-218">Kąt wyrażony w radianach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-218">An angle, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-219">Zwraca cosinus odpowiadający podanemu kątowi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-219">Returns the cosine of the specified angle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-220">Cosinus <paramref name="d" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-220">The cosine of <paramref name="d" />.</span>
          </span>
          <span data-ttu-id="92e45-221">Jeśli <paramref name="d" /> jest równa <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, lub <see cref="F:System.Double.PositiveInfinity" />, ta metoda zwraca <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-221">If <paramref name="d" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-222">Kąt `d`, musi być podany w radianach.</span><span class="sxs-lookup"><span data-stu-id="92e45-222">The angle, `d`, must be in radians.</span></span> <span data-ttu-id="92e45-223">Mnożenie przez <xref:System.Math.PI?displayProperty=nameWithType>/180 do Konwertuj stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="92e45-223">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 <span data-ttu-id="92e45-224">Dopuszczalne wartości `d` z zakresu od około-9223372036854775295 do około 9223372036854775295.</span><span class="sxs-lookup"><span data-stu-id="92e45-224">Acceptable values of `d` range from approximately -9223372036854775295 to approximately 9223372036854775295.</span></span> <span data-ttu-id="92e45-225">Dla wartości poza tym zakresem <xref:System.Math.Cos%2A> metoda zwraca `d` niezmienione zamiast zgłaszać wyjątek.</span><span class="sxs-lookup"><span data-stu-id="92e45-225">For values outside this range, the <xref:System.Math.Cos%2A> method returns `d` unchanged rather than throwing an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-226">W poniższym przykładzie użyto <xref:System.Math.Cos%2A> do oceny niektórych trygonometryczne tożsamości dla wybranych kątów.</span><span class="sxs-lookup"><span data-stu-id="92e45-226">The following example uses <xref:System.Math.Cos%2A> to evaluate certain trigonometric identities for selected angles.</span></span>  
  
 [!code-cpp[System.Math.SinCos#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp#1)]
 [!code-csharp[System.Math.SinCos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs#1)]
 [!code-vb[System.Math.SinCos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static double Cosh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cosh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cosh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cosh(double value);" />
      <MemberSignature Language="F#" Value="static member Cosh : double -&gt; double" Usage="System.Math.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-227">Kąt wyrażony w radianach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-227">An angle, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-228">Zwraca cosinus hiperboliczny podanemu kątowi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-228">Returns the hyperbolic cosine of the specified angle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-229">Cosinus hiperboliczny liczby <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-229">The hyperbolic cosine of <paramref name="value" />.</span>
          </span>
          <span data-ttu-id="92e45-230">Jeśli <paramref name="value" /> jest równa <see cref="F:System.Double.NegativeInfinity" /> lub <see cref="F:System.Double.PositiveInfinity" />, <see cref="F:System.Double.PositiveInfinity" /> jest zwracany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-230">If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" /> or <see cref="F:System.Double.PositiveInfinity" />, <see cref="F:System.Double.PositiveInfinity" /> is returned.</span>
          </span>
          <span data-ttu-id="92e45-231">Jeśli <paramref name="value" /> jest równa <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> jest zwracany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-231">If <paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-232">Kąt `value`, musi być podany w radianach.</span><span class="sxs-lookup"><span data-stu-id="92e45-232">The angle, `value`, must be in radians.</span></span> <span data-ttu-id="92e45-233">Mnożenie przez <xref:System.Math.PI?displayProperty=nameWithType>/180 do Konwertuj stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="92e45-233">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-234">W poniższym przykładzie użyto <xref:System.Math.Cosh%2A> do oceny niektórych hiperboliczny tożsamości dla wybranych wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-234">The following example uses <xref:System.Math.Cosh%2A> to evaluate certain hyperbolic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.SinhCosh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp#1)]
 [!code-csharp[System.Math.SinhCosh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs#1)]
 [!code-vb[System.Math.SinhCosh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivRem">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="92e45-235">Oblicza iloraz dwóch liczb, a także zwraca resztę do parametru output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-235">Calculates the quotient of two numbers and also returns the remainder in an output parameter.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static int DivRem (int a, int b, out int result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 DivRem(int32 a, int32 b, [out] int32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (a As Integer, b As Integer, ByRef result As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int DivRem(int a, int b, [Runtime::InteropServices::Out] int % result);" />
      <MemberSignature Language="F#" Value="static member DivRem : int * int *  -&gt; int" Usage="System.Math.DivRem (a, b, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int32" />
        <Parameter Name="result" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="92e45-236">Dzielna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-236">The dividend.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="92e45-237">Dzielnik.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-237">The divisor.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="92e45-238">Pozostałe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-238">The remainder.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-239">Oblicza iloraz dwóch liczb całkowitych ze znakiem 32-bitowe i również zwraca resztę do parametru output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-239">Calculates the quotient of two 32-bit signed integers and also returns the remainder in an output parameter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-240">Iloraz podanych liczb.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-240">The quotient of the specified numbers.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-241">Pozostała jest obliczana przy użyciu operacji modułu.</span><span class="sxs-lookup"><span data-stu-id="92e45-241">The remainder is calculated by using the modulus operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-242">W poniższym przykładzie pokazano <xref:System.Math.DivRem%28System.Int32%2CSystem.Int32%2CSystem.Int32%40%29> metody.</span><span class="sxs-lookup"><span data-stu-id="92e45-242">The following example demonstrates the <xref:System.Math.DivRem%28System.Int32%2CSystem.Int32%2CSystem.Int32%40%29> method.</span></span>  
  
 [!code-csharp[System.Math.DivRem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem1.cs#1)]
 [!code-vb[System.Math.DivRem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <span data-ttu-id="92e45-243">
            <paramref name="b" /> wynosi zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-243">
              <paramref name="b" /> is zero.</span>
          </span>
        </exception>
        <altmember cref="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static long DivRem (long a, long b, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 DivRem(int64 a, int64 b, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (a As Long, b As Long, ByRef result As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long DivRem(long a, long b, [Runtime::InteropServices::Out] long % result);" />
      <MemberSignature Language="F#" Value="static member DivRem : int64 * int64 *  -&gt; int64" Usage="System.Math.DivRem (a, b, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int64" />
        <Parameter Name="b" Type="System.Int64" />
        <Parameter Name="result" Type="System.Int64&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="92e45-244">Dzielna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-244">The dividend.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="92e45-245">Dzielnik.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-245">The divisor.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="92e45-246">Pozostałe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-246">The remainder.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-247">Oblicza iloraz dwóch liczb całkowitych ze znakiem 64-bitowe i również zwraca resztę do parametru output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-247">Calculates the quotient of two 64-bit signed integers and also returns the remainder in an output parameter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-248">Iloraz podanych liczb.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-248">The quotient of the specified numbers.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-249">Pozostała jest obliczana przy użyciu operacji modułu.</span><span class="sxs-lookup"><span data-stu-id="92e45-249">The remainder is calculated by using the modulus operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-250">W poniższym przykładzie pokazano <xref:System.Math.DivRem%28System.Int64%2CSystem.Int64%2CSystem.Int64%40%29> metody.</span><span class="sxs-lookup"><span data-stu-id="92e45-250">The following example demonstrates the <xref:System.Math.DivRem%28System.Int64%2CSystem.Int64%2CSystem.Int64%40%29> method.</span></span>  
  
 [!code-csharp[System.Math.DivRem#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem2.cs#2)]
 [!code-vb[System.Math.DivRem#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <span data-ttu-id="92e45-251">
            <paramref name="b" /> wynosi zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-251">
              <paramref name="b" /> is zero.</span>
          </span>
        </exception>
        <altmember cref="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public const double E = 2.71828182845905;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 E = (2.71828182845905)" />
      <MemberSignature Language="DocId" Value="F:System.Math.E" />
      <MemberSignature Language="VB.NET" Value="Public Const E As Double  = 2.71828182845905" />
      <MemberSignature Language="C++ CLI" Value="public: double E = 2.71828182845905;" />
      <MemberSignature Language="F#" Value="val mutable E : double" Usage="System.Math.E" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>2.71828182845905</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="92e45-252">Reprezentuje podstawa logarytmu naturalnego, określony przez wartość stałej, <see langword="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-252">Represents the natural logarithmic base, specified by the constant, <see langword="e" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-253">Wartość tego pola jest 2.7182818284590452354.</span><span class="sxs-lookup"><span data-stu-id="92e45-253">The value of this field is 2.7182818284590452354.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-254">Poniższy przykład porównuje <xref:System.Math.E> z wartością obliczoną na podstawie serii zasilania.</span><span class="sxs-lookup"><span data-stu-id="92e45-254">The following example compares <xref:System.Math.E> with the value calculated from a power series.</span></span>  
  
 [!code-cpp[System.Math.E#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.E/CPP/efield.cpp#1)]
 [!code-csharp[System.Math.E#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.E/CS/efield.cs#1)]
 [!code-vb[System.Math.E#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.E/VB/efield.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static double Exp (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exp(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Exp(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exp(double d);" />
      <MemberSignature Language="F#" Value="static member Exp : double -&gt; double" Usage="System.Math.Exp d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-255">Liczba określająca potęgi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-255">A number specifying a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-256">Zwraca <see langword="e" /> podniesionej do potęgi określonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-256">Returns <see langword="e" /> raised to the specified power.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-257">Liczba <see langword="e" /> podniesionej do potęgi <paramref name="d" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-257">The number <see langword="e" /> raised to the power <paramref name="d" />.</span>
          </span>
          <span data-ttu-id="92e45-258">Jeśli <paramref name="d" /> jest równe <see cref="F:System.Double.NaN" /> lub <see cref="F:System.Double.PositiveInfinity" />, jest zwracana wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-258">If <paramref name="d" /> equals <see cref="F:System.Double.NaN" /> or <see cref="F:System.Double.PositiveInfinity" />, that value is returned.</span>
          </span>
          <span data-ttu-id="92e45-259">Jeśli <paramref name="d" /> jest równe <see cref="F:System.Double.NegativeInfinity" />, zwracany jest 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-259">If <paramref name="d" /> equals <see cref="F:System.Double.NegativeInfinity" />, 0 is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-260">`e` jest stałe matematyczne, którego wartość wynosi około 2.71828.</span><span class="sxs-lookup"><span data-stu-id="92e45-260">`e` is a mathematical constant whose value is approximately 2.71828.</span></span>  
  
 <span data-ttu-id="92e45-261">Użyj <xref:System.Math.Pow%2A> metodę obliczania uprawnień innych typów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="92e45-261">Use the <xref:System.Math.Pow%2A> method to calculate powers of other bases.</span></span>  
  
 <span data-ttu-id="92e45-262"><xref:System.Math.Exp%2A> jest odwrotność <xref:System.Math.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="92e45-262"><xref:System.Math.Exp%2A> is the inverse of <xref:System.Math.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-263">W poniższym przykładzie użyto <xref:System.Math.Exp%2A> do oceny niektórych wykładniczej i logarytmicznej tożsamości dla wybranych wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-263">The following example uses <xref:System.Math.Exp%2A> to evaluate certain exponential and logarithmic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.Exp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Exp/CPP/exp.cpp#1)]
 [!code-csharp[System.Math.Exp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Exp/CS/exp.cs#1)]
 [!code-vb[System.Math.Exp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Exp/VB/exp.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Math.E" />
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
        <altmember cref="M:System.Math.Log(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Floor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="92e45-264">Zwraca największą wartość całkowitą mniejszą niż określona liczba.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-264">Returns the largest integral value less than or equal to the specified number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-265">Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="92e45-265">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="92e45-266">Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku minus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="92e45-266">This kind of rounding is sometimes called rounding toward negative infinity.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static decimal Floor (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Floor(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Floor(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Floor : decimal -&gt; decimal" Usage="System.Math.Floor d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-267">Liczba dziesiętna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-267">A decimal number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-268">Zwraca największą wartość całkowitą mniejszą niż określona liczba dziesiętna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-268">Returns the largest integral value less than or equal to the specified decimal number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-269">Całkowite największą wartość mniejsza lub równa <paramref name="d" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-269">The largest integral value less than or equal to <paramref name="d" />.</span>
          </span>
          <span data-ttu-id="92e45-270">Należy pamiętać, że ta metoda zwraca wartość całkowitą typu <see cref="T:System.Decimal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-270">Note that the method returns an integral value of type <see cref="T:System.Decimal" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-271">Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="92e45-271">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="92e45-272">Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku minus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="92e45-272">This kind of rounding is sometimes called rounding toward negative infinity.</span></span> <span data-ttu-id="92e45-273">Innymi słowy Jeśli `d` jest dodatnia, dowolny składnik ułamkowych zostały obcięte.</span><span class="sxs-lookup"><span data-stu-id="92e45-273">In other words, if `d` is positive, any fractional component is truncated.</span></span> <span data-ttu-id="92e45-274">Jeśli `d` jest ujemna, obecności ułamkowych części powoduje ona ma zostać zaokrąglona na mniejszą liczbę całkowitą.</span><span class="sxs-lookup"><span data-stu-id="92e45-274">If `d` is negative, the presence of any fractional component causes it to be rounded to the smaller integer.</span></span> <span data-ttu-id="92e45-275">Operacja ta metoda różni się od <xref:System.Math.Ceiling%2A> metodę, która obsługuje zaokrąglania kierunku nieskończoności dodatniej.</span><span class="sxs-lookup"><span data-stu-id="92e45-275">The operation of this method differs from the <xref:System.Math.Ceiling%2A> method, which supports rounding toward positive infinity.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-276">Poniższy przykład przedstawia <xref:System.Math.Floor%28System.Decimal%29?displayProperty=nameWithType> metody różnic między go przy użyciu <xref:System.Math.Ceiling%28System.Decimal%29> metody.</span><span class="sxs-lookup"><span data-stu-id="92e45-276">The following example illustrates the <xref:System.Math.Floor%28System.Decimal%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Ceiling%28System.Decimal%29> method.</span></span>  
  
 [!code-csharp[System.Math.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#1)]
 [!code-vb[System.Math.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Decimal.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static double Floor (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Floor(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Floor(double d);" />
      <MemberSignature Language="F#" Value="static member Floor : double -&gt; double" Usage="System.Math.Floor d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-277">Liczba zmiennoprzecinkowa podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-277">A double-precision floating-point number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-278">Zwraca największą wartość całkowitą mniejszą lub równą podanej liczbie zmiennoprzecinkowej podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-278">Returns the largest integral value less than or equal to the specified double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-279">Całkowite największą wartość mniejsza lub równa <paramref name="d" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-279">The largest integral value less than or equal to <paramref name="d" />.</span>
          </span>
          <span data-ttu-id="92e45-280">Jeśli <paramref name="d" /> jest równa <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, lub <see cref="F:System.Double.PositiveInfinity" />, jest zwracana wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-280">If <paramref name="d" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, that value is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-281">Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="92e45-281">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="92e45-282">Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku minus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="92e45-282">This kind of rounding is sometimes called rounding toward negative infinity.</span></span> <span data-ttu-id="92e45-283">Innymi słowy Jeśli `d` jest dodatnia, dowolny składnik ułamkowych zostały obcięte.</span><span class="sxs-lookup"><span data-stu-id="92e45-283">In other words, if `d` is positive, any fractional component is truncated.</span></span> <span data-ttu-id="92e45-284">Jeśli `d` jest ujemna, obecności ułamkowych części powoduje ona ma zostać zaokrąglona na mniejszą liczbę całkowitą.</span><span class="sxs-lookup"><span data-stu-id="92e45-284">If `d` is negative, the presence of any fractional component causes it to be rounded to the smaller integer.</span></span> <span data-ttu-id="92e45-285">Operacja ta metoda różni się od <xref:System.Math.Ceiling%2A> metodę, która obsługuje zaokrąglania kierunku nieskończoności dodatniej.</span><span class="sxs-lookup"><span data-stu-id="92e45-285">The operation of this method differs from the <xref:System.Math.Ceiling%2A> method, which supports rounding toward positive infinity.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-286">Poniższy przykład przedstawia <xref:System.Math.Floor%28System.Double%29?displayProperty=nameWithType> metody różnic między go przy użyciu <xref:System.Math.Ceiling%28System.Double%29> metody.</span><span class="sxs-lookup"><span data-stu-id="92e45-286">The following example illustrates the <xref:System.Math.Floor%28System.Double%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Ceiling%28System.Double%29> method.</span></span>  
  
 [!code-csharp[System.Math.Ceiling#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#2)]
 [!code-vb[System.Math.Ceiling#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="IEEERemainder">
      <MemberSignature Language="C#" Value="public static double IEEERemainder (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 IEEERemainder(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IEEERemainder (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double IEEERemainder(double x, double y);" />
      <MemberSignature Language="F#" Value="static member IEEERemainder : double * double -&gt; double" Usage="System.Math.IEEERemainder (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">
          <span data-ttu-id="92e45-287">Dzielna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-287">A dividend.</span>
          </span>
        </param>
        <param name="y">
          <span data-ttu-id="92e45-288">Dzielnik.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-288">A divisor.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-289">Zwraca resztę z dzielenia liczby określonej przez inną podany numer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-289">Returns the remainder resulting from the division of a specified number by another specified number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-290">Liczby równej <paramref name="x" /> -(<paramref name="y" /> Q), gdzie Q jest równy ilorazowi <paramref name="x" />  /  <paramref name="y" /> zaokrąglona do najbliższej liczby całkowitej (Jeśli <paramref name="x" />  /  <paramref name="y" /> znajduje się w połowie między dwie liczb całkowitych, parzystej liczby całkowitej zwrócił).</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-290">A number equal to <paramref name="x" /> - (<paramref name="y" /> Q), where Q is the quotient of <paramref name="x" /> / <paramref name="y" /> rounded to the nearest integer (if <paramref name="x" /> / <paramref name="y" /> falls halfway between two integers, the even integer is returned).</span>
          </span>
          <span data-ttu-id="92e45-291">Jeśli <paramref name="x" /> -(<paramref name="y" /> Q) jest zero, wartość + 0 jest zwracany, jeśli <paramref name="x" /> jest dodatni lub — jeśli 0 <paramref name="x" /> jest ujemna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-291">If <paramref name="x" /> - (<paramref name="y" /> Q) is zero, the value +0 is returned if <paramref name="x" /> is positive, or -0 if <paramref name="x" /> is negative.</span>
          </span>
          <span data-ttu-id="92e45-292">Jeśli <paramref name="y" /> = 0, <see cref="F:System.Double.NaN" /> jest zwracany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-292">If <paramref name="y" /> = 0, <see cref="F:System.Double.NaN" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-293">Ta operacja jest zgodny z pozostałą operacji zdefiniowanej w sekcji 5.1 754-1985 ANSI/IEEE Std; Standard IEEE binarne arytmetyczne zmiennoprzecinkowe; Institute of prądu i Electronics Engineers, Inc.; 1985.</span><span class="sxs-lookup"><span data-stu-id="92e45-293">This operation complies with the remainder operation defined in Section 5.1 of ANSI/IEEE Std 754-1985; IEEE Standard for Binary Floating-Point Arithmetic; Institute of Electrical and Electronics Engineers, Inc; 1985.</span></span>  
  
 <span data-ttu-id="92e45-294"><xref:System.Math.IEEERemainder%2A> Metoda nie jest taka sama jak operator modulo.</span><span class="sxs-lookup"><span data-stu-id="92e45-294">The <xref:System.Math.IEEERemainder%2A> method is not the same as the modulus operator.</span></span> <span data-ttu-id="92e45-295">Mimo że zwrócą resztę po dzielenia formuły używane są różne.</span><span class="sxs-lookup"><span data-stu-id="92e45-295">Although both return the remainder after division, the formulas they use are different.</span></span> <span data-ttu-id="92e45-296">Formuła <xref:System.Math.IEEERemainder%2A> metoda jest:</span><span class="sxs-lookup"><span data-stu-id="92e45-296">The formula for the <xref:System.Math.IEEERemainder%2A> method is:</span></span>  
  
```  
IEEERemainder = dividend - (divisor * Math.Round(dividend / divisor))  
```  
  
 <span data-ttu-id="92e45-297">Z kolei dla operatora modulo jest:</span><span class="sxs-lookup"><span data-stu-id="92e45-297">In contrast, the formula for the modulus operator is:</span></span>  
  
```  
Modulus = (Math.Abs(dividend) - (Math.Abs(divisor) *   
          (Math.Floor(Math.Abs(dividend) / Math.Abs(divisor))))) *   
          Math.Sign(dividend)  
```  
  
   
  
## Examples  
 <span data-ttu-id="92e45-298">Poniższy przykład zachowanie różni się od pozostałej zwrócony przez <xref:System.Math.IEEERemainder%2A> metody pozostałych zwracanych przez operator dzielenie modulo.</span><span class="sxs-lookup"><span data-stu-id="92e45-298">The following example contrasts the remainder returned by the <xref:System.Math.IEEERemainder%2A> method with the remainder returned by the modulus division operator.</span></span>  
  
 [!code-csharp[System.Math.IEEERemainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.ieeeremainder/cs/ieeeremainder1.cs#1)]
 [!code-vb[System.Math.IEEERemainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.ieeeremainder/vb/ieeeremainder1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="92e45-299">Zwraca wartość logarytmu określonej liczby.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-299">Returns the logarithm of a specified number.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(double d);" />
      <MemberSignature Language="F#" Value="static member Log : double -&gt; double" Usage="System.Math.Log d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-300">Liczba, której logarytm ma zostać znaleziona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-300">The number whose logarithm is to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-301">Zwraca fizyczna (podstawowy <see langword="e" />) logarytm o podstawie określonej liczby.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-301">Returns the natural (base <see langword="e" />) logarithm of a specified number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-302">Jedna z wartości w tabeli poniżej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-302">One of the values in the following table.</span>
          </span>
          <span data-ttu-id="92e45-303">
            <list type="table">
              <listheader>
                <term>
                  <paramref name="d" /> parameter  </term>
                <description> Return value  </description>
              </listheader>
              <item>
                <term> Positive  </term>
                <description> The natural logarithm of <paramref name="d" />; that is, ln <paramref name="d" />, or log e <paramref name="d" /></description>
              </item>
              <item>
                <term> Zero  </term>
                <description>
                  <see cref="F:System.Double.NegativeInfinity" />
                </description>
              </item>
              <item>
                <term> Negative  </term>
                <description>
                  <see cref="F:System.Double.NaN" />
                </description>
              </item>
              <item>
                <term> Equal to <see cref="F:System.Double.NaN" /></term>
                <description>
                  <see cref="F:System.Double.NaN" />
                </description>
              </item>
              <item>
                <term> Equal to <see cref="F:System.Double.PositiveInfinity" /></term>
                <description>
                  <see cref="F:System.Double.PositiveInfinity" />
                </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-303">
              <list type="table">
                <listheader>
                  <term>
                    <paramref name="d" /> parameter  </term>
                  <description> Return value  </description>
                </listheader>
                <item>
                  <term> Positive  </term>
                  <description> The natural logarithm of <paramref name="d" />; that is, ln <paramref name="d" />, or log e <paramref name="d" /></description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description>
                    <see cref="F:System.Double.NegativeInfinity" />
                  </description>
                </item>
                <item>
                  <term> Negative  </term>
                  <description>
                    <see cref="F:System.Double.NaN" />
                  </description>
                </item>
                <item>
                  <term> Equal to <see cref="F:System.Double.NaN" /></term>
                  <description>
                    <see cref="F:System.Double.NaN" />
                  </description>
                </item>
                <item>
                  <term> Equal to <see cref="F:System.Double.PositiveInfinity" /></term>
                  <description>
                    <see cref="F:System.Double.PositiveInfinity" />
                  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-304">Parametr `d` jest określony jako podstawowy numer 10.</span><span class="sxs-lookup"><span data-stu-id="92e45-304">Parameter `d` is specified as a base 10 number.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-305">Poniższy przykład przedstawia <xref:System.Math.Log%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="92e45-305">The following example illustrates the <xref:System.Math.Log%2A> method.</span></span>  
  
 [!code-csharp[System.Math.Log_Overloads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/log1.cs#2)]
 [!code-vb[System.Math.Log_Overloads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/log1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Math.E" />
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double a, double newBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 a, float64 newBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (a As Double, newBase As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(double a, double newBase);" />
      <MemberSignature Language="F#" Value="static member Log : double * double -&gt; double" Usage="System.Math.Log (a, newBase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
        <Parameter Name="newBase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="92e45-306">Liczba, której logarytm ma zostać znaleziona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-306">The number whose logarithm is to be found.</span>
          </span>
        </param>
        <param name="newBase">
          <span data-ttu-id="92e45-307">Podstawa logarytmu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-307">The base of the logarithm.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-308">Zwraca logarytm o określonej liczby w określonej podstawy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-308">Returns the logarithm of a specified number in a specified base.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-309">Jedna z wartości w tabeli poniżej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-309">One of the values in the following table.</span>
          </span>
          <span data-ttu-id="92e45-310">(+ Oznacza nieskończoność <see cref="F:System.Double.PositiveInfinity" />, - oznacza nieskończoność <see cref="F:System.Double.NegativeInfinity" />, i określa NaN <see cref="F:System.Double.NaN" />.)  <list type="table"><listheader><term><paramref name="a" /></term><description><paramref name="newBase" /></description><description> Return value  </description></listheader><item><term><paramref name="a" />&gt; 0  </term><description> (0 &lt;<paramref name="newBase" />&lt; 1) -or-(<paramref name="newBase" />&gt; 1)  </description><description> lognewBase(a)  </description></item><item><term><paramref name="a" />&lt; 0  </term><description> (any value)  </description><description> NaN  </description></item><item><term> (any value)  </term><description><paramref name="newBase" />&lt; 0  </description><description> NaN  </description></item><item><term><paramref name="a" /> != 1  </term><description><paramref name="newBase" /> = 0  </description><description> NaN  </description></item><item><term><paramref name="a" /> != 1  </term><description><paramref name="newBase" /> = +Infinity  </description><description> NaN  </description></item><item><term><paramref name="a" /> = NaN  </term><description> (any value)  </description><description> NaN  </description></item><item><term> (any value)  </term><description><paramref name="newBase" /> = NaN  </description><description> NaN  </description></item><item><term> (any value)  </term><description><paramref name="newBase" /> = 1  </description><description> NaN  </description></item><item><term><paramref name="a" /> = 0  </term><description> 0 &lt;<paramref name="newBase" />&lt; 1  </description><description> +Infinity  </description></item><item><term><paramref name="a" /> = 0  </term><description><paramref name="newBase" />&gt; 1  </description><description> -Infinity  </description></item><item><term><paramref name="a" /> =  +Infinity  </term><description> 0 &lt;<paramref name="newBase" />&lt; 1  </description><description> -Infinity  </description></item><item><term><paramref name="a" /> =  +Infinity  </term><description><paramref name="newBase" />&gt; 1  </description><description> +Infinity  </description></item><item><term><paramref name="a" /> = 1  </term><description><paramref name="newBase" /> = 0  </description><description> 0  </description></item><item><term><paramref name="a" /> = 1  </term><description><paramref name="newBase" /> = +Infinity  </description><description> 0  </description></item></list></span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-310">(+Infinity denotes <see cref="F:System.Double.PositiveInfinity" />, -Infinity denotes <see cref="F:System.Double.NegativeInfinity" />, and NaN denotes <see cref="F:System.Double.NaN" />.)  <list type="table"><listheader><term><paramref name="a" /></term><description><paramref name="newBase" /></description><description> Return value  </description></listheader><item><term><paramref name="a" />&gt; 0  </term><description> (0 &lt;<paramref name="newBase" />&lt; 1) -or-(<paramref name="newBase" />&gt; 1)  </description><description> lognewBase(a)  </description></item><item><term><paramref name="a" />&lt; 0  </term><description> (any value)  </description><description> NaN  </description></item><item><term> (any value)  </term><description><paramref name="newBase" />&lt; 0  </description><description> NaN  </description></item><item><term><paramref name="a" /> != 1  </term><description><paramref name="newBase" /> = 0  </description><description> NaN  </description></item><item><term><paramref name="a" /> != 1  </term><description><paramref name="newBase" /> = +Infinity  </description><description> NaN  </description></item><item><term><paramref name="a" /> = NaN  </term><description> (any value)  </description><description> NaN  </description></item><item><term> (any value)  </term><description><paramref name="newBase" /> = NaN  </description><description> NaN  </description></item><item><term> (any value)  </term><description><paramref name="newBase" /> = 1  </description><description> NaN  </description></item><item><term><paramref name="a" /> = 0  </term><description> 0 &lt;<paramref name="newBase" />&lt; 1  </description><description> +Infinity  </description></item><item><term><paramref name="a" /> = 0  </term><description><paramref name="newBase" />&gt; 1  </description><description> -Infinity  </description></item><item><term><paramref name="a" /> =  +Infinity  </term><description> 0 &lt;<paramref name="newBase" />&lt; 1  </description><description> -Infinity  </description></item><item><term><paramref name="a" /> =  +Infinity  </term><description><paramref name="newBase" />&gt; 1  </description><description> +Infinity  </description></item><item><term><paramref name="a" /> = 1  </term><description><paramref name="newBase" /> = 0  </description><description> 0  </description></item><item><term><paramref name="a" /> = 1  </term><description><paramref name="newBase" /> = +Infinity  </description><description> 0  </description></item></list></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-311">W poniższym przykładzie użyto <xref:System.Math.Log%2A> do oceny niektórych logarytmicznej tożsamości dla wybranych wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-311">The following example uses <xref:System.Math.Log%2A> to evaluate certain logarithmic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.Log_Overloads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CPP/loggen.cpp#1)]
 [!code-csharp[System.Math.Log_Overloads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/loggen.cs#1)]
 [!code-vb[System.Math.Log_Overloads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/loggen.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log10(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(double d);" />
      <MemberSignature Language="F#" Value="static member Log10 : double -&gt; double" Usage="System.Math.Log10 d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-312">Liczba, której logarytm ma zostać znaleziona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-312">A number whose logarithm is to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-313">Zwraca logarytm 10 podanej liczby.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-313">Returns the base 10 logarithm of a specified number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-314">Jedna z wartości w tabeli poniżej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-314">One of the values in the following table.</span>
          </span>
          <span data-ttu-id="92e45-315">
            <list type="table">
              <listheader>
                <term>
                  <paramref name="d" /> Parametr </term>
                <description> zwrócić wartość </description>
              </listheader>
              <item>
                <term> dodatnią </term>
                <description> podstawowej dziennik 10 <paramref name="d" />; Zaloguj się 10<paramref name="d" />.  </description>
              </item>
              <item>
                <term> Zero </term>
                <description>
                  <see cref="F:System.Double.NegativeInfinity" />
                </description>
              </item>
              <item>
                <term> ujemna </term>
                <description>
                  <see cref="F:System.Double.NaN" />
                </description>
              </item>
              <item>
                <term> Równa <see cref="F:System.Double.NaN" /></term>
                <description>
                  <see cref="F:System.Double.NaN" />
                </description>
              </item>
              <item>
                <term> równe <see cref="F:System.Double.PositiveInfinity" /></term>
                <description>
                  <see cref="F:System.Double.PositiveInfinity" />
                </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-315">
              <list type="table">
                <listheader>
                  <term>
                    <paramref name="d" /> parameter  </term>
                  <description> Return value  </description>
                </listheader>
                <item>
                  <term> Positive  </term>
                  <description> The base 10 log of <paramref name="d" />; that is, log 10<paramref name="d" />.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description>
                    <see cref="F:System.Double.NegativeInfinity" />
                  </description>
                </item>
                <item>
                  <term> Negative  </term>
                  <description>
                    <see cref="F:System.Double.NaN" />
                  </description>
                </item>
                <item>
                  <term> Equal to <see cref="F:System.Double.NaN" /></term>
                  <description>
                    <see cref="F:System.Double.NaN" />
                  </description>
                </item>
                <item>
                  <term> Equal to <see cref="F:System.Double.PositiveInfinity" /></term>
                  <description>
                    <see cref="F:System.Double.PositiveInfinity" />
                  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-316">Parametr `d` jest określony jako podstawowy numer 10.</span><span class="sxs-lookup"><span data-stu-id="92e45-316">Parameter `d` is specified as a base 10 number.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-317">W poniższym przykładzie użyto <xref:System.Math.Log10%2A> metoda zwraca logarytm 10 dla wybranych wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-317">The following example uses the <xref:System.Math.Log10%2A> method to return the base 10 logarithm for selected values.</span></span>  
  
 [!code-csharp[System.Math.Log10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log10/CS/log10.cs#1)]
 [!code-vb[System.Math.Log10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log10/VB/log10.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="92e45-318">Zwraca większych dwóch podanych liczb.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-318">Returns the larger of two specified numbers.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static byte Max (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Max(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Byte, val2 As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Max(System::Byte val1, System::Byte val2);" />
      <MemberSignature Language="F#" Value="static member Max : byte * byte -&gt; byte" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-319">Pierwszy z dwóch 8-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-319">The first of two 8-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-320">Drugi dwóch 8-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-320">The second of two 8-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-321">Zwraca większy dwie liczb całkowitych bez znaku 8-bitową.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-321">Returns the larger of two 8-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-322">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-322">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-323">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.</span><span class="sxs-lookup"><span data-stu-id="92e45-323">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Decimal, val2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Max(System::Decimal val1, System::Decimal val2);" />
      <MemberSignature Language="F#" Value="static member Max : decimal * decimal -&gt; decimal" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-324">Pierwsze dwie liczb dziesiętnych do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-324">The first of two decimal numbers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-325">Drugi dwóch liczb dziesiętnych do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-325">The second of two decimal numbers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-326">Zwraca większych dwóch liczb dziesiętnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-326">Returns the larger of two decimal numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-327">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-327">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-328">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.</span><span class="sxs-lookup"><span data-stu-id="92e45-328">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Double, val2 As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Max(double val1, double val2);" />
      <MemberSignature Language="F#" Value="static member Max : double * double -&gt; double" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-329">Pierwsze dwie liczb zmiennoprzecinkowych podwójnej precyzji do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-329">The first of two double-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-330">Drugi dwie liczby zmiennoprzecinkowe podwójnej precyzji do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-330">The second of two double-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-331">Zwraca większych dwie liczb zmiennoprzecinkowych podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-331">Returns the larger of two double-precision floating-point numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-332">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-332">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
          <span data-ttu-id="92e45-333">Jeśli <paramref name="val1" />, <paramref name="val2" />, lub obie <paramref name="val1" /> i <paramref name="val2" /> są równe <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> jest zwracany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-333">If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-334">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.</span><span class="sxs-lookup"><span data-stu-id="92e45-334">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static short Max (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Max(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Short, val2 As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Max(short val1, short val2);" />
      <MemberSignature Language="F#" Value="static member Max : int16 * int16 -&gt; int16" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-335">Pierwszy z dwóch 16-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-335">The first of two 16-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-336">Drugi dwóch 16-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-336">The second of two 16-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-337">Zwraca większego z dwóch 16-bitowych liczb całkowitych ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-337">Returns the larger of two 16-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-338">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-338">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-339">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.</span><span class="sxs-lookup"><span data-stu-id="92e45-339">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Integer, val2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Max(int val1, int val2);" />
      <MemberSignature Language="F#" Value="static member Max : int * int -&gt; int" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-340">Pierwszy z dwóch 32-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-340">The first of two 32-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-341">Drugi dwa 32-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-341">The second of two 32-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-342">Zwraca większego z dwóch 32-bitowych liczb całkowitych ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-342">Returns the larger of two 32-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-343">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-343">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-344">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.</span><span class="sxs-lookup"><span data-stu-id="92e45-344">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Long, val2 As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Max(long val1, long val2);" />
      <MemberSignature Language="F#" Value="static member Max : int64 * int64 -&gt; int64" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-345">Pierwszy z dwóch 64-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-345">The first of two 64-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-346">Drugi dwóch 64-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-346">The second of two 64-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-347">Zwraca większego z dwóch 64-bitowych liczb całkowitych ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-347">Returns the larger of two 64-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-348">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-348">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-349">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.</span><span class="sxs-lookup"><span data-stu-id="92e45-349">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static sbyte Max (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Max(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As SByte, val2 As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Max(System::SByte val1, System::SByte val2);" />
      <MemberSignature Language="F#" Value="static member Max : sbyte * sbyte -&gt; sbyte" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-350">Pierwszy z dwóch 8-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-350">The first of two 8-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-351">Drugi dwóch 8-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-351">The second of two 8-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-352">Zwraca większego z dwóch 8-bitowych liczb całkowitych ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-352">Returns the larger of two 8-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-353">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-353">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-354">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.</span><span class="sxs-lookup"><span data-stu-id="92e45-354">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Single, val2 As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Max(float val1, float val2);" />
      <MemberSignature Language="F#" Value="static member Max : single * single -&gt; single" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-355">Pierwsze dwie liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-355">The first of two single-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-356">Drugi dwie liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-356">The second of two single-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-357">Zwraca większych dwie liczb zmiennoprzecinkowych pojedynczej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-357">Returns the larger of two single-precision floating-point numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-358">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-358">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
          <span data-ttu-id="92e45-359">Jeśli <paramref name="val1" />, lub <paramref name="val2" />, lub obie <paramref name="val1" /> i <paramref name="val2" /> są równe <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> jest zwracany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-359">If <paramref name="val1" />, or <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-360">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.</span><span class="sxs-lookup"><span data-stu-id="92e45-360">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ushort Max (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Max(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UShort, val2 As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Max(System::UInt16 val1, System::UInt16 val2);" />
      <MemberSignature Language="F#" Value="static member Max : uint16 * uint16 -&gt; uint16" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-361">Pierwszy z dwóch 16-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-361">The first of two 16-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-362">Drugi dwóch 16-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-362">The second of two 16-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-363">Zwraca większy dwie liczb całkowitych bez znaku 16-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-363">Returns the larger of two 16-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-364">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-364">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-365">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.</span><span class="sxs-lookup"><span data-stu-id="92e45-365">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static uint Max (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Max(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UInteger, val2 As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Max(System::UInt32 val1, System::UInt32 val2);" />
      <MemberSignature Language="F#" Value="static member Max : uint32 * uint32 -&gt; uint32" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-366">Pierwszy z dwóch 32-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-366">The first of two 32-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-367">Drugi dwa 32-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-367">The second of two 32-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-368">Zwraca większy dwie liczb całkowitych bez znaku 32-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-368">Returns the larger of two 32-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-369">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-369">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-370">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.</span><span class="sxs-lookup"><span data-stu-id="92e45-370">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ulong Max (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Max(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As ULong, val2 As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Max(System::UInt64 val1, System::UInt64 val2);" />
      <MemberSignature Language="F#" Value="static member Max : uint64 * uint64 -&gt; uint64" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-371">Pierwszy z dwóch 64-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-371">The first of two 64-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-372">Drugi dwóch 64-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-372">The second of two 64-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-373">Zwraca większy dwie liczb całkowitych bez znaku 64-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-373">Returns the larger of two 64-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-374">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-374">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-375">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.</span><span class="sxs-lookup"><span data-stu-id="92e45-375">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="92e45-376">Zwraca mniejszy z dwóch liczb.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-376">Returns the smaller of two numbers.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static byte Min (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Min(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Byte, val2 As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Min(System::Byte val1, System::Byte val2);" />
      <MemberSignature Language="F#" Value="static member Min : byte * byte -&gt; byte" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-377">Pierwszy z dwóch 8-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-377">The first of two 8-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-378">Drugi dwóch 8-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-378">The second of two 8-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-379">Zwraca mniejszy z dwóch liczb całkowitych bez znaku 8-bitową.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-379">Returns the smaller of two 8-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-380">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-380">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-381">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="92e45-381">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Decimal, val2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Min(System::Decimal val1, System::Decimal val2);" />
      <MemberSignature Language="F#" Value="static member Min : decimal * decimal -&gt; decimal" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-382">Pierwsze dwie liczb dziesiętnych do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-382">The first of two decimal numbers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-383">Drugi dwóch liczb dziesiętnych do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-383">The second of two decimal numbers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-384">Zwraca mniejszy z dwóch liczb dziesiętnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-384">Returns the smaller of two decimal numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-385">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-385">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-386">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="92e45-386">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Double, val2 As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Min(double val1, double val2);" />
      <MemberSignature Language="F#" Value="static member Min : double * double -&gt; double" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-387">Pierwsze dwie liczb zmiennoprzecinkowych podwójnej precyzji do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-387">The first of two double-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-388">Drugi dwie liczby zmiennoprzecinkowe podwójnej precyzji do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-388">The second of two double-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-389">Zwraca mniejszy z dwóch liczby zmiennoprzecinkowe podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-389">Returns the smaller of two double-precision floating-point numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-390">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-390">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
          <span data-ttu-id="92e45-391">Jeśli <paramref name="val1" />, <paramref name="val2" />, lub obie <paramref name="val1" /> i <paramref name="val2" /> są równe <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> jest zwracany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-391">If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-392">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="92e45-392">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static short Min (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Min(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Short, val2 As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Min(short val1, short val2);" />
      <MemberSignature Language="F#" Value="static member Min : int16 * int16 -&gt; int16" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-393">Pierwszy z dwóch 16-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-393">The first of two 16-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-394">Drugi dwóch 16-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-394">The second of two 16-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-395">Zwraca mniejszy z dwóch 16-bitowych liczb całkowitych ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-395">Returns the smaller of two 16-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-396">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-396">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-397">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="92e45-397">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Integer, val2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Min(int val1, int val2);" />
      <MemberSignature Language="F#" Value="static member Min : int * int -&gt; int" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-398">Pierwszy z dwóch 32-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-398">The first of two 32-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-399">Drugi dwa 32-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-399">The second of two 32-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-400">Zwraca mniejszy z dwóch 32-bitowych liczb całkowitych ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-400">Returns the smaller of two 32-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-401">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-401">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-402">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="92e45-402">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Long, val2 As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Min(long val1, long val2);" />
      <MemberSignature Language="F#" Value="static member Min : int64 * int64 -&gt; int64" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-403">Pierwszy z dwóch 64-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-403">The first of two 64-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-404">Drugi dwóch 64-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-404">The second of two 64-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-405">Zwraca mniejszy z dwóch 64-bitowych liczb całkowitych ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-405">Returns the smaller of two 64-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-406">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-406">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-407">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="92e45-407">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static sbyte Min (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Min(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As SByte, val2 As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Min(System::SByte val1, System::SByte val2);" />
      <MemberSignature Language="F#" Value="static member Min : sbyte * sbyte -&gt; sbyte" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-408">Pierwszy z dwóch 8-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-408">The first of two 8-bit signed integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-409">Drugi dwóch 8-bitowych liczb całkowitych ze znakiem do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-409">The second of two 8-bit signed integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-410">Zwraca mniejszy z dwóch 8-bitowych liczb całkowitych ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-410">Returns the smaller of two 8-bit signed integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-411">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-411">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-412">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="92e45-412">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Single, val2 As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Min(float val1, float val2);" />
      <MemberSignature Language="F#" Value="static member Min : single * single -&gt; single" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-413">Pierwsze dwie liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-413">The first of two single-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-414">Drugi dwie liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-414">The second of two single-precision floating-point numbers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-415">Zwraca mniejszy z dwóch liczb zmiennoprzecinkowych pojedynczej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-415">Returns the smaller of two single-precision floating-point numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-416">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-416">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
          <span data-ttu-id="92e45-417">Jeśli <paramref name="val1" />, <paramref name="val2" />, lub obie <paramref name="val1" /> i <paramref name="val2" /> są równe <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> jest zwracany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-417">If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-418">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="92e45-418">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ushort Min (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Min(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UShort, val2 As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Min(System::UInt16 val1, System::UInt16 val2);" />
      <MemberSignature Language="F#" Value="static member Min : uint16 * uint16 -&gt; uint16" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-419">Pierwszy z dwóch 16-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-419">The first of two 16-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-420">Drugi dwóch 16-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-420">The second of two 16-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-421">Zwraca mniejszy z dwóch liczb całkowitych bez znaku 16-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-421">Returns the smaller of two 16-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-422">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-422">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-423">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="92e45-423">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static uint Min (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Min(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UInteger, val2 As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Min(System::UInt32 val1, System::UInt32 val2);" />
      <MemberSignature Language="F#" Value="static member Min : uint32 * uint32 -&gt; uint32" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-424">Pierwszy z dwóch 32-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-424">The first of two 32-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-425">Drugi dwa 32-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-425">The second of two 32-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-426">Zwraca mniejszy z dwóch liczb całkowitych bez znaku 32-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-426">Returns the smaller of two 32-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-427">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-427">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-428">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="92e45-428">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ulong Min (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Min(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As ULong, val2 As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Min(System::UInt64 val1, System::UInt64 val2);" />
      <MemberSignature Language="F#" Value="static member Min : uint64 * uint64 -&gt; uint64" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1">
          <span data-ttu-id="92e45-429">Pierwszy z dwóch 64-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-429">The first of two 64-bit unsigned integers to compare.</span>
          </span>
        </param>
        <param name="val2">
          <span data-ttu-id="92e45-430">Drugi dwóch 64-bitowych liczb całkowitych bez znaku do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-430">The second of two 64-bit unsigned integers to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-431">Zwraca mniejszy z dwóch liczb całkowitych bez znaku 64-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-431">Returns the smaller of two 64-bit unsigned integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-432">Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-432">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-433">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.</span><span class="sxs-lookup"><span data-stu-id="92e45-433">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PI">
      <MemberSignature Language="C#" Value="public const double PI = 3.14159265358979;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PI = (3.14159265358979)" />
      <MemberSignature Language="DocId" Value="F:System.Math.PI" />
      <MemberSignature Language="VB.NET" Value="Public Const PI As Double  = 3.14159265358979" />
      <MemberSignature Language="C++ CLI" Value="public: double PI = 3.14159265358979;" />
      <MemberSignature Language="F#" Value="val mutable PI : double" Usage="System.Math.PI" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>3.14159265358979</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="92e45-434">Reprezentuje stosunek obwodu koło jego średnicy, określony przez wartość stałej, π.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-434">Represents the ratio of the circumference of a circle to its diameter, specified by the constant, π.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-435">Wartość tego pola jest 3.14159265358979323846.</span><span class="sxs-lookup"><span data-stu-id="92e45-435">The value of this field is 3.14159265358979323846.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-436">W poniższym przykładzie użyto <xref:System.Math.PI> ułatwiających obliczenia wewnętrzny kąty danego Trapez.</span><span class="sxs-lookup"><span data-stu-id="92e45-436">The following example uses <xref:System.Math.PI> to assist in the computation of the inner angles of a given trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static double Pow (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Pow(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Pow(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Pow(double x, double y);" />
      <MemberSignature Language="F#" Value="static member Pow : double * double -&gt; double" Usage="System.Math.Pow (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">
          <span data-ttu-id="92e45-437">Liczba zmiennoprzecinkowa podwójnej precyzji do podniesione do potęgi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-437">A double-precision floating-point number to be raised to a power.</span>
          </span>
        </param>
        <param name="y">
          <span data-ttu-id="92e45-438">Liczba zmiennoprzecinkowe podwójnej precyzji, która określa potęgi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-438">A double-precision floating-point number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-439">Zwraca określoną liczbę podniesioną do wskazanej potęgi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-439">Returns a specified number raised to the specified power.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-440">Liczba <paramref name="x" /> podniesionej do potęgi <paramref name="y" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-440">The number <paramref name="x" /> raised to the power <paramref name="y" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-441">W poniższej tabeli przedstawiono wartość zwracana, gdy określono dla różnych wartości lub wartości `x` i `y` parametrów.</span><span class="sxs-lookup"><span data-stu-id="92e45-441">The following table indicates the return value when various values or ranges of values are specified for the `x` and `y` parameters.</span></span> <span data-ttu-id="92e45-442">Aby uzyskać więcej informacji, zobacz <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, i <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="92e45-442">For more information, see <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="92e45-443">Parametry</span><span class="sxs-lookup"><span data-stu-id="92e45-443">Parameters</span></span>|<span data-ttu-id="92e45-444">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="92e45-444">Return value</span></span>|  
|----------------|------------------|  
|<span data-ttu-id="92e45-445">`x` lub `y`  =  `NaN`.</span><span class="sxs-lookup"><span data-stu-id="92e45-445">`x` or `y` = `NaN`.</span></span>|`NaN`|  
|<span data-ttu-id="92e45-446">`x` = Wszystkie wartości z wyjątkiem `NaN`; `y` = 0.</span><span class="sxs-lookup"><span data-stu-id="92e45-446">`x` = Any value except `NaN`; `y` = 0.</span></span>|<span data-ttu-id="92e45-447">1</span><span class="sxs-lookup"><span data-stu-id="92e45-447">1</span></span>|  
|<span data-ttu-id="92e45-448">`x` = `NegativeInfinity`; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="92e45-448">`x` = `NegativeInfinity`; `y` < 0.</span></span>|<span data-ttu-id="92e45-449">0</span><span class="sxs-lookup"><span data-stu-id="92e45-449">0</span></span>|  
|<span data-ttu-id="92e45-450">`x` = `NegativeInfinity`; `y` jest nieparzysta dodatnią liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="92e45-450">`x` = `NegativeInfinity`; `y` is a positive odd integer.</span></span>|`NegativeInfinity`|  
|<span data-ttu-id="92e45-451">`x` = `NegativeInfinity`; `y` jest dodatnia, ale nie nieparzystą liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="92e45-451">`x` = `NegativeInfinity`; `y` is positive but not an odd integer.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="92e45-452">`x` < 0, ale nie `NegativeInfinity`; `y` nie jest liczbą całkowitą `NegativeInfinity`, lub `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="92e45-452">`x` < 0 but not `NegativeInfinity`; `y` is not an integer, `NegativeInfinity`, or `PositiveInfinity`.</span></span>|`NaN`|  
|<span data-ttu-id="92e45-453">`x` = -1; `y`  =  `NegativeInfinity` lub `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="92e45-453">`x` = -1; `y` = `NegativeInfinity` or `PositiveInfinity`.</span></span>|`NaN`|  
|<span data-ttu-id="92e45-454">-1 < `x` < 1; `y` = `NegativeInfinity`.</span><span class="sxs-lookup"><span data-stu-id="92e45-454">-1 < `x` < 1; `y` = `NegativeInfinity`.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="92e45-455">-1 < `x` < 1; `y` = `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="92e45-455">-1 < `x` < 1; `y` = `PositiveInfinity`.</span></span>|<span data-ttu-id="92e45-456">0</span><span class="sxs-lookup"><span data-stu-id="92e45-456">0</span></span>|  
|<span data-ttu-id="92e45-457">`x` < wartość -1 lub `x` > 1; `y` = `NegativeInfinity`.</span><span class="sxs-lookup"><span data-stu-id="92e45-457">`x` < -1 or `x` > 1; `y` = `NegativeInfinity`.</span></span>|<span data-ttu-id="92e45-458">0</span><span class="sxs-lookup"><span data-stu-id="92e45-458">0</span></span>|  
|<span data-ttu-id="92e45-459">`x` < wartość -1 lub `x` > 1; `y` = `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="92e45-459">`x` < -1 or `x` > 1; `y` = `PositiveInfinity`.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="92e45-460">`x` = 0; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="92e45-460">`x` = 0; `y` < 0.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="92e45-461">`x` = 0; `y` > 0.</span><span class="sxs-lookup"><span data-stu-id="92e45-461">`x` = 0; `y` > 0.</span></span>|<span data-ttu-id="92e45-462">0</span><span class="sxs-lookup"><span data-stu-id="92e45-462">0</span></span>|  
|<span data-ttu-id="92e45-463">`x` = 1; `y` jest dowolną wartością, z wyjątkiem `NaN`.</span><span class="sxs-lookup"><span data-stu-id="92e45-463">`x` = 1; `y` is any value except `NaN`.</span></span>|<span data-ttu-id="92e45-464">1</span><span class="sxs-lookup"><span data-stu-id="92e45-464">1</span></span>|  
|<span data-ttu-id="92e45-465">`x` = `PositiveInfinity`; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="92e45-465">`x` = `PositiveInfinity`; `y` < 0.</span></span>|<span data-ttu-id="92e45-466">0</span><span class="sxs-lookup"><span data-stu-id="92e45-466">0</span></span>|  
|<span data-ttu-id="92e45-467">`x` = `PositiveInfinity`; `y` > 0.</span><span class="sxs-lookup"><span data-stu-id="92e45-467">`x` = `PositiveInfinity`; `y` > 0.</span></span>|`PositiveInfinity`|  
  
   
  
## Examples  
 <span data-ttu-id="92e45-468">W poniższym przykładzie użyto <xref:System.Math.Pow%2A> metody do obliczenia wartości będące wynikiem wywoływanie 2 do potęgi od 0 do 32.</span><span class="sxs-lookup"><span data-stu-id="92e45-468">The following example uses the <xref:System.Math.Pow%2A> method to calculate the value that results from raising 2 to a power ranging from 0 to 32.</span></span>  
  
 [!code-csharp[System.Math.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.pow/cs/pow1.cs#1)]
 [!code-vb[System.Math.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sqrt(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Round">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="92e45-469">Zaokrągla wartość do najbliższej liczby całkowitej lub do określonej liczby cyfr ułamkowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-469">Rounds a value to the nearest integer or to the specified number of fractional digits.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-470">W tej sekcji:</span><span class="sxs-lookup"><span data-stu-id="92e45-470">In this section:</span></span>  
  
 <span data-ttu-id="92e45-471">[Przeciążona metoda składni](#Syntax) </span><span class="sxs-lookup"><span data-stu-id="92e45-471">[Overloaded method syntax](#Syntax) </span></span>  
 <span data-ttu-id="92e45-472">[Parametry](#Params) </span><span class="sxs-lookup"><span data-stu-id="92e45-472">[Parameters](#Params) </span></span>  
 <span data-ttu-id="92e45-473">[Wartość zwracana](#Returns) </span><span class="sxs-lookup"><span data-stu-id="92e45-473">[Return value](#Returns) </span></span>  
 <span data-ttu-id="92e45-474">[Wyjątki](#Exceptions) </span><span class="sxs-lookup"><span data-stu-id="92e45-474">[Exceptions](#Exceptions) </span></span>  
 <span data-ttu-id="92e45-475">[Która metoda zostanie wywołana?](#Tasks) </span><span class="sxs-lookup"><span data-stu-id="92e45-475">[Which method do I call?](#Tasks) </span></span>  
 <span data-ttu-id="92e45-476">[Środkowy wartości i konwencje zaokrąglania](#Midpoint) </span><span class="sxs-lookup"><span data-stu-id="92e45-476">[Midpoint values and rounding conventions](#Midpoint) </span></span>  
 <span data-ttu-id="92e45-477">[Zaokrąglanie i dokładność](#Precision) </span><span class="sxs-lookup"><span data-stu-id="92e45-477">[Rounding and precision](#Precision) </span></span>  
 <span data-ttu-id="92e45-478">[Zaokrąglania i pojedynczej precyzji wartości zmiennoprzecinkowych](#Single) </span><span class="sxs-lookup"><span data-stu-id="92e45-478">[Rounding and single-precision floating-point values](#Single) </span></span>  
 <span data-ttu-id="92e45-479">Przykłady:</span><span class="sxs-lookup"><span data-stu-id="92e45-479">Examples:</span></span>   
 [<span data-ttu-id="92e45-480">Math.Round(Decimal)</span><span class="sxs-lookup"><span data-stu-id="92e45-480">Math.Round(Decimal)</span></span>](#Round1_Example)  
 [<span data-ttu-id="92e45-481">Math.Round(Double)</span><span class="sxs-lookup"><span data-stu-id="92e45-481">Math.Round(Double)</span></span>](#Round2_Example)  
 [<span data-ttu-id="92e45-482">Math.round — (dziesiętna, Int32)</span><span class="sxs-lookup"><span data-stu-id="92e45-482">Math.Round(Decimal, Int32)</span></span>](#Round3_Example)  
 [<span data-ttu-id="92e45-483">Math.round — (dziesiętna, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="92e45-483">Math.Round(Decimal, MidpointRounding)</span></span>](#Round4_Example)  
 [<span data-ttu-id="92e45-484">Math.round — (o podwójnej precyzji, Int32)</span><span class="sxs-lookup"><span data-stu-id="92e45-484">Math.Round(Double, Int32)</span></span>](#Round5_Example)  
 [<span data-ttu-id="92e45-485">Math.round — (o podwójnej precyzji, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="92e45-485">Math.Round(Double, MidpointRounding)</span></span>](#Round6_Example)  
 [<span data-ttu-id="92e45-486">Math.round — (Decimal, Int32, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="92e45-486">Math.Round(Decimal, Int32, MidpointRounding)</span></span>](#Round7_Example)  
 [<span data-ttu-id="92e45-487">Math.round — (MidpointRounding o podwójnej precyzji, Int32)</span><span class="sxs-lookup"><span data-stu-id="92e45-487">Math.Round(Double, Int32, MidpointRounding)</span></span>](#Round8_Example)  
[<span data-ttu-id="92e45-488">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="92e45-488">Version information</span></span>](#Round_Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-method-syntax"></a><span data-ttu-id="92e45-489">Przeciążona metoda składni</span><span class="sxs-lookup"><span data-stu-id="92e45-489">Overloaded method syntax</span></span>  
 <span data-ttu-id="92e45-490">Aby uzyskać dodatkowe wskazówki dotyczące wybierania przeciążenia, zobacz [która metoda zostanie wywołana?](#Tasks)</span><span class="sxs-lookup"><span data-stu-id="92e45-490">For additional guidance on choosing an overload, see [Which method do I call?](#Tasks)</span></span>  
  
 <span data-ttu-id="92e45-491">`Decimal Math.Round(Decimal` `d` `)`</span><span class="sxs-lookup"><span data-stu-id="92e45-491">`Decimal Math.Round(Decimal` `d` `)`</span></span>  
 <span data-ttu-id="92e45-492">Powoduje zaokrąglenie do najbliższej liczby całkowitej wartości dziesiętnej, a punkt środkowy Zaokrągla do najbliższej parzystej liczby ([przykład](#Round1_Example)).</span><span class="sxs-lookup"><span data-stu-id="92e45-492">Rounds a decimal value to the nearest integer, and rounds midpoint values to the nearest even number ([example](#Round1_Example)).</span></span>  
  
 <span data-ttu-id="92e45-493">`Double Math.Round(Double` `a` `)`</span><span class="sxs-lookup"><span data-stu-id="92e45-493">`Double Math.Round(Double` `a` `)`</span></span>  
 <span data-ttu-id="92e45-494">Zaokrągla wartość zmiennoprzecinkową podwójnej precyzji dla najbliższej liczby całkowitej i zaokrągla środkowego do najbliższej parzystej liczby ([przykład](#Round2_Example)).</span><span class="sxs-lookup"><span data-stu-id="92e45-494">Rounds a double-precision floating-point value to the nearest integer, and rounds midpoint values to the nearest even number ([example](#Round2_Example)).</span></span>  
  
 <span data-ttu-id="92e45-495">`Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `)`</span><span class="sxs-lookup"><span data-stu-id="92e45-495">`Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `)`</span></span>  
 <span data-ttu-id="92e45-496">Zaokrągla wartość dziesiętną do określonej liczby cyfr ułamkowych i zaokrągla środkowego do najbliższej parzystej liczby ([przykład](#Round3_Example)).</span><span class="sxs-lookup"><span data-stu-id="92e45-496">Rounds a decimal value to a specified number of fractional digits, and rounds midpoint values to the nearest even number ([example](#Round3_Example)).</span></span>  
  
 <span data-ttu-id="92e45-497">`Double Math.Round(Double` `value` `, Int32`  `digits` `)`</span><span class="sxs-lookup"><span data-stu-id="92e45-497">`Double Math.Round(Double` `value` `, Int32`  `digits` `)`</span></span>  
 <span data-ttu-id="92e45-498">Zaokrągla liczbę do określonej liczby cyfr ułamkowych wartości zmiennoprzecinkowej podwójnej precyzji i zaokrągla środkowego do najbliższej parzystej liczby ([przykład](#Round4_Example)).</span><span class="sxs-lookup"><span data-stu-id="92e45-498">Rounds a double-precision floating-point value to a specified number of fractional digits, and rounds midpoint values to the nearest even number ([example](#Round4_Example)).</span></span>  
  
 <span data-ttu-id="92e45-499">`Decimal Math.Round(Decimal` `d` `, MidpointRounding`  `mode` `)`</span><span class="sxs-lookup"><span data-stu-id="92e45-499">`Decimal Math.Round(Decimal` `d` `, MidpointRounding`  `mode` `)`</span></span>  
 <span data-ttu-id="92e45-500">Powoduje zaokrąglenie do najbliższej liczby całkowitej wartość dziesiętna i używa konwencji zaokrąglania określonej wartości punkt środkowy ([przykład](#Round5_Example)).</span><span class="sxs-lookup"><span data-stu-id="92e45-500">Rounds a decimal value to the nearest integer, and uses the specified rounding convention for midpoint values ([example](#Round5_Example)).</span></span>  
  
 <span data-ttu-id="92e45-501">`Double Math.Round(Double` `value` `, MidpointRounding`  `mode` `)`</span><span class="sxs-lookup"><span data-stu-id="92e45-501">`Double Math.Round(Double` `value` `, MidpointRounding`  `mode` `)`</span></span>  
 <span data-ttu-id="92e45-502">Zaokrągla wartość zmiennoprzecinkową podwójnej precyzji dla najbliższej liczby całkowitej i używa konwencji zaokrąglania określonej wartości punkt środkowy ([przykład](#Round6_Example)).</span><span class="sxs-lookup"><span data-stu-id="92e45-502">Rounds a double-precision floating-point value to the nearest integer, and uses the specified rounding convention for midpoint values ([example](#Round6_Example)).</span></span>  
  
 <span data-ttu-id="92e45-503">`Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `, MidpointRounding`  `mode` `)`</span><span class="sxs-lookup"><span data-stu-id="92e45-503">`Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `, MidpointRounding`  `mode` `)`</span></span>  
 <span data-ttu-id="92e45-504">Zaokrągla wartość dziesiętną do określonej liczby cyfr ułamkowych i używa konwencji zaokrąglania określonej wartości punkt środkowy ([przykład](#Round7_Example)).</span><span class="sxs-lookup"><span data-stu-id="92e45-504">Rounds a decimal value to a specified number of fractional digits, and uses the specified rounding convention for midpoint values ([example](#Round7_Example)).</span></span>  
  
 <span data-ttu-id="92e45-505">`Double Math.Round(Double` `value` `, Int32`  `digits` `, MidpointRounding`  `mode` `)`</span><span class="sxs-lookup"><span data-stu-id="92e45-505">`Double Math.Round(Double` `value` `, Int32`  `digits` `, MidpointRounding`  `mode` `)`</span></span>  
 <span data-ttu-id="92e45-506">Zaokrągla liczbę do określonej liczby cyfr ułamkowych wartości zmiennoprzecinkowej podwójnej precyzji i używa konwencji zaokrąglania określonej wartości punkt środkowy ([przykład](#Round8_Example)).</span><span class="sxs-lookup"><span data-stu-id="92e45-506">Rounds a double-precision floating-point value to a specified number of fractional digits, and uses the specified rounding convention for midpoint values ([example](#Round8_Example)).</span></span>  
  
<a name="Params"></a>   
## <a name="parameters"></a><span data-ttu-id="92e45-507">Parametry</span><span class="sxs-lookup"><span data-stu-id="92e45-507">Parameters</span></span>  
 <span data-ttu-id="92e45-508">Jest to pełna lista parametrów <xref:System.Math.Round%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="92e45-508">This is a complete list of parameters for the <xref:System.Math.Round%2A> method.</span></span> <span data-ttu-id="92e45-509">Dla parametrów używanych przez każde przeciążenie, zobacz powyżej temat dotyczący składni przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="92e45-509">For the parameters used by each overload, see the overload syntax above.</span></span>  
  
|<span data-ttu-id="92e45-510">Parametr</span><span class="sxs-lookup"><span data-stu-id="92e45-510">Parameter</span></span>|<span data-ttu-id="92e45-511">Typ</span><span class="sxs-lookup"><span data-stu-id="92e45-511">Type</span></span>|<span data-ttu-id="92e45-512">Opis</span><span class="sxs-lookup"><span data-stu-id="92e45-512">Description</span></span>|  
|---------------|----------|-----------------|  
|`d`|<xref:System.Decimal>|<span data-ttu-id="92e45-513">Liczbę do zaokrąglenia.</span><span class="sxs-lookup"><span data-stu-id="92e45-513">A number to be rounded.</span></span>|  
|`a`<br /><br /> <span data-ttu-id="92e45-514">—lub—</span><span class="sxs-lookup"><span data-stu-id="92e45-514">-or-</span></span><br /><br /> `value`|<xref:System.Double>|<span data-ttu-id="92e45-515">Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać zaokrąglona.</span><span class="sxs-lookup"><span data-stu-id="92e45-515">A double-precision floating-point number to be rounded.</span></span>|  
|`decimals`<br /><br /> <span data-ttu-id="92e45-516">—lub—</span><span class="sxs-lookup"><span data-stu-id="92e45-516">-or-</span></span><br /><br /> `digits`|<xref:System.Int32>|<span data-ttu-id="92e45-517">Liczba cyfr ułamkowych w wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="92e45-517">The number of fractional digits in the return value.</span></span> <span data-ttu-id="92e45-518">Aby uzyskać <xref:System.Decimal> wartości, go może należeć do zakresu od 0 do 28.</span><span class="sxs-lookup"><span data-stu-id="92e45-518">For <xref:System.Decimal> values, it can range from 0 to 28.</span></span> <span data-ttu-id="92e45-519">Aby uzyskać <xref:System.Double> wartości, go może należeć do zakresu od 0 do 15.</span><span class="sxs-lookup"><span data-stu-id="92e45-519">For <xref:System.Double> values, it can range from 0 to 15.</span></span> <span data-ttu-id="92e45-520">Należy pamiętać, że 15 jest maksymalna liczba cyfr z zaokrągleń obsługiwane przez <xref:System.Double> typu.</span><span class="sxs-lookup"><span data-stu-id="92e45-520">Note that 15 is the maximum number of integral and fractional digits supported by the <xref:System.Double> type.</span></span><br /><br /> <span data-ttu-id="92e45-521">Wartość domyślna: 0, co powoduje zaokrąglenie do liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="92e45-521">Default value: 0, which rounds to an integer</span></span>|  
|`mode`|<xref:System.MidpointRounding>|<span data-ttu-id="92e45-522">Flaga określająca Konwencji do użycia na potrzeby zaokrąglania środkowego wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-522">A flag that specifies the convention to use for rounding midpoint values.</span></span> <span data-ttu-id="92e45-523">Zobacz [wartości punkt środkowy i konwencje zaokrąglania](#Midpoint).</span><span class="sxs-lookup"><span data-stu-id="92e45-523">See [Midpoint values and rounding conventions](#Midpoint).</span></span><br /><br /> <span data-ttu-id="92e45-524">Wartość domyślna: <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="92e45-524">Default value: <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType></span></span>|  
  
<a name="Returns"></a>   
## <a name="return-value"></a><span data-ttu-id="92e45-525">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="92e45-525">Return value</span></span>  
 <span data-ttu-id="92e45-526">Typ: <xref:System.Decimal> lub <xref:System.Double>, w zależności od typu wartości, które ma zostać zaokrąglona.</span><span class="sxs-lookup"><span data-stu-id="92e45-526">Type: <xref:System.Decimal> or <xref:System.Double>, depending on the type of the value to be rounded.</span></span>   
<span data-ttu-id="92e45-527">Wartość numeryczna tego samego typu co `d`, `a`, lub `value`, ale zaokrąglone do liczby całkowitej lub do określonej liczby miejsc po przecinku.</span><span class="sxs-lookup"><span data-stu-id="92e45-527">A numeric value of the same type as `d`, `a`, or `value`, but rounded either to an integer or to the specified number of decimal digits.</span></span> <span data-ttu-id="92e45-528">Zobacz [wartości punkt środkowy i konwencje zaokrąglania](#Midpoint) informacji o zaokrąglanie liczb z wartościami środkową.</span><span class="sxs-lookup"><span data-stu-id="92e45-528">See [Midpoint values and rounding conventions](#Midpoint) for information about rounding numbers with midpoint values.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="92e45-529">Gdy zaokrąglanie wartości punkt środkowy, algorytm zaokrąglania wykonuje testu równości.</span><span class="sxs-lookup"><span data-stu-id="92e45-529">When rounding midpoint values, the rounding algorithm performs an equality test.</span></span> <span data-ttu-id="92e45-530">Z powodu problemów binarna reprezentacja i dokładność format liczb zmiennoprzecinkowych może być nieoczekiwane wartość zwrócona przez metodę.</span><span class="sxs-lookup"><span data-stu-id="92e45-530">Because of problems of binary representation and precision in the floating-point format, the value returned by the method can be unexpected.</span></span> <span data-ttu-id="92e45-531">Aby uzyskać więcej informacji, zobacz [zaokrąglanie i dokładność](#Precision).</span><span class="sxs-lookup"><span data-stu-id="92e45-531">For more information, see [Rounding and precision](#Precision).</span></span>  
  
 <span data-ttu-id="92e45-532">Jeśli przeciążenia z <xref:System.Double> parametru jest wywoływana z <xref:System.Double.NaN?displayProperty=nameWithType>, metoda zwraca <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="92e45-532">If an overload with a <xref:System.Double> parameter is called with <xref:System.Double.NaN?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="92e45-533">Jeśli zostanie wywołany z <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, metoda zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="92e45-533">If it is called with <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a><span data-ttu-id="92e45-534">Wyjątki</span><span class="sxs-lookup"><span data-stu-id="92e45-534">Exceptions</span></span>  
  
|<span data-ttu-id="92e45-535">Wyjątek</span><span class="sxs-lookup"><span data-stu-id="92e45-535">Exception</span></span>|<span data-ttu-id="92e45-536">Warunek</span><span class="sxs-lookup"><span data-stu-id="92e45-536">Condition</span></span>|<span data-ttu-id="92e45-537">Generowane przez</span><span class="sxs-lookup"><span data-stu-id="92e45-537">Thrown by</span></span>|  
|---------------|---------------|---------------|  
|<xref:System.OverflowException>|<span data-ttu-id="92e45-538">Wynik jest poza zakresem <xref:System.Decimal> typu.</span><span class="sxs-lookup"><span data-stu-id="92e45-538">The result is outside the range of the <xref:System.Decimal> type.</span></span>|<xref:System.Math.Round%28System.Decimal%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="92e45-539">`decimals` jest mniejsza niż 0 lub większą niż 28.</span><span class="sxs-lookup"><span data-stu-id="92e45-539">`decimals` is less than 0 or greater than 28.</span></span><br /><br /> <span data-ttu-id="92e45-540">—lub—</span><span class="sxs-lookup"><span data-stu-id="92e45-540">-or-</span></span><br /><br /> <span data-ttu-id="92e45-541">`digits` jest mniejsza niż 0 lub większą niż 15.</span><span class="sxs-lookup"><span data-stu-id="92e45-541">`digits` is less than 0 or greater than 15.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<xref:System.ArgumentException>|<span data-ttu-id="92e45-542">`mode` nie jest prawidłową wartością <xref:System.MidpointRounding>.</span><span class="sxs-lookup"><span data-stu-id="92e45-542">`mode` is not a valid value of <xref:System.MidpointRounding>.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a><span data-ttu-id="92e45-543">Jaką metodę wywołać?</span><span class="sxs-lookup"><span data-stu-id="92e45-543">Which method do I call?</span></span>  
  
|<span data-ttu-id="92e45-544">Do</span><span class="sxs-lookup"><span data-stu-id="92e45-544">To</span></span>|<span data-ttu-id="92e45-545">wywołania</span><span class="sxs-lookup"><span data-stu-id="92e45-545">Call</span></span>|  
|--------|----------|  
|<span data-ttu-id="92e45-546">Zaokrągla liczbę do wartości całkowitej przy użyciu zaokrąglenie do najbliższej Konwencji.</span><span class="sxs-lookup"><span data-stu-id="92e45-546">Round a number to an integer by using the rounding to nearest convention.</span></span>|<xref:System.Math.Round%28System.Decimal%29><br /><br /> <span data-ttu-id="92e45-547">—lub—</span><span class="sxs-lookup"><span data-stu-id="92e45-547">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%29>|  
|<span data-ttu-id="92e45-548">Zaokrąglij liczbę na liczbę całkowitą przy użyciu określonej zaokrąglania Konwencji.</span><span class="sxs-lookup"><span data-stu-id="92e45-548">Round a number to an integer by using a specified rounding convention.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <span data-ttu-id="92e45-549">—lub—</span><span class="sxs-lookup"><span data-stu-id="92e45-549">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|  
|<span data-ttu-id="92e45-550">Zaokrągla liczbę do określonej liczby cyfr ułamkowych przy użyciu zaokrąglenie do najbliższej Konwencji.</span><span class="sxs-lookup"><span data-stu-id="92e45-550">Round a number to a specified number of fractional digits by using the rounding to nearest convention.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <span data-ttu-id="92e45-551">—lub—</span><span class="sxs-lookup"><span data-stu-id="92e45-551">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|  
|<span data-ttu-id="92e45-552">Zaokrąglij liczbę do określonej liczby cyfr ułamkowych przy użyciu określonej zaokrąglania Konwencji.</span><span class="sxs-lookup"><span data-stu-id="92e45-552">Round a number to a specified number of fractional digits by using a specified rounding convention.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <span data-ttu-id="92e45-553">—lub—</span><span class="sxs-lookup"><span data-stu-id="92e45-553">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<span data-ttu-id="92e45-554">ROUND <xref:System.Single> wartości do określonej liczby cyfr ułamkowych przy użyciu określonego zaokrąglania Konwencji i minimalizując utratę dokładności.</span><span class="sxs-lookup"><span data-stu-id="92e45-554">Round a <xref:System.Single> value to a specified number of fractional digits by using a specified rounding convention and minimizing the loss of precision.</span></span>|<span data-ttu-id="92e45-555">Konwertuj <xref:System.Single> do <xref:System.Decimal> i Wywołaj <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>.</span><span class="sxs-lookup"><span data-stu-id="92e45-555">Convert the <xref:System.Single> to a <xref:System.Decimal> and call <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>.</span></span>|  
|<span data-ttu-id="92e45-556">Zaokrągla liczbę do określonej liczby cyfr ułamkowych przy jednoczesnym zmniejszeniu problemów dokładności zaokrąglania środkowego wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-556">Round a number to a specified number of fractional digits while minimizing problems of precision in rounding midpoint values.</span></span>|<span data-ttu-id="92e45-557">Wywołaj metodę zaokrąglania, która implementuje porównania "większe niż lub równa około".</span><span class="sxs-lookup"><span data-stu-id="92e45-557">Call a rounding method that implements a "greater than or approximately equal to" comparison.</span></span> <span data-ttu-id="92e45-558">Zobacz [zaokrąglanie i dokładność](#Precision).</span><span class="sxs-lookup"><span data-stu-id="92e45-558">See [Rounding and precision](#Precision).</span></span>|  
|<span data-ttu-id="92e45-559">Zaokrąglij wartość ułamkową, na liczbę całkowitą, która jest większa niż wartość ułamkową.</span><span class="sxs-lookup"><span data-stu-id="92e45-559">Round a fractional value to an integer that is greater than the fractional value.</span></span> <span data-ttu-id="92e45-560">Na przykład okrągłe 3.1 do 4.</span><span class="sxs-lookup"><span data-stu-id="92e45-560">For example, round 3.1 to 4.</span></span>|<xref:System.Math.Ceiling%2A>|  
|<span data-ttu-id="92e45-561">Zaokrąglij wartość ułamkową, na liczbę całkowitą jest mniejsza niż wartość ułamkową.</span><span class="sxs-lookup"><span data-stu-id="92e45-561">Round a fractional value to an integer that is less than the fractional value.</span></span> <span data-ttu-id="92e45-562">Na przykład okrągłe 3.9 do 3.</span><span class="sxs-lookup"><span data-stu-id="92e45-562">For example, round 3.9 to 3.</span></span>|<xref:System.Math.Floor%2A>|  
  
<a name="Midpoint"></a>   
## <a name="midpoint-values-and-rounding-conventions"></a><span data-ttu-id="92e45-563">Wartości punktu środkowego i konwencje zaokrąglania</span><span class="sxs-lookup"><span data-stu-id="92e45-563">Midpoint values and rounding conventions</span></span>  
 <span data-ttu-id="92e45-564">Zaokrąglanie polega na konwertowaniu wartość liczbową z dokładnością do określonej do najbliższej wartości z mniej dokładności.</span><span class="sxs-lookup"><span data-stu-id="92e45-564">Rounding involves converting a numeric value with a specified precision to the nearest value with less precision.</span></span> <span data-ttu-id="92e45-565">Na przykład można użyć <xref:System.Math.Round%28System.Double%29> metody zostać zaokrąglona wartość 3.4 do 3.0 i <xref:System.Math.Round%28System.Double%2CSystem.Int32%29> metody zostać zaokrąglona wartość 3,579 do 3.58.</span><span class="sxs-lookup"><span data-stu-id="92e45-565">For example, you can use the <xref:System.Math.Round%28System.Double%29> method to round a value of 3.4 to 3.0, and the <xref:System.Math.Round%28System.Double%2CSystem.Int32%29> method to round a value of 3.579 to 3.58.</span></span>  
  
 <span data-ttu-id="92e45-566">Wartość środkowego wartość po najmniej znaczący cyfr w wyniku jest dokładnie połowy między dwiema liczbami.</span><span class="sxs-lookup"><span data-stu-id="92e45-566">In a midpoint value, the value after the least significant digit in the result is precisely half way between two numbers.</span></span> <span data-ttu-id="92e45-567">Na przykład 3.47500 jest wartość punkt środkowy, jeśli ma zostać zaokrąglona dwoma miejscami dziesiętnymi, a 7.500 jest wartością środkową, jeśli jest zaokrąglana do liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="92e45-567">For example, 3.47500 is a midpoint value if it is to be rounded two decimal places, and 7.500 is a midpoint value if it is to be rounded to an integer.</span></span> <span data-ttu-id="92e45-568">W takich przypadkach najbliższej wartości nie można łatwo zidentyfikować bez konwencją zaokrąglania.</span><span class="sxs-lookup"><span data-stu-id="92e45-568">In these cases, the nearest value can't be easily identified without a rounding convention.</span></span>  
  
 <span data-ttu-id="92e45-569"><xref:System.Math.Round%2A> Metoda obsługuje dwa konwencje zaokrąglania obsługi środkowego wartości:</span><span class="sxs-lookup"><span data-stu-id="92e45-569">The <xref:System.Math.Round%2A> method supports two rounding conventions for handling midpoint values:</span></span>  
  
 <span data-ttu-id="92e45-570">**Zaokrąglanie w kierunku od zera.**</span><span class="sxs-lookup"><span data-stu-id="92e45-570">**Rounding away from zero**</span></span>  
 <span data-ttu-id="92e45-571">Środkowy wartości są zaokrąglane do następnej liczby w kierunku od zera.</span><span class="sxs-lookup"><span data-stu-id="92e45-571">Midpoint values are rounded to the next number away from zero.</span></span> <span data-ttu-id="92e45-572">Na przykład 3,75 powoduje zaokrąglenie do 3.8, 3.85 zaokrąglenie do 3.9,-3.75 powoduje zaokrąglenie do-3.8, i-3.85 powoduje zaokrąglenie do-3.9.</span><span class="sxs-lookup"><span data-stu-id="92e45-572">For example, 3.75 rounds to 3.8, 3.85 rounds to 3.9, -3.75 rounds to -3.8, and -3.85 rounds to -3.9.</span></span> <span data-ttu-id="92e45-573">Ten formularz zaokrąglania jest reprezentowana przez <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> element członkowski wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="92e45-573">This form of rounding is represented by the <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> enumeration member.</span></span>  
  
 <span data-ttu-id="92e45-574">Zaokrąglanie w kierunku od zera jest powszechnie znane formularza zaokrąglania.</span><span class="sxs-lookup"><span data-stu-id="92e45-574">Rounding away from zero is the most widely known form of rounding.</span></span>  
  
 <span data-ttu-id="92e45-575">**Zaokrąglenie do najbliższej lub zaokrąglenie kwot**</span><span class="sxs-lookup"><span data-stu-id="92e45-575">**Rounding to nearest, or banker's rounding**</span></span>  
 <span data-ttu-id="92e45-576">Środkowy wartości są zaokrąglane do najbliższej parzystej liczby.</span><span class="sxs-lookup"><span data-stu-id="92e45-576">Midpoint values are rounded to the nearest even number.</span></span> <span data-ttu-id="92e45-577">Na przykład zarówno 3,75 i 3.85 zaokrąglona do 3.8, a jednocześnie-3.75 i-3.85 zaokrąglona do-3.8.</span><span class="sxs-lookup"><span data-stu-id="92e45-577">For example, both 3.75 and 3.85 round to 3.8, and both -3.75 and -3.85 round to -3.8.</span></span> <span data-ttu-id="92e45-578">Ten formularz zaokrąglania jest reprezentowana przez <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> element członkowski wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="92e45-578">This form of rounding is represented by the <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> enumeration member.</span></span>  
  
 <span data-ttu-id="92e45-579">Zaokrąglenie do najbliższej to standardowy formularz zaokrąglania w operacjach finansowych i statystycznych.</span><span class="sxs-lookup"><span data-stu-id="92e45-579">Rounding to nearest is the standard form of rounding used in financial and statistical operations.</span></span> <span data-ttu-id="92e45-580">Odpowiada 754 Standard IEEE, sekcji 4.</span><span class="sxs-lookup"><span data-stu-id="92e45-580">It conforms to IEEE Standard 754, section 4.</span></span> <span data-ttu-id="92e45-581">W wielu operacjach zaokrąglania powoduje zmniejszenie zaokrąglania błąd jest spowodowany przez spójnie zaokrąglanie wartości punkt środkowy w jednym kierunku.</span><span class="sxs-lookup"><span data-stu-id="92e45-581">When used in multiple rounding operations, it reduces the rounding error that is caused by consistently rounding midpoint values in a single direction.</span></span> <span data-ttu-id="92e45-582">W niektórych przypadkach może być istotne ten błąd zaokrąglania.</span><span class="sxs-lookup"><span data-stu-id="92e45-582">In some cases, this rounding error can be significant.</span></span>  
  
 <span data-ttu-id="92e45-583">Poniższy przykład przedstawia odchylenia, które mogą być wynikiem spójnie zaokrąglanie wartości punkt środkowy w jednym kierunku.</span><span class="sxs-lookup"><span data-stu-id="92e45-583">The following example illustrates the bias that can result from consistently rounding midpoint values in a single direction.</span></span> <span data-ttu-id="92e45-584">Przykład oblicza średnią wartość true tablicy <xref:System.Decimal> wartości, a następnie oblicza średnią po wartości w tablicy są zaokrąglane przy użyciu dwóch Konwencji.</span><span class="sxs-lookup"><span data-stu-id="92e45-584">The example computes the true mean of an array of <xref:System.Decimal> values, and then computes the mean when the values in the array are rounded by using the two conventions.</span></span> <span data-ttu-id="92e45-585">W tym przykładzie średnią wartość true i oznaczają, że gdy zaokrąglenie do najbliższej są takie same.</span><span class="sxs-lookup"><span data-stu-id="92e45-585">In this example, the true mean and the mean that results when rounding to nearest are the same.</span></span> <span data-ttu-id="92e45-586">Jednak oznaczają, że gdy zaokrąglania w kierunku od zera różni się o.05 (lub 3,6%) z średnią wartość true.</span><span class="sxs-lookup"><span data-stu-id="92e45-586">However, the mean that results when rounding away from zero differs by .05 (or by 3.6%) from the true mean.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mean1.cs#2)]
 [!code-vb[System.Math.Round.Overload#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mean1.vb#2)]  
  
 <span data-ttu-id="92e45-587">Domyślnie <xref:System.Math.Round%2A> metoda używa zaokrąglenie do najbliższej Konwencji.</span><span class="sxs-lookup"><span data-stu-id="92e45-587">By default, the <xref:System.Math.Round%2A> method uses the rounding to nearest convention.</span></span> <span data-ttu-id="92e45-588">W poniższej tabeli wymieniono przeciążeń <xref:System.Math.Round%2A> — metoda i zaokrąglania Konwencji każda używa.</span><span class="sxs-lookup"><span data-stu-id="92e45-588">The following table lists the overloads of the <xref:System.Math.Round%2A> method and the rounding convention that each uses.</span></span>  
  
|<span data-ttu-id="92e45-589">Przeciążenia</span><span class="sxs-lookup"><span data-stu-id="92e45-589">Overload</span></span>|<span data-ttu-id="92e45-590">Zaokrąglanie Konwencji</span><span class="sxs-lookup"><span data-stu-id="92e45-590">Rounding convention</span></span>|  
|--------------|-------------------------|  
|<xref:System.Math.Round%28System.Decimal%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29>|<span data-ttu-id="92e45-591">Ustaleniami `mode` parametru.</span><span class="sxs-lookup"><span data-stu-id="92e45-591">Determined by `mode` parameter.</span></span>|  
|<xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|<span data-ttu-id="92e45-592">Ustaleniami `mode` parametru</span><span class="sxs-lookup"><span data-stu-id="92e45-592">Determined by `mode` parameter</span></span>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>|<span data-ttu-id="92e45-593">Ustaleniami `mode` parametru</span><span class="sxs-lookup"><span data-stu-id="92e45-593">Determined by `mode` parameter</span></span>|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|<span data-ttu-id="92e45-594">Ustaleniami `mode` parametru</span><span class="sxs-lookup"><span data-stu-id="92e45-594">Determined by `mode` parameter</span></span>|  
  
<a name="Precision"></a>   
## <a name="rounding-and-precision"></a><span data-ttu-id="92e45-595">Zaokrąglenia i dokładność</span><span class="sxs-lookup"><span data-stu-id="92e45-595">Rounding and precision</span></span>  
 <span data-ttu-id="92e45-596">W celu ustalenia, czy operacja zaokrąglania obejmuje wartością środkową <xref:System.Math.Round%2A> metody mnoży oryginalna wartość ma zostać zaokrąglona przez 10<sup>n</sup>, gdzie *n* jest odpowiednią liczbę ułamkowych cyfr w zwracanej wartości, a następnie określa, czy pozostałej części ułamkowych wartość jest większa niż lub równa.5.</span><span class="sxs-lookup"><span data-stu-id="92e45-596">In order to determine whether a rounding operation involves a midpoint value, the <xref:System.Math.Round%2A> method multiplies the original value to be rounded by 10<sup>n</sup>, where *n* is the desired number of fractional digits in the return value, and then determines whether the remaining fractional portion of the value is greater than or equal to .5.</span></span> <span data-ttu-id="92e45-597">Jest to niewielkie zmiany w teście równości i jak opisano w sekcji "Testowania dla równości" <xref:System.Double> temat referencyjny testy równości z wartości zmiennoprzecinkowych mogą powodować problemy ze względu na format zmiennoprzecinkowy problemy z plikiem binarnym Reprezentacja i dokładność.</span><span class="sxs-lookup"><span data-stu-id="92e45-597">This is a slight variation on a test for equality, and as discussed in the "Testing for Equality" section of the <xref:System.Double> reference topic, tests for equality with floating-point values are problematic because of the floating-point format's issues with binary representation and precision.</span></span> <span data-ttu-id="92e45-598">Oznacza to, że wszystkie ułamkową część liczby, która może nieco przekraczać.5 (ze względu na zmniejszenie precyzji) nie są zaokrąglane w górę.</span><span class="sxs-lookup"><span data-stu-id="92e45-598">This means that any fractional portion of a number that is slightly less than .5 (because of a loss of precision) will not be rounded upward.</span></span>  
  
 <span data-ttu-id="92e45-599">Poniższy przykład ilustruje ten problem.</span><span class="sxs-lookup"><span data-stu-id="92e45-599">The following example illustrates the problem.</span></span> <span data-ttu-id="92e45-600">Wielokrotnie dodaje.1 do 11.0 i zaokrągla wynik do najbliższej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="92e45-600">It repeatedly adds .1 to 11.0 and rounds the result to the nearest integer.</span></span> <span data-ttu-id="92e45-601">Niezależnie od konwencji zaokrąglania 11.5 powinien zaokrąglona do 12.</span><span class="sxs-lookup"><span data-stu-id="92e45-601">Regardless of the rounding convention, 11.5 should round to 12.</span></span> <span data-ttu-id="92e45-602">Jednak jako dane wyjściowe w przykładzie pokazano, nie.</span><span class="sxs-lookup"><span data-stu-id="92e45-602">However, as the output from the example shows, it does not.</span></span> <span data-ttu-id="92e45-603">W przykładzie użyto "R" [ciągu standardowego formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) do wyświetlenia zmiennoprzecinkowy pełnej dokładności wartości i pokazuje, że wartość ma zostać zaokrąglona utracił dokładności podczas powtarzane dodatków i jej wartość jest rzeczywiście 11.499999999999998.</span><span class="sxs-lookup"><span data-stu-id="92e45-603">The example uses the "R" [standard numeric format string](~/docs/standard/base-types/standard-numeric-format-strings.md) to display the floating point value's full precision, and shows that the value to be rounded has lost precision during repeated additions, and its value is actually 11.499999999999998.</span></span> <span data-ttu-id="92e45-604">Ponieważ.499999999999998 jest mniejsza niż.5, wartość nie jest zaokrąglana do następną największą liczbę całkowitą.</span><span class="sxs-lookup"><span data-stu-id="92e45-604">Because .499999999999998 is less than .5, the value is not rounded to the next highest integer.</span></span> <span data-ttu-id="92e45-605">Jako przykład przedstawiono również, ten problem nie występuje, jeśli firma Microsoft po prostu Przypisz wartości stałej 11.5 do <xref:System.Double> zmiennej.</span><span class="sxs-lookup"><span data-stu-id="92e45-605">As the example also shows, this problem does not occur if we simply assign the constant value 11.5 to a <xref:System.Double> variable.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision1.cs#7)]
 [!code-vb[System.Math.Round.Overload#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision1.vb#7)]  
  
 <span data-ttu-id="92e45-606">Problemy dokładności zaokrąglania środkowego wartości są najbardziej prawdopodobne w następujących warunkach:</span><span class="sxs-lookup"><span data-stu-id="92e45-606">Problems of precision in rounding midpoint values are most likely to arise in the following conditions:</span></span>  
  
-   <span data-ttu-id="92e45-607">Jeśli wartość ułamkową, nie można wyrazić dokładnie w formacie binarnym typie zmiennoprzecinkowym.</span><span class="sxs-lookup"><span data-stu-id="92e45-607">When a fractional value cannot be expressed precisely in the floating-point type's binary format.</span></span>  
  
-   <span data-ttu-id="92e45-608">Gdy ma zostać zaokrąglona wartość jest obliczana na podstawie jednego lub więcej operacji zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="92e45-608">When the value to be rounded is calculated from one or more floating-point operations.</span></span>  
  
-   <span data-ttu-id="92e45-609">Gdy ustawiona wartość ma zostać zaokrąglona to <xref:System.Single> zamiast <xref:System.Double> lub <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="92e45-609">When the value to be rounded is a <xref:System.Single> rather than a <xref:System.Double> or <xref:System.Decimal>.</span></span> <span data-ttu-id="92e45-610">Aby uzyskać więcej informacji, zobacz następną sekcję, [zaokrąglanie i wartości zmiennoprzecinkowych pojedynczej precyzji](#Single).</span><span class="sxs-lookup"><span data-stu-id="92e45-610">For more information, see the next section, [Rounding and single-precision floating-point values](#Single).</span></span>  
  
 <span data-ttu-id="92e45-611">W przypadku braku dokładności zaokrąglając operacji problem należy wykonać następujące:</span><span class="sxs-lookup"><span data-stu-id="92e45-611">In cases where the lack of precision in rounding operations is problematic, you can do the following:</span></span>  
  
-   <span data-ttu-id="92e45-612">Jeśli zaokrąglania operacji wywołania przeciążenia, które zaokrągla <xref:System.Double> wartości, można zmienić <xref:System.Double> do <xref:System.Decimal> wartości i wywoływać przeciążenia zaokrągla <xref:System.Decimal> jest wartość.</span><span class="sxs-lookup"><span data-stu-id="92e45-612">If the rounding operation calls an overload that rounds a <xref:System.Double> value, you can change the <xref:System.Double> to a <xref:System.Decimal> value and call an overload that rounds a <xref:System.Decimal> value instead.</span></span> <span data-ttu-id="92e45-613">Mimo że <xref:System.Decimal> — typ danych ma również problemy z reprezentacji i zmniejszenie precyzji, te problemy występują znacznie mniej.</span><span class="sxs-lookup"><span data-stu-id="92e45-613">Although the <xref:System.Decimal> data type also has problems of representation and loss of precision, these issues are far less common.</span></span>  
  
-   <span data-ttu-id="92e45-614">Zdefiniuj niestandardowe algorytm zaokrąglania, który przeprowadza test "prawie równe", aby określić, czy wartość ma zostać zaokrąglona prawidłowo jest blisko wartości punkt środkowy.</span><span class="sxs-lookup"><span data-stu-id="92e45-614">Define a custom rounding algorithm that performs a "nearly equal" test to determine whether the value to be rounded is acceptably close to a midpoint value.</span></span> <span data-ttu-id="92e45-615">W poniższym przykładzie zdefiniowano `RoundApproximate` metodę, która sprawdza, czy wartość ułamkową jest wystarczająco blisko wartość środkowego podlegać zaokrąglania punkt środkowy.</span><span class="sxs-lookup"><span data-stu-id="92e45-615">The following example defines a `RoundApproximate` method that examines whether a fractional value is sufficiently near to a midpoint value to be subject to midpoint rounding.</span></span> <span data-ttu-id="92e45-616">Jak dane wyjściowe w przykładzie pokazano, rozwiązuje problem zaokrąglania w poprzednim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="92e45-616">As the output from the example shows, it corrects the rounding problem shown in the previous example.</span></span>  
  
     [!code-csharp[System.Math.Round.Overload#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision2.cs#8)]
     [!code-vb[System.Math.Round.Overload#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision2.vb#8)]  
  
<a name="Single"></a>   
## <a name="rounding-and-single-precision-floating-point-values"></a><span data-ttu-id="92e45-617">Zaokrąglenia i pojedyncza precyzja wartości zmiennoprzecinkowych</span><span class="sxs-lookup"><span data-stu-id="92e45-617">Rounding and single-precision floating-point values</span></span>  
 <span data-ttu-id="92e45-618"><xref:System.Math.Round%2A> Metoda zawiera przeciążenia, które akceptują argumentów typu <xref:System.Decimal> i <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="92e45-618">The <xref:System.Math.Round%2A> method includes overloads that accept arguments of type <xref:System.Decimal> and <xref:System.Double>.</span></span> <span data-ttu-id="92e45-619">Metodami nie zaokrąglanie wartości typu <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="92e45-619">There are no methods that round values of type <xref:System.Single>.</span></span> <span data-ttu-id="92e45-620">W przypadku przekazania <xref:System.Single> wartość do jednego z przeciążeń <xref:System.Math.Round%2A> metody jest rzutowanie (C#) lub przekonwertować (w języku Visual Basic) <xref:System.Double>i odpowiadający mu <xref:System.Math.Round%2A> przeciążenia z <xref:System.Double> nosi nazwę parametru.</span><span class="sxs-lookup"><span data-stu-id="92e45-620">If you pass a <xref:System.Single> value to one of the overloads of the <xref:System.Math.Round%2A> method, it is cast (in C#) or converted (in Visual Basic) to a <xref:System.Double>, and the corresponding <xref:System.Math.Round%2A> overload with a <xref:System.Double> parameter is called.</span></span> <span data-ttu-id="92e45-621">Choć to konwersję rozszerzającą często spowodowałoby utratę dokładności, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="92e45-621">Although this is a widening conversion, it often involves a loss of precision, as the following example illustrates.</span></span> <span data-ttu-id="92e45-622">Gdy <xref:System.Single> wartość 16.325 jest przekazywana do <xref:System.Math.Round%2A> — metoda i zaokrąglona do dwóch miejsc po przecinku przy użyciu zaokrąglenie do najbliższej Konwencji, wynikiem jest wynik 16.33 i nie oczekiwano 16.32.</span><span class="sxs-lookup"><span data-stu-id="92e45-622">When a <xref:System.Single> value of 16.325 is passed to the <xref:System.Math.Round%2A> method and rounded to two decimal places using the rounding to nearest convention, the result is 16.33 and not the expected result of 16.32.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/single1.cs#1)]
 [!code-vb[System.Math.Round.Overload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/single1.vb#1)]  
  
 <span data-ttu-id="92e45-623">Jest to nieoczekiwany wynik z powodu utraty dokładności konwersji <xref:System.Single> do wartości <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="92e45-623">This unexpected result is due to a loss of precision in the conversion of the <xref:System.Single> value to a <xref:System.Double>.</span></span> <span data-ttu-id="92e45-624">Ponieważ powstałe w ten sposób <xref:System.Double> wartość 16.325000762939453 nie jest wartością środkową i jest większy niż 16.325, jest zawsze zaokrąglona w górę.</span><span class="sxs-lookup"><span data-stu-id="92e45-624">Because the resulting <xref:System.Double> value of 16.325000762939453 is not a midpoint value and is greater than 16.325, it is always rounded upward.</span></span>  
  
 <span data-ttu-id="92e45-625">W wielu przypadkach, jak pokazano w przykładzie utratę dokładności można zminimalizowane lub usunięte przez rzutowania lub konwersji <xref:System.Single> do wartości <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="92e45-625">In many cases, as the example illustrates, the loss of precision can be minimized or eliminated by casting or converting the <xref:System.Single> value to a <xref:System.Decimal>.</span></span> <span data-ttu-id="92e45-626">Należy pamiętać, że, ponieważ jest to konwersji zawężającej, wymaga przy użyciu operatora rzutowania lub wywołanie metody konwersji.</span><span class="sxs-lookup"><span data-stu-id="92e45-626">Note that, because this is a narrowing conversion, it requires using a cast operator or calling a conversion method.</span></span>  
  
<a name="Round1_Example"></a>   
## <a name="mathrounddecimal-example"></a><span data-ttu-id="92e45-627">Przykład Math.Round(Decimal)</span><span class="sxs-lookup"><span data-stu-id="92e45-627">Math.Round(Decimal) example</span></span>  
 <span data-ttu-id="92e45-628">W poniższym przykładzie pokazano <xref:System.Math.Round%28System.Decimal%29> metody.</span><span class="sxs-lookup"><span data-stu-id="92e45-628">The following example demonstrates the <xref:System.Math.Round%28System.Decimal%29> method.</span></span> <span data-ttu-id="92e45-629">Należy pamiętać, że <xref:System.Decimal> wartość 4.5 powoduje zaokrąglenie do 4, a nie 5, ponieważ to przeciążenie używa domyślnej <xref:System.MidpointRounding.ToEven> Konwencji.</span><span class="sxs-lookup"><span data-stu-id="92e45-629">Note that the <xref:System.Decimal> value of 4.5 rounds to 4 rather than 5, because this overload uses the default <xref:System.MidpointRounding.ToEven> convention.</span></span>  
  
 [!code-csharp[System.Math.Round#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/rounddecimal1.cs#6)]
 [!code-vb[System.Math.Round#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/rounddecimal1.vb#6)]  
  
<a name="Round2_Example"></a>   
## <a name="mathrounddouble-example"></a><span data-ttu-id="92e45-630">Przykład Math.Round(Double)</span><span class="sxs-lookup"><span data-stu-id="92e45-630">Math.Round(Double) example</span></span>  
 <span data-ttu-id="92e45-631">W poniższym przykładzie pokazano zaokrąglenie do najbliższej wartości całkowitej.</span><span class="sxs-lookup"><span data-stu-id="92e45-631">The following example demonstrates rounding to the nearest integer value.</span></span>  
  
 [!code-cpp[Classic Math.Round Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Math.Round Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round Example/CS/source.cs#1)]
 [!code-vb[Classic Math.Round Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round Example/VB/source.vb#1)]  
  
<a name="Round3_Example"></a>   
## <a name="mathrounddecimal-int32-example"></a><span data-ttu-id="92e45-632">Przykład Math.Round (Decimal, Int32)</span><span class="sxs-lookup"><span data-stu-id="92e45-632">Math.Round(Decimal, Int32) example</span></span>  
 <span data-ttu-id="92e45-633">Poniższy przykład powoduje zaokrąglenie wartości dziesiętnych z dwóch cyfr ułamkowych do wartości, które mają pojedynczą cyfrą ułamkową.</span><span class="sxs-lookup"><span data-stu-id="92e45-633">The following example rounds decimal values with two fractional digits to values that have a single fractional digit.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/source.cs#3)]
 [!code-vb[System.Math.Round.Overload#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/source.vb#3)]  
  
<a name="Round4_Example"></a>   
## <a name="mathrounddouble-int32-example"></a><span data-ttu-id="92e45-634">Przykład Math.Round (podwójny, Int32)</span><span class="sxs-lookup"><span data-stu-id="92e45-634">Math.Round(Double, Int32) example</span></span>  
 <span data-ttu-id="92e45-635">Poniższy przykład zaokrągla dwa razy z dwóch cyfr ułamkowych na symulacyjnych mające pojedynczą cyfrą ułamkową.</span><span class="sxs-lookup"><span data-stu-id="92e45-635">The following example rounds double values with two fractional digits to doubles that have a single fractional digit.</span></span>  
  
 [!code-cpp[Classic Math.Round2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Math.Round2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CS/source.cs#1)]
 [!code-vb[Classic Math.Round2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round2 Example/VB/source.vb#1)]  
  
<a name="Round5_Example"></a>   
## <a name="mathrounddecimal-midpointrounding-example"></a><span data-ttu-id="92e45-636">Przykład Math.Round (Decimal, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="92e45-636">Math.Round(Decimal, MidpointRounding) example</span></span>  
 <span data-ttu-id="92e45-637">W poniższym przykładzie przedstawiono wartości zwracanych przez <xref:System.Math.Round%28System.Decimal%29> metody <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> metody z `mode` argument <xref:System.MidpointRounding.ToEven>i <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> metody z `mode` argument <xref:System.MidpointRounding.AwayFromZero>.</span><span class="sxs-lookup"><span data-stu-id="92e45-637">The following example displays values returned by the <xref:System.Math.Round%28System.Decimal%29> method, the <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.ToEven>, and the <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.AwayFromZero>.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint1.cs#5)]
 [!code-vb[System.Math.Round.Overload#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint1.vb#5)]  
  
<a name="Round6_Example"></a>   
## <a name="mathrounddouble-midpointrounding-example"></a><span data-ttu-id="92e45-638">Przykład Math.Round (Double, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="92e45-638">Math.Round(Double, MidpointRounding) example</span></span>  
 <span data-ttu-id="92e45-639">W poniższym przykładzie przedstawiono wartości zwracanych przez <xref:System.Math.Round%28System.Double%29> metody <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> metody z `mode` argument <xref:System.MidpointRounding.ToEven>i <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> metody z `mode` argument <xref:System.MidpointRounding.AwayFromZero>.</span><span class="sxs-lookup"><span data-stu-id="92e45-639">The following example displays values returned by the <xref:System.Math.Round%28System.Double%29> method, the <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.ToEven>, and the <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.AwayFromZero>.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint2.cs#6)]
 [!code-vb[System.Math.Round.Overload#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint2.vb#6)]  
  
<a name="Round7_Example"></a>   
## <a name="mathrounddecimal-int32-midpointrounding-example"></a><span data-ttu-id="92e45-640">Przykład Math.Round (Decimal, Int32, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="92e45-640">Math.Round(Decimal, Int32, MidpointRounding) example</span></span>  
 <span data-ttu-id="92e45-641">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Round%2A> metody z <xref:System.MidpointRounding> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="92e45-641">The following example demonstrates how to use the <xref:System.Math.Round%2A> method with the <xref:System.MidpointRounding> enumeration.</span></span>  
  
 [!code-cpp[math.midpointrounding#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.midpointrounding/cpp/mpr.cpp#1)]
 [!code-csharp[math.midpointrounding#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.midpointrounding/CS/mpr.cs#1)]
 [!code-vb[math.midpointrounding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.midpointrounding/VB/mpr.vb#1)]  
  
<a name="Round8_Example"></a>   
## <a name="mathrounddouble-int32-midpointrounding-example"></a><span data-ttu-id="92e45-642">Przykład Math.Round (Double, Int32, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="92e45-642">Math.Round(Double, Int32, MidpointRounding) example</span></span>  
 <span data-ttu-id="92e45-643">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29> metody z <xref:System.MidpointRounding> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="92e45-643">The following example demonstrates how to use the <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29> method with the <xref:System.MidpointRounding> enumeration.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mpr.cs#4)]
 [!code-vb[System.Math.Round.Overload#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mpr.vb#4)]  
  
<a name="Round_Versions"></a>   
## <a name="version-information"></a><span data-ttu-id="92e45-644">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="92e45-644">Version information</span></span>  
 <span data-ttu-id="92e45-645">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="92e45-645">.NET Framework</span></span>  
 <span data-ttu-id="92e45-646">Overloads bez <xref:System.MidpointRounding> parametru są obsługiwane w: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</span><span class="sxs-lookup"><span data-stu-id="92e45-646">Overloads without a <xref:System.MidpointRounding> parameter are supported in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</span></span>  
<span data-ttu-id="92e45-647">Overloads z <xref:System.MidpointRounding> parametru są obsługiwane w: 4.5, 4, 3.5, 3.0, 2.0</span><span class="sxs-lookup"><span data-stu-id="92e45-647">Overloads with a <xref:System.MidpointRounding> parameter are supported in: 4.5, 4, 3.5, 3.0, 2.0</span></span>  
  
 <span data-ttu-id="92e45-648">.NET Framework Client Profile</span><span class="sxs-lookup"><span data-stu-id="92e45-648">.NET Framework Client Profile</span></span>  
 <span data-ttu-id="92e45-649">Wszystkie przeciążenia są obsługiwane w wersjach: 4, 3.5 z dodatkiem SP1</span><span class="sxs-lookup"><span data-stu-id="92e45-649">All overloads are supported in: 4, 3.5 SP1</span></span>  
  
 <span data-ttu-id="92e45-650">Biblioteka klas przenośnych</span><span class="sxs-lookup"><span data-stu-id="92e45-650">Portable Class Library</span></span>  
 <span data-ttu-id="92e45-651">Obsługiwane są wszystkie przeciążenia</span><span class="sxs-lookup"><span data-stu-id="92e45-651">All overloads are supported</span></span>  
  
 <span data-ttu-id="92e45-652">Środowisko .NET dla aPLikacji do Sklepu Windows</span><span class="sxs-lookup"><span data-stu-id="92e45-652">.NET for Windows Store apps</span></span>  
 <span data-ttu-id="92e45-653">Wszystkie przeciążenia są obsługiwane w systemie Windows 8</span><span class="sxs-lookup"><span data-stu-id="92e45-653">All overloads are supported in: Windows 8</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
        <altmember cref="M:System.Math.Truncate(System.Decimal)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Round : decimal -&gt; decimal" Usage="System.Math.Round d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-654">Liczba dziesiętna ma zostać zaokrąglona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-654">A decimal number to be rounded.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-655">Zaokrągla wartość dziesiętną do najbliższej wartości całkowitej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-655">Rounds a decimal value to the nearest integral value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-656">Liczba całkowita najbliższej parametru <paramref name="d" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-656">The integer nearest parameter <paramref name="d" />.</span>
          </span>
          <span data-ttu-id="92e45-657">Jeśli część ułamkowa <paramref name="d" /> jest w połowie między i innych nietypowych dwie liczb całkowitych, z których jeden jest parzysta, zwracany jest parzystą liczbą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-657">If the fractional component of <paramref name="d" /> is halfway between two integers, one of which is even and the other odd, the even number is returned.</span>
          </span>
          <span data-ttu-id="92e45-658">Należy pamiętać, że ta metoda zwraca <see cref="T:System.Decimal" /> zamiast typ całkowity.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-658">Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="92e45-659">Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.</span><span class="sxs-lookup"><span data-stu-id="92e45-659">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="92e45-660">Wynik jest poza zakresem <see cref="T:System.Decimal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-660">The result is outside the range of a <see cref="T:System.Decimal" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double a);" />
      <MemberSignature Language="F#" Value="static member Round : double -&gt; double" Usage="System.Math.Round a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="92e45-661">Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać zaokrąglona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-661">A double-precision floating-point number to be rounded.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-662">Powoduje zaokrąglenie do najbliższej wartości całkowitych wartości zmiennoprzecinkowej podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-662">Rounds a double-precision floating-point value to the nearest integral value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-663">Liczba całkowita najbliższej <paramref name="a" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-663">The integer nearest <paramref name="a" />.</span>
          </span>
          <span data-ttu-id="92e45-664">Jeśli część ułamkowa <paramref name="a" /> jest w połowie między dwie liczb całkowitych, z których jeden jest parzysta i innych nietypowych, zwracana jest parzystą liczbą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-664">If the fractional component of <paramref name="a" /> is halfway between two integers, one of which is even and the other odd, then the even number is returned.</span>
          </span>
          <span data-ttu-id="92e45-665">Należy pamiętać, że ta metoda zwraca <see cref="T:System.Double" /> zamiast typ całkowity.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-665">Note that this method returns a <see cref="T:System.Double" /> instead of an integral type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="92e45-666">Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.</span><span class="sxs-lookup"><span data-stu-id="92e45-666">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="92e45-667">
            <para>Ze względu na zmniejszenie precyzji, która może wynikać z reprezentujący wartości dziesiętnej jako liczby zmiennoprzecinkowe lub wykonywanie operacji arytmetycznych na wartości zmiennoprzecinkowe w niektórych przypadkach <see cref="M:System.Math.Round(System.Double)" /> zostać zaokrąglona środkowego wartości nie może występować — metoda najbliższej parzystej liczby całkowitej. W poniższym przykładzie, ponieważ wartość zmiennoprzecinkowa.1 nie ma skończonego binarne reprezentacji, pierwsze wywołanie <see cref="M:System.Math.Round(System.Double)" /> metoda o wartości 11.5 zwraca 11 zamiast 12.  [! code-csharp[System.Math.Round#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round2.cs#1)] [! code-vb[System.Math.Round#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round2.vb#1)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-667">
              <para>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double)" /> method may not appear to round midpoint values to the nearest even integer. In the following example, because the floating-point value .1 has no finite binary representation, the first call to the <see cref="M:System.Math.Round(System.Double)" /> method with a value of 11.5 returns 11 instead of 12.  [!code-csharp[System.Math.Round#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round2.cs#1)] [!code-vb[System.Math.Round#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round2.vb#1)]</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals);" />
      <MemberSignature Language="F#" Value="static member Round : decimal * int -&gt; decimal" Usage="System.Math.Round (d, decimals)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-668">Liczba dziesiętna ma zostać zaokrąglona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-668">A decimal number to be rounded.</span>
          </span>
        </param>
        <param name="decimals">
          <span data-ttu-id="92e45-669">Liczba miejsc dziesiętnych w wartości zwracanej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-669">The number of decimal places in the return value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-670">Zaokrągla liczbę do określonej liczby cyfr ułamkowych wartości dziesiętnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-670">Rounds a decimal value to a specified number of fractional digits.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-671">Liczba najbliżej do <paramref name="d" /> zawierający liczba cyfr ułamkowych równa <paramref name="decimals" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-671">The number nearest to <paramref name="d" /> that contains a number of fractional digits equal to <paramref name="decimals" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="92e45-672">Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.</span><span class="sxs-lookup"><span data-stu-id="92e45-672">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="92e45-673">
            <paramref name="decimals" /> jest mniejsza niż 0 lub większą niż 28.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-673">
              <paramref name="decimals" /> is less than 0 or greater than 28.</span>
          </span>
        </exception>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="92e45-674">Wynik jest poza zakresem <see cref="T:System.Decimal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-674">The result is outside the range of a <see cref="T:System.Decimal" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : decimal * MidpointRounding -&gt; decimal" Usage="System.Math.Round (d, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-675">Liczba dziesiętna ma zostać zaokrąglona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-675">A decimal number to be rounded.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="92e45-676">Specyfikacja sposobu zaokrąglona <c>d</c> przypadku pośrodku dwie inne liczby.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-676">Specification for how to round <c>d</c> if it is midway between two other numbers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-677">Zaokrągla wartość dziesiętną do najbliższej liczby całkowitej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-677">Rounds a decimal value to the nearest integer.</span>
          </span>
          <span data-ttu-id="92e45-678">Parametr określa sposób zaokrąglania wartości, jeśli jest w połowie między dwiema liczbami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-678">A parameter specifies how to round the value if it is midway between two numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-679">Liczba całkowita najbliższej <paramref name="d" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-679">The integer nearest <paramref name="d" />.</span>
          </span>
          <span data-ttu-id="92e45-680">Jeśli <paramref name="d" /> następnie jest w połowie między dwóch liczb, z których jeden jest parzysta i innych nietypowych <paramref name="mode" /> określa dwóch zwrócony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-680">If <paramref name="d" /> is halfway between two numbers, one of which is even and the other odd, then <paramref name="mode" /> determines which of the two is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="92e45-681">Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.</span><span class="sxs-lookup"><span data-stu-id="92e45-681">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="92e45-682">
            <paramref name="mode" /> nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-682">
              <paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span>
          </span>
        </exception>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="92e45-683">Wynik jest poza zakresem <see cref="T:System.Decimal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-683">The result is outside the range of a <see cref="T:System.Decimal" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, digits As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, int digits);" />
      <MemberSignature Language="F#" Value="static member Round : double * int -&gt; double" Usage="System.Math.Round (value, digits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-684">Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać zaokrąglona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-684">A double-precision floating-point number to be rounded.</span>
          </span>
        </param>
        <param name="digits">
          <span data-ttu-id="92e45-685">Liczba cyfr ułamkowych w wartości zwracanej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-685">The number of fractional digits in the return value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-686">Zaokrągla liczbę do określonej liczby cyfr ułamkowych wartości zmiennoprzecinkowej podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-686">Rounds a double-precision floating-point value to a specified number of fractional digits.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-687">Liczba najbliżej do <paramref name="value" /> zawierający liczba cyfr ułamkowych równa <paramref name="digits" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-687">The number nearest to <paramref name="value" /> that contains a number of fractional digits equal to <paramref name="digits" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="92e45-688">Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.</span><span class="sxs-lookup"><span data-stu-id="92e45-688">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="92e45-689">
            <paramref name="digits" /> jest mniejsza niż 0 lub większą niż 15.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-689">
              <paramref name="digits" /> is less than 0 or greater than 15.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="92e45-690">
            <para>Ze względu na zmniejszenie precyzji, która może wynikać z reprezentujący wartości dziesiętnej jako liczby zmiennoprzecinkowe lub wykonywanie operacji arytmetycznych na wartości zmiennoprzecinkowe w niektórych przypadkach <see cref="M:System.Math.Round(System.Double,System.Int32)" /> zostać zaokrąglona środkowego wartości nie może występować — metoda najbliższej parzystej wartości w <paramref name="digits" /> dziesiętnego. Jest to zilustrowane w poniższym przykładzie, w którym 2.135 jest zaokrąglana do 2.13 zamiast 2.14. Dzieje się tak dlatego wewnętrznie mnoży metody <paramref name="value" /> przez 10<sup>cyfr</sup>, i operacja mnożenia w takim przypadku odczuwa utratę dokładności.  [! code-csharp[System.Math.Round#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round3.cs#2)] [! code-vb[System.Math.Round#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round3.vb#2)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-690">
              <para>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.Int32)" /> method may not appear to round midpoint values to the nearest even value in the <paramref name="digits" /> decimal position. This is illustrated in the following example, where 2.135 is rounded to 2.13 instead of 2.14. This occurs because internally the method multiplies <paramref name="value" /> by 10<sup>digits</sup>, and the multiplication operation in this case suffers from a loss of precision.  [!code-csharp[System.Math.Round#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round3.cs#2)] [!code-vb[System.Math.Round#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round3.vb#2)]</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, mode As MidpointRounding) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : double * MidpointRounding -&gt; double" Usage="System.Math.Round (value, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-691">Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać zaokrąglona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-691">A double-precision floating-point number to be rounded.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="92e45-692">Specyfikacja sposobu zaokrąglona <c>wartość</c> przypadku pośrodku dwie inne liczby.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-692">Specification for how to round <c>value</c> if it is midway between two other numbers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-693">Zaokrągla wartość zmiennoprzecinkową podwójnej precyzji dla najbliższej liczby całkowitej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-693">Rounds a double-precision floating-point value to the nearest integer.</span>
          </span>
          <span data-ttu-id="92e45-694">Parametr określa sposób zaokrąglania wartości, jeśli jest w połowie między dwiema liczbami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-694">A parameter specifies how to round the value if it is midway between two numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-695">Liczba całkowita najbliższej <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-695">The integer nearest <paramref name="value" />.</span>
          </span>
          <span data-ttu-id="92e45-696">Jeśli <paramref name="value" /> następnie jest w połowie między dwie liczb całkowitych, z których jeden jest parzysta i innych nietypowych <paramref name="mode" /> określa dwóch zwrócony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-696">If <paramref name="value" /> is halfway between two integers, one of which is even and the other odd, then <paramref name="mode" /> determines which of the two is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="92e45-697">Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.</span><span class="sxs-lookup"><span data-stu-id="92e45-697">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="92e45-698">
            <paramref name="mode" /> nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-698">
              <paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="92e45-699">
            <para>Ze względu na zmniejszenie precyzji, która może wynikać z reprezentujący wartości dziesiętnej jako liczby zmiennoprzecinkowe lub wykonywanie operacji arytmetycznych na wartości zmiennoprzecinkowe w niektórych przypadkach <see cref="M:System.Math.Round(System.Double,System.MidpointRounding)" /> zostać zaokrąglona środkowego wartości nie może występować — metoda najbliższej parzystej liczby całkowitej. W poniższym przykładzie, ponieważ wartość zmiennoprzecinkowa.1 nie ma skończonego binarne reprezentacji, pierwsze wywołanie <see cref="M:System.Math.Round(System.Double)" /> metoda o wartości 11.5 zwraca 11 zamiast 12.  [! code-csharp[System.Math.Round#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round5.cs#4)] [! code-vb[System.Math.Round#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round5.vb#4)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-699">
              <para>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.MidpointRounding)" /> method may not appear to round midpoint values to the nearest even integer. In the following example, because the floating-point value .1 has no finite binary representation, the first call to the <see cref="M:System.Math.Round(System.Double)" /> method with a value of 11.5 returns 11 instead of 12.  [!code-csharp[System.Math.Round#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round5.cs#4)] [!code-vb[System.Math.Round#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round5.vb#4)]</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : decimal * int * MidpointRounding -&gt; decimal" Usage="System.Math.Round (d, decimals, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-700">Liczba dziesiętna ma zostać zaokrąglona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-700">A decimal number to be rounded.</span>
          </span>
        </param>
        <param name="decimals">
          <span data-ttu-id="92e45-701">Liczba miejsc dziesiętnych w wartości zwracanej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-701">The number of decimal places in the return value.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="92e45-702">Specyfikacja sposobu zaokrąglona <c>d</c> przypadku pośrodku dwie inne liczby.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-702">Specification for how to round <c>d</c> if it is midway between two other numbers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-703">Zaokrągla liczbę do określonej liczby cyfr ułamkowych wartości dziesiętnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-703">Rounds a decimal value to a specified number of fractional digits.</span>
          </span>
          <span data-ttu-id="92e45-704">Parametr określa sposób zaokrąglania wartości, jeśli jest w połowie między dwiema liczbami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-704">A parameter specifies how to round the value if it is midway between two numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-705">Liczba najbliżej do <paramref name="d" /> zawierający liczba cyfr ułamkowych równa <paramref name="decimals" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-705">The number nearest to <paramref name="d" /> that contains a number of fractional digits equal to <paramref name="decimals" />.</span>
          </span>
          <span data-ttu-id="92e45-706">Jeśli <paramref name="d" /> ma mniejszą liczbę cyfr ułamkowych niż <paramref name="decimals" />, <paramref name="d" /> zwróceniu niezmieniona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-706">If <paramref name="d" /> has fewer fractional digits than <paramref name="decimals" />, <paramref name="d" /> is returned unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="92e45-707">Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.</span><span class="sxs-lookup"><span data-stu-id="92e45-707">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="92e45-708">
            <paramref name="decimals" /> jest mniejsza niż 0 lub większą niż 28.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-708">
              <paramref name="decimals" /> is less than 0 or greater than 28.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="92e45-709">
            <paramref name="mode" /> nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-709">
              <paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span>
          </span>
        </exception>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="92e45-710">Wynik jest poza zakresem <see cref="T:System.Decimal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-710">The result is outside the range of a <see cref="T:System.Decimal" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, digits As Integer, mode As MidpointRounding) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, int digits, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : double * int * MidpointRounding -&gt; double" Usage="System.Math.Round (value, digits, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-711">Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać zaokrąglona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-711">A double-precision floating-point number to be rounded.</span>
          </span>
        </param>
        <param name="digits">
          <span data-ttu-id="92e45-712">Liczba cyfr ułamkowych w wartości zwracanej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-712">The number of fractional digits in the return value.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="92e45-713">Specyfikacja sposobu zaokrąglona <c>wartość</c> przypadku pośrodku dwie inne liczby.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-713">Specification for how to round <c>value</c> if it is midway between two other numbers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-714">Zaokrągla liczbę do określonej liczby cyfr ułamkowych wartości zmiennoprzecinkowej podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-714">Rounds a double-precision floating-point value to a specified number of fractional digits.</span>
          </span>
          <span data-ttu-id="92e45-715">Parametr określa sposób zaokrąglania wartości, jeśli jest w połowie między dwiema liczbami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-715">A parameter specifies how to round the value if it is midway between two numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-716">Liczba najbliżej do <paramref name="value" /> mający liczba cyfr ułamkowych równa <paramref name="digits" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-716">The number nearest to <paramref name="value" /> that has a number of fractional digits equal to <paramref name="digits" />.</span>
          </span>
          <span data-ttu-id="92e45-717">Jeśli <paramref name="value" /> ma mniejszą liczbę cyfr ułamkowych niż <paramref name="digits" />, <paramref name="value" /> zwróceniu niezmieniona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-717">If <paramref name="value" /> has fewer fractional digits than <paramref name="digits" />, <paramref name="value" /> is returned unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="92e45-718">Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.</span><span class="sxs-lookup"><span data-stu-id="92e45-718">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="92e45-719">
            <paramref name="digits" /> jest mniejsza niż 0 lub większą niż 15.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-719">
              <paramref name="digits" /> is less than 0 or greater than 15.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="92e45-720">
            <paramref name="mode" /> nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-720">
              <paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="92e45-721">
            <para>Ze względu na zmniejszenie precyzji, która może wynikać z reprezentujący wartości dziesiętnej jako liczby zmiennoprzecinkowe lub wykonywanie operacji arytmetycznych na wartości zmiennoprzecinkowe w niektórych przypadkach <see cref="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" /> zostać zaokrąglona środkowego wartości określonych nie może występować — metoda przez <paramref name="mode" /> parametru. Jest to zilustrowane w poniższym przykładzie, w którym 2.135 jest zaokrąglana do 2.13 zamiast 2.14. Dzieje się tak dlatego wewnętrznie mnoży metody <paramref name="value" /> przez 10<sup>cyfr</sup>, i operacja mnożenia w takim przypadku odczuwa utratę dokładności.  [! code-csharp[System.Math.Round#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round4.cs#3)] [! code-vb[System.Math.Round#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round4.vb#3)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-721">
              <para>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" /> method may not appear to round midpoint values as specified by the <paramref name="mode" /> parameter. This is illustrated in the following example, where 2.135 is rounded to 2.13 instead of 2.14. This occurs because internally the method multiplies <paramref name="value" /> by 10<sup>digits</sup>, and the multiplication operation in this case suffers from a loss of precision.  [!code-csharp[System.Math.Round#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round4.cs#3)] [!code-vb[System.Math.Round#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round4.vb#3)]</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sign">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="92e45-722">Zwraca liczbę całkowitą, która wskazuje znak liczby.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-722">Returns an integer that indicates the sign of a number.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Sign : decimal -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-723">Podpisem liczbą dziesiętną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-723">A signed decimal number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-724">Zwraca liczbę całkowitą, która wskazuje znak liczby dziesiętnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-724">Returns an integer that indicates the sign of a decimal number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-725">Liczba, która określa znak <paramref name="value" />, jak pokazano w poniższej tabeli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-725">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span>
          </span>
          <span data-ttu-id="92e45-726">
            <list type="table">
              <listheader>
                <term> Wartość zwracana </term>
                <description> znaczenie </description>
              </listheader>
              <item>
                <term> -1 </term>
                <description>
                  <paramref name="value" /> jest mniejszy od zera.  </description>
              </item>
              <item>
                <term> 0 </term>
                <description>
                  <paramref name="value" /> jest równa zero.  </description>
              </item>
              <item>
                <term> 1 </term>
                <description>
                  <paramref name="value" /> jest większa od zera.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-726">
              <list type="table">
                <listheader>
                  <term> Return value  </term>
                  <description> Meaning  </description>
                </listheader>
                <item>
                  <term> -1  </term>
                  <description>
                    <paramref name="value" /> is less than zero.  </description>
                </item>
                <item>
                  <term> 0  </term>
                  <description>
                    <paramref name="value" /> is equal to zero.  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <paramref name="value" /> is greater than zero.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-727">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Sign%28System.Decimal%29> metodę, aby określić znak <xref:System.Decimal> wartość i wyświetl ją do konsoli.</span><span class="sxs-lookup"><span data-stu-id="92e45-727">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Decimal%29> method to determine the sign of a <xref:System.Decimal> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(double value);" />
      <MemberSignature Language="F#" Value="static member Sign : double -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-728">Liczba oznaczona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-728">A signed number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-729">Zwraca liczbę całkowitą, która wskazuje znak liczby zmiennoprzecinkowej podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-729">Returns an integer that indicates the sign of a double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-730">Liczba, która określa znak <paramref name="value" />, jak pokazano w poniższej tabeli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-730">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span>
          </span>
          <span data-ttu-id="92e45-731">
            <list type="table">
              <listheader>
                <term> Wartość zwracana </term>
                <description> znaczenie </description>
              </listheader>
              <item>
                <term> -1 </term>
                <description>
                  <paramref name="value" /> jest mniejszy od zera.  </description>
              </item>
              <item>
                <term> 0 </term>
                <description>
                  <paramref name="value" /> jest równa zero.  </description>
              </item>
              <item>
                <term> 1 </term>
                <description>
                  <paramref name="value" /> jest większa od zera.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-731">
              <list type="table">
                <listheader>
                  <term> Return value  </term>
                  <description> Meaning  </description>
                </listheader>
                <item>
                  <term> -1  </term>
                  <description>
                    <paramref name="value" /> is less than zero.  </description>
                </item>
                <item>
                  <term> 0  </term>
                  <description>
                    <paramref name="value" /> is equal to zero.  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <paramref name="value" /> is greater than zero.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-732">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Sign%28System.Double%29> metodę, aby określić znak <xref:System.Double> wartość i wyświetl ją do konsoli.</span><span class="sxs-lookup"><span data-stu-id="92e45-732">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Double%29> method to determine the sign of a <xref:System.Double> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException">
          <span data-ttu-id="92e45-733">
            <paramref name="value" /> jest równa <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-733">
              <paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Short) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(short value);" />
      <MemberSignature Language="F#" Value="static member Sign : int16 -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-734">Liczba oznaczona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-734">A signed number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-735">Zwraca liczbę całkowitą, która wskazuje znak 16-bitową liczbę całkowitą ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-735">Returns an integer that indicates the sign of a 16-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-736">Liczba, która określa znak <paramref name="value" />, jak pokazano w poniższej tabeli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-736">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span>
          </span>
          <span data-ttu-id="92e45-737">
            <list type="table">
              <listheader>
                <term> Wartość zwracana </term>
                <description> znaczenie </description>
              </listheader>
              <item>
                <term> -1 </term>
                <description>
                  <paramref name="value" /> jest mniejszy od zera.  </description>
              </item>
              <item>
                <term> 0 </term>
                <description>
                  <paramref name="value" /> jest równa zero.  </description>
              </item>
              <item>
                <term> 1 </term>
                <description>
                  <paramref name="value" /> jest większa od zera.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-737">
              <list type="table">
                <listheader>
                  <term> Return value  </term>
                  <description> Meaning  </description>
                </listheader>
                <item>
                  <term> -1  </term>
                  <description>
                    <paramref name="value" /> is less than zero.  </description>
                </item>
                <item>
                  <term> 0  </term>
                  <description>
                    <paramref name="value" /> is equal to zero.  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <paramref name="value" /> is greater than zero.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-738">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Sign%28System.Int16%29> metodę, aby określić znak <xref:System.Int16> wartość i wyświetl ją do konsoli.</span><span class="sxs-lookup"><span data-stu-id="92e45-738">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int16%29> method to determine the sign of an <xref:System.Int16> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(int value);" />
      <MemberSignature Language="F#" Value="static member Sign : int -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-739">Liczba oznaczona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-739">A signed number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-740">Zwraca liczbę całkowitą, która wskazuje znak całkowita 32-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-740">Returns an integer that indicates the sign of a 32-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-741">Liczba, która określa znak <paramref name="value" />, jak pokazano w poniższej tabeli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-741">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span>
          </span>
          <span data-ttu-id="92e45-742">
            <list type="table">
              <listheader>
                <term> Wartość zwracana </term>
                <description> znaczenie </description>
              </listheader>
              <item>
                <term> -1 </term>
                <description>
                  <paramref name="value" /> jest mniejszy od zera.  </description>
              </item>
              <item>
                <term> 0 </term>
                <description>
                  <paramref name="value" /> jest równa zero.  </description>
              </item>
              <item>
                <term> 1 </term>
                <description>
                  <paramref name="value" /> jest większa od zera.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-742">
              <list type="table">
                <listheader>
                  <term> Return value  </term>
                  <description> Meaning  </description>
                </listheader>
                <item>
                  <term> -1  </term>
                  <description>
                    <paramref name="value" /> is less than zero.  </description>
                </item>
                <item>
                  <term> 0  </term>
                  <description>
                    <paramref name="value" /> is equal to zero.  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <paramref name="value" /> is greater than zero.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-743">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Sign%28System.Int32%29> metodę, aby określić znak <xref:System.Int32> wartość i wyświetl ją do konsoli.</span><span class="sxs-lookup"><span data-stu-id="92e45-743">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int32%29> method to determine the sign of an <xref:System.Int32> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(long value);" />
      <MemberSignature Language="F#" Value="static member Sign : int64 -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-744">Liczba oznaczona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-744">A signed number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-745">Zwraca liczbę całkowitą, która wskazuje znak 64-bitowej podpisanej liczby całkowitej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-745">Returns an integer that indicates the sign of a 64-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-746">Liczba, która określa znak <paramref name="value" />, jak pokazano w poniższej tabeli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-746">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span>
          </span>
          <span data-ttu-id="92e45-747">
            <list type="table">
              <listheader>
                <term> Wartość zwracana </term>
                <description> znaczenie </description>
              </listheader>
              <item>
                <term> -1 </term>
                <description>
                  <paramref name="value" /> jest mniejszy od zera.  </description>
              </item>
              <item>
                <term> 0 </term>
                <description>
                  <paramref name="value" /> jest równa zero.  </description>
              </item>
              <item>
                <term> 1 </term>
                <description>
                  <paramref name="value" /> jest większa od zera.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-747">
              <list type="table">
                <listheader>
                  <term> Return value  </term>
                  <description> Meaning  </description>
                </listheader>
                <item>
                  <term> -1  </term>
                  <description>
                    <paramref name="value" /> is less than zero.  </description>
                </item>
                <item>
                  <term> 0  </term>
                  <description>
                    <paramref name="value" /> is equal to zero.  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <paramref name="value" /> is greater than zero.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-748">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Sign%28System.Int64%29> metodę, aby określić znak <xref:System.Int64> wartość i wyświetl ją do konsoli.</span><span class="sxs-lookup"><span data-stu-id="92e45-748">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int64%29> method to determine the sign of an <xref:System.Int64> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As SByte) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member Sign : sbyte -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-749">Liczba oznaczona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-749">A signed number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-750">Zwraca liczbę całkowitą, która wskazuje znak 8-bitową liczbę całkowitą ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-750">Returns an integer that indicates the sign of an 8-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-751">Liczba, która określa znak <paramref name="value" />, jak pokazano w poniższej tabeli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-751">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span>
          </span>
          <span data-ttu-id="92e45-752">
            <list type="table">
              <listheader>
                <term> Wartość zwracana </term>
                <description> znaczenie </description>
              </listheader>
              <item>
                <term> -1 </term>
                <description>
                  <paramref name="value" /> jest mniejszy od zera.  </description>
              </item>
              <item>
                <term> 0 </term>
                <description>
                  <paramref name="value" /> jest równa zero.  </description>
              </item>
              <item>
                <term> 1 </term>
                <description>
                  <paramref name="value" /> jest większa od zera.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-752">
              <list type="table">
                <listheader>
                  <term> Return value  </term>
                  <description> Meaning  </description>
                </listheader>
                <item>
                  <term> -1  </term>
                  <description>
                    <paramref name="value" /> is less than zero.  </description>
                </item>
                <item>
                  <term> 0  </term>
                  <description>
                    <paramref name="value" /> is equal to zero.  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <paramref name="value" /> is greater than zero.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-753">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Sign%28System.SByte%29> metodę, aby określić znak <xref:System.SByte> wartość i wyświetl ją do konsoli.</span><span class="sxs-lookup"><span data-stu-id="92e45-753">The following example demonstrates how to use the <xref:System.Math.Sign%28System.SByte%29> method to determine the sign of an <xref:System.SByte> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(float value);" />
      <MemberSignature Language="F#" Value="static member Sign : single -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-754">Liczba oznaczona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-754">A signed number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-755">Zwraca liczbę całkowitą, która wskazuje znak liczby zmiennoprzecinkowej pojedynczej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-755">Returns an integer that indicates the sign of a single-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-756">Liczba, która określa znak <paramref name="value" />, jak pokazano w poniższej tabeli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-756">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span>
          </span>
          <span data-ttu-id="92e45-757">
            <list type="table">
              <listheader>
                <term> Wartość zwracana </term>
                <description> znaczenie </description>
              </listheader>
              <item>
                <term> -1 </term>
                <description>
                  <paramref name="value" /> jest mniejszy od zera.  </description>
              </item>
              <item>
                <term> 0 </term>
                <description>
                  <paramref name="value" /> jest równa zero.  </description>
              </item>
              <item>
                <term> 1 </term>
                <description>
                  <paramref name="value" /> jest większa od zera.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-757">
              <list type="table">
                <listheader>
                  <term> Return value  </term>
                  <description> Meaning  </description>
                </listheader>
                <item>
                  <term> -1  </term>
                  <description>
                    <paramref name="value" /> is less than zero.  </description>
                </item>
                <item>
                  <term> 0  </term>
                  <description>
                    <paramref name="value" /> is equal to zero.  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <paramref name="value" /> is greater than zero.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-758">W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Sign%28System.Single%29> metodę, aby określić znak <xref:System.Single> wartość i wyświetl ją do konsoli.</span><span class="sxs-lookup"><span data-stu-id="92e45-758">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Single%29> method to determine the sign of a <xref:System.Single> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException">
          <span data-ttu-id="92e45-759">
            <paramref name="value" /> jest równa <see cref="F:System.Single.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-759">
              <paramref name="value" /> is equal to <see cref="F:System.Single.NaN" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static double Sin (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sin(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sin(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sin(double a);" />
      <MemberSignature Language="F#" Value="static member Sin : double -&gt; double" Usage="System.Math.Sin a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="92e45-760">Kąt wyrażony w radianach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-760">An angle, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-761">Zwraca sinus określonego kąta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-761">Returns the sine of the specified angle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-762">Sinus <paramref name="a" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-762">The sine of <paramref name="a" />.</span>
          </span>
          <span data-ttu-id="92e45-763">Jeśli <paramref name="a" /> jest równa <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, lub <see cref="F:System.Double.PositiveInfinity" />, ta metoda zwraca <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-763">If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-764">Kąt `a`, musi być podany w radianach.</span><span class="sxs-lookup"><span data-stu-id="92e45-764">The angle, `a`, must be in radians.</span></span> <span data-ttu-id="92e45-765">Mnożenie przez <xref:System.Math.PI?displayProperty=nameWithType>/180 do Konwertuj stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="92e45-765">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 <span data-ttu-id="92e45-766">Dopuszczalne wartości `a` z zakresu od około-9223372036854775295 do około 9223372036854775295.</span><span class="sxs-lookup"><span data-stu-id="92e45-766">Acceptable values of `a` range from approximately -9223372036854775295 to approximately 9223372036854775295.</span></span> <span data-ttu-id="92e45-767">Dla wartości poza tym zakresem <xref:System.Math.Sin%2A> metoda zwraca `a` niezmienione zamiast zgłaszać wyjątek.</span><span class="sxs-lookup"><span data-stu-id="92e45-767">For values outside of this range, the <xref:System.Math.Sin%2A> method returns `a` unchanged rather than throwing an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-768">W poniższym przykładzie użyto <xref:System.Math.Sin%2A> do oceny niektórych trygonometryczne tożsamości dla wybranych kątów.</span><span class="sxs-lookup"><span data-stu-id="92e45-768">The following example uses <xref:System.Math.Sin%2A> to evaluate certain trigonometric identities for selected angles.</span></span>  
  
 [!code-cpp[System.Math.SinCos#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp#1)]
 [!code-csharp[System.Math.SinCos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs#1)]
 [!code-vb[System.Math.SinCos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static double Sinh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sinh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sinh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sinh(double value);" />
      <MemberSignature Language="F#" Value="static member Sinh : double -&gt; double" Usage="System.Math.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-769">Kąt wyrażony w radianach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-769">An angle, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-770">Zwraca sinus hiperboliczny podanemu kątowi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-770">Returns the hyperbolic sine of the specified angle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-771">Sinus hiperboliczny <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-771">The hyperbolic sine of <paramref name="value" />.</span>
          </span>
          <span data-ttu-id="92e45-772">Jeśli <paramref name="value" /> jest równa <see cref="F:System.Double.NegativeInfinity" />, <see cref="F:System.Double.PositiveInfinity" />, lub <see cref="F:System.Double.NaN" />, ta metoda zwraca <see cref="T:System.Double" /> równa <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-772">If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" />, <see cref="F:System.Double.PositiveInfinity" />, or <see cref="F:System.Double.NaN" />, this method returns a <see cref="T:System.Double" /> equal to <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-773">Kąt `value`, musi być podany w radianach.</span><span class="sxs-lookup"><span data-stu-id="92e45-773">The angle, `value`, must be in radians.</span></span> <span data-ttu-id="92e45-774">Mnożenie przez <xref:System.Math.PI?displayProperty=nameWithType>/180 do Konwertuj stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="92e45-774">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-775">W poniższym przykładzie użyto <xref:System.Math.Sinh%2A> do oceny niektórych hiperboliczny tożsamości dla wybranych wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-775">The following example uses <xref:System.Math.Sinh%2A> to evaluate certain hyperbolic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.SinhCosh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp#1)]
 [!code-csharp[System.Math.SinhCosh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs#1)]
 [!code-vb[System.Math.SinhCosh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static double Sqrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sqrt(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sqrt(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sqrt(double d);" />
      <MemberSignature Language="F#" Value="static member Sqrt : double -&gt; double" Usage="System.Math.Sqrt d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-776">Liczba, której pierwiastek kwadratowy ma zostać znaleziona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-776">The number whose square root is to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-777">Zwraca pierwiastek kwadratowy z podanej liczby.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-777">Returns the square root of a specified number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-778">Jedna z wartości w tabeli poniżej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-778">One of the values in the following table.</span>
          </span>
          <span data-ttu-id="92e45-779">
            <list type="table">
              <listheader>
                <term>
                  <paramref name="d" /> Parametr </term>
                <description> zwrócić wartość </description>
              </listheader>
              <item>
                <term> 0 lub dodatnia </term>
                <description> dodatnią pierwiastek kwadratowy liczby <paramref name="d" />.  </description>
              </item>
              <item>
                <term> Ujemna </term>
                <description>
                  <see cref="F:System.Double.NaN" />
                </description>
              </item>
              <item>
                <term> jest równe <see cref="F:System.Double.NaN" /></term>
                <description>
                  <see cref="F:System.Double.NaN" />
                </description>
              </item>
              <item>
                <term> Jest równe <see cref="F:System.Double.PositiveInfinity" /></term>
                <description>
                  <see cref="F:System.Double.PositiveInfinity" />
                </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-779">
              <list type="table">
                <listheader>
                  <term>
                    <paramref name="d" /> parameter  </term>
                  <description> Return value  </description>
                </listheader>
                <item>
                  <term> Zero or positive  </term>
                  <description> The positive square root of <paramref name="d" />.  </description>
                </item>
                <item>
                  <term> Negative  </term>
                  <description>
                    <see cref="F:System.Double.NaN" />
                  </description>
                </item>
                <item>
                  <term> Equals <see cref="F:System.Double.NaN" /></term>
                  <description>
                    <see cref="F:System.Double.NaN" />
                  </description>
                </item>
                <item>
                  <term> Equals <see cref="F:System.Double.PositiveInfinity" /></term>
                  <description>
                    <see cref="F:System.Double.PositiveInfinity" />
                  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="92e45-780">Pierwiastek kwadratowy obszaru kwadrat reprezentuje długość boków kwadratu.</span><span class="sxs-lookup"><span data-stu-id="92e45-780">The square root of the area of a square represents the length of any side of the square.</span></span> <span data-ttu-id="92e45-781">Poniższy przykład przedstawia obszaru niektórych miastach w Stanach Zjednoczonych i daje wyobrażenie o rozmiarze każdemu miastu, jeśli były reprezentowane przez kwadrat.</span><span class="sxs-lookup"><span data-stu-id="92e45-781">The following example displays the area of some cities in the United States and gives an impression of each city's size if it were represented by a square.</span></span>  
  
 [!code-csharp[System.Math.Sqrt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.sqrt/cs/sqrt1.cs#1)]
 [!code-vb[System.Math.Sqrt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.sqrt/vb/sqrt1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static double Tan (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tan(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tan(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Tan(double a);" />
      <MemberSignature Language="F#" Value="static member Tan : double -&gt; double" Usage="System.Math.Tan a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="92e45-782">Kąt wyrażony w radianach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-782">An angle, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-783">Zwraca tangens odpowiadający podanemu kątowi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-783">Returns the tangent of the specified angle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-784">Tangens <paramref name="a" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-784">The tangent of <paramref name="a" />.</span>
          </span>
          <span data-ttu-id="92e45-785">Jeśli <paramref name="a" /> jest równa <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, lub <see cref="F:System.Double.PositiveInfinity" />, ta metoda zwraca <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-785">If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-786">Kąt `a`, musi być podany w radianach.</span><span class="sxs-lookup"><span data-stu-id="92e45-786">The angle, `a`, must be in radians.</span></span> <span data-ttu-id="92e45-787">Mnożenie przez <xref:System.Math.PI?displayProperty=nameWithType>/180 do Konwertuj stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="92e45-787">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-788">W poniższym przykładzie pokazano sposób Oblicz tangens kąta i wyświetl ją do konsoli.</span><span class="sxs-lookup"><span data-stu-id="92e45-788">The following example demonstrates how to calculate the tangent of an angle and display it to the console.</span></span>  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static double Tanh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tanh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tanh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Tanh(double value);" />
      <MemberSignature Language="F#" Value="static member Tanh : double -&gt; double" Usage="System.Math.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="92e45-789">Kąt wyrażony w radianach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-789">An angle, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-790">Zwraca tangens hiperboliczny podanemu kątowi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-790">Returns the hyperbolic tangent of the specified angle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-791">Tangens hiperboliczny liczby <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-791">The hyperbolic tangent of <paramref name="value" />.</span>
          </span>
          <span data-ttu-id="92e45-792">Jeśli <paramref name="value" /> jest równa <see cref="F:System.Double.NegativeInfinity" />, ta metoda zwraca wartość -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-792">If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" />, this method returns -1.</span>
          </span>
          <span data-ttu-id="92e45-793">Jeśli wartość jest równa <see cref="F:System.Double.PositiveInfinity" />, ta metoda zwraca wartość 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-793">If value is equal to <see cref="F:System.Double.PositiveInfinity" />, this method returns 1.</span>
          </span>
          <span data-ttu-id="92e45-794">Jeśli <paramref name="value" /> jest równa <see cref="F:System.Double.NaN" />, ta metoda zwraca <see cref="F:System.Double.NaN" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-794">If <paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />, this method returns <see cref="F:System.Double.NaN" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-795">Kąt `value`, musi być podany w radianach.</span><span class="sxs-lookup"><span data-stu-id="92e45-795">The angle, `value`, must be in radians.</span></span> <span data-ttu-id="92e45-796">Mnożenie przez <xref:System.Math.PI?displayProperty=nameWithType>/180 do Konwertuj stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="92e45-796">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-797">W poniższym przykładzie użyto <xref:System.Math.Tanh%2A> do oceny niektórych tangens hiperboliczny tożsamości wybranych wartości.</span><span class="sxs-lookup"><span data-stu-id="92e45-797">The following example uses <xref:System.Math.Tanh%2A> to evaluate certain hyperbolic tangent identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.Tanh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Tanh/CPP/tanh.cpp#1)]
 [!code-csharp[System.Math.Tanh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Tanh/CS/tanh.cs#1)]
 [!code-vb[System.Math.Tanh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Tanh/VB/tanh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Truncate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="92e45-798">Oblicza integralną część liczby.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-798">Calculates the integral part of a number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-799">Liczba jest zaokrąglana do najbliższej liczby całkowitej w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="92e45-799">The number is rounded to the nearest integer towards zero.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static decimal Truncate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Truncate(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Truncate(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Truncate : decimal -&gt; decimal" Usage="System.Math.Truncate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-800">Liczba obcięcia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-800">A number to truncate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-801">Oblicza integralną częścią określony liczbą dziesiętną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-801">Calculates the integral part of a specified decimal number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-802">Integralną częścią <paramref name="d" />; oznacza to, liczba który pozostaje po wszelkich cyfr ułamkowych zostały odrzucone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-802">The integral part of <paramref name="d" />; that is, the number that remains after any fractional digits have been discarded.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-803"><xref:System.Math.Truncate%2A> Zaokrągla `d` do najbliższej liczby całkowitej w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="92e45-803"><xref:System.Math.Truncate%2A> rounds `d` to the nearest integer towards zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-804">Następujące przykładowe wywołania <xref:System.Math.Truncate%28System.Decimal%29> metody obcięcia zarówno pozytywnych i ujemny <xref:System.Decimal> wartość.</span><span class="sxs-lookup"><span data-stu-id="92e45-804">The following example calls the <xref:System.Math.Truncate%28System.Decimal%29> method to truncate both a positive and a negative <xref:System.Decimal> value.</span></span>  
  
 [!code-csharp[System.Math.Truncate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs#2)]
 [!code-vb[System.Math.Truncate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static double Truncate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Truncate(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Truncate(double d);" />
      <MemberSignature Language="F#" Value="static member Truncate : double -&gt; double" Usage="System.Math.Truncate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="92e45-805">Liczba obcięcia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-805">A number to truncate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="92e45-806">Oblicza integralną częścią podanej liczbie zmiennoprzecinkowej podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-806">Calculates the integral part of a specified double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="92e45-807">Integralną częścią <paramref name="d" />; oznacza to, liczba który pozostaje po wszelkich cyfr ułamkowych zostały odrzucone lub jedna z wartości wymienionych w poniższej tabeli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-807">The integral part of <paramref name="d" />; that is, the number that remains after any fractional digits have been discarded, or one of the values listed in the following table.</span>
          </span>
          <span data-ttu-id="92e45-808">
            <list type="table">
              <listheader>
                <term>
                  <paramref name="d" />
                </term>
                <description> Wartość zwracana  </description>
              </listheader>
              <item>
                <term>
                  <see cref="F:System.Double.NaN" />
                </term>
                <description>
                  <see cref="F:System.Double.NaN" />
                </description>
              </item>
              <item>
                <term>
                  <see cref="F:System.Double.NegativeInfinity" />
                </term>
                <description>
                  <see cref="F:System.Double.NegativeInfinity" />
                </description>
              </item>
              <item>
                <term>
                  <see cref="F:System.Double.PositiveInfinity" />
                </term>
                <description>
                  <see cref="F:System.Double.PositiveInfinity" />
                </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="92e45-808">
              <list type="table">
                <listheader>
                  <term>
                    <paramref name="d" />
                  </term>
                  <description> Return value  </description>
                </listheader>
                <item>
                  <term>
                    <see cref="F:System.Double.NaN" />
                  </term>
                  <description>
                    <see cref="F:System.Double.NaN" />
                  </description>
                </item>
                <item>
                  <term>
                    <see cref="F:System.Double.NegativeInfinity" />
                  </term>
                  <description>
                    <see cref="F:System.Double.NegativeInfinity" />
                  </description>
                </item>
                <item>
                  <term>
                    <see cref="F:System.Double.PositiveInfinity" />
                  </term>
                  <description>
                    <see cref="F:System.Double.PositiveInfinity" />
                  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="92e45-809"><xref:System.Math.Truncate%2A> Zaokrągla `d` do najbliższej liczby całkowitej w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="92e45-809"><xref:System.Math.Truncate%2A> rounds `d` to the nearest integer towards zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="92e45-810">Następujące przykładowe wywołania <xref:System.Math.Truncate%28System.Double%29> metody obcięcia zarówno pozytywnych i ujemny <xref:System.Double> wartość.</span><span class="sxs-lookup"><span data-stu-id="92e45-810">The following example calls the <xref:System.Math.Truncate%28System.Double%29> method to truncate both a positive and a negative <xref:System.Double> value.</span></span>  
  
 [!code-csharp[System.Math.Truncate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs#1)]
 [!code-vb[System.Math.Truncate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
      </Docs>
    </Member>
  </Members>
</Type>
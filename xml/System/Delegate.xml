<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3f0536eac77f3171e3a7eeb74486cfcf863ec3d8" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30744953" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje delegata, który jest strukturą danych, która odwołuje się do metody statycznej lub wystąpienia klasy i metody wystąpienia tej klasy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate> Klasy to klasa podstawowa dla typów delegatów. Jednak tylko systemu i kompilatory można jawnie pochodzi od <xref:System.Delegate> klasy lub <xref:System.MulticastDelegate> klasy. Również nie jest dozwolone wyprowadzenia nowy typ z typem obiektu delegowanego. <xref:System.Delegate> Klasa nie jest uznawany za typ delegata; jest on klasą używany do uzyskania typów delegatów.  
  
 Większość języków zaimplementować `delegate` — słowo kluczowe i kompilatory w tych językach mogą pochodzić z <xref:System.MulticastDelegate> klasy; w związku z tym użytkownicy powinni używać `delegate` — słowo kluczowe udostępniane przez język.  
  
> [!NOTE]
>  Udostępnia środowisko uruchomieniowe języka wspólnego `Invoke` metody dla każdego typu obiektu delegowanego z takiego samego podpisu jak obiekt delegowany. Nie trzeba jawnie wywołać tę metodę w C#, Visual Basic lub Visual C++, ponieważ kompilatory wywołać ją automatycznie. `Invoke` Metoda jest przydatna w [odbicia](~/docs/framework/reflection-and-codedom/reflection.md) gdy chcesz znaleźć podpisu z typem obiektu delegowanego.  
  
 Środowisko uruchomieniowe języka wspólnego zapewnia każdego typu obiektu delegowanego z `BeginInvoke` i `EndInvoke` metody w celu umożliwienia wywołania asynchronicznego delegata. Aby uzyskać więcej informacji na temat tych metod, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 Deklaracja typu delegata ustanawia kontraktu, który określa podpis co najmniej jedną metodę. Delegat jest wystąpieniem typu delegata, który odwołuje się do:  
  
-   Metoda wystąpienia typu i można przypisać do tego typu obiektu docelowego.  
  
-   Metodą wystąpienia typu, ukrytego `this` parametru widoczne na liście parametrów formalnych. Delegat jest określany jako pełnomocnika otwartej instancji.  
  
-   Metoda statyczna.  
  
-   Metody statycznej i obiekt docelowy można przypisać do pierwszego parametru metody. Delegat jest nazywany zamknięte przez jego pierwszym argumentem.  
  
 Aby uzyskać więcej informacji na delegata powiązanie, zobacz <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenie metody.  
  
> [!NOTE]
>  W wersji systemu .NET Framework 1.0 i 1.1 Delegat może reprezentować metody tylko wtedy, gdy podpis metody jest identyczny podpis określony przez typ delegata. W związku z tym są obsługiwane tylko pierwszy i trzeci punktory z powyższej listy, a pierwszy punktor wymaga typu dokładnego dopasowania.  
  
 Jeśli delegat reprezentuje metodę wystąpienia zamknięte za pośrednictwem pierwszego argumentu (najbardziej typowych przypadkach), delegat przechowuje odwołania do metody punktu wejścia i odwołanie do obiektu o nazwie docelowych, które można przypisać do typu, który jest zdefiniowany typ Metoda. Delegat reprezentuje metodę Otwórz wystąpienie, są przechowywane odwołania do metody punktu wejścia. Podpis delegata musi zawierać ukrytego `this` parametrem na liście parametrów formalnych; w takim przypadku delegat nie ma odwołanie do obiektu docelowego i obiekt docelowy musi być podany jest wywoływany delegat.  
  
 Jeśli delegat reprezentuje metody statycznej, delegat przechowuje odwołania do metody punktu wejścia. Jeśli delegat reprezentuje statycznej metody zamknięte za pośrednictwem pierwszego argumentu, delegat przechowuje odwołania do metody punktu wejścia i odwołanie do obiektu docelowego, można przypisać do typu pierwszy argument metody. Po wywołaniu delegat pierwszy argument metody statycznej odbiera obiektu docelowego.  
  
 Lista wywołania delegata jest uporządkowany zestaw obiektów delegowanych, w których każdy element listy wywołuje dokładnie jedną z metod reprezentowany przez delegata. Lista wywołanie może zawierać zduplikowanych metody. Podczas wywoływania metody są wywoływane w kolejności, w którym są wyświetlane na liście wywołania. Delegat podejmuje próbę wywołania metody, co na swojej liście wywołania; duplikaty są wywoływane po za każdym razem, są wyświetlane na liście wywołania. Obiekty delegowane są niezmienne; Po utworzeniu listy wywołania delegata nie zmienia się.  
  
 Obiekty delegowane są określane jako multiemisji lub łączonymi, ponieważ Delegat może wywołać co najmniej jedną metodę i mogą być używane w połączeniu operacji.  
  
 Połączenie operacji, takich jak <xref:System.Delegate.Combine%2A> i <xref:System.Delegate.Remove%2A>, nie należy zmieniać istniejących obiektów delegowanych. Zamiast tego takie działanie zwraca nowe delegowanie, zawierającego wyniki operacji pełnomocnika bez zmian lub `null`. Zwraca operacji łączenia `null` gdy wyniku operacji jest delegata, który nie odwołuje się co najmniej jedną metodę. Operacji łączenia zwraca delegata bez zmian, gdy żądana operacja nie ma wpływu.  
  
> [!NOTE]
>  Zarządzane Użyj języków <xref:System.Delegate.Combine%2A> i <xref:System.Delegate.Remove%2A> metody służące do implementacji działania delegata. Przykłady obejmują `AddHandler` i `RemoveHandler` instrukcji w języku Visual Basic i operatory "+= i-=" na delegata typów w języku C#.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], ogólnych typów delegata mogą mieć parametrów typu variant. Parametry typu kontrawariantnego mogą być używane jako typy parametrów delegata, a parametr typu kowariantnego może służyć jako typ zwracany. Ta funkcja umożliwia Delegat ogólny typy, które są tworzone na podstawie tej samej definicji typu ogólnego za zgodny przypisania, jeśli ich argumenty typu są typy referencyjne z relację dziedziczenia, zgodnie z objaśnieniem w [Kowariancja i Kontrawariancja](~/docs/standard/generics/covariance-and-contravariance.md).  
  
> [!NOTE]
>  Delegaty ogólne, które są zgodne z przypisania z powodu wariancję nie są zawsze łączonymi. Być łączonymi typy muszą być całkowicie zgodne. Na przykład załóżmy, że klasa o nazwie `Derived` jest pochodną klasy o nazwie `Base`. Delegowanego typu `Action<Base>` (`Action(Of Base)` w języku Visual Basic) można przypisać do zmiennej typu `Action<Derived>`, ale nie można połączyć dwóch delegatów, ponieważ typy nie są zgodne dokładnie.  
  
 Wywołana metoda zgłasza wyjątek, metoda zatrzymuje wykonywanie, wyjątek jest przekazywane z powrotem do wywołującego delegata i pozostałe metody na liście wywołania nie są wywoływane. Przechwytywanie wyjątków w obiekt wywołujący nie zmienia to zachowanie.  
  
 Podpis metody wywoływane przez obiekt delegowany zawierającego wartość zwrotna, delegat zwraca wartość zwracaną ostatniego elementu na liście wywołania. Jeśli podpis zawiera parametr, który jest przekazywana przez odwołanie, końcowa wartość parametru jest wynikiem każdej metody na liście wywołania wykonywane sekwencyjnie i aktualizowania wartości parametru.  
  
 Najbliższym odpowiednikiem delegata w języka C lub C++ jest wskaźnik funkcji. Delegat może reprezentować metodą statyczną lub metodą wystąpienia. Jeśli delegat reprezentuje metodę wystąpienia, delegat przechowuje nie tylko odwołania do metody punktu wejścia, ale również odwołanie do wystąpienia klasy. W przeciwieństwie do wskaźników funkcji delegatów są obiektowej i wpisz bezpieczne.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób definiowania delegata o nazwie `myMethodDelegate`. Utworzenie wystąpień tego obiektu delegowanego dla metody wystąpienia i metodą statyczną zagnieżdżone `mySampleClass` klasy. Delegat dla metody wystąpienia wymaga wystąpienia `mySampleClass`. `mySampleClass` Wystąpienia jest zapisywane w zmiennej o nazwie `mySC`.  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe delegowanie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">Wystąpienie klasy, w którym wywołuje delegata <c>metody</c>.</param>
        <param name="method">Nazwa metody wystąpienia, który reprezentuje delegata.</param>
        <summary>Inicjuje delegata, który wywołuje metodę wystąpienia określonego wystąpienia określonej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor nie można używać w kodzie aplikacji. Aby utworzyć delegata, określając nazwę metody wystąpienia, należy użyć przeciążenia <xref:System.Delegate.CreateDelegate%2A> metodę, która określa nazwę metody i obiekt docelowy. Na przykład <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> przeciążenie metody tworzy delegowany do metody wystąpienia o określonej nazwie.  
  
 Ten konstruktor tworzy delegatów na przykład tylko metody. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wystąpił błąd powiązania z metodą docelową.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Type" /> Reprezentujący klasę, która definiuje <c>metody</c>.</param>
        <param name="method">Nazwa metody statycznej, który reprezentuje delegata.</param>
        <summary>Inicjuje delegata, który wywołuje określonej metody statycznej z określonej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor nie można używać w kodzie aplikacji. Do utworzenia delegata, określając nazwę metody statycznej, użyj przeciążenia <xref:System.Delegate.CreateDelegate%2A> metodę, która określa nazwę metody, ale nie określa obiektu docelowego. Na przykład <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> przeciążenie metody tworzy delegata statycznej metody o określonej nazwie.  
  
 Ten konstruktor tworzy delegatów tylko metody statyczne. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
 —lub—  
  
 <paramref name="target" /> reprezentuje otwartym typem ogólnym.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię pobieżną delegata.</summary>
        <returns>Kopia pobieżna delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klon ma taką samą <xref:System.Type>, listy docelowej, metodę oraz wywołania jak oryginalny obiekt delegowany.  
  
 Kopia pobieżna tworzy nowe wystąpienie tego samego typu co oryginalny obiekt, a następnie kopiuje niestatycznego pola oryginalnego obiektu. Jeśli pole jest typu wartości, jest wykonywane kopii bitowej przez bitowej pola. Jeśli pole jest typu odwołania, jest kopiowana odwołania, ale określony obiekt jest; w związku z tym odwołania w obiekcie oryginalnym i odwołania w klonowania wskazują ten sam obiekt. Z kolei głęboką kopię obiektu jest duplikatem wszystko bezpośrednio lub pośrednio odwołuje się pola w obiekcie.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Łączy listę wywołania obiekty delegowane multiemisji określony (łączonymi).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">Tablica obiektów delegowanych połączyć.</param>
        <summary>Łączy listę wywołania tablicę obiektów delegowanych.</summary>
        <returns>Nowe delegowanie przy użyciu listy wywołania, który łączy list wywołania delegatów w <paramref name="delegates" /> tablicy. Zwraca <see langword="null" /> Jeśli <paramref name="delegates" /> jest <see langword="null" />, jeśli <paramref name="delegates" /> nie zawiera zero elementów lub jeśli każdy wpis w <paramref name="delegates" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `delegates` tablica zawiera wpisów, które są `null`, te wpisy są ignorowane.  
  
 Lista wywołanie może zawierać zduplikowanych wpisów; oznacza to, wpisów, które odwołują się do tej samej metody na tym samym obiekcie.  
  
> [!NOTE]
>  Delegaty ogólne, które są zgodne z przypisania z powodu wariancję nie są zawsze łączonymi. Być łączonymi typy muszą być całkowicie zgodne. Na przykład załóżmy, że klasa o nazwie `Derived` jest pochodną klasy o nazwie `Base`. Delegowanego typu `Action<Base>` (`Action(Of Base)` w języku Visual Basic) można przypisać do zmiennej typu `Action<Derived>`, zgodnie z objaśnieniem w [Kowariancja i Kontrawariancja](~/docs/standard/generics/covariance-and-contravariance.md), ale nie można połączyć dwóch delegatów, ponieważ typy są nie takie same.  
  
 <xref:System.Delegate.Combine%2A> jest przydatne w przypadku tworzenia procedury obsługi zdarzeń, które występuje wiele metod czasu zdarzenie wywołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie wszystkie wpisy z systemem innym niż null w <paramref name="delegates" /> wystąpień tego samego typu delegowanego.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">Delegat, którego lista wywołania zostanie osiągnięty jako pierwszy.</param>
        <param name="b">Delegat, którego lista wywołania pochodzi ostatni.</param>
        <summary>Łączy listę wywołania dwóch delegatów.</summary>
        <returns>Nowe delegowanie przy użyciu listy wywołania, który łączy wywołanie list <paramref name="a" /> i <paramref name="b" /> w podanej kolejności. Zwraca <paramref name="a" /> Jeśli <paramref name="b" /> jest <see langword="null" />, zwraca <paramref name="b" /> Jeśli <paramref name="a" /> jest odwołanie o wartości null i zwraca odwołanie o wartości null, jeśli obie <paramref name="a" /> i <paramref name="b" /> są puste odwołania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lista wywołanie może zawierać zduplikowanych wpisów; oznacza to, wpisów, które odwołują się do tej samej metody na tym samym obiekcie.  
  
> [!NOTE]
>  Delegaty ogólne, które są zgodne z przypisania z powodu wariancję nie są zawsze łączonymi. Być łączonymi typy muszą być całkowicie zgodne. Na przykład załóżmy, że klasa o nazwie `Derived` jest pochodną klasy o nazwie `Base`. Delegowanego typu `Action<Base>` (`Action(Of Base)` w języku Visual Basic) można przypisać do zmiennej typu `Action<Derived>`, zgodnie z objaśnieniem w [Kowariancja i Kontrawariancja](~/docs/standard/generics/covariance-and-contravariance.md), ale nie można połączyć dwóch delegatów, ponieważ typy są nie takie same.  
  
 <xref:System.Delegate.Combine%2A> jest przydatne w przypadku tworzenia procedury obsługi zdarzeń, które występuje wiele metod czasu zdarzenie wywołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Zarówno <paramref name="a" /> i <paramref name="b" /> nie są <see langword="null" />, i <paramref name="a" /> i <paramref name="b" /> nie są wystąpień tego samego typu delegowanego.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">(Łączonymi) multiemisji delegować delegować których listy wywołania do dołączenia do końca listy wywołania bieżącego multiemisji (łączonymi).</param>
        <summary>Łączy listę wywołania określonego delegata (łączonymi) multiemisji i bieżącego multiemisji delegata (łączonymi).</summary>
        <returns>Delegowanie nowe multiemisja (łączonymi) przy użyciu listy wywołania, który łączy listy wywołania bieżącego multiemisji delegata (łączonymi) i wywołania listę <paramref name="d" />, delegować bieżącego multiemisji (łączonymi), jeśli <paramref name="d" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma zastosowanie tylko wtedy, gdy bieżący delegat jest multiemisji (łączonymi).  
  
 Bieżąca implementacja po prostu zgłasza <xref:System.MulticastNotSupportedException>.  
  
 Lista wywołanie może zawierać zduplikowanych wpisów; oznacza to, wpisów, które odwołują się do tej samej metody na tym samym obiekcie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Zawsze generowany.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy delegata określonego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Opisujące statycznych lub metody obiektu delegowanego jest do reprezentowania wystąpienia. Tylko metody statyczne są obsługiwane w programie .NET Framework w wersji 1.0, 1.1.</param>
        <summary>Tworzy delegata do reprezentowania określonej metody statyczne określonego typu.</summary>
        <returns>Delegat określonego typu do reprezentowania określonej metody statycznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework w wersji 1.0, 1.1 przeciążenie metody tworzy delegatów tylko metody statyczne. W programie .NET Framework w wersji 2.0 przeciążenie metody również tworzyć Otwórz wystąpienie metody obiektów delegowanych; oznacza to delegatów, zapewniających jawnie ukryte pierwszego argumentu wystąpienia metody. Aby uzyskać szczegółowy opis, zobacz więcej ogólnych <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> przeciążenie metody, dzięki czemu można utworzyć wszystkie kombinacje open lub closed delegatów wystąpieniem lub metody statyczne i opcjonalnie określ pierwszy argument.  
  
> [!NOTE]
>  Przeciążenie tej metody należy użyć podczas delegat nie zostaną zamknięte za pośrednictwem pierwszego argumentu, ponieważ jest nieco szybszy w takim przypadku.  
  
 Przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenie metody i określając `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do niepublicznego metody dostępu, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant metody niepublicznej jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Zgodne typy parametrów i zwracany typ  
 W programie .NET Framework w wersji 2.0 typy parametrów i typ zwracany delegata utworzone za pomocą tego przeciążenia metody muszą być zgodne z typami parametrów i typ zwracany metody, która reprezentuje delegata; typy musi dokładnie odpowiadać. Reprezentuje złagodzenie zachowanie wiązania w programie .NET Framework w wersji 1.0, 1.1, których typy muszą być zgodne.  
  
 Parametr typu delegata jest zgodny z odpowiadającego mu parametru metody, jeśli typ parametru delegowanego jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przekazany do delegata można bezpiecznie przekazany do Metoda.  
  
 Podobnie zwracany typ delegata jest zgodny z typem zwracanym metody, jeśli typ zwracany metody jest bardziej restrykcyjny niż typ zwracany delegata, ponieważ gwarantuje to, że zwracana wartość metody mogą być bezpiecznie rzutowane na zwracany typ e delegata.  
  
 Na przykład delegata z parametrem typu <xref:System.Collections.Hashtable> i typ zwracany <xref:System.Object> może reprezentować metody z parametrem typu <xref:System.Object> i zwracanej wartości typu <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. W pierwszym przykładzie pokazano dwa rodzaje obiektów delegowanych, które mogą być tworzone za pomocą tego przeciążenia metody: Otwórz za pośrednictwem metody wystąpienia a za pośrednictwem metody statycznej.  
  
 Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 **Przykład 1**  
  
 W poniższym przykładzie kodu pokazano dwa sposoby delegata mogą być tworzone przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia metody <xref:System.Delegate.CreateDelegate%2A> — metoda, która określa <xref:System.Reflection.MethodInfo> , ale pierwszy argument; ich funkcji jest taki sam, z wyjątkiem tego, co umożliwia Określ, czy ma być generowany w przypadku niepowodzenia powiązać i innych zawsze zwraca. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład deklaruje klasy `C` z metodą statyczną `M2` i metody wystąpienia `M1`, i delegowanie dwa typy: `D1` przyjmuje wystąpienia `C` i ciąg, i `D2` ciąg znaków.  
  
 Drugiej klasy o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegat typu `D1`, reprezentujący metodę otwarte wystąpienia, jest tworzona dla metody wystąpienia `M1`. Wystąpienie musi zostać przekazane podczas wywoływania delegata.  
  
-   Delegat typu `D2`, reprezentujący otwarty metody statycznej, jest tworzona dla metody statycznej `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 Przykładowy kod definiuje klasę podstawową o nazwie `Base` i klasę o nazwie `Derived` która pochodzi z `Base`. Klasa pochodna ma `static` (`Shared` w języku Visual Basic) metodę o nazwie `MyMethod` z jednym parametrem typu `Base` i typ zwracany `Derived`. Przykładowy kod definiuje również delegata o nazwie `Example` który ma jeden parametr typu `Derived` i typ zwracany `Base`.  
  
 Przykład kodu pokazuje, że delegata o nazwie `Example` może służyć do reprezentowania metody `MyMethod`. Metodę można powiązać z delegatem, ponieważ:  
  
-   Typ parametru delegata (`Derived`) jest bardziej restrykcyjny niż typ parametru `MyMethod` (`Base`), dzięki czemu zawsze jest bezpieczne argument pełnomocnika, aby przekazać `MyMethod`.  
  
-   Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpieczne rzutowanie zwracany typ metody na zwracany typ delegata.  
  
 W przykładowym kodzie nie są generowane żadne dane wyjściowe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
 —lub—  
  
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
 —lub—  
  
 <paramref name="method" /> nie jest metodą statyczną, i jest programu .NET Framework w wersji 1.0 lub 1.1.  
  
 —lub—  
  
 <paramref name="method" /> Nie można powiązać.  
  
 —lub—  
  
 <paramref name="method" /> nie jest <see langword="RuntimeMethodInfo" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="firstArgument">Obiekt, z którym jest powiązany delegata, lub <see langword="null" /> traktować <c>metody</c> jako <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic).</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Opisujące statycznych lub metody obiektu delegowanego jest do reprezentowania wystąpienia.</param>
        <summary>Tworzy określonego typu, który reprezentuje określony static lub metody wystąpienia, z określonym pierwszym argumentem delegata.</summary>
        <returns>Delegat określonego typu, który reprezentuje określony static lub metody wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie metody przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenie metody i określając `true` dla `throwOnBindFailure`. Te dwa przeciążenia umożliwiają najbardziej elastycznego do tworzenia delegatów. Można używać ich do tworzenia delegatów dla statycznych lub metody wystąpienia i opcjonalnie określ pierwszy argument.  
  
> [!NOTE]
>  Jeśli pierwszy argument nie zostanie podana, użyj <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenie metody w celu zapewnienia lepszej wydajności.  
  
 Typ delegata i metody muszą mieć zgodne typy zwracane. Oznacza to, że typ zwracany `method` musi być można przypisać do typu zwracanego przez `type`.  
  
 Jeśli `firstArgument` jest podany, jest on przekazany do `method` za każdym razem, gdy jest wywoływany delegat; `firstArgument` jest nazywany powiązać delegata, i zostanie zamknięty za pośrednictwem jego pierwszym argumentem delegata. Jeśli `method` jest `static` (`Shared` w języku Visual Basic), argument dostarczona podczas wywoływania delegat lista zawiera wszystkie parametry oprócz pierwszego; Jeśli `method` jest metodą wystąpienia `firstArgument` została przekazana do wystąpienia ukryte parametr (reprezentowane przez `this` w języku C# lub przez `Me` w języku Visual Basic).  
  
 Jeśli `firstArgument` zostanie podany, pierwszy parametr `method` musi być typem referencyjnym, i `firstArgument` muszą być zgodne z danym typem.  
  
> [!IMPORTANT]
>  Jeśli `method` jest `static` (`Shared` w języku Visual Basic) i jej pierwszy parametr jest typu <xref:System.Object> lub <xref:System.ValueType>, następnie `firstArgument` może być typem wartości. W takim przypadku `firstArgument` automatycznie jest opakowany. Automatyczne opakowywanie nie występuje inne argumenty, zgodnie z go w C# lub Visual Basic funkcji wywołać.  
  
 Jeśli `firstArgument` jest odwołanie o wartości null i `method` jest metodą wystąpienia wynik zależy od podpisów typu delegata `type` i `method`:  
  
-   Jeśli podpis `type` jawnie zawiera ukryty pierwszy parametr `method`, delegat jest nazywany do reprezentowania metody open wystąpienia. Po wywołaniu delegat pierwszego argumentu na liście argumentów jest przekazany do parametru ukryte wystąpienia `method`.  
  
-   Jeśli sygnatur `method` i `type` zgodne (to znaczy, że wszystkie typy parametrów są zgodne), następnie delegat jest nazywany zostanie zamknięty przez odwołanie o wartości null. Wywoływanie delegat przypomina na wystąpienie o wartości null, która nie jest szczególnie przydatne etapem podczas wywoływania metody wystąpienia.  
  
 Jeśli `firstArgument` jest odwołanie o wartości null i `method` jest statyczny, wynik zależy od podpisów typu delegata `type` i `method`:  
  
-   Jeśli podpis `method` i `type` zgodne (to znaczy, że wszystkie typy parametrów są zgodne), delegat jest nazywany do reprezentowania statycznej metody open. Dotyczy to najbardziej typowe dla metod statycznych. W takim przypadku nieco lepszą wydajność można uzyskać za pomocą <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenie metody.  
  
-   Jeśli podpis `type` zaczyna się od drugiego parametru `method` i pozostałe typy parametrów są niezgodne, a następnie delegat jest nazywany zostanie zamknięty przez odwołanie o wartości null. Po wywołaniu delegat odwołanie o wartości null jest przekazywany do pierwszego parametru metody `method`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do niepublicznego metody dostępu, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant metody niepublicznej jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Zgodne typy parametrów i zwracany typ  
 Typy parametrów i typ zwracany delegata musi być zgodny z typami parametrów i typ zwracany metody, która reprezentuje delegata; typy musi dokładnie odpowiadać.  
  
> [!NOTE]
>  W programie .NET Framework w wersji 1.0, 1.1 typy muszą być całkowicie zgodne.  
  
 Parametr typu delegata jest zgodny z odpowiadającego mu parametru metody, jeśli typ parametru delegowanego jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przekazany do delegata można bezpiecznie przekazany do Metoda.  
  
 Podobnie zwracany typ delegata jest zgodny z typem zwracanym metody, jeśli typ zwracany metody jest bardziej restrykcyjny niż typ zwracany delegata, ponieważ gwarantuje to, że zwracana wartość metody mogą być bezpiecznie rzutowane na zwracany typ e delegata.  
  
 Na przykład delegata z parametrem typu <xref:System.Collections.Hashtable> i typ zwracany <xref:System.Object> może reprezentować metody z parametrem typu <xref:System.Object> i zwracanej wartości typu <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Określenie metod, które może reprezentować delegat  
 Innym sposobem przydatne Rozważmy elastyczności przez to przeciążenie metody <xref:System.Delegate.CreateDelegate%2A> jest żadnego delegowania danego reprezentują cztery różne kombinacje podpis metody i rodzaj — metoda (statyczne i wystąpienie). Należy wziąć pod uwagę typ delegata `D` z jednym argumentem typu `C`. Poniżej opisano metody `D` może reprezentować ignorowanie typ zwracany, ponieważ musi on być zgodny we wszystkich przypadkach:  
  
-   `D` może reprezentować dowolnej metody wystąpienia, który ma dokładnie jeden argument typu `C`, niezależnie od tego, jakiego typu metody wystąpienia należy. Gdy <xref:System.Delegate.CreateDelegate%2A> jest nazywany `firstArgument` jest wystąpieniem typu `method` , do której należy i zamknięte przez to wystąpienie wynikowego obiektu delegowanego. (Trivially, `D` również może zostać zamknięty przez odwołanie o wartości null, jeśli `firstArgument` jest odwołanie o wartości null.)  
  
-   `D` może reprezentować metod wystąpień `C` który nie ma argumentów. Gdy <xref:System.Delegate.CreateDelegate%2A> jest nazywany `firstArgument` jest odwołanie o wartości null. Wynikowa delegata reprezentuje metody Otwórz wystąpienie i wystąpienie `C` musi zostać dostarczona zawsze jest wywoływana.  
  
-   `D` może reprezentować statyczną metodę, która przyjmuje jeden argument typu `C`, i czy metoda może należeć do dowolnego typu. Gdy <xref:System.Delegate.CreateDelegate%2A> jest nazywany `firstArgument` jest odwołanie o wartości null. Wynikowa delegata reprezentuje Otwórz metody statycznej i wystąpienie `C` musi zostać dostarczona zawsze jest wywoływana.  
  
-   `D` może reprezentować statyczną metodę, która należy do typu `F` i ma dwa argumenty typu `F` i typu `C`. Gdy <xref:System.Delegate.CreateDelegate%2A> jest nazywany `firstArgument` jest wystąpieniem `F`. Wynikowa delegata reprezentuje statyczną metodę, która jest zamknięte przez to wystąpienie `F`. Należy pamiętać, że w przypadku gdy `F` i `C` są tego samego typu, metody statycznej ma dwa argumenty typu. (W tym przypadku `D` zamknięte przez odwołanie o wartości null, jeśli `firstArgument` jest odwołanie o wartości null.)  
  
   
  
## Examples  
 Ta sekcja zawiera trzy przykłady kodu. Pierwszym przykładzie przedstawiono cztery rodzaje obiektów delegowanych, które mogą być tworzone: zamknięte za pośrednictwem metody wystąpienia, Otwórz za pośrednictwem metody wystąpienia, Otwórz za pośrednictwem metody statycznej i zamknięte za pośrednictwem metody statycznej.  
  
 Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 Trzeci przykładowy kod definiuje typ delegata pojedynczego i zawiera wszystkie metody, których typ delegowany może reprezentować.  
  
 **Przykład 1**  
  
 W poniższym przykładzie kodu pokazano cztery metody delegata mogą być tworzone przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia metody <xref:System.Delegate.CreateDelegate%2A> — metoda, która określa `firstArgument` i <xref:System.Reflection.MethodInfo>; ich funkcji jest taki sam, z wyjątkiem tego, co umożliwia Określ, czy ma być generowany w przypadku niepowodzenia powiązać i innych zawsze zwraca. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład deklaruje klasy `C` z metodą statyczną `M2` i metody wystąpienia `M1`, i trzech typów delegatów: `D1` przyjmuje wystąpienia `C` i ciąg, `D2` ciągu i `D3`nie ma argumentów.  
  
 Drugiej klasy o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegat typu `D2`zamkniętej za pośrednictwem wystąpienia `C`, jest tworzona dla metody wystąpienia `M1`. Jest wywoływana z różnych ciągami, wykazała, że wystąpienie powiązania `C` zawsze jest używany.  
  
-   Delegat typu `D1`, reprezentujący metodę otwarte wystąpienia, jest tworzona dla metody wystąpienia `M1`. Wystąpienie musi zostać przekazane podczas wywoływania delegata.  
  
-   Delegat typu `D2`, reprezentujący otwarty metody statycznej, jest tworzona dla metody statycznej `M2`.  
  
-   Na koniec delegowanego typu `D3`, zamknięte przez ciąg, jest tworzona dla metody statycznej `M2`. Metoda wywoływana w celu Pokaż korzysta z ciągu powiązania.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
> [!NOTE]
>  W tym przykładzie kodu używane <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenie metody. Użyj innych overloads które trwają <xref:System.Reflection.MethodInfo> przypomina.  
  
 Przykładowy kod definiuje klasę podstawową o nazwie `Base` i klasę o nazwie `Derived` która pochodzi z `Base`. Klasa pochodna ma `static` (`Shared` w języku Visual Basic) metodę o nazwie `MyMethod` z jednym parametrem typu `Base` i typ zwracany `Derived`. Przykładowy kod definiuje również delegata o nazwie `Example` który ma jeden parametr typu `Derived` i typ zwracany `Base`.  
  
 Przykład kodu pokazuje, że delegata o nazwie `Example` może służyć do reprezentowania metody `MyMethod`. Metodę można powiązać z delegatem, ponieważ:  
  
-   Typ parametru delegata (`Derived`) jest bardziej restrykcyjny niż typ parametru `MyMethod` (`Base`), dzięki czemu zawsze jest bezpieczne argument pełnomocnika, aby przekazać `MyMethod`.  
  
-   Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpieczne rzutowanie zwracany typ metody na zwracany typ delegata.  
  
 W przykładowym kodzie nie są generowane żadne dane wyjściowe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Przykład 3**  
  
 Poniższy przykład kodu pokazuje wszystkie metody typu delegata pojedynczego może reprezentować przy użyciu <xref:System.Delegate.CreateDelegate%2A> metody do tworzenia delegatów.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia metody <xref:System.Delegate.CreateDelegate%2A> — metoda, która określa `firstArgument` i <xref:System.Reflection.MethodInfo>; ich funkcji jest taki sam, z wyjątkiem tego, co umożliwia Określ, czy ma być generowany w przypadku niepowodzenia powiązać i innych zawsze zwraca. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład kodu definiuje dwie klasy `C` i `F`, a typem obiektu delegowanego `D` z jednym argumentem typu `C`. Klasy zawierają zgodnych statyczne i wystąpienie metody `M1`, `M3`, i `M4`, a klasa `C` ma również metody wystąpienia `M2` który nie ma argumentów.  
  
 Innej klasy o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Obiekty delegowane są tworzone dla wystąpienia metody `M1` typu `C` i typu `F`; każdego zostało zamknięte przez wystąpienie odpowiedniego typu. Metoda `M1` typu `C` Wyświetla `ID` właściwości powiązanej wystąpienia i argumentu.  
  
-   Delegat jest tworzony dla metody `M2` typu `C`. Jest to pełnomocnika otwartej instancji, w którym argumentu delegata reprezentuje ukryte pierwszy argument dla metody wystąpienia. Metoda nie ma innych argumentów. Jest to tak, jakby była metodą statyczną.  
  
-   Obiekty delegowane są tworzone dla metody statycznej `M3` typu `C` i typu `F`; są one otwarte statycznych obiektów delegowanych.  
  
-   Na koniec delegatów są tworzone dla metody statycznej `M4` typu `C` i typu `F`; każda metoda ma typ deklarujący jako pierwszego argumentu i wystąpienie typu został podany, więc delegatów są zamykane za pośrednictwem ich pierwszym argumentów . Metoda `M4` typu `C` Wyświetla `ID` właściwości powiązanej wystąpienia i argumentu.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
 —lub—  
  
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
 —lub—  
  
 <paramref name="method" /> Nie można powiązać.  
  
 —lub—  
  
 <paramref name="method" /> nie jest <see langword="RuntimeMethodInfo" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="target">Wystąpienie klasy, w którym <c>metoda</c> jest wywoływana.</param>
        <param name="method">Nazwa metody wystąpienia, która ma reprezentować delegata.</param>
        <summary>Tworzy delegata określonego typu, który reprezentuje określone wystąpienie metody w wystąpieniu określonej klasy.</summary>
        <returns>Delegat określonego typu, który reprezentuje określone wystąpienie metody w wystąpieniu określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów na przykład tylko metody. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 Przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenia metody, określając `false` dla `ignoreCase` i `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do niepublicznego metody dostępu, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant metody niepublicznej jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="target" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
 —lub—  
  
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
 —lub—  
  
 <paramref name="method" /> nie jest metodą wystąpienia.  
  
 —lub—  
  
 <paramref name="method" /> Nie można powiązać, np. ponieważ nie można odnaleźć.</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Opisujące statycznych lub metody obiektu delegowanego jest do reprezentowania wystąpienia.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli <c>metody</c> nie może być powiązane; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy określonego typu do reprezentowania określonej metody statycznej z określonego zachowania w przypadku awarii można powiązać delegata.</summary>
        <returns>Delegat określonego typu do reprezentowania określonej metody statycznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenie tej metody można utworzyć delegatów Otwórz metody statycznej i otwórz wystąpienie metody delegatów — to znaczy delegatów, które udostępniają ukryte pierwszego argumentu wystąpienia metody. Aby uzyskać szczegółowy opis, zobacz więcej ogólnych <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenie metody, dzięki czemu można na przykład utworzyć wszystkie kombinacje delegatów open lub closed lub metod statycznych.  
  
> [!NOTE]
>  Przeciążenie tej metody należy użyć podczas delegat nie zostaną zamknięte za pośrednictwem pierwszego argumentu, ponieważ jest nieco szybszy w takim przypadku.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do niepublicznego metody dostępu, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant metody niepublicznej jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Zgodne typy parametrów i zwracany typ  
 Typy parametrów i typ zwracany delegata musi być zgodny z typami parametrów i typ zwracany metody, która reprezentuje delegata; typy musi dokładnie odpowiadać.  
  
> [!NOTE]
>  W programie .NET Framework w wersji 1.0, 1.1 typy muszą być całkowicie zgodne.  
  
 Parametr typu delegata jest zgodny z odpowiadającego mu parametru metody, jeśli typ parametru delegowanego jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przekazany do delegata można bezpiecznie przekazany do Metoda.  
  
 Podobnie zwracany typ delegata jest zgodny z typem zwracanym metody, jeśli typ zwracany metody jest bardziej restrykcyjny niż typ zwracany delegata, ponieważ gwarantuje to, że zwracana wartość metody mogą być bezpiecznie rzutowane na zwracany typ e delegata.  
  
 Na przykład delegata z parametrem typu <xref:System.Collections.Hashtable> i typ zwracany <xref:System.Object> może reprezentować metody z parametrem typu <xref:System.Object> i zwracanej wartości typu <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. W pierwszym przykładzie pokazano dwa rodzaje obiektów delegowanych, które mogą być tworzone za pomocą tego przeciążenia metody: Otwórz za pośrednictwem metody wystąpienia a za pośrednictwem metody statycznej.  
  
 Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 **Przykład 1**  
  
 W poniższym przykładzie kodu pokazano dwa sposoby delegata mogą być tworzone przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia metody <xref:System.Delegate.CreateDelegate%2A> — metoda, która określa <xref:System.Reflection.MethodInfo> , ale pierwszy argument; ich funkcji jest taki sam, z wyjątkiem tego, co umożliwia Określ, czy ma być generowany w przypadku niepowodzenia powiązać i innych zawsze zwraca. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład deklaruje klasy `C` z metodą statyczną `M2` i metody wystąpienia `M1`, i delegowanie dwa typy: `D1` przyjmuje wystąpienia `C` i ciąg, i `D2` ciąg znaków.  
  
 Drugiej klasy o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegat typu `D1`, reprezentujący metodę otwarte wystąpienia, jest tworzona dla metody wystąpienia `M1`. Wystąpienie musi zostać przekazane podczas wywoływania delegata.  
  
-   Delegat typu `D2`, reprezentujący otwarty metody statycznej, jest tworzona dla metody statycznej `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
> [!NOTE]
>  W tym przykładzie kodu używane <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenie metody. Użyj innych overloads które trwają <xref:System.Reflection.MethodInfo> przypomina.  
  
 Przykładowy kod definiuje klasę podstawową o nazwie `Base` i klasę o nazwie `Derived` która pochodzi z `Base`. Klasa pochodna ma `static` (`Shared` w języku Visual Basic) metodę o nazwie `MyMethod` z jednym parametrem typu `Base` i typ zwracany `Derived`. Przykładowy kod definiuje również delegata o nazwie `Example` który ma jeden parametr typu `Derived` i typ zwracany `Base`.  
  
 Przykład kodu pokazuje, że delegata o nazwie `Example` może służyć do reprezentowania metody `MyMethod`. Metodę można powiązać z delegatem, ponieważ:  
  
-   Typ parametru delegata (`Derived`) jest bardziej restrykcyjny niż typ parametru `MyMethod` (`Base`), dzięki czemu zawsze jest bezpieczne argument pełnomocnika, aby przekazać `MyMethod`.  
  
-   Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpieczne rzutowanie zwracany typ metody na zwracany typ delegata.  
  
 W przykładowym kodzie nie są generowane żadne dane wyjściowe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
 —lub—  
  
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
 —lub—  
  
 <paramref name="method" /> Nie można powiązać, i <paramref name="throwOnBindFailure" /> jest <see langword="true" />.  
  
 —lub—  
  
 <paramref name="method" /> nie jest <see langword="RuntimeMethodInfo" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="target">
          <see cref="T:System.Type" /> Reprezentujący klasę, która implementuje <c>metody</c>.</param>
        <param name="method">Nazwa statyczną metodę, która ma reprezentować delegata.</param>
        <summary>Tworzy delegata określonego typu, który reprezentuje określonej metody statycznej określonej klasy.</summary>
        <returns>Delegat określonego typu, który reprezentuje określonej metody statycznej określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów tylko metody statyczne. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 Przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenia metody, określając `false` dla `ignoreCase` i `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do niepublicznego metody dostępu, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant metody niepublicznej jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="target" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
 —lub—  
  
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
 —lub—  
  
 <paramref name="target" /> nie jest <see langword="RuntimeType" />.  
  
 —lub—  
  
 <paramref name="target" /> jest to otwarty typ ogólny. Oznacza to, że jego <see cref="P:System.Type.ContainsGenericParameters" /> jest właściwość <see langword="true" />.  
  
 —lub—  
  
 <paramref name="method" /> nie jest <see langword="static" /> — metoda (<see langword="Shared" /> metody w języku Visual Basic).  
  
 —lub—  
  
 <paramref name="method" /> Nie można powiązać, np. ponieważ nie można odnaleźć, i <paramref name="throwOnBindFailure" /> jest <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> reprezentujący typ delegata do utworzenia.</param>
        <param name="firstArgument">
          <see cref="T:System.Object" /> Oznacza to pierwszy argument metody reprezentuje delegata. Dla wystąpienia metody, musi ona zgodna z typem wystąpienia.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Opisujące statycznych lub metody obiektu delegowanego jest do reprezentowania wystąpienia.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli <c>metody</c> nie może być powiązane; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy określonego typu, który reprezentuje określony static lub metody wystąpienia, z określonym pierwszy argument i określonego zachowania w przypadku awarii można powiązać delegata.</summary>
        <returns>Delegat określony typ, który reprezentuje określony static lub metody wystąpienia lub <see langword="null" /> Jeśli <paramref name="throwOnBindFailure" /> jest <see langword="false" /> i nie można powiązać delegata z <paramref name="method" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody i <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> przeciążenie metody, która zawsze zgłoszenie błędu można powiązać, podaj najbardziej elastyczny sposób do tworzenia delegatów. Służy ich do tworzenia delegatów dla statycznych lub metody wystąpienia, z lub bez pierwszy argument.  
  
> [!NOTE]
>  Jeśli pierwszy argument nie zostanie podana, użyj <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenie metody w celu zapewnienia lepszej wydajności.  
  
 Typ delegata i metody muszą mieć zgodne typy zwracane. Oznacza to, że typ zwracany `method` musi być można przypisać do typu zwracanego przez `type`.  
  
 Jeśli `firstArgument` jest podany, jest on przekazany do `method` za każdym razem, gdy jest wywoływany delegat; `firstArgument` jest nazywany powiązać delegata, i zostanie zamknięty za pośrednictwem jego pierwszym argumentem delegata. Jeśli `method` jest `static` (`Shared` w języku Visual Basic), argument dostarczona podczas wywoływania delegat lista zawiera wszystkie parametry oprócz pierwszego; Jeśli `method` jest metodą wystąpienia `firstArgument` została przekazana do wystąpienia ukryte parametr (reprezentowane przez `this` w języku C# lub przez `Me` w języku Visual Basic).  
  
 Jeśli `firstArgument` zostanie podany, pierwszy parametr `method` musi być typem referencyjnym, i `firstArgument` muszą być zgodne z danym typem.  
  
> [!IMPORTANT]
>  Jeśli `method` jest `static` (`Shared` w języku Visual Basic) i jej pierwszy parametr jest typu <xref:System.Object> lub <xref:System.ValueType>, następnie `firstArgument` może być typem wartości. W takim przypadku `firstArgument` automatycznie jest opakowany. Automatyczne opakowywanie nie występuje inne argumenty, zgodnie z go w C# lub Visual Basic funkcji wywołać.  
  
 Jeśli `firstArgument` jest odwołanie o wartości null i `method` jest metodą wystąpienia wynik zależy od podpisów typu delegata `type` i `method`:  
  
-   Jeśli podpis `type` jawnie zawiera ukryty pierwszy parametr `method`, delegat jest nazywany do reprezentowania metody open wystąpienia. Po wywołaniu delegat pierwszego argumentu na liście argumentów jest przekazany do parametru ukryte wystąpienia `method`.  
  
-   Jeśli sygnatur `method` i `type` zgodne (to znaczy, że wszystkie typy parametrów są zgodne), następnie delegat jest nazywany zostanie zamknięty przez odwołanie o wartości null. Wywoływanie delegat przypomina na wystąpienie o wartości null, która nie jest szczególnie przydatne etapem podczas wywoływania metody wystąpienia.  
  
 Jeśli `firstArgument` jest odwołanie o wartości null i `method` jest statyczny, wynik zależy od podpisów typu delegata `type` i `method`:  
  
-   Jeśli podpis `method` i `type` zgodne (to znaczy, że wszystkie typy parametrów są zgodne), delegat jest nazywany do reprezentowania statycznej metody open. Dotyczy to najbardziej typowe dla metod statycznych. W takim przypadku nieco lepszą wydajność można uzyskać za pomocą <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenie metody.  
  
-   Jeśli podpis `type` zaczyna się od drugiego parametru `method` i pozostałe typy parametrów są niezgodne, a następnie delegat jest nazywany zostanie zamknięty przez odwołanie o wartości null. Po wywołaniu delegat odwołanie o wartości null jest przekazywany do pierwszego parametru metody `method`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do niepublicznego metody dostępu, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant metody niepublicznej jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Zgodne typy parametrów i zwracany typ  
 Typy parametrów i typ zwracany delegata musi być zgodny z typami parametrów i typ zwracany metody, która reprezentuje delegata; typy musi dokładnie odpowiadać.  
  
> [!NOTE]
>  W programie .NET Framework w wersji 1.0, 1.1 typy muszą być całkowicie zgodne.  
  
 Parametr typu delegata jest zgodny z odpowiadającego mu parametru metody, jeśli typ parametru delegowanego jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przekazany do delegata można bezpiecznie przekazany do Metoda.  
  
 Podobnie zwracany typ delegata jest zgodny z typem zwracanym metody, jeśli typ zwracany metody jest bardziej restrykcyjny niż typ zwracany delegata, ponieważ gwarantuje to, że zwracana wartość metody mogą być bezpiecznie rzutowane na zwracany typ e delegata.  
  
 Na przykład delegata z parametrem typu <xref:System.Collections.Hashtable> i typ zwracany <xref:System.Object> może reprezentować metody z parametrem typu <xref:System.Object> i zwracanej wartości typu <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Określenie metod, które może reprezentować delegat  
 Innym sposobem przydatne Rozważmy elastyczności przez to przeciążenie metody <xref:System.Delegate.CreateDelegate%2A> jest żadnego delegowania danego reprezentują cztery różne kombinacje podpis metody i rodzaj — metoda (statyczne i wystąpienie). Należy wziąć pod uwagę typ delegata `D` z jednym argumentem typu `C`. Poniżej opisano metody `D` może reprezentować ignorowanie typ zwracany, ponieważ musi on być zgodny we wszystkich przypadkach:  
  
-   `D` może reprezentować dowolnej metody wystąpienia, który ma dokładnie jeden argument typu `C`, niezależnie od tego, jakiego typu metody wystąpienia należy. Gdy <xref:System.Delegate.CreateDelegate%2A> jest nazywany `firstArgument` jest wystąpieniem typu `method` , do której należy i zamknięte przez to wystąpienie wynikowego obiektu delegowanego. (Trivially, `D` również może zostać zamknięty przez odwołanie o wartości null, jeśli `firstArgument` jest `null`.)  
  
-   `D` może reprezentować metod wystąpień `C` który nie ma argumentów. Gdy <xref:System.Delegate.CreateDelegate%2A> jest nazywany `firstArgument` jest odwołanie o wartości null. Wynikowa delegata reprezentuje metody Otwórz wystąpienie i wystąpienie `C` musi zostać dostarczona zawsze jest wywoływana.  
  
-   `D` może reprezentować statyczną metodę, która przyjmuje jeden argument typu `C`, i czy metoda może należeć do dowolnego typu. Gdy <xref:System.Delegate.CreateDelegate%2A> jest nazywany `firstArgument` jest odwołanie o wartości null. Wynikowa delegata reprezentuje Otwórz metody statycznej i wystąpienie `C` musi zostać dostarczona zawsze jest wywoływana.  
  
-   `D` może reprezentować statyczną metodę, która należy do typu `F` i ma dwa argumenty typu `F` i typu `C`. Gdy <xref:System.Delegate.CreateDelegate%2A> jest nazywany `firstArgument` jest wystąpieniem `F`. Wynikowa delegata reprezentuje statyczną metodę, która jest zamknięte przez to wystąpienie `F`. Należy pamiętać, że w przypadku gdy `F` i `C` są tego samego typu, metody statycznej ma dwa argumenty typu. (W tym przypadku `D` zamknięte przez odwołanie o wartości null, jeśli `firstArgument` jest `null`.)  
  
   
  
## Examples  
 Ta sekcja zawiera trzy przykłady kodu. Pierwszym przykładzie przedstawiono cztery rodzaje obiektów delegowanych, które mogą być tworzone: zamknięte za pośrednictwem metody wystąpienia, Otwórz za pośrednictwem metody wystąpienia, Otwórz za pośrednictwem metody statycznej i zamknięte za pośrednictwem metody statycznej.  
  
 Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 Trzeci przykładowy kod definiuje typ delegata pojedynczego i zawiera wszystkie metody, których typ delegowany może reprezentować.  
  
 **Przykład 1**  
  
 W poniższym przykładzie kodu pokazano cztery metody delegata mogą być tworzone przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia metody <xref:System.Delegate.CreateDelegate%2A> — metoda, która określa `firstArgument` i <xref:System.Reflection.MethodInfo>; ich funkcji jest taki sam, z wyjątkiem tego, co umożliwia Określ, czy ma być generowany w przypadku niepowodzenia powiązać i innych zawsze zwraca. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład deklaruje klasy `C` z metodą statyczną `M2` i metody wystąpienia `M1`, i trzech typów delegatów: `D1` przyjmuje wystąpienia `C` i ciąg, `D2` ciągu i `D3`nie ma argumentów.  
  
 Drugiej klasy o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegat typu `D2`zamkniętej za pośrednictwem wystąpienia `C`, jest tworzona dla metody wystąpienia `M1`. Jest wywoływana z różnych ciągami, wykazała, że wystąpienie powiązania `C` zawsze jest używany.  
  
-   Delegat typu `D1`, reprezentujący metodę otwarte wystąpienia, jest tworzona dla metody wystąpienia `M1`. Wystąpienie musi zostać przekazane podczas wywoływania delegata.  
  
-   Delegat typu `D2`, reprezentujący otwarty metody statycznej, jest tworzona dla metody statycznej `M2`.  
  
-   Na koniec delegowanego typu `D3`, zamknięte przez ciąg, jest tworzona dla metody statycznej `M2`. Metoda wywoływana w celu Pokaż korzysta z ciągu powiązania.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
> [!NOTE]
>  W tym przykładzie kodu używane <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenie metody. Użyj innych overloads które trwają <xref:System.Reflection.MethodInfo> przypomina.  
  
 Przykładowy kod definiuje klasę podstawową o nazwie `Base` i klasę o nazwie `Derived` która pochodzi z `Base`. Klasa pochodna ma `static` (`Shared` w języku Visual Basic) metodę o nazwie `MyMethod` z jednym parametrem typu `Base` i typ zwracany `Derived`. Przykładowy kod definiuje również delegata o nazwie `Example` który ma jeden parametr typu `Derived` i typ zwracany `Base`.  
  
 Przykład kodu pokazuje, że delegata o nazwie `Example` może służyć do reprezentowania metody `MyMethod`. Metodę można powiązać z delegatem, ponieważ:  
  
-   Typ parametru delegata (`Derived`) jest bardziej restrykcyjny niż typ parametru `MyMethod` (`Base`), dzięki czemu zawsze jest bezpieczne argument pełnomocnika, aby przekazać `MyMethod`.  
  
-   Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpieczne rzutowanie zwracany typ metody na zwracany typ delegata.  
  
 W przykładowym kodzie nie są generowane żadne dane wyjściowe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Przykład 3**  
  
 Poniższy przykład kodu pokazuje wszystkie metody, które może wymagać typu delegata pojedynczego.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia metody <xref:System.Delegate.CreateDelegate%2A> — metoda, która określa `firstArgument` i <xref:System.Reflection.MethodInfo>; ich funkcji jest taki sam, z wyjątkiem tego, co umożliwia Określ, czy ma być generowany w przypadku niepowodzenia powiązać i innych zawsze zwraca. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład kodu definiuje dwie klasy `C` i `F`, a typem obiektu delegowanego `D` z jednym argumentem typu `C`. Klasy zawierają zgodnych statyczne i wystąpienie metody `M1`, `M3`, i `M4`, a klasa `C` ma również metody wystąpienia `M2` który nie ma argumentów.  
  
 Innej klasy o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Obiekty delegowane są tworzone dla wystąpienia metody `M1` typu `C` i typu `F`; każdego zostało zamknięte przez wystąpienie odpowiedniego typu. Metoda `M1` typu `C` Wyświetla `ID` właściwości powiązanej wystąpienia i argumentu.  
  
-   Delegat jest tworzony dla metody `M2` typu `C`. Jest to pełnomocnika otwartej instancji, w którym argumentu delegata reprezentuje ukryte pierwszy argument dla metody wystąpienia. Metoda nie ma innych argumentów.  
  
-   Obiekty delegowane są tworzone dla metody statycznej `M3` typu `C` i typu `F`; są one otwarte statycznych obiektów delegowanych.  
  
-   Na koniec delegatów są tworzone dla metody statycznej `M4` typu `C` i typu `F`; każda metoda ma typ deklarujący jako pierwszego argumentu i wystąpienie typu został podany, więc delegatów są zamykane za pośrednictwem ich pierwszym argumentów . Metoda `M4` typu `C` Wyświetla `ID` właściwości powiązanej wystąpienia i argumentu.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
 —lub—  
  
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
 —lub—  
  
 <paramref name="method" /> Nie można powiązać, i <paramref name="throwOnBindFailure" /> jest <see langword="true" />.  
  
 —lub—  
  
 <paramref name="method" /> nie jest <see langword="RuntimeMethodInfo" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="target">Wystąpienie klasy, w którym <c>metoda</c> jest wywoływana.</param>
        <param name="method">Nazwa metody wystąpienia, która ma reprezentować delegata.</param>
        <param name="ignoreCase">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</param>
        <summary>Tworzy delegata określonego typu, który reprezentuje określone wystąpienie metody w wystąpieniu określonej klasy z określonym rozróżnianiem wielkości liter.</summary>
        <returns>Delegat określonego typu, który reprezentuje określone wystąpienie metody w wystąpieniu określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów na przykład tylko metody. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 Przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenia metody, określając `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do niepublicznego metody dostępu, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant metody niepublicznej jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="target" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
 —lub—  
  
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
 —lub—  
  
 <paramref name="method" /> nie jest metodą wystąpienia.  
  
 —lub—  
  
 <paramref name="method" /> Nie można powiązać, np. ponieważ nie można odnaleźć.</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="target">
          <see cref="T:System.Type" /> Reprezentujący klasę, która implementuje <c>metody</c>.</param>
        <param name="method">Nazwa statyczną metodę, która ma reprezentować delegata.</param>
        <param name="ignoreCase">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</param>
        <summary>Tworzy delegata określonego typu, który reprezentuje określonej metody statycznej określonej klasy, z określonym rozróżnianiem wielkości liter.</summary>
        <returns>Delegat określonego typu, który reprezentuje określonej metody statycznej określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów tylko metody statyczne. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 Przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenia metody, określając `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do niepublicznego metody dostępu, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant metody niepublicznej jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="target" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
 —lub—  
  
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
 —lub—  
  
 <paramref name="target" /> nie jest <see langword="RuntimeType" />.  
  
 —lub—  
  
 <paramref name="target" /> jest to otwarty typ ogólny. Oznacza to, że jego <see cref="P:System.Type.ContainsGenericParameters" /> jest właściwość <see langword="true" />.  
  
 —lub—  
  
 <paramref name="method" /> nie jest <see langword="static" /> — metoda (<see langword="Shared" /> metody w języku Visual Basic).  
  
 —lub—  
  
 <paramref name="method" /> Nie można powiązać, np. ponieważ nie można odnaleźć.</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="target">Wystąpienie klasy, w którym <c>metoda</c> jest wywoływana.</param>
        <param name="method">Nazwa metody wystąpienia, która ma reprezentować delegata.</param>
        <param name="ignoreCase">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli <c>metody</c> nie może być powiązane; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy określonego typu, który reprezentuje określone wystąpienie metody wystąpienia określonej klasy, z określonym uwzględnianie wielkości liter i określonego zachowania w przypadku awarii można powiązać delegata.</summary>
        <returns>Delegat określonego typu, który reprezentuje określone wystąpienie metody w wystąpieniu określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów na przykład tylko metody. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do niepublicznego metody dostępu, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant metody niepublicznej jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="target" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
 —lub—  
  
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
 —lub—  
  
 <paramref name="method" /> nie jest metodą wystąpienia.  
  
 —lub—  
  
 <paramref name="method" /> Nie można powiązać, np. ponieważ nie można odnaleźć, i <paramref name="throwOnBindFailure" /> jest <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="target">
          <see cref="T:System.Type" /> Reprezentujący klasę, która implementuje <c>metody</c>.</param>
        <param name="method">Nazwa statyczną metodę, która ma reprezentować delegata.</param>
        <param name="ignoreCase">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli <c>metody</c> nie może być powiązane; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy określonego typu, który reprezentuje określonej metody statycznej określonej klasy, z określonym uwzględnianie wielkości liter i określonego zachowania w przypadku awarii można powiązać delegata.</summary>
        <returns>Delegat określonego typu, który reprezentuje określonej metody statycznej określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów tylko metody statyczne. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do niepublicznego metody dostępu, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant metody niepublicznej jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="target" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
 —lub—  
  
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbicia](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
 —lub—  
  
 <paramref name="target" /> nie jest <see langword="RuntimeType" />.  
  
 —lub—  
  
 <paramref name="target" /> jest to otwarty typ ogólny. Oznacza to, że jego <see cref="P:System.Type.ContainsGenericParameters" /> jest właściwość <see langword="true" />.  
  
 —lub—  
  
 <paramref name="method" /> nie jest <see langword="static" /> — metoda (<see langword="Shared" /> metody w języku Visual Basic).  
  
 —lub—  
  
 <paramref name="method" /> Nie można powiązać, np. ponieważ nie można odnaleźć, i <paramref name="throwOnBindFailure" /> jest <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Tablica obiektów, które są argumenty do przekazania do metodę reprezentowaną przez bieżące delegata.  
  
 —lub—  
  
 <see langword="null" />, jeśli metodę reprezentowaną przez bieżące delegata nie wymaga argumentów.</param>
        <summary>Dynamicznie wywołuje (późnym wiązaniem) metodę reprezentowaną przez bieżące delegata.</summary>
        <returns>Obiekt zwrócony przez metodę reprezentowaną przez delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.Delegate.DynamicInvokeImpl%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).  
  
 —lub—  
  
 Numer zamówienia i typu na liście parametrów <paramref name="args" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException">Metodę reprezentowaną przez delegat jest wywoływane na obiekt lub klasa, która nie obsługuje.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Metodę reprezentowaną przez delegat jest metodą wystąpienia i obiekt docelowy jest <see langword="null" />.  
  
 —lub—  
  
 Jedną z metod hermetyzowany zgłasza wyjątek.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">Tablica obiektów, które są argumenty do przekazania do metodę reprezentowaną przez bieżące delegata.  
  
 —lub—  
  
 <see langword="null" />, jeśli metodę reprezentowaną przez bieżące delegata nie wymaga argumentów.</param>
        <summary>Dynamicznie wywołuje (późnym wiązaniem) metodę reprezentowaną przez bieżące delegata.</summary>
        <returns>Obiekt zwrócony przez metodę reprezentowaną przez delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje <xref:System.Delegate.DynamicInvoke%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).  
  
 —lub—  
  
 Numer zamówienia i typu na liście parametrów <paramref name="args" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException">Metodę reprezentowaną przez delegat jest wywoływane na obiekt lub klasa, która nie obsługuje.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Metodę reprezentowaną przez delegat jest metodą wystąpienia i obiekt docelowy jest <see langword="null" />.  
  
 —lub—  
  
 Jedną z metod hermetyzowany zgłasza wyjątek.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z bieżącym obiektem delegowanym.</param>
        <summary>Określa, czy określony obiekt i bieżącego delegata są tego samego typu i udostępnianie tego samego elementów docelowych, metod i listy wywołania.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> i bieżącego delegat ma tego samego elementów docelowych, metod i listy wywołania; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dwa obiekty delegowane nie są tego samego typu, nie jest uwzględniana takie same.  
  
> [!IMPORTANT]
>  W programie .NET Framework w wersji 1.0, 1.1 dwóch delegatów zostały uznane za takie same, jeśli ich elementów docelowych, metod i listy wywołania były takie same, nawet jeżeli różnych typów delegatów.  
  
 Metody i obiekty docelowe są porównywane pod kątem równości w następujący sposób:  
  
-   Jeśli te dwie metody są porównywane są statyczne i tej samej metody na tej samej klasy, metody są traktowane jako równe i elementy docelowe również są traktowane jako równe.  
  
-   Jeśli te dwie metody są porównywane metody wystąpienia i tej samej metody dla tego samego obiektu, metody są traktowane jako równe i elementy docelowe również są traktowane jako równe.  
  
-   W przeciwnym razie metod nie są traktowane jako równe i elementy docelowe również nie są uważane za równe.  
  
 Dwie listy wywołania są traktowane jako identyczne, tylko wtedy, gdy mają one taką samą kolejność i odpowiednie elementy z dwoma listami reprezentują te same metody i docelowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla obiekt delegowany.</summary>
        <returns>Wartość skrótu dla obiekt delegowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana tej metody nie musi utrwalone dwóch powodów. Najpierw funkcji skrótu klasy może zostać zmienione w celu Generowanie lepsze dystrybucji renderowania wartości z starego funkcji skrótu bezużyteczny. Po drugie Domyślna implementacja tej klasy nie gwarantuje, że taką samą wartość zwracaną przez różnych wystąpień.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę wywołania delegata.</summary>
        <returns>Tablica obiektów delegowanych reprezentujący listy wywołania bieżącego obiektu delegowanego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy delegata w tablicy reprezentuje dokładnie jedną metodę.  
  
 Kolejność delegatów w tablicy jest tej samej kolejności, w którym bieżącego obiektu delegowanego wywołuje metody, które reprezentują tych obiektów delegowanych.  
  
   
  
## Examples  
 Poniższy przykład przypisuje trzy metody delegata. Następnie wywołuje <xref:System.Delegate.GetInvocationList%2A> metodę, aby pobrać całkowita liczba metod przypisane do delegata, można wykonać delegatów w odwrotnej kolejności i wykonywanie metod, którego nazwa zawiera podciąg "Plik".  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera metody statycznej reprezentowany przez bieżącego obiektu delegowanego.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> opisujące metody statycznej reprezentowany przez bieżącego obiektu delegowanego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma zastosowanie tylko wtedy, gdy bieżący delegata reprezentuje metody statycznej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Nieobsługiwane.</param>
        <param name="context">Nieobsługiwane.</param>
        <summary>Nieobsługiwane.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obsługiwana.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metodę reprezentowaną przez delegata.</summary>
        <value>A <see cref="T:System.Reflection.MethodInfo" /> opisujące metodę reprezentowaną przez delegata.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Pierwszy delegata do porównania.</param>
        <param name="d2">Delegat drugi do porównania.</param>
        <summary>Określa, czy określony delegatów są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="d1" /> jest równa <paramref name="d2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa obiekty delegowane tego samego typu z tej samej elementy docelowe, metod i listy wywołania są traktowane jako równe.  
  
 Jeśli dwa obiekty delegowane nie są tego samego typu, nie jest uwzględniana takie same.  
  
> [!IMPORTANT]
>  W programie .NET Framework w wersji 1.0, 1.1 dwóch delegatów zostały uznane za takie same, jeśli ich elementów docelowych, metod i listy wywołania były takie same, nawet jeżeli różnych typów delegatów.  
  
 Metody i obiekty docelowe są porównywane pod kątem równości w następujący sposób:  
  
-   Jeśli te dwie metody są porównywane są statyczne i tej samej metody na tej samej klasy, metody są traktowane jako równe i elementy docelowe również są traktowane jako równe.  
  
-   Jeśli te dwie metody są porównywane metody wystąpienia i tej samej metody dla tego samego obiektu, metody są traktowane jako równe i elementy docelowe również są traktowane jako równe.  
  
-   W przeciwnym razie metod nie są traktowane jako równe i elementy docelowe również nie są uważane za równe.  
  
 Dwie listy wywołania są traktowane jako identyczne, jeśli mają taką samą kolejność i odpowiednie elementy z dwoma listami reprezentują te same metody i docelowej.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Pierwszy delegata do porównania.</param>
        <param name="d2">Delegat drugi do porównania.</param>
        <summary>Określa, czy określony delegatów nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="d1" /> nie jest równa <paramref name="d2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa obiekty delegowane nie są uważane za taki sam, jeśli są różnych typów lub różnych metod, różnych elementów docelowych lub list innego wywołania.  
  
 Jeśli dwa obiekty delegowane nie są tego samego typu, nie jest uwzględniana takie same.  
  
> [!IMPORTANT]
>  W programie .NET Framework w wersji 1.0, 1.1 dwa obiekty delegowane są traktowane jako równe, jeśli ich elementów docelowych, metod i listy wywołania były takie same, nawet jeżeli różnych typów delegatów.  
  
 Metody i obiekty docelowe są porównywane pod kątem równości w następujący sposób:  
  
-   Jeśli te dwie metody są porównywane są statyczne i tej samej metody na tej samej klasy, metody są traktowane jako równe i elementy docelowe również są traktowane jako równe.  
  
-   Jeśli te dwie metody są porównywane metody wystąpienia i tej samej metody dla tego samego obiektu, metody są traktowane jako równe i elementy docelowe również są traktowane jako równe.  
  
-   W przeciwnym razie metod nie są traktowane jako równe i elementy docelowe również nie są uważane za równe.  
  
 Dwie listy wywołania nie są takie same, jeśli mają różne rozmiary, jeśli są uporządkowane inaczej lub co najmniej jeden element z listy jeden reprezentuje metody lub docelowego, który różni się od reprezentowany przez jej odpowiadającego mu elementu na liście inne.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Delegat, z którego mają zostać usunięte wywołanie lista <c>wartość</c>.</param>
        <param name="value">Delegata, który dostarcza listy wywołania do usunięcia z listy wywołania <c>źródła</c>.</param>
        <summary>Usuwa ostatniego wystąpienia listy wywołania delegata z listy wywołanie innego obiektu delegowanego.</summary>
        <returns>Nowe delegowanie przy użyciu listy wywołania utworzony listy wywołania <paramref name="source" /> i usuwanie ostatniego wystąpienia listy wywołania <paramref name="value" />, jeśli na liście wywołania <paramref name="value" /> znajduje się na liście wywołania <paramref name="source" />. Zwraca <paramref name="source" /> Jeśli <paramref name="value" /> jest <see langword="null" /> lub, jeśli na liście wywołania <paramref name="value" /> nie znajduje się na liście wywołania <paramref name="source" />. Zwraca odwołanie o wartości null, jeśli na liście wywołania <paramref name="value" /> jest taki sam, jak lista wywołania <paramref name="source" /> lub, jeśli <paramref name="source" /> jest odwołanie o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli na liście wywołania `value` odpowiada ciągłe zbiór elementów na liście wywołania `source`, następnie wywołania listę `value` mówimy na liście wywołania `source`. Jeśli na liście wywołania `value` występuje więcej niż raz na liście wywołania `source`, ostatnie wystąpienie zostanie usunięta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <exception cref="T:System.ArgumentException">Typy delegatów są niezgodne.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Delegat, z którego mają zostać usunięte wywołanie lista <c>wartość</c>.</param>
        <param name="value">Delegata, który dostarcza listy wywołania do usunięcia z listy wywołania <c>źródła</c>.</param>
        <summary>Usuwa wszystkie wystąpienia listy wywołania delegata z listy wywołanie innego obiektu delegowanego.</summary>
        <returns>Nowe delegowanie przy użyciu listy wywołania utworzony listy wywołania <paramref name="source" /> i usunięcie wszystkich wystąpień elementu listy wywołania <paramref name="value" />, jeśli na liście wywołania <paramref name="value" /> znajduje się na liście wywołania <paramref name="source" />. Zwraca <paramref name="source" /> Jeśli <paramref name="value" /> jest <see langword="null" /> lub, jeśli na liście wywołania <paramref name="value" /> nie znajduje się na liście wywołania <paramref name="source" />. Zwraca odwołanie o wartości null, jeśli na liście wywołania <paramref name="value" /> jest taki sam, jak lista wywołania <paramref name="source" />, jeśli <paramref name="source" /> zawiera tylko szereg listy wywołania, które są takie same na liście wywołania <paramref name="value" />, lub, jeśli <paramref name="source" /> ma wartość null odwołanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli na liście wywołania `value` odpowiada ciągłe zbiór elementów na liście wywołania `source`, następnie wywołania listę `value` mówimy na liście wywołania `source`. Jeśli na liście wywołania `value` występuje więcej niż raz na liście wywołania `source`, zostaną usunięte wszystkie wystąpienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <exception cref="T:System.ArgumentException">Typy delegatów są niezgodne.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">Delegat, który dostarcza listy wywołania do usunięcia z listy wywołania bieżącego obiektu delegowanego.</param>
        <summary>Usuwa listy wywołania delegata z listy wywołanie innego obiektu delegowanego.</summary>
        <returns>Nowe delegowanie przy użyciu listy wywołania utworzone przez pobranie listy wywołania bieżącego obiektu delegowanego i usuwanie listy wywołania <paramref name="value" />, jeśli na liście wywołania <paramref name="value" /> znajduje się w obrębie listy wywołania bieżącego obiektu delegowanego. Zwraca bieżący delegata, jeśli <paramref name="value" /> jest <see langword="null" /> lub, jeśli na liście wywołania <paramref name="value" /> nie można odnaleźć w bieżącym delegata wywołania listy. Zwraca <see langword="null" /> Jeśli wywołanie lista <paramref name="value" /> jest taki sam, jak bieżący delegata wywołania listy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli na liście wywołania `value` odpowiada ciągłe zbiór elementów w bieżącym delegata wywołania listy, a następnie na liście wywołania `value` mówimy w obrębie bieżącego delegata wywołania listy. Jeśli na liście wywołania `value` występuje więcej niż raz na liście wywołania delegata bieżącego ostatniego wystąpienia zostanie usunięta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wystąpienie klasy, w którym bieżącego obiektu delegowanego wywołuje metodę wystąpienia.</summary>
        <value>Obiekt, na którym bieżącego obiektu delegowanego wywołuje metodę wystąpienia, jeśli delegat reprezentuje metodę wystąpienia; <see langword="null" /> Jeśli delegat reprezentuje metody statycznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 Jeśli delegat wywołuje co najmniej jedną metodę wystąpienia, ta właściwość zwraca docelowy metody ostatniego wystąpienia na liście wywołania.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="018e5371bd85cbb8ad0cda7ecba314155412268d" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51896602" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje delegata, która jest strukturą danych, która odwołuje się do metody statycznej lub wystąpienie klasy i metody wystąpienia tej klasy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate> Klasa to klasa podstawowa dla typów obiektów delegowanych. Jednak tylko system i kompilatorów mogą dziedziczyć jawnie <xref:System.Delegate> klasy lub <xref:System.MulticastDelegate> klasy. Ponadto nie jest dozwolone do wyprowadzenia nowego typu z typem delegowanym. <xref:System.Delegate> Klasy nie jest uznawany za typ delegata; jest klasą używaną do wyprowadzenia typy delegatów.  
  
 Implementowanie większość języków `delegate` — słowo kluczowe i kompilatorów dla tych języków mogą pochodzić od <xref:System.MulticastDelegate> klasy; dlatego użytkownicy powinni używać `delegate` — słowo kluczowe, dostarczone przez język.  
  
> [!NOTE]
>  Środowisko uruchomieniowe języka wspólnego `Invoke` metody dla każdego typu delegata z taką samą sygnaturę jak delegat. Nie trzeba jawnie wywołać tę metodę w języku C#, Visual Basic lub Visual C++, ponieważ kompilatory wywołać ją automatycznie. `Invoke` Metoda jest przydatna w [odbicia](~/docs/framework/reflection-and-codedom/reflection.md) kiedy chcesz odnaleźć podpisu typu delegata.  
  
 Środowisko uruchomieniowe języka wspólnego zawiera każdy typ delegata z `BeginInvoke` i `EndInvoke` metody, aby włączyć asynchroniczne wywołanie delegata. Aby uzyskać więcej informacji o tych metodach, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 Deklaracja typu delegata ustanawia kontraktu, który określa podpis co najmniej jednej metody. Obiekt delegowany jest wystąpieniem typu delegata, który zawiera odwołania do:  
  
-   Metoda wystąpienia, typem i obiekt docelowy, który można przypisać do tego typu.  
  
-   Metoda wystąpienia typu, przy użyciu ukrytego `this` parametru widoczne na liście parametrów formalnych. Delegat jest określane jako Otwórz wystąpienie delegata.  
  
-   Metoda statyczna.  
  
-   Metoda statyczna i obiekt docelowy, który można przypisać do pierwszego parametru metody. Delegat jest nazywany zamknięte w ciągu pierwszego argumentu.  
  
 Aby uzyskać więcej informacji o powiązaniach delegatów, zobacz <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenie metody.  
  
> [!NOTE]
>  W wersjach programu .NET Framework 1.0 i 1.1 delegata może reprezentować metodę, tylko wtedy, gdy sygnatura metody dokładnie pasuje do oznaczenia określonego przez typ delegata. W związku z tym obsługiwane są tylko pierwszy i trzeci punktory na powyższej liście, a pierwszy punktor wymaga dopasowania dokładnego typu.  
  
 Gdy obiekt delegowany reprezentuje metodę wystąpienia, zamknięte przez swój pierwszy argument (najbardziej typowe wielkości liter), delegat przechowuje odwołanie do metody punktu wejścia i odwołanie do obiektu o nazwie obiektu docelowego, który można przypisać do typu, który zdefiniowany typ Metoda. Obiekt delegowany reprezentuje otwartą metodę wystąpienia, są przechowywane odwołania do metody punktu wejścia. Podpis delegata może zawierać ukryte `this` parametru na liście parametrów formalnych; w takim przypadku delegat nie ma odwołanie do obiektu docelowego i obiekt docelowy musi być podany obiekt delegowany jest wywoływany.  
  
 Gdy obiekt delegowany reprezentuje metodę statyczną, delegat przechowuje odwołania do metody punktu wejścia. Gdy obiekt delegowany reprezentuje metodę statyczną zamknięte w ciągu pierwszego argumentu, delegat przechowuje odwołanie do metody punktu wejścia i odwołanie do obiektu docelowego, który można przypisać do typu pierwszego argumentu metody. Gdy obiekt delegowany jest wywoływany, pierwszy argument metody statycznej odbiera obiektu docelowego.  
  
 Listy wywołań obiektu delegowanego jest uporządkowany zestaw obiektów delegowanych, w których każdy element listy wywołuje dokładnie jeden z metody reprezentowanej przez delegata. Listę wywołań może zawierać zduplikowanych metody. Podczas wywoływania metody są wywoływane w kolejności, w jakiej są wyświetlane na liście wywołania. Delegat próbuje wywołać co metodę liście wywołania; duplikaty są wywoływane, gdy dla każdej godziny są wyświetlane na liście wywołania. Delegaty są niezmienne; Po utworzeniu listy wywołań obiektu delegowanego nie zmienia się.  
  
 Delegaty są określane jako multiemisji lub możliwych do łączenia, ponieważ delegata można wywołać jedną lub więcej metod i mogą być używane w połączeniu operacji.  
  
 Łącząc operacje, takie jak <xref:System.Delegate.Combine%2A> i <xref:System.Delegate.Remove%2A>, nie należy zmieniać istniejących obiektów delegowanych. Zamiast tego taka operacja zwraca nowy delegata, który zawiera wyniki operacji, delegat bez zmian lub `null`. Operacja łączenia zwraca `null` po wyniku operacji jest delegat, który nie odwołuje się do co najmniej jedną metodę. Operacja łączenia zwraca delegat bez zmian, gdy żądana operacja nie ma wpływu.  
  
> [!NOTE]
>  Użyj języki zarządzane <xref:System.Delegate.Combine%2A> i <xref:System.Delegate.Remove%2A> metody służące do implementacji operacje delegata. Przykłady obejmują `AddHandler` i `RemoveHandler` instrukcji w języku Visual Basic i operatory "+= i-=" na delegowanie typów w języku C#.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], ogólnymi typami delegatów mogą mieć wariantne parametry typu. Kontrawariantnych parametrów typu można używać jako typy parametrów delegata i kowariantnego parametru typu może służyć jako typ zwracany. Ta funkcja umożliwia Delegat ogólny typy, które są konstruowane na podstawie jednej definicji typu ogólnego, aby być zgodny przypisania, jeśli ich argumentów typu są typami odwołań przy użyciu relacji dziedziczenia, jak wyjaśniono w [kowariancji i Kontrawariancja](~/docs/standard/generics/covariance-and-contravariance.md).  
  
> [!NOTE]
>  Delegaty ogólne, które są zgodne z przypisania ze względu na odchylenie nie są zawsze możliwych do łączenia. Jako możliwych do łączenia, typy musi dokładnie pasować. Na przykład załóżmy, że klasę o nazwie `Derived` jest pochodną klasę o nazwie `Base`. Delegat typu `Action<Base>` (`Action(Of Base)` w języku Visual Basic) można przypisać do zmiennej typu `Action<Derived>`, ale nie można łączyć dwóch obiektów delegowanych, ponieważ typy nie są dokładnie zgodne.  
  
 Wywołana metoda zgłasza wyjątek, metoda zatrzymuje wykonywanie, wyjątek jest przekazywany z powrotem do obiektu wywołującego delegata i pozostałe metody na liście wywołania nie są wywoływane. Przechwytywanie wyjątku w obiekcie wywołującym nie zmienia to zachowanie.  
  
 Po podpis metody wywoływane przez obiekt delegowany zawiera wartości zwracanej, delegat zwraca wartość zwracaną wartość ostatniego elementu na liście wywołania. Jeśli podpis zawiera parametr, który jest przekazywany przez odwołanie, końcowa wartość parametru jest wynik każdej metody na liście wywołania, wykonanie sekwencyjne i aktualizowania wartości parametru.  
  
 Najbliższy wielokrotność delegata w C lub C++ jest wskaźnik funkcji. Delegat może reprezentować metodę statyczną lub metodą wystąpienia. Gdy delegat reprezentuje metodę wystąpienia, delegat przechowuje nie tylko odwołanie do metody punktu wejścia, ale również odwołanie do wystąpienia klasy. W przeciwieństwie do wskaźników funkcji obiekty delegowane są zorientowana obiektowo i bezpieczeństwa typów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje jak zdefiniować delegata, o nazwie `myMethodDelegate`. Wystąpienia tego obiektu delegowanego są tworzone dla metody wystąpienia i niestatyczną metodą zagnieżdżonego `mySampleClass` klasy. Delegata dla metody wystąpienia wymaga wystąpienia `mySampleClass`. `mySampleClass` Wystąpienia jest zapisywane w zmiennej o nazwie `mySC`.  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">Wywołanie metod synchronicznych w sposób asynchroniczny</related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">Delegaty (Przewodnik programowania w języku C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">Delegaty (Visual Basic)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">Porady: definiowanie obiektów delegowanych (C++/CLI) oraz korzystanie z nich</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">Obsługa i wywoływanie zdarzeń</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe delegowanie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">Wystąpienie klasy, na którym wywołuje delegata <c>metoda</c>.</param>
        <param name="method">Nazwa metody wystąpienia, który reprezentuje obiekt delegowany.</param>
        <summary>Inicjuje obiekt delegowany, wywołuje metodę wystąpienia określonego wystąpienia określonej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor nie można użyć w kodzie aplikacji. Do utworzenia delegata, określając nazwę metody wystąpienia, używanie przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, która określa nazwę metody i obiekt docelowy. Na przykład <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> przeciążenie metody tworzy delegata dla metody wystąpienie o określonej nazwie.  
  
 Ten konstruktor tworzy delegatów dla wystąpienia tylko metody. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wystąpił błąd wiązania do metody docelowej.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Type" /> Reprezentujący klasę, która definiuje <c>metoda</c>.</param>
        <param name="method">Nazwa metody statycznej, który reprezentuje obiekt delegowany.</param>
        <summary>Inicjuje delegat, który wywołuje określoną metodę statyczną z określonej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor nie można użyć w kodzie aplikacji. Do utworzenia delegata, określając nazwę metody statycznej, użyj przeciążenia <xref:System.Delegate.CreateDelegate%2A> metodę, która określa nazwę metody, ale nie określa obiektu docelowego. Na przykład <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> przeciążenie metody tworzy statyczny delegata dla metody o określonej nazwie.  
  
 Ten konstruktor tworzy delegatów dla tylko metody statyczne. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="target" /> reprezentuje otwartym typem ogólnym.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię pobieżną delegata.</summary>
        <returns>Płytka kopia elementu delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klon ma taką samą <xref:System.Type>, listy docelowej, metody i wywołania jak oryginalny obiekt delegowany.  
  
 Wykonywana jest płytka kopia tworzy nowe wystąpienie tego samego typu co oryginalny obiekt, a następnie kopiuje niestatycznego pola oryginalnego obiektu. Jeśli pole jest typem wartości, bit przez bitowy kopię pole jest wykonywane. Jeśli pole jest typem referencyjnym, odwołanie jest kopiowane, ale przywoływanego obiektu jest; w związku z tym odwołań w oryginalnym obiekcie i odwołania w klonu wskazują ten sam obiekt. Natomiast głębokie kopiowanie obiektu duplikuje wszystko bezpośrednio lub pośrednio odwołuje się pola w obiekcie.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Łączy listę wywołania delegatów multiemisji określony (combinable).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">Tablica obiektów delegowanych, aby połączyć.</param>
        <summary>Łączy listę wywołania tablicę obiektów delegowanych.</summary>
        <returns>Nowe delegowanie przy użyciu listy wywołania łączącej list wywołania delegatów w <paramref name="delegates" /> tablicy. Zwraca <see langword="null" /> Jeśli <paramref name="delegates" /> jest <see langword="null" />, jeśli <paramref name="delegates" /> zawiera zero elementy, lub w przypadku każdego wpisu w <paramref name="delegates" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `delegates` tablica zawiera wpisy, które są `null`, te wpisy są ignorowane.  
  
 Lista wywołania może zawierać zduplikowane wpisy. oznacza to, wpisy, które odwołują się do tej samej metody na tym samym obiekcie.  
  
> [!NOTE]
>  Delegaty ogólne, które są zgodne z przypisania ze względu na odchylenie nie są zawsze możliwych do łączenia. Jako możliwych do łączenia, typy musi dokładnie pasować. Na przykład załóżmy, że klasę o nazwie `Derived` jest pochodną klasę o nazwie `Base`. Delegat typu `Action<Base>` (`Action(Of Base)` w języku Visual Basic) można przypisać do zmiennej typu `Action<Derived>`, jak wyjaśniono w [kowariancji i kontrawariancji](~/docs/standard/generics/covariance-and-contravariance.md), ale nie można połączyć dwa delegaty, ponieważ typy zrobić nie są dokładnie zgodne.  
  
 <xref:System.Delegate.Combine%2A> jest przydatne do tworzenia programów obsługi zdarzeń, które występuje wiele metod czas zdarzenia wywołań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie wszystkie wpisy inną niż null w <paramref name="delegates" /> wystąpień tego samego typu delegata.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">Delegat wykorzystasz którego lista wywołania.</param>
        <param name="b">Delegat, w których listy wywołań pochodzi ostatni.</param>
        <summary>Łączy listę wywołania dwóch delegatów.</summary>
        <returns>Nowy delegat z listy wywołań, która łączy wywołania wykazy <paramref name="a" /> i <paramref name="b" /> w tej kolejności. Zwraca <paramref name="a" /> Jeśli <paramref name="b" /> jest <see langword="null" />, zwraca <paramref name="b" /> Jeśli <paramref name="a" /> jest odwołanie o wartości null i zwraca odwołanie o wartości null, jeśli obie <paramref name="a" /> i <paramref name="b" /> są odwołaniami o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lista wywołania może zawierać zduplikowane wpisy. oznacza to, wpisy, które odwołują się do tej samej metody na tym samym obiekcie.  
  
> [!NOTE]
>  Delegaty ogólne, które są zgodne z przypisania ze względu na odchylenie nie są zawsze możliwych do łączenia. Jako możliwych do łączenia, typy musi dokładnie pasować. Na przykład załóżmy, że klasę o nazwie `Derived` jest pochodną klasę o nazwie `Base`. Delegat typu `Action<Base>` (`Action(Of Base)` w języku Visual Basic) można przypisać do zmiennej typu `Action<Derived>`, jak wyjaśniono w [kowariancji i kontrawariancji](~/docs/standard/generics/covariance-and-contravariance.md), ale nie można połączyć dwa delegaty, ponieważ typy zrobić nie są dokładnie zgodne.  
  
 <xref:System.Delegate.Combine%2A> jest przydatne do tworzenia programów obsługi zdarzeń, które występuje wiele metod czas zdarzenia wywołań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Zarówno <paramref name="a" /> i <paramref name="b" /> nie <see langword="null" />, i <paramref name="a" /> i <paramref name="b" /> nie są wystąpieniami tego samego typu delegata.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">Multiemisji (combinable) delegować delegować którego lista wywołania do dołączenia na końcu listy wywołania bieżącego multiemisji (combinable).</param>
        <summary>Łączy listę wywołania określonego delegata (combinable) multiemisji i bieżącej multiemisji delegata (combinable).</summary>
        <returns>Nowe multiemisja (combinable) delegowanie przy użyciu listy wywołania łączącej listy wywołania bieżącego multiemisji delegata (combinable) i listę wywołania <paramref name="d" />, lub delegować bieżącego multiemisji (możliwych do łączenia), jeśli <paramref name="d" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma zastosowanie tylko wtedy, gdy bieżący delegat jest multiemisji (combinable).  
  
 Bieżąca implementacja parametru po prostu wywołuje wyjątek <xref:System.MulticastNotSupportedException>.  
  
 Lista wywołania może zawierać zduplikowane wpisy. oznacza to, wpisy, które odwołują się do tej samej metody na tym samym obiekcie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Zawsze generowany.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy delegata, o określonym typie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Opisujące statyczną lub metodę ma reprezentować delegat wystąpienia. W .NET Framework w wersji 1.0 i 1.1, obsługiwane są tylko metody statyczne.</param>
        <summary>Tworzy obiekt delegowany określonego typu i reprezentują określonej metody statycznej.</summary>
        <returns>Delegat określonego typu do reprezentowania określonej metody statycznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W .NET Framework w wersji 1.0 i 1.1 tego przeciążenia metody tworzy delegatów dla tylko metody statyczne. W .NET Framework w wersji 2.0 tego przeciążenia metody również utworzyć Otwórz wystąpienie metody delegatów; oznacza to delegatów, które jawnie dostarczyć ukryte pierwszy argument wystąpienia metody. Aby uzyskać szczegółowy opis Zobacz bardziej ogólnej <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> przeciążenia metody, która pozwala na tworzenie wszystkich kombinacji delegatów otwarte lub zamknięte dla wystąpienia lub metody statyczne i opcjonalnie określ pierwszy argument.  
  
> [!NOTE]
>  Tego przeciążenia metody należy użyć gdy delegat nie jest zamknięty przez swój pierwszy argument, ponieważ jest trochę szybszy w takiej sytuacji.  
  
 Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenie metody i określając `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do metod niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień metod niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Zgodne typy parametrów i zwracany typ  
 W .NET Framework w wersji 2.0 typy parametrów i typ zwracany obiektu delegowanego utworzone za pomocą tego przeciążenia metody muszą być zgodne z typami parametrów i zwracany typ metody, który reprezentuje obiekt delegowany; typy musi dokładnie odpowiadać. Reprezentuje złagodzenie zachowanie wiązania w .NET Framework w wersji 1.0 i 1.1, których typy muszą być zgodne.  
  
 Parametru obiektu delegowanego jest zgodny z odpowiednim parametrem metody, jeśli typ parametru delegata jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przekazany do obiektu delegowanego można bezpiecznie przekazać do Metoda.  
  
 Podobnie zwracany typ delegata jest zgodny z typem zwracanym metody, jeśli typ zwracany metody jest bardziej restrykcyjny niż typ zwracany obiektu delegowanego, ponieważ gwarantuje to, że wartość zwracana metody może być bezpiecznie umieszczona na zwracany typ e delegata.  
  
 Na przykład delegat z parametrem typu <xref:System.Collections.Hashtable> i zwracanym typem <xref:System.Object> może reprezentować metodę z parametrem typu <xref:System.Object> oraz wartość zwracaną typu <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. W pierwszym przykładzie pokazano dwa rodzaje obiektów delegowanych, które mogą być tworzone za pomocą tego przeciążenia metody: Otwórz za pośrednictwem metody wystąpienia, a następnie otwórz za pośrednictwem metody statycznej.  
  
 Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 **Przykład 1**  
  
 Poniższy przykład kodu pokazuje dwa sposoby delegata można tworzyć przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> — określające <xref:System.Reflection.MethodInfo> , ale pierwszy argument; ich funkcjonalność jest taka sama, z tą różnicą, że jeden pozwala określić, czy po niepowodzeniu do powiązania, a drugi zawsze zgłasza. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład deklaruje klasę `C` przy użyciu statycznej metody `M2` i metoda wystąpienia `M1`, i dwa typy delegatów: `D1` przyjmuje wystąpienie klasy `C` i ciąg, a `D2` ciąg znaków.  
  
 Druga klasa o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegat typu `D1`, reprezentujący otwartą metodę wystąpienia, jest tworzony dla metody wystąpienia `M1`. Wystąpienie musi zostać przekazane podczas wywoływania delegata.  
  
-   Delegat typu `D2`, reprezentujący otwartą metodę statyczną, jest tworzony dla metody statycznej `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 Przykładowy kod definiuje klasę bazową, o nazwie `Base` i klasę o nazwie `Derived` który pochodzi od klasy `Base`. Klasa pochodna zawiera `static` (`Shared` w języku Visual Basic) metodę o nazwie `MyMethod` z jednym parametrem typu `Base` i zwracanym typem `Derived`. Przykład kodu jest również definiowany delegat o nazwie `Example` posiadającą jeden parametr typu `Derived` i zwracanym typem `Base`.  
  
 Przykład kodu demonstruje, że delegat o nazwie `Example` może służyć do reprezentowania metody `MyMethod`. Metodę można powiązać z delegatem, ponieważ:  
  
-   Typ parametru delegata (`Derived`) jest bardziej restrykcyjny niż typ parametru `MyMethod` (`Base`), dzięki czemu jest zawsze można bezpiecznie przekazać argument delegata do `MyMethod`.  
  
-   Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpieczne rzutować zwracany typ metody do zwracanego typu delegata.  
  
 W przykładowym kodzie nie są generowane żadne dane wyjściowe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="method" /> nie jest statyczna metoda, a wersja programu .NET Framework jest w wersji 1.0 lub 1.1.  
  
—lub— 
 <paramref name="method" /> Nie można powiązać.  
  
—lub— 
 <paramref name="method" /> nie jest <see langword="RuntimeMethodInfo" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnienia niezbędne do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="firstArgument">Obiekt, z którym powiązany jest delegat, lub <see langword="null" /> traktowanie <c>metoda</c> jako <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic).</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Opisujące statyczną lub metodę ma reprezentować delegat wystąpienia.</param>
        <summary>Tworzy delegata określonego typu, który reprezentuje określony statyczna lub metoda wystąpienia, z pierwszego określonego argumentu.</summary>
        <returns>Delegat określonego typu, który reprezentuje określony statyczną lub metodę wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenie metody i określając `true` dla `throwOnBindFailure`. Te dwa przeciążenia zawierają najbardziej elastyczny sposób do tworzenia obiektów delegowanych. Można ich użyć do tworzenia delegatów dla statycznych lub metoda instancji i opcjonalnie określ pierwszy argument.  
  
> [!NOTE]
>  Jeśli pierwszy argument nie zostanie podana, należy użyć <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenie metody w celu zapewnienia lepszej wydajności.  
  
 Typ delegata, a także metoda musi mieć zgodne typy zwracane. Oznacza to, że typ zwracany `method` musi być przypisane do zwracanego typu `type`.  
  
 Jeśli `firstArgument` jest podany, zostanie on przekazany do `method` za każdym razem, gdy obiekt delegowany jest wywoływany; `firstArgument` jest nazywany powiązać z delegatem, i delegowany jest zamknięte w ciągu pierwszego argumentu. Jeśli `method` jest `static` (`Shared` w języku Visual Basic), argument dostarczona podczas wywoływania delegata lista zawiera wszystkie parametry z wyjątkiem pierwszej; Jeśli `method` jest metodą wystąpienia `firstArgument` są przekazywane do wystąpienia ukryte parametr (reprezentowane przez `this` w języku C# lub przez `Me` w języku Visual Basic).  
  
 Jeśli `firstArgument` jest podany, pierwszy parametr `method` musi być typem referencyjnym, i `firstArgument` muszą być zgodne z danym typem.  
  
> [!IMPORTANT]
>  Jeśli `method` jest `static` (`Shared` w języku Visual Basic), a jej pierwszy parametr jest typu <xref:System.Object> lub <xref:System.ValueType>, następnie `firstArgument` może być typem wartości. W tym przypadku `firstArgument` jest automatycznie ramce. Automatyczne pakowanie nie występuje żadnych argumentów, jak w języku C# lub Visual Basic funkcji wywołałby.  
  
 Jeśli `firstArgument` jest odwołanie o wartości null i `method` jest metodą wystąpienia, wynik zależy od podpisy typu delegata `type` i `method`:  
  
-   Jeśli podpis `type` jawnie zawierającym ukryte pierwszy parametr `method`, delegowany jest reprezentujący otwartą metodę wystąpienia. Gdy obiekt delegowany jest wywoływany, pierwszy argument na liście argumentów jest przekazywany do parametru instance ukrytych z `method`.  
  
-   Jeśli sygnatur `method` i `type` dopasowania (oznacza to, że wszystkie typy parametrów są zgodne), a następnie delegowany jest zamknięte przez odwołanie o wartości null. Wywołanie delegata jest podobne do wywołania metody wystąpienia na wystąpienie o wartości null, która nie jest szczególnie przydatne niczego robić.  
  
 Jeśli `firstArgument` jest odwołanie o wartości null i `method` jest statyczny, wynik zależy od podpisy typu delegata `type` i `method`:  
  
-   Jeśli podpis `method` i `type` dopasowania (oznacza to, że wszystkie typy parametrów są zgodne), delegowany jest reprezentujący otwartą metodę statyczną. Dotyczy to najbardziej typowe dla metod statycznych. W tym przypadku nieco lepszą wydajność można uzyskać za pomocą <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenie metody.  
  
-   Jeśli podpis `type` zaczyna się od drugiego parametru `method` i pozostałe typy parametrów są niezgodne, a następnie delegowany jest zamknięte przez odwołanie o wartości null. Gdy obiekt delegowany jest wywoływany, odwołanie o wartości null jest przekazywana do pierwszy parametr `method`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do metod niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień metod niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Zgodne typy parametrów i zwracany typ  
 Typy parametrów i typ zwracany obiektu delegowanego musi być zgodny z typami parametrów i zwracany typ metody, który reprezentuje obiekt delegowany; typy musi dokładnie odpowiadać.  
  
> [!NOTE]
>  W .NET Framework w wersji 1.0 i 1.1 typy musi dokładnie pasować.  
  
 Parametru obiektu delegowanego jest zgodny z odpowiednim parametrem metody, jeśli typ parametru delegata jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przekazany do obiektu delegowanego można bezpiecznie przekazać do Metoda.  
  
 Podobnie zwracany typ delegata jest zgodny z typem zwracanym metody, jeśli typ zwracany metody jest bardziej restrykcyjny niż typ zwracany obiektu delegowanego, ponieważ gwarantuje to, że wartość zwracana metody może być bezpiecznie umieszczona na zwracany typ e delegata.  
  
 Na przykład delegat z parametrem typu <xref:System.Collections.Hashtable> i zwracanym typem <xref:System.Object> może reprezentować metodę z parametrem typu <xref:System.Object> oraz wartość zwracaną typu <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Określenie metod, które może reprezentować delegat  
 Innym sposobem przydatne z elastyczności, jaką to przeciążenie <xref:System.Delegate.CreateDelegate%2A> jest, że wszelkie danego które może reprezentować delegat cztery różne kombinacje podpis metody i rodzaju metody (statyczne w porównaniu z wystąpienia). Należy wziąć pod uwagę typ delegata `D` z jednym argumentem typu `C`. Poniżej opisano metody `D` może reprezentować ignoruje typ zwracany, ponieważ musi on być zgodny we wszystkich przypadkach:  
  
-   `D` może reprezentować dowolną metodę wystąpienia, która ma dokładnie jednego argumentu typu `C`, niezależnie od tego, jakiego typu, którego należy metoda wystąpienia. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest wystąpieniem typu `method` , do której należy i wynikowego delegata ma zostać zamknięte w ciągu tego wystąpienia. (W przypadku, `D` również może zostać zamknięty przez odwołanie o wartości null, jeśli `firstArgument` jest odwołanie o wartości null.)  
  
-   `D` może reprezentować metodę wystąpienia `C` , nie ma argumentów. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest odwołanie o wartości null. Wynikowego delegata reprezentuje otwartą metodę wystąpienia, a wystąpienie `C` musi zostać dostarczony zawsze jest wywoływany.  
  
-   `D` może reprezentować statycznej metody, która przyjmuje jeden argument typu `C`, oraz że metoda mogą należeć do dowolnego typu. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest odwołanie o wartości null. Wynikowego delegata reprezentuje otwartą metodę statyczną i wystąpienie `C` musi zostać dostarczony zawsze jest wywoływany.  
  
-   `D` może reprezentować statycznej metody, która należy do typu `F` i ma dwa argumenty typu `F` i typ `C`. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest wystąpieniem `F`. Metoda statyczna, który jest zamknięty przez to wystąpienie reprezentuje wynikowy obiekt delegowany `F`. Należy pamiętać, że w przypadku których `F` i `C` tego samego typu, statycznej metody ma dwa argumenty typu. (W tym przypadku `D` zamknięte przez odwołanie o wartości null, jeśli `firstArgument` jest odwołanie o wartości null.)  
  
   
  
## Examples  
 Ta sekcja zawiera trzy przykłady kodu. Pierwszy przykład przedstawia cztery rodzaje obiektów delegowanych, które mogą być tworzone: zamknięte za pośrednictwem metody wystąpienia, otwartego za pośrednictwem metody wystąpienia, otwartego za pośrednictwem statycznej metody i zamknięte przez metodę statyczną.  
  
 Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 Trzeci przykład kodu Określa typ delegata pojedynczego i pokazuje, że wszystkie metody, których typ delegowany może reprezentować.  
  
 **Przykład 1**  
  
 Poniższy przykład kodu demonstruje cztery sposoby delegata można tworzyć przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> — określające `firstArgument` i <xref:System.Reflection.MethodInfo>; ich funkcjonalność jest taka sama, z tą różnicą, że jeden pozwala określić, czy po niepowodzeniu do powiązania, a drugi zawsze zgłasza. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład deklaruje klasę `C` za pomocą metody statycznej `M2` i metoda wystąpienia `M1`, i trzy typy delegatów: `D1` przyjmuje wystąpienie klasy `C` i ciąg, `D2` przyjmuje parametry i `D3`nie ma argumentów.  
  
 Druga klasa o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegat typu `D2`, zamknięte przez wystąpienie `C`, jest tworzony dla metody wystąpienia `M1`. Jest wywoływany przy użyciu różnych ciągów, aby pokazać, że wystąpienia związanego `C` jest zawsze używana.  
  
-   Delegat typu `D1`, reprezentujący otwartą metodę wystąpienia, jest tworzony dla metody wystąpienia `M1`. Wystąpienie musi zostać przekazane podczas wywoływania delegata.  
  
-   Delegat typu `D2`, reprezentujący otwartą metodę statyczną, jest tworzony dla metody statycznej `M2`.  
  
-   Na koniec delegat typu `D3`, zamknięte przez ciąg, jest tworzony dla metody statycznej `M2`. Metoda jest wywoływana do wyświetlenia, korzysta z powiązanej ciągu.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
> [!NOTE]
>  W tym przykładzie kodu użyto <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenie metody. Użyj innych przeciążeń przybierają tego <xref:System.Reflection.MethodInfo> jest podobny.  
  
 Przykładowy kod definiuje klasę bazową, o nazwie `Base` i klasę o nazwie `Derived` który pochodzi od klasy `Base`. Klasa pochodna zawiera `static` (`Shared` w języku Visual Basic) metodę o nazwie `MyMethod` z jednym parametrem typu `Base` i zwracanym typem `Derived`. Przykład kodu jest również definiowany delegat o nazwie `Example` posiadającą jeden parametr typu `Derived` i zwracanym typem `Base`.  
  
 Przykład kodu demonstruje, że delegat o nazwie `Example` może służyć do reprezentowania metody `MyMethod`. Metodę można powiązać z delegatem, ponieważ:  
  
-   Typ parametru delegata (`Derived`) jest bardziej restrykcyjny niż typ parametru `MyMethod` (`Base`), dzięki czemu jest zawsze można bezpiecznie przekazać argument delegata do `MyMethod`.  
  
-   Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpieczne rzutować zwracany typ metody do zwracanego typu delegata.  
  
 W przykładowym kodzie nie są generowane żadne dane wyjściowe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Przykład 3**  
  
 Poniższy przykład kodu pokazuje wszystkie metody typ pojedynczego obiektu delegowanego może reprezentować przy użyciu <xref:System.Delegate.CreateDelegate%2A> metodą tworzenia delegatów.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> — określające `firstArgument` i <xref:System.Reflection.MethodInfo>; ich funkcjonalność jest taka sama, z tą różnicą, że jeden pozwala określić, czy po niepowodzeniu do powiązania, a drugi zawsze zgłasza. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykładowy kod definiuje dwie klasy `C` i `F`, a typ delegata `D` z jednym argumentem typu `C`. Klasy mają odpowiednie statycznych lub wystąpienie metody `M1`, `M3`, i `M4`, a klasa `C` ma również metodą wystąpienia `M2` , nie ma argumentów.  
  
 Trzecim klasę o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegaty są tworzone na przykład metoda `M1` typu `C` i typ `F`; każdy zostało zamknięte przez wystąpienie odpowiedniego typu. Metoda `M1` typu `C` Wyświetla `ID` właściwości powiązanej wystąpienia i argumentu.  
  
-   Obiekt delegowany jest tworzony dla metody `M2` typu `C`. Jest to delegat Otwórz wystąpienie, w której argument delegata reprezentuje ukryte pierwszy argument dla metody wystąpienia. Metoda nie ma innych argumentów. Jest to tak, jakby był to metoda statyczna.  
  
-   Delegaty są tworzone dla metody statycznej `M3` typu `C` i typ `F`; są one otwarte statycznych obiektów delegowanych.  
  
-   Na koniec obiekty delegowane są tworzone dla metody statycznej `M4` typu `C` i typ `F`; każda metoda charakteryzuje się typ deklarujący jako swój pierwszy argument, a wystąpienie tego typu jest podany, więc delegatów zostaną zamknięte za pośrednictwem ich pierwszym argumentów . Metoda `M4` typu `C` Wyświetla `ID` właściwości powiązanej wystąpienia i argumentu.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="method" /> Nie można powiązać.  
  
—lub— 
 <paramref name="method" /> nie jest <see langword="RuntimeMethodInfo" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnienia niezbędne do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="target">Wystąpienie klasy, na którym <c>metoda</c> jest wywoływana.</param>
        <param name="method">Nazwa metody wystąpienia, która ma reprezentować delegat.</param>
        <summary>Tworzy obiekt delegowany określony typ, który reprezentuje określonego wystąpienia metody do wywołania na wystąpienie określonej klasy.</summary>
        <returns>Delegat określonego typu, który reprezentuje metodę określone wystąpienie do wywołania na wystąpienie określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów dla wystąpienia tylko metody. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenia metody, określając `false` dla `ignoreCase` i `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do metod niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień metod niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="target" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="method" /> nie jest metodą wystąpienia.  
  
—lub— 
 <paramref name="method" /> Nie można powiązać, na przykład ponieważ nie można odnaleźć.</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnienia niezbędne do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Opisujące statyczną lub metodę ma reprezentować delegat wystąpienia.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli <c>metoda</c> nie może być; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy określonego typu do reprezentowania określonej metody statycznej z określonego zachowania w przypadku niepowodzenia, można powiązać delegata.</summary>
        <returns>Delegat określonego typu do reprezentowania określonej metody statycznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego przeciążenia metody można utworzyć delegatów otwartą metodę statyczną i otwórz wystąpienie metody delegatów — czyli delegatów, które ujawniają ukryte pierwszy argument wystąpienia metody. Aby uzyskać szczegółowy opis Zobacz bardziej ogólnej <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenia metody, dzięki czemu można na przykład utworzyć wszystkie kombinacje delegatów otwarte lub zamknięte lub metod statycznych.  
  
> [!NOTE]
>  Tego przeciążenia metody należy użyć gdy delegat nie jest zamknięty przez swój pierwszy argument, ponieważ jest trochę szybszy w takiej sytuacji.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do metod niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień metod niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Zgodne typy parametrów i zwracany typ  
 Typy parametrów i typ zwracany obiektu delegowanego musi być zgodny z typami parametrów i zwracany typ metody, który reprezentuje obiekt delegowany; typy musi dokładnie odpowiadać.  
  
> [!NOTE]
>  W .NET Framework w wersji 1.0 i 1.1 typy musi dokładnie pasować.  
  
 Parametru obiektu delegowanego jest zgodny z odpowiednim parametrem metody, jeśli typ parametru delegata jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przekazany do obiektu delegowanego można bezpiecznie przekazać do Metoda.  
  
 Podobnie zwracany typ delegata jest zgodny z typem zwracanym metody, jeśli typ zwracany metody jest bardziej restrykcyjny niż typ zwracany obiektu delegowanego, ponieważ gwarantuje to, że wartość zwracana metody może być bezpiecznie umieszczona na zwracany typ e delegata.  
  
 Na przykład delegat z parametrem typu <xref:System.Collections.Hashtable> i zwracanym typem <xref:System.Object> może reprezentować metodę z parametrem typu <xref:System.Object> oraz wartość zwracaną typu <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. W pierwszym przykładzie pokazano dwa rodzaje obiektów delegowanych, które mogą być tworzone za pomocą tego przeciążenia metody: Otwórz za pośrednictwem metody wystąpienia, a następnie otwórz za pośrednictwem metody statycznej.  
  
 Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 **Przykład 1**  
  
 Poniższy przykład kodu pokazuje dwa sposoby delegata można tworzyć przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> — określające <xref:System.Reflection.MethodInfo> , ale pierwszy argument; ich funkcjonalność jest taka sama, z tą różnicą, że jeden pozwala określić, czy po niepowodzeniu do powiązania, a drugi zawsze zgłasza. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład deklaruje klasę `C` przy użyciu statycznej metody `M2` i metoda wystąpienia `M1`, i dwa typy delegatów: `D1` przyjmuje wystąpienie klasy `C` i ciąg, a `D2` ciąg znaków.  
  
 Druga klasa o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegat typu `D1`, reprezentujący otwartą metodę wystąpienia, jest tworzony dla metody wystąpienia `M1`. Wystąpienie musi zostać przekazane podczas wywoływania delegata.  
  
-   Delegat typu `D2`, reprezentujący otwartą metodę statyczną, jest tworzony dla metody statycznej `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
> [!NOTE]
>  W tym przykładzie kodu użyto <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenie metody. Użyj innych przeciążeń przybierają tego <xref:System.Reflection.MethodInfo> jest podobny.  
  
 Przykładowy kod definiuje klasę bazową, o nazwie `Base` i klasę o nazwie `Derived` który pochodzi od klasy `Base`. Klasa pochodna zawiera `static` (`Shared` w języku Visual Basic) metodę o nazwie `MyMethod` z jednym parametrem typu `Base` i zwracanym typem `Derived`. Przykład kodu jest również definiowany delegat o nazwie `Example` posiadającą jeden parametr typu `Derived` i zwracanym typem `Base`.  
  
 Przykład kodu demonstruje, że delegat o nazwie `Example` może służyć do reprezentowania metody `MyMethod`. Metodę można powiązać z delegatem, ponieważ:  
  
-   Typ parametru delegata (`Derived`) jest bardziej restrykcyjny niż typ parametru `MyMethod` (`Base`), dzięki czemu jest zawsze można bezpiecznie przekazać argument delegata do `MyMethod`.  
  
-   Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpieczne rzutować zwracany typ metody do zwracanego typu delegata.  
  
 W przykładowym kodzie nie są generowane żadne dane wyjściowe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="method" /> Nie można powiązać, i <paramref name="throwOnBindFailure" /> jest <see langword="true" />.  
  
—lub— 
 <paramref name="method" /> nie jest <see langword="RuntimeMethodInfo" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnienia niezbędne do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="target">
          <see cref="T:System.Type" /> Reprezentujący klasę, która implementuje <c>metoda</c>.</param>
        <param name="method">Nazwa statyczna metoda, która ma reprezentować delegat.</param>
        <summary>Tworzy obiekt delegowany określony typ, który reprezentuje określonej metody statycznej określonej klasy.</summary>
        <returns>Delegat określony typ, który reprezentuje określonej metody statycznej określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów dla tylko metody statyczne. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenia metody, określając `false` dla `ignoreCase` i `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do metod niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień metod niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="target" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="target" /> nie jest <see langword="RuntimeType" />.  
  
—lub— 
 <paramref name="target" /> jest to otwarty typ ogólny. Oznacza to, że jego <see cref="P:System.Type.ContainsGenericParameters" /> właściwość <see langword="true" />.  
  
—lub— 
 <paramref name="method" /> nie jest <see langword="static" /> — metoda (<see langword="Shared" /> w języku Visual Basic).  
  
—lub— 
 <paramref name="method" /> Nie można powiązać, na przykład ponieważ nie można odnaleźć, i <paramref name="throwOnBindFailure" /> jest <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnienia niezbędne do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> reprezentujący typ delegata do utworzenia.</param>
        <param name="firstArgument">
          <see cref="T:System.Object" /> Oznacza to pierwszy argument metody reprezentuje obiekt delegowany. Na przykład metody, musi ona zgodny z typem wystąpienia.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Opisujące statyczną lub metodę ma reprezentować delegat wystąpienia.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli <c>metoda</c> nie może być; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy określonego typu, który reprezentuje określony statyczna lub metoda wystąpienia, z pierwszego określonego argumentu i określonego zachowania w przypadku niepowodzenia, można powiązać delegata.</summary>
        <returns>Delegat określonego typu, który reprezentuje określony statyczna lub metoda wystąpienia, lub <see langword="null" /> Jeśli <paramref name="throwOnBindFailure" /> jest <see langword="false" /> i nie można powiązać delegata z <paramref name="method" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego przeciążenia metody i <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> przeciążenia metody, która zawsze zgłasza wyjątek w przypadku niepowodzenia, można powiązać, podaj najbardziej elastyczny sposób do tworzenia obiektów delegowanych. Służy ich do tworzenia delegatów dla statycznych lub metody wystąpienia, z lub bez pierwszy argument.  
  
> [!NOTE]
>  Jeśli pierwszy argument nie zostanie podana, należy użyć <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenie metody w celu zapewnienia lepszej wydajności.  
  
 Typ delegata, a także metoda musi mieć zgodne typy zwracane. Oznacza to, że typ zwracany `method` musi być przypisane do zwracanego typu `type`.  
  
 Jeśli `firstArgument` jest podany, zostanie on przekazany do `method` za każdym razem, gdy obiekt delegowany jest wywoływany; `firstArgument` jest nazywany powiązać z delegatem, i delegowany jest zamknięte w ciągu pierwszego argumentu. Jeśli `method` jest `static` (`Shared` w języku Visual Basic), argument dostarczona podczas wywoływania delegata lista zawiera wszystkie parametry z wyjątkiem pierwszej; Jeśli `method` jest metodą wystąpienia `firstArgument` są przekazywane do wystąpienia ukryte parametr (reprezentowane przez `this` w języku C# lub przez `Me` w języku Visual Basic).  
  
 Jeśli `firstArgument` jest podany, pierwszy parametr `method` musi być typem referencyjnym, i `firstArgument` muszą być zgodne z danym typem.  
  
> [!IMPORTANT]
>  Jeśli `method` jest `static` (`Shared` w języku Visual Basic), a jej pierwszy parametr jest typu <xref:System.Object> lub <xref:System.ValueType>, następnie `firstArgument` może być typem wartości. W tym przypadku `firstArgument` jest automatycznie ramce. Automatyczne pakowanie nie występuje żadnych argumentów, jak w języku C# lub Visual Basic funkcji wywołałby.  
  
 Jeśli `firstArgument` jest odwołanie o wartości null i `method` jest metodą wystąpienia, wynik zależy od podpisy typu delegata `type` i `method`:  
  
-   Jeśli podpis `type` jawnie zawierającym ukryte pierwszy parametr `method`, delegowany jest reprezentujący otwartą metodę wystąpienia. Gdy obiekt delegowany jest wywoływany, pierwszy argument na liście argumentów jest przekazywany do parametru instance ukrytych z `method`.  
  
-   Jeśli sygnatur `method` i `type` dopasowania (oznacza to, że wszystkie typy parametrów są zgodne), a następnie delegowany jest zamknięte przez odwołanie o wartości null. Wywołanie delegata jest podobne do wywołania metody wystąpienia na wystąpienie o wartości null, która nie jest szczególnie przydatne niczego robić.  
  
 Jeśli `firstArgument` jest odwołanie o wartości null i `method` jest statyczny, wynik zależy od podpisy typu delegata `type` i `method`:  
  
-   Jeśli podpis `method` i `type` dopasowania (oznacza to, że wszystkie typy parametrów są zgodne), delegowany jest reprezentujący otwartą metodę statyczną. Dotyczy to najbardziej typowe dla metod statycznych. W tym przypadku nieco lepszą wydajność można uzyskać za pomocą <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenie metody.  
  
-   Jeśli podpis `type` zaczyna się od drugiego parametru `method` i pozostałe typy parametrów są niezgodne, a następnie delegowany jest zamknięte przez odwołanie o wartości null. Gdy obiekt delegowany jest wywoływany, odwołanie o wartości null jest przekazywana do pierwszy parametr `method`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do metod niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień metod niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Zgodne typy parametrów i zwracany typ  
 Typy parametrów i typ zwracany obiektu delegowanego musi być zgodny z typami parametrów i zwracany typ metody, który reprezentuje obiekt delegowany; typy musi dokładnie odpowiadać.  
  
> [!NOTE]
>  W .NET Framework w wersji 1.0 i 1.1 typów musi dokładnie pasować.  
  
 Parametru obiektu delegowanego jest zgodny z odpowiednim parametrem metody, jeśli typ parametru delegata jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przekazany do obiektu delegowanego można bezpiecznie przekazać do Metoda.  
  
 Podobnie zwracany typ delegata jest zgodny z typem zwracanym metody, jeśli typ zwracany metody jest bardziej restrykcyjny niż typ zwracany obiektu delegowanego, ponieważ gwarantuje to, że wartość zwracana metody może być bezpiecznie umieszczona na zwracany typ e delegata.  
  
 Na przykład delegat z parametrem typu <xref:System.Collections.Hashtable> i zwracanym typem <xref:System.Object> może reprezentować metodę z parametrem typu <xref:System.Object> oraz wartość zwracaną typu <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Określenie metod, które może reprezentować delegat  
 Innym sposobem przydatne z elastyczności, jaką to przeciążenie <xref:System.Delegate.CreateDelegate%2A> jest, że wszelkie danego które może reprezentować delegat cztery różne kombinacje podpis metody i rodzaju metody (statyczne w porównaniu z wystąpienia). Należy wziąć pod uwagę typ delegata `D` z jednym argumentem typu `C`. Poniżej opisano metody `D` może reprezentować ignoruje typ zwracany, ponieważ musi on być zgodny we wszystkich przypadkach:  
  
-   `D` może reprezentować dowolną metodę wystąpienia, która ma dokładnie jednego argumentu typu `C`, niezależnie od tego, jakiego typu, którego należy metoda wystąpienia. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest wystąpieniem typu `method` , do której należy i wynikowego delegata ma zostać zamknięte w ciągu tego wystąpienia. (W przypadku, `D` również może zostać zamknięty przez odwołanie o wartości null, jeśli `firstArgument` jest `null`.)  
  
-   `D` może reprezentować metodę wystąpienia `C` , nie ma argumentów. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest odwołanie o wartości null. Wynikowego delegata reprezentuje otwartą metodę wystąpienia, a wystąpienie `C` musi zostać dostarczony zawsze jest wywoływany.  
  
-   `D` może reprezentować statycznej metody, która przyjmuje jeden argument typu `C`, oraz że metoda mogą należeć do dowolnego typu. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest odwołanie o wartości null. Wynikowego delegata reprezentuje otwartą metodę statyczną i wystąpienie `C` musi zostać dostarczony zawsze jest wywoływany.  
  
-   `D` może reprezentować statycznej metody, która należy do typu `F` i ma dwa argumenty typu `F` i typ `C`. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest wystąpieniem `F`. Metoda statyczna, który jest zamknięty przez to wystąpienie reprezentuje wynikowy obiekt delegowany `F`. Należy pamiętać, że w przypadku których `F` i `C` tego samego typu, statycznej metody ma dwa argumenty typu. (W tym przypadku `D` zamknięte przez odwołanie o wartości null, jeśli `firstArgument` jest `null`.)  
  
   
  
## Examples  
 Ta sekcja zawiera trzy przykłady kodu. Pierwszy przykład przedstawia cztery rodzaje obiektów delegowanych, które mogą być tworzone: zamknięte za pośrednictwem metody wystąpienia, otwartego za pośrednictwem metody wystąpienia, otwartego za pośrednictwem statycznej metody i zamknięte przez metodę statyczną.  
  
 Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 Trzeci przykład kodu Określa typ delegata pojedynczego i pokazuje, że wszystkie metody, których typ delegowany może reprezentować.  
  
 **Przykład 1**  
  
 Poniższy przykład kodu demonstruje cztery sposoby delegata można tworzyć przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> — określające `firstArgument` i <xref:System.Reflection.MethodInfo>; ich funkcjonalność jest taka sama, z tą różnicą, że jeden pozwala określić, czy po niepowodzeniu do powiązania, a drugi zawsze zgłasza. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład deklaruje klasę `C` za pomocą metody statycznej `M2` i metoda wystąpienia `M1`, i trzy typy delegatów: `D1` przyjmuje wystąpienie klasy `C` i ciąg, `D2` przyjmuje parametry i `D3`nie ma argumentów.  
  
 Druga klasa o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegat typu `D2`, zamknięte przez wystąpienie `C`, jest tworzony dla metody wystąpienia `M1`. Jest wywoływany przy użyciu różnych ciągów, aby pokazać, że wystąpienia związanego `C` jest zawsze używana.  
  
-   Delegat typu `D1`, reprezentujący otwartą metodę wystąpienia, jest tworzony dla metody wystąpienia `M1`. Wystąpienie musi zostać przekazane podczas wywoływania delegata.  
  
-   Delegat typu `D2`, reprezentujący otwartą metodę statyczną, jest tworzony dla metody statycznej `M2`.  
  
-   Na koniec delegat typu `D3`, zamknięte przez ciąg, jest tworzony dla metody statycznej `M2`. Metoda jest wywoływana do wyświetlenia, korzysta z powiązanej ciągu.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
> [!NOTE]
>  W tym przykładzie kodu użyto <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenie metody. Użyj innych przeciążeń przybierają tego <xref:System.Reflection.MethodInfo> jest podobny.  
  
 Przykładowy kod definiuje klasę bazową, o nazwie `Base` i klasę o nazwie `Derived` który pochodzi od klasy `Base`. Klasa pochodna zawiera `static` (`Shared` w języku Visual Basic) metodę o nazwie `MyMethod` z jednym parametrem typu `Base` i zwracanym typem `Derived`. Przykład kodu jest również definiowany delegat o nazwie `Example` posiadającą jeden parametr typu `Derived` i zwracanym typem `Base`.  
  
 Przykład kodu demonstruje, że delegat o nazwie `Example` może służyć do reprezentowania metody `MyMethod`. Metodę można powiązać z delegatem, ponieważ:  
  
-   Typ parametru delegata (`Derived`) jest bardziej restrykcyjny niż typ parametru `MyMethod` (`Base`), dzięki czemu jest zawsze można bezpiecznie przekazać argument delegata do `MyMethod`.  
  
-   Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpieczne rzutować zwracany typ metody do zwracanego typu delegata.  
  
 W przykładowym kodzie nie są generowane żadne dane wyjściowe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Przykład 3**  
  
 Poniższy przykład kodu pokazuje wszystkie metody, których typ pojedynczego obiektu delegowanego może reprezentować.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> — określające `firstArgument` i <xref:System.Reflection.MethodInfo>; ich funkcjonalność jest taka sama, z tą różnicą, że jeden pozwala określić, czy po niepowodzeniu do powiązania, a drugi zawsze zgłasza. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykładowy kod definiuje dwie klasy `C` i `F`, a typ delegata `D` z jednym argumentem typu `C`. Klasy mają odpowiednie statycznych lub wystąpienie metody `M1`, `M3`, i `M4`, a klasa `C` ma również metodą wystąpienia `M2` , nie ma argumentów.  
  
 Trzecim klasę o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegaty są tworzone na przykład metoda `M1` typu `C` i typ `F`; każdy zostało zamknięte przez wystąpienie odpowiedniego typu. Metoda `M1` typu `C` Wyświetla `ID` właściwości powiązanej wystąpienia i argumentu.  
  
-   Obiekt delegowany jest tworzony dla metody `M2` typu `C`. Jest to delegat Otwórz wystąpienie, w której argument delegata reprezentuje ukryte pierwszy argument dla metody wystąpienia. Metoda nie ma innych argumentów.  
  
-   Delegaty są tworzone dla metody statycznej `M3` typu `C` i typ `F`; są one otwarte statycznych obiektów delegowanych.  
  
-   Na koniec obiekty delegowane są tworzone dla metody statycznej `M4` typu `C` i typ `F`; każda metoda charakteryzuje się typ deklarujący jako swój pierwszy argument, a wystąpienie tego typu jest podany, więc delegatów zostaną zamknięte za pośrednictwem ich pierwszym argumentów . Metoda `M4` typu `C` Wyświetla `ID` właściwości powiązanej wystąpienia i argumentu.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="method" /> Nie można powiązać, i <paramref name="throwOnBindFailure" /> jest <see langword="true" />.  
  
—lub— 
 <paramref name="method" /> nie jest <see langword="RuntimeMethodInfo" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnienia niezbędne do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="target">Wystąpienie klasy, na którym <c>metoda</c> jest wywoływana.</param>
        <param name="method">Nazwa metody wystąpienia, która ma reprezentować delegat.</param>
        <param name="ignoreCase">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</param>
        <summary>Tworzy delegata określonego typu, który reprezentuje metodę określone wystąpienie do wywołania na wystąpienie określonej klasy przy użyciu określonego uwzględnianie wielkości liter.</summary>
        <returns>Delegat określonego typu, który reprezentuje metodę określone wystąpienie do wywołania na wystąpienie określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów dla wystąpienia tylko metody. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenia metody, określając `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do metod niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień metod niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="target" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="method" /> nie jest metodą wystąpienia.  
  
—lub— 
 <paramref name="method" /> Nie można powiązać, na przykład ponieważ nie można odnaleźć.</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnienia niezbędne do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="target">
          <see cref="T:System.Type" /> Reprezentujący klasę, która implementuje <c>metoda</c>.</param>
        <param name="method">Nazwa statyczna metoda, która ma reprezentować delegat.</param>
        <param name="ignoreCase">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</param>
        <summary>Tworzy delegata określonego typu, który reprezentuje określonej metody statycznej określonej klasy przy użyciu określonego uwzględnianie wielkości liter.</summary>
        <returns>Delegat określony typ, który reprezentuje określonej metody statycznej określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów dla tylko metody statyczne. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenia metody, określając `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do metod niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień metod niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="target" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="target" /> nie jest <see langword="RuntimeType" />.  
  
—lub— 
 <paramref name="target" /> jest to otwarty typ ogólny. Oznacza to, że jego <see cref="P:System.Type.ContainsGenericParameters" /> właściwość <see langword="true" />.  
  
—lub— 
 <paramref name="method" /> nie jest <see langword="static" /> — metoda (<see langword="Shared" /> w języku Visual Basic).  
  
—lub— 
 <paramref name="method" /> Nie można powiązać, na przykład ponieważ nie można odnaleźć.</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnienia niezbędne do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="target">Wystąpienie klasy, na którym <c>metoda</c> jest wywoływana.</param>
        <param name="method">Nazwa metody wystąpienia, która ma reprezentować delegat.</param>
        <param name="ignoreCase">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli <c>metoda</c> nie może być; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy określonego typu, który reprezentuje metodę określone wystąpienie do wywołania na wystąpienie określonej klasy przy użyciu określonego uwzględnianie wielkości liter i określonego zachowania w przypadku niepowodzenia, można powiązać delegata.</summary>
        <returns>Delegat określonego typu, który reprezentuje metodę określone wystąpienie do wywołania na wystąpienie określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów dla wystąpienia tylko metody. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do metod niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień metod niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="target" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="method" /> nie jest metodą wystąpienia.  
  
—lub— 
 <paramref name="method" /> Nie można powiązać, na przykład ponieważ nie można odnaleźć, i <paramref name="throwOnBindFailure" /> jest <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnienia niezbędne do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Delegata do utworzenia.</param>
        <param name="target">
          <see cref="T:System.Type" /> Reprezentujący klasę, która implementuje <c>metoda</c>.</param>
        <param name="method">Nazwa statyczna metoda, która ma reprezentować delegat.</param>
        <param name="ignoreCase">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli <c>metoda</c> nie może być; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy określonego typu, który reprezentuje określonej metody statycznej określonej klasy z określonym uwzględnianie wielkości liter i określonego zachowania w przypadku niepowodzenia, można powiązać delegata.</summary>
        <returns>Delegat określony typ, który reprezentuje określonej metody statycznej określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów dla tylko metody statyczne. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do metod niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień metod niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="target" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" /> nie jest <see langword="RuntimeType" />. Zobacz [typów środowiska wykonawczego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="target" /> nie jest <see langword="RuntimeType" />.  
  
—lub— 
 <paramref name="target" /> jest to otwarty typ ogólny. Oznacza to, że jego <see cref="P:System.Type.ContainsGenericParameters" /> właściwość <see langword="true" />.  
  
—lub— 
 <paramref name="method" /> nie jest <see langword="static" /> — metoda (<see langword="Shared" /> w języku Visual Basic).  
  
—lub— 
 <paramref name="method" /> Nie można powiązać, na przykład ponieważ nie można odnaleźć, i <paramref name="throwOnBindFailure" /> jest <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <see langword="Invoke" /> Metody <paramref name="type" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnienia niezbędne do dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Tablica obiektów, które są argumenty do przekazania do metody reprezentowanej przez delegata bieżącego.  
  
—lub— 
 <see langword="null" />, jeśli metoda reprezentowanej przez delegata bieżącego nie wymaga argumentów.</param>
        <summary>Dynamicznie wywołuje (z późnym wiązaniem) metodę reprezentowaną przez bieżące delegata.</summary>
        <returns>Obiekt zwracany przez metodę reprezentowanej przez delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.Delegate.DynamicInvokeImpl%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).  
  
—lub— 
Liczbę, kolejność lub typu parametrów wymienionych w <paramref name="args" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException">Metoda reprezentowanej przez delegata jest wywoływane na obiekt lub klasa, która nie obsługuje.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Metoda reprezentowanej przez delegata jest metodą wystąpienia i obiekt docelowy jest <see langword="null" />.  
  
—lub— 
Jedną z metod zhermetyzowany zgłasza wyjątek.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">Tablica obiektów, które są argumenty do przekazania do metody reprezentowanej przez delegata bieżącego.  
  
—lub— 
 <see langword="null" />, jeśli metoda reprezentowanej przez delegata bieżącego nie wymaga argumentów.</param>
        <summary>Dynamicznie wywołuje (z późnym wiązaniem) metodę reprezentowaną przez bieżące delegata.</summary>
        <returns>Obiekt zwracany przez metodę reprezentowanej przez delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje <xref:System.Delegate.DynamicInvoke%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).  
  
—lub— 
Liczbę, kolejność lub typu parametrów wymienionych w <paramref name="args" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException">Metoda reprezentowanej przez delegata jest wywoływane na obiekt lub klasa, która nie obsługuje.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Metoda reprezentowanej przez delegata jest metodą wystąpienia i obiekt docelowy jest <see langword="null" />.  
  
—lub— 
Jedną z metod zhermetyzowany zgłasza wyjątek.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z bieżącym obiektem delegowanym.</param>
        <summary>Określa, czy określony obiekt bieżącej delegata są tego samego typu i udostępniać te same obiekty docelowe, metody i listy wywołań.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> i bieżącej delegat ma te same obiekty docelowe, metody i listy wywołań; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dwa obiekty delegowane są tego samego typu, nie są uwzględniane równe.  
  
> [!IMPORTANT]
>  W .NET Framework w wersji 1.0 i 1.1 dwa delegaty były uważane za równe, ich celów, metody i listy wywołań były takie same, nawet gdyby delegatów różnych typów.  
  
 Metody i obiekty docelowe są porównywane pod kątem równości w następujący sposób:  
  
-   Jeśli te dwie metody, którą jest porównywany są statyczne i tej samej metody na tej samej klasy, metody są traktowane jako równe i elementy docelowe również są traktowane jako równe.  
  
-   Jeśli te dwie metody, którą jest porównywany wystąpienia metod i tej samej metody na ten sam obiekt, te metody są traktowane jako równe i elementy docelowe również są traktowane jako równe.  
  
-   W przeciwnym razie metody nie są uważane za równe, i elementy docelowe również nie są uważane za równe.  
  
 Dwie listy wywołania są traktowane jako identyczne, tylko wtedy, gdy mają takiej samej kolejności, a odpowiednie elementy z dwóch list reprezentują te same metody i docelowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla delegata.</summary>
        <returns>Wartość skrótu dla delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana przez tę metodę nie musi zostać utrwalona, dwóch powodów. Najpierw funkcji skrótu klasy może zmienić do generowania dystrybucji lepsze, renderowanie bezcelowe żadnych wartości ze starej funkcji skrótu. Po drugie Domyślna implementacja tej klasy nie gwarantuje, że taką samą wartość zwracaną przez różne wystąpienia.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę wywołanie delegata.</summary>
        <returns>Tablica obiektów delegowanych reprezentujący listę wywołanie delegata bieżącego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdego delegata w tablicy reprezentuje dokładnie jedną z metod.  
  
 Kolejność delegatów w tablicy jest tej samej kolejności, w którym bieżącego delegata wywołuje metody, które reprezentują tych delegatów.  
  
   
  
## Examples  
 Poniższy przykład przypisuje trzy metody delegata. Następnie wywołuje <xref:System.Delegate.GetInvocationList%2A> metodę, aby uzyskać łączna liczba metod przypisane do delegata, można wykonać delegatów w odwrotnej kolejności i wykonywanie metod, których nazwa zawiera podciąg "File".  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera statycznej metody reprezentowanej przez delegata bieżącego.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> opisujące statycznej metody reprezentowanej przez delegata bieżącego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma zastosowanie tylko wtedy, gdy metoda statyczna reprezentuje bieżący obiekt delegowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Nieobsługiwane.</param>
        <param name="context">Nieobsługiwane.</param>
        <summary>Nieobsługiwane.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obsługiwana.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metody reprezentowanej przez delegata.</summary>
        <value>A <see cref="T:System.Reflection.MethodInfo" /> opisujące metody reprezentowanej przez delegata.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Pierwszy delegata do porównania.</param>
        <param name="d2">Drugiego delegata do porównania.</param>
        <summary>Określa, czy określony delegatów są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="d1" /> jest równa <paramref name="d2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa delegaty tego samego typu przy użyciu list wywołania te same obiekty docelowe, metody i są uznawane za równe.  
  
 Jeśli dwa obiekty delegowane są tego samego typu, nie są uwzględniane równe.  
  
> [!IMPORTANT]
>  W .NET Framework w wersji 1.0 i 1.1 dwa delegaty były uważane za równe, ich celów, metody i listy wywołań były takie same, nawet gdyby delegatów różnych typów.  
  
 Metody i obiekty docelowe są porównywane pod kątem równości w następujący sposób:  
  
-   Jeśli te dwie metody, którą jest porównywany są statyczne i tej samej metody na tej samej klasy, metody są traktowane jako równe i elementy docelowe również są traktowane jako równe.  
  
-   Jeśli te dwie metody, którą jest porównywany wystąpienia metod i tej samej metody na ten sam obiekt, te metody są traktowane jako równe i elementy docelowe również są traktowane jako równe.  
  
-   W przeciwnym razie metody nie są uważane za równe, i elementy docelowe również nie są uważane za równe.  
  
 Dwie listy wywołania są traktowane jako identyczne, jeśli mają takiej samej kolejności, a odpowiednie elementy z dwóch list reprezentują te same metody i docelowej.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Pierwszy delegata do porównania.</param>
        <param name="d2">Drugiego delegata do porównania.</param>
        <summary>Określa, czy określony delegatów nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="d1" /> nie jest równa <paramref name="d2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa obiekty delegowane są traktowane jako nie równe są różnych typów lub mają różne metody, różnych elementów docelowych lub listy różnych wywołania.  
  
 Jeśli dwa obiekty delegowane są tego samego typu, nie są uwzględniane równe.  
  
> [!IMPORTANT]
>  W .NET Framework w wersji 1.0 i 1.1 dwa delegaty są traktowane jako równe, ich celów, metody i listy wywołań były takie same, nawet gdyby delegatów różnych typów.  
  
 Metody i obiekty docelowe są porównywane pod kątem równości w następujący sposób:  
  
-   Jeśli te dwie metody, którą jest porównywany są statyczne i tej samej metody na tej samej klasy, metody są traktowane jako równe i elementy docelowe również są traktowane jako równe.  
  
-   Jeśli te dwie metody, którą jest porównywany wystąpienia metod i tej samej metody na ten sam obiekt, te metody są traktowane jako równe i elementy docelowe również są traktowane jako równe.  
  
-   W przeciwnym razie metody nie są uważane za równe, i elementy docelowe również nie są uważane za równe.  
  
 Dwie listy wywołania nie są równe, jeśli mają różne rozmiary, jeśli są uporządkowane inaczej, czy co najmniej jeden element z listy jeden reprezentuje metodę lub docelowy, który jest inny niż czas reprezentowany przez odpowiadającego mu elementu na liście inne.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Delegat, z którego mają zostać usunięte wywołanie listę <c>wartość</c>.</param>
        <param name="value">Delegat, który dostarcza listę wywołań, aby usunąć z listy wywołania <c>źródła</c>.</param>
        <summary>Usuwa ostatniego wystąpienia listy wywołań obiektu delegowanego z listy wywołanie innego obiektu delegowanego.</summary>
        <returns>Nowe delegowanie przy użyciu listy wywołania utworzone przez wykonanie wywołania listę <paramref name="source" /> i usuwanie ostatniego wystąpienia listy wywołania <paramref name="value" />, jeśli na liście wywołania <paramref name="value" /> znajduje się w obrębie listy wywołania <paramref name="source" />. Zwraca <paramref name="source" /> Jeśli <paramref name="value" /> jest <see langword="null" /> lub, jeśli na liście wywołania <paramref name="value" /> nie znajduje się w obrębie listy wywołania <paramref name="source" />. Zwraca odwołanie o wartości null, jeśli na liście wywołania <paramref name="value" /> jest taki sam, jak wywołania listę <paramref name="source" /> lub, jeśli <paramref name="source" /> jest odwołanie o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli na liście wywołania `value` odpowiada ciągły zestaw elementów na liście wywołania `source`, następnie wywołania listy `value` mówimy w obrębie listy wywołania `source`. Jeśli na liście wywołania `value` występuje więcej niż raz na liście wywołania `source`, ostatnie wystąpienie zostanie usunięte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <exception cref="T:System.ArgumentException">Typy delegatów są niezgodne.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Delegat, z którego mają zostać usunięte wywołanie listę <c>wartość</c>.</param>
        <param name="value">Delegat, który dostarcza listę wywołań, aby usunąć z listy wywołania <c>źródła</c>.</param>
        <summary>Usuwa wszystkie wystąpienia listy wywołań obiektu delegowanego z listy wywołanie innego obiektu delegowanego.</summary>
        <returns>Nowe delegowanie przy użyciu listy wywołania utworzone przez wykonanie wywołania listę <paramref name="source" /> i usunięcie wszystkich wystąpień elementu na liście wywołania <paramref name="value" />, jeśli na liście wywołania <paramref name="value" /> znajduje się w obrębie listy wywołania <paramref name="source" />. Zwraca <paramref name="source" /> Jeśli <paramref name="value" /> jest <see langword="null" /> lub, jeśli na liście wywołania <paramref name="value" /> nie znajduje się w obrębie listy wywołania <paramref name="source" />. Zwraca odwołanie o wartości null, jeśli wywołania listę <paramref name="value" /> jest taki sam, jak wywołania listę <paramref name="source" />, jeśli <paramref name="source" /> zawiera tylko szereg listy wywołania, które są równe do listy wywołania <paramref name="value" />, lub jeśli <paramref name="source" /> ma wartość null odwołanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli na liście wywołania `value` odpowiada ciągły zestaw elementów na liście wywołania `source`, następnie wywołania listy `value` mówimy w obrębie listy wywołania `source`. Jeśli na liście wywołania `value` występuje więcej niż raz na liście wywołania `source`, zostaną usunięte wszystkie wystąpienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <exception cref="T:System.ArgumentException">Typy delegatów są niezgodne.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">Delegat, który dostarcza listę wywołań, można usunąć z listy wywołań bieżącego obiektu delegowanego.</param>
        <summary>Usuwa listy wywołań obiektu delegowanego z listy wywołanie innego obiektu delegowanego.</summary>
        <returns>Nowe delegowanie przy użyciu listy wywołania utworzone przez pobranie listy wywołanie delegata bieżącego i usuwanie listy wywołania <paramref name="value" />, jeśli na liście wywołania <paramref name="value" /> znajduje się w obrębie listy wywołań obiektu delegowanego bieżącego. Zwraca bieżący delegata, jeśli <paramref name="value" /> jest <see langword="null" /> lub, jeśli na liście wywołania <paramref name="value" /> nie znajduje się w obrębie listy wywołań obiektu delegowanego bieżącego. Zwraca <see langword="null" /> Jeśli wywołanie listę <paramref name="value" /> jest taki sam, jak listy wywołań obiektu delegowanego bieżącego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli na liście wywołania `value` dopasowuje ciągły zestaw elementów listy wywołań obiektu delegowanego bieżący, a następnie na liście wywołania `value` mówimy w obrębie listy wywołań obiektu delegowanego bieżącego. Jeśli na liście wywołania `value` występuje więcej niż jeden raz w bieżącej listy wywołań obiektu delegowanego, ostatnie wystąpienie zostanie usunięte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wystąpienie klasy, na którym bieżącego delegata wywołuje metodę wystąpienia.</summary>
        <value>Obiekt, na którym bieżącego delegata wywołuje metodę wystąpienia, jeśli metoda wystąpienia; reprezentuje obiekt delegowany <see langword="null" /> Jeśli delegat reprezentuje metodę statyczną.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 Jeśli delegat wywołuje co najmniej jedną metodę wystąpienia, ta właściwość zwraca celem ostatniego metodę wystąpienia na liście wywołania.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
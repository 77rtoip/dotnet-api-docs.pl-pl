<Type Name="Delegate" FullName="System.Delegate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="49bd802fa8ffc3122beb07d490740f9cf8d7af4c" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69406631" /></Metadata><TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje delegata, który jest strukturą danych, która odwołuje się do metody statycznej lub do wystąpienia klasy i metody wystąpienia tej klasy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate> Klasa jest klasą bazową dla typów delegatów. Jednak tylko system i kompilatory mogą pochodzić jawnie z <xref:System.Delegate> klasy lub <xref:System.MulticastDelegate> z klasy. Nie jest również dozwolone uzyskanie nowego typu z typu delegata. <xref:System.Delegate> Klasa nie jest uważana za typ delegata; jest to Klasa używana do wyprowadzania typów delegatów.  
  
 Większość języków implementuje `delegate` słowo kluczowe i kompilatory dla tych języków mogą dziedziczyć <xref:System.MulticastDelegate> z klasy, w związku z czym użytkownicy powinni używać `delegate` słowa kluczowego dostarczonego przez język.  
  
> [!NOTE]
>  Środowisko uruchomieniowe języka wspólnego udostępnia `Invoke` metodę dla każdego typu delegata z tą samą sygnaturą co delegat. Nie trzeba jawnie wywoływać tej metody z C#, Visual Basic lub wizualizacji C++, ponieważ kompilatory automatycznie wywołują tę metodę. Metoda jest przydatna podczas odbicia, gdy chcesz znaleźć podpis typu delegata. [](~/docs/framework/reflection-and-codedom/reflection.md) `Invoke`  
  
 Środowisko uruchomieniowe języka wspólnego zapewnia każdy typ delegata `EndInvoke` z `BeginInvoke` metodami i, aby umożliwić asynchroniczne wywołanie delegata. Aby uzyskać więcej informacji na temat tych metod, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 Deklaracja typu delegata ustanawia kontrakt, który określa podpis jednej lub kilku metod. Delegat jest wystąpieniem typu delegata, do którego odwołuje się:  
  
-   Metoda wystąpienia typu i obiektu docelowego można przypisać do tego typu.  
  
-   Metoda wystąpienia typu, z ukrytym `this` parametrem uwidocznionym na liście parametrów formalnych. Delegat jest nazywany delegatem otwartego wystąpienia.  
  
-   Metoda statyczna.  
  
-   Metoda statyczna i obiekt docelowy można przypisać do pierwszego parametru metody. Delegat jest określany jako zamknięty w pierwszym argumencie.  
  
 Aby uzyskać więcej informacji na temat powiązania delegata <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> , zobacz Przeciążenie metody.  
  
> [!NOTE]
>  W .NET Framework wersje 1,0 i 1,1 delegat może reprezentować metodę tylko wtedy, gdy podpis metody dokładnie pasuje do podpisu określonego przez typ delegata. W tym celu obsługiwane są tylko pierwsze i trzecie punktory na poprzedniej liście, a pierwszy punktor wymaga dokładnego dopasowania typu.  
  
 Gdy delegat reprezentuje metodę wystąpienia zamkniętą względem pierwszego argumentu (najczęściej używany przypadek), delegat przechowuje odwołanie do punktu wejścia metody i odwołanie do obiektu, nazywany obiektem docelowym, który jest typu, który można przypisać do typu, który definiuje Method. Gdy delegat reprezentuje metodę otwartego wystąpienia, przechowuje odwołanie do punktu wejścia metody. Podpis delegata musi zawierać ukryty `this` parametr na liście parametrów formalnych. w tym przypadku delegat nie ma odwołania do obiektu docelowego, a obiekt docelowy musi być dostarczony, gdy delegat jest wywoływany.  
  
 Gdy delegat reprezentuje metodę statyczną, delegat przechowuje odwołanie do punktu wejścia metody. Gdy delegat reprezentuje statyczną metodę zamkniętą względem pierwszego argumentu, delegat przechowuje odwołanie do punktu wejścia metody i odwołanie do obiektu docelowego można przypisać do typu pierwszego argumentu metody. Gdy delegat jest wywoływany, pierwszy argument metody statycznej otrzymuje obiekt docelowy.  
  
 Lista wywołań delegata jest uporządkowanym zestawem delegatów, w których każdy element listy wywołuje dokładnie jedną z metod reprezentowanych przez delegata. Lista wywołań może zawierać zduplikowane metody. W trakcie wywołania metody są wywoływane w kolejności, w jakiej występują na liście wywołań. Delegat próbuje wywołać każdą metodę na swojej liście wywołań; duplikaty są wywoływane raz dla każdej chwili, gdy pojawiają się na liście wywołań. Delegaty są niezmienne; Po utworzeniu Lista wywołań delegata nie zmienia się.  
  
 Delegaty nazywa się multiemisją lub kombinacją, ponieważ delegat może wywołać jedną lub więcej metod i może być używany w operacjach łączenia.  
  
 Łączenie operacji, takich jak <xref:System.Delegate.Combine%2A> i <xref:System.Delegate.Remove%2A>, nie zmieniaj istniejących delegatów. Zamiast tego, taka operacja zwraca nowy delegat zawierający wyniki operacji, niezmieniony delegata lub `null`. Operacja łączenia zwraca `null` , gdy wynik operacji jest delegatem, który nie odwołuje się do co najmniej jednej metody. Operacja łączenia zwraca niezmieniony delegata, gdy żądana operacja nie ma żadnego wpływu.  
  
> [!NOTE]
>  Języki zarządzane używają <xref:System.Delegate.Combine%2A> metod i <xref:System.Delegate.Remove%2A> do implementowania operacji delegatów. Przykłady zawierają `AddHandler` instrukcje i `RemoveHandler` w Visual Basic oraz operatory + = i-= w typach delegatów w. C#  
  
 Począwszy od, typy delegatów ogólnych mogą zawierać parametry typu variant. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] Parametry typu kontrawariantne mogą być używane jako typy parametrów delegata, a jako typ zwracany można użyć parametru typu współwariantowego. Ta funkcja umożliwia ogólne typy delegatów, które są tworzone na podstawie tej samej definicji typu ogólnego, tak aby były zgodne z przypisaniem, jeśli ich argumenty typu są typami odwołań z relacją dziedziczenia, jak wyjaśniono w [kowariancji i kontrawariancja ](~/docs/standard/generics/covariance-and-contravariance.md).  
  
> [!NOTE]
>  Delegaty ogólne, które są zgodne z przypisaniem ze względu na wariancję, nie muszą być kombinacją. Aby można było połączyć, typy muszą dokładnie pasować. Załóżmy na przykład, że Klasa o nazwie `Derived` pochodzi od klasy o nazwie. `Base` Delegat typu `Action<Base>` (`Action(Of Base)` w Visual Basic) można przypisać do zmiennej typu `Action<Derived>`, ale nie można łączyć dwóch delegatów, ponieważ typy nie są dokładnie zgodne.  
  
 Jeśli wywołana metoda zgłasza wyjątek, Metoda przerywa wykonywanie, wyjątek jest przenoszona z powrotem do obiektu wywołującego delegata, a pozostałe metody na liście wywołań nie są wywoływane. Przechwytywanie wyjątku w obiekcie wywołującym nie zmienia tego zachowania.  
  
 Gdy sygnatura metod wywoływanych przez delegata zawiera wartość zwracaną, delegat zwraca wartość zwracaną ostatniego elementu na liście wywołań. Gdy podpis zawiera parametr, który jest przesyłany przez odwołanie, końcowa wartość parametru jest wynikiem każdej metody na liście wywołań, która wykonuje sekwencyjne i aktualizuje wartość parametru.  
  
 Najbliższy odpowiednik delegata w C jest wskaźnikiem funkcji. Delegat może reprezentować metodę statyczną lub metodę wystąpienia. Gdy delegat reprezentuje metodę wystąpienia, delegat przechowuje nie tylko odwołanie do punktu wejścia metody, ale również odwołanie do wystąpienia klasy. W przeciwieństwie do wskaźników funkcji Delegaty są zorientowane obiektowo i typu bezpieczne.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zdefiniować delegata o nazwie `myMethodDelegate`. Wystąpienia tego delegata są tworzone dla metody wystąpienia i statycznej metody klasy zagnieżdżonej `mySampleClass` . Delegat dla metody Instance wymaga wystąpienia `mySampleClass`. Wystąpienie jest zapisywane w zmiennej o nazwie `mySC`. `mySampleClass`  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">Wywołanie metod synchronicznych w sposób asynchroniczny</related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">Delegaty (Przewodnik programowania w języku C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">Delegaty (Visual Basic)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">Instrukcje: Definiowanie delegatów (C++/CLI) i korzystanie z nich</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">Obsługa i wywoływanie zdarzeń</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowy delegat.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target">Wystąpienie klasy, na którym jest wywoływany <paramref name="method" />delegat.</param>
        <param name="method">Nazwa metody wystąpienia reprezentowanej przez delegata.</param>
        <summary>Inicjuje delegata, który wywołuje określoną metodę wystąpienia w określonym wystąpieniu klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego konstruktora nie można używać w kodzie aplikacji. Aby utworzyć delegata poprzez określenie nazwy metody wystąpienia, Użyj przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, która określa nazwę metody i obiekt docelowy. Na przykład <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> Przeciążenie metody tworzy delegata dla metody wystąpienia o określonej nazwie.  
  
 Ten konstruktor tworzy delegatów tylko dla metod wystąpienia. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas tworzenia powiązania z metodą docelową.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target">Reprezentuje klasę, która definiuje <paramref name="method" />. <see cref="T:System.Type" /></param>
        <param name="method">Nazwa metody statycznej reprezentowanej przez delegata.</param>
        <summary>Inicjuje delegata, który wywołuje określoną metodę statyczną z określonej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego konstruktora nie można używać w kodzie aplikacji. Aby utworzyć delegata poprzez określenie nazwy metody statycznej, Użyj przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, która określa nazwę metody, ale nie określa obiektu docelowego. Na przykład <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> Przeciążenie metody tworzy statyczny delegat dla metody o określonej nazwie.  
  
 Ten konstruktor tworzy delegatów tylko dla metod statycznych. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" />nie <see langword="RuntimeType" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="target" />reprezentuje otwarty typ ogólny.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy skróconą kopię delegata.</summary>
        <returns>Skrócona kopia delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klon ma taką samą <xref:System.Type>, docelową, metodę i listę wywołań jak oryginalny delegat.  
  
 Kopia płytki tworzy nowe wystąpienie tego samego typu co oryginalny obiekt, a następnie kopiuje pola niestatyczne oryginalnego obiektu. Jeśli pole jest typu wartości, zostanie przeprowadzona bitowa kopia przez bit pola. Jeśli pole jest typem referencyjnym, odwołanie jest kopiowane, ale określony obiekt nie jest; w związku z tym odwołanie w oryginalnym obiekcie i odwołanie w klonie wskazuje na ten sam obiekt. W przeciwieństwie do głębokiej kopii obiektu duplikuje wszystkie elementy, które bezpośrednio lub pośrednio odwołują się do pól w obiekcie.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Łączy listy wywołań określonych obiektów delegowanych multiemisji (połączonych).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">Tablica delegatów do połączenia.</param>
        <summary>Łączy listy wywołań tablicy delegatów.</summary>
        <returns>Nowy delegat z listą wywołań, który łączy listy wywołań delegatów w <paramref name="delegates" /> tablicy. Zwraca <see langword="null" /> wartość <paramref name="delegates" /> , <see langword="null" />jeśli jest <paramref name="delegates" /> , jeśli zawiera elementy zero lub jeśli każdy wpis <paramref name="delegates" /> w <see langword="null" />ma wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli tablica zawiera wpisy, które są `null`ignorowane. `delegates`  
  
 Lista wywołań może zawierać zduplikowane wpisy; oznacza to, że wpisy odwołujące się do tej samej metody w tym samym obiekcie.  
  
> [!NOTE]
>  Delegaty ogólne, które są zgodne z przypisaniem ze względu na wariancję, nie muszą być kombinacją. Aby można było połączyć, typy muszą dokładnie pasować. Załóżmy na przykład, że Klasa o nazwie `Derived` pochodzi od klasy o nazwie. `Base` Delegat typu `Action<Base>` (`Action(Of Base)` w Visual Basic) można przypisać do zmiennej typu `Action<Derived>`, jak wyjaśniono w kowariancji [i kontrawariancja](~/docs/standard/generics/covariance-and-contravariance.md), ale nie można łączyć dwóch delegatów, ponieważ typy nie są dokładnie zgodne.  
  
 <xref:System.Delegate.Combine%2A>jest przydatne do tworzenia programów obsługi zdarzeń, które wywołują wiele metod przy każdym wystąpieniu zdarzenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie wszystkie wpisy inne niż null w programie <paramref name="delegates" /> są wystąpieniami tego samego typu delegata.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">Delegat, którego lista wywołania jest połączona jako pierwsza.</param>
        <param name="b">Delegat, którego lista wywołań jest Ostatnia.</param>
        <summary>Łączy listy wywołań dwóch delegatów.</summary>
        <returns>Nowy delegat z listą wywołań, który łączy listy <paramref name="a" /> wywołań i <paramref name="b" /> w tej kolejności. Zwraca <paramref name="a" /> Jeśli <paramref name="a" /> <paramref name="b" /> is jest <see langword="null" />, zwraca<paramref name="b" /> wartość, jeśli jest odwołaniem null i zwraca odwołanie o wartości <paramref name="a" /> null, jeśli oba i są odwołaniami o wartości null. <paramref name="b" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lista wywołań może zawierać zduplikowane wpisy; oznacza to, że wpisy odwołujące się do tej samej metody w tym samym obiekcie.  
  
> [!NOTE]
>  Delegaty ogólne, które są zgodne z przypisaniem ze względu na wariancję, nie muszą być kombinacją. Aby można było połączyć, typy muszą dokładnie pasować. Załóżmy na przykład, że Klasa o nazwie `Derived` pochodzi od klasy o nazwie. `Base` Delegat typu `Action<Base>` (`Action(Of Base)` w Visual Basic) można przypisać do zmiennej typu `Action<Derived>`, jak wyjaśniono w kowariancji [i kontrawariancja](~/docs/standard/generics/covariance-and-contravariance.md), ale nie można łączyć dwóch delegatów, ponieważ typy nie są dokładnie zgodne.  
  
 <xref:System.Delegate.Combine%2A>jest przydatne do tworzenia programów obsługi zdarzeń, które wywołują wiele metod przy każdym wystąpieniu zdarzenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Oba <paramref name="a" /> obiekty <paramref name="b" /> i nie <see langword="null" /> są<paramref name="a" /> wystąpieniami tego samego typu delegata. <paramref name="b" /></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">Obiekt delegowany multiemisji (z kombinacją), którego lista wywołania zostanie dołączona na końcu listy wywołań bieżącego multiemisji (z zakresem).</param>
        <summary>Łączy listy wywołań określonego delegata multiemisji (z połączeniem) i bieżącego delegata multiemisji (połączonego).</summary>
        <returns>Nowy obiekt delegowany multiemisji (połączony) z listą wywołań, który łączy listę wywołań bieżącego obiektu delegowanego multiemisji (połączonego) i listę <paramref name="d" />wywołań lub bieżący delegat multiemisji (z połączeniem), jeśli jest <paramref name="d" /> <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma zastosowanie tylko wtedy, gdy bieżący delegat jest multiemisją (z możliwych do przyłączania).  
  
 Bieżąca implementacja po prostu zgłasza <xref:System.MulticastNotSupportedException>.  
  
 Lista wywołań może zawierać zduplikowane wpisy; oznacza to, że wpisy odwołujące się do tej samej metody w tym samym obiekcie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Zawsze generowany.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy delegata określonego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Delegat do utworzenia.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Opisywanie metody statycznej lub instancji, która ma być reprezentowana przez delegata. W .NET Framework w wersji 1,0 i 1,1 obsługiwane są tylko metody statyczne.</param>
        <summary>Tworzy delegat określonego typu do reprezentowania określonej metody statycznej.</summary>
        <returns>Delegat określonego typu reprezentujący określoną metodę statyczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W .NET Framework w wersji 1,0 i 1,1 to Przeciążenie metody tworzy delegatów tylko dla metod statycznych. W .NET Framework w wersji 2,0, to Przeciążenie metody również może utworzyć delegatów metody otwartego wystąpienia; oznacza to, że Delegaty jawnie dostarczają ukryty pierwszy argument metod wystąpień. Aby uzyskać szczegółowe wyjaśnienie, zobacz bardziej ogólne <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> Przeciążenie metody, które pozwala na tworzenie wszystkich kombinacji otwartych lub zamkniętych delegatów dla wystąpień lub metod statycznych, a opcjonalnie określić pierwszy argument.  
  
> [!NOTE]
>  Tego przeciążenia metody należy użyć, gdy delegat nie jest zamknięty nad jego pierwszym argumentem, ponieważ jest nieco szybszy w tym przypadku.  
  
 To Przeciążenie metody jest równoważne wywołaniu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> metody przeciążenia i określanie `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Zgodne typy parametrów i zwracany typ  
 W .NET Framework w wersji 2,0 typy parametrów i zwracany typ delegata utworzonego przy użyciu tego przeciążenia metody muszą być zgodne z typami parametrów i zwracanym typem metody reprezentowanej przez delegata; typy nie muszą dokładnie pasować. Reprezentuje to złagodzenie zachowania powiązania w .NET Framework w wersji 1,0 i 1,1, gdzie typy muszą dokładnie pasować.  
  
 Parametr delegata jest zgodny z odpowiadającym mu parametrem metody, jeśli typ parametru delegata jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przesłany do delegata może być bezpiecznie przekazywać do Metoda.  
  
 Analogicznie, zwracany typ delegata jest zgodny z typem zwracanym metody, Jeśli zwracany typ metody jest bardziej restrykcyjny niż typ zwracany delegata, ponieważ gwarantuje to, że wartość zwracana metody może być bezpiecznie rzutowana na typ zwracany e delegata.  
  
 Na przykład delegat <xref:System.Collections.Hashtable> z parametrem typu i <xref:System.Object> typem zwracanym może reprezentować metodę z parametrem typu <xref:System.Object> i wartością zwracaną typu <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. W pierwszym przykładzie pokazano dwa rodzaje delegatów, które można utworzyć za pomocą tego przeciążenia metody: Otwórz za pomocą metody Instance i Otwórz za pomocą metody statycznej.  
  
 Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 **Przykład 1**  
  
 Poniższy przykład kodu demonstruje dwa sposoby tworzenia delegata przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, które <xref:System.Reflection.MethodInfo> określają, ale nie pierwszy argument; ich funkcjonalność jest taka sama, z tą różnicą, że jedna pozwala określić, czy zgłaszać błąd w przypadku niepowodzenia powiązania, a drugie zawsze zwraca wartość. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład `C` deklaruje klasę z metodą `M2` statyczną i metodą `M1`wystąpienia, a `C` dwa typy delegatów: `D1` przyjmuje wystąpienie i ciąg i `D2` Pobiera ciąg.  
  
 Druga klasa o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegat typu `D1`, reprezentujący otwartą metodę wystąpienia, jest tworzony dla metody `M1`wystąpienia. Wystąpienie musi zostać przekazane podczas wywoływania delegata.  
  
-   Delegat typu `D2`, reprezentujący otwartą metodę statyczną, jest tworzony dla metody `M2`statycznej.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 Przykładowy kod definiuje klasę bazową o nazwie `Base` i klasę o nazwie `Derived` , która dziedziczy `Base`z. Klasa pochodna `static` ma metodę (`Shared` w Visual Basic) o nazwie `MyMethod` z jednym `Derived`parametrem typu `Base` i typem zwracanym. Przykład kodu definiuje także delegat o nazwie `Example` , który ma jeden parametr typu `Derived` `Base`i zwracany typ.  
  
 Przykład kodu pokazuje, że delegat o nazwie `Example` może służyć do reprezentowania metody. `MyMethod` Metodę można powiązać z delegatem, ponieważ:  
  
-   Typ`Derived`parametru delegata () jest bardziej restrykcyjny niż `MyMethod` typ parametru (`Base`), dzięki czemu zawsze można bezpiecznie przekazać argument delegata do `MyMethod`.  
  
-   Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpiecznie do rzutowania zwracanego typu metody na zwracany typ delegata.  
  
 W przykładowym kodzie nie są generowane żadne dane wyjściowe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" />nie <see langword="RuntimeType" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="method" />nie jest metodą statyczną, a wersja .NET Framework to 1,0 lub 1,1.  
  
—lub— 
 <paramref name="method" />nie można powiązać.  
  
—lub— 
 <paramref name="method" />nie <see langword="RuntimeMethodInfo" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Delegat do utworzenia.</param>
        <param name="firstArgument">Obiekt, z którym jest powiązany <see langword="null" /> delegat, lub do traktowania <paramref name="method" /> jako <see langword="static" /> (<see langword="Shared" /> w Visual Basic).</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Opisywanie metody statycznej lub instancji, która ma być reprezentowana przez delegata.</param>
        <summary>Tworzy delegat określonego typu, który reprezentuje określoną metodę statyczną lub wystąpienie, z określonym pierwszym argumentem.</summary>
        <returns>Delegat określonego typu, który reprezentuje określoną metodę static lub instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tego przeciążenia metody jest równoznaczne z wywołaniem <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenia metody i określanie `throwOnBindFailure` `true` dla. Te dwa przeciążenia zapewniają najbardziej elastyczny sposób tworzenia delegatów. Można ich użyć do tworzenia delegatów dla metod statycznych lub wystąpień oraz opcjonalnie określić pierwszy argument.  
  
> [!NOTE]
>  Jeśli nie podasz pierwszego argumentu, użyj <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenia metody w celu uzyskania lepszej wydajności.  
  
 Typ delegata i Metoda muszą mieć zgodne typy zwracane. Oznacza to, że zwracany typ `method` musi być możliwy do przypisania do `type`typu zwracanego.  
  
 Jeśli `firstArgument` jest podany, jest przekazywany do `method` każdego momentu wywołania delegata; `firstArgument` jest określana jako powiązana z delegatem, a delegat jest określany jako zamknięty w pierwszym argumencie. Jeśli `method` jest `static` ( `method` `firstArgument` w Visual Basic), lista argumentów dostarczona podczas wywoływania delegata zawiera wszystkie parametry z wyjątkiem pierwszej; jeśli jest to metoda wystąpienia, zostaje przekazana do wystąpienia ukrytego`Shared` parametr (reprezentowany przez `this` w C#, lub `Me` w Visual Basic).  
  
 Jeśli `firstArgument` jest podany, pierwszy parametr elementu `method` musi być typem referencyjnym i `firstArgument` musi być zgodny z tym typem.  
  
> [!IMPORTANT]
>  Jeśli `method` jest `static` ( <xref:System.Object> wVisualBasic<xref:System.ValueType>) i jego`firstArgument` pierwszy parametr jest typu lub, może być typem wartości.`Shared` W tym przypadku `firstArgument` jest automatycznie opakowany. Automatyczne pakowanie nie występuje dla żadnych innych argumentów, tak jak w przypadku C# wywołania funkcji lub Visual Basic.  
  
 Jeśli `firstArgument` jest odwołaniem o wartości `method` null i jest metodą wystąpienia, wynik zależy od sygnatur typu `type` delegata i `method`:  
  
-   Jeśli podpis `type` jawnie obejmuje ukryty pierwszy `method`parametr, delegat jest reprezentowany do reprezentowania metody otwartego wystąpienia. Gdy obiekt delegowany jest wywoływany, pierwszy argument na liście argumentów jest przenoszona do ukrytego wystąpienia parametru `method`.  
  
-   Jeśli sygnatury `method` i `type` są zgodne (to oznacza, że wszystkie typy parametrów są zgodne), delegat jest określany jako zamknięty w odniesieniu do wartości null. Wywoływanie delegata jest podobne do wywołania metody wystąpienia w wystąpieniu o wartości null, która nie jest szczególnie przydatna.  
  
 Jeśli `firstArgument` jest odwołaniem null i `method` jest statyczna, wynik zależy od sygnatur typu `type` delegata i `method`:  
  
-   Jeśli sygnatura `method` i `type` dopasowanie (to oznacza, że wszystkie typy parametrów są zgodne), delegat jest reprezentowany jako otwarta metoda statyczna. Jest to najbardziej typowy przypadek dla metod statycznych. W takim przypadku można uzyskać nieco lepszą wydajność przy użyciu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenia metody.  
  
-   Jeśli sygnatura `type` zaczyna się od drugiego `method` parametru, a pozostałe typy parametrów są zgodne, delegat jest uznawany za zamknięty w odniesieniu do wartości null. Gdy obiekt delegowany jest wywoływany, odwołanie o wartości null jest przesyłane do pierwszego `method`parametru.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Zgodne typy parametrów i zwracany typ  
 Typy parametrów i typ zwracany delegata muszą być zgodne z typami parametrów i zwracanym typem metody reprezentowanej przez delegata; typy nie muszą dokładnie pasować.  
  
> [!NOTE]
>  W .NET Framework w wersji 1,0 i 1,1 typy muszą dokładnie pasować.  
  
 Parametr delegata jest zgodny z odpowiadającym mu parametrem metody, jeśli typ parametru delegata jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przesłany do delegata może być bezpiecznie przekazywać do Metoda.  
  
 Analogicznie, zwracany typ delegata jest zgodny z typem zwracanym metody, Jeśli zwracany typ metody jest bardziej restrykcyjny niż typ zwracany delegata, ponieważ gwarantuje to, że wartość zwracana metody może być bezpiecznie rzutowana na typ zwracany e delegata.  
  
 Na przykład delegat <xref:System.Collections.Hashtable> z parametrem typu i <xref:System.Object> typem zwracanym może reprezentować metodę z parametrem typu <xref:System.Object> i wartością zwracaną typu <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Określenie metod, które może reprezentować delegat  
 Innym przydatnym sposobem, aby określić elastyczność zapewnianą przez to Przeciążenie <xref:System.Delegate.CreateDelegate%2A> , jest to, że każdy delegat może reprezentować cztery różne kombinacje sygnatur metody i rodzaju metody (statyczny a wystąpienie). Należy wziąć pod uwagę `D` typ delegata z jednym `C`argumentem typu. Poniżej opisano metody `D` , które mogą reprezentować, ignorowanie zwracanego typu, ponieważ musi on być zgodny we wszystkich przypadkach:  
  
-   `D`może reprezentować każdą metodę wystąpienia, która ma dokładnie jeden `C`argument typu, bez względu na typ, do którego należy metoda wystąpienia. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` to wystąpienie typu `method` należy do, a otrzymany delegat jest wskazany do zamknięcia tego wystąpienia. (Prosta, można `D` także zamknąć odwołanie o wartości null, jeśli `firstArgument` jest odwołaniem o wartości null).  
  
-   `D`może reprezentować metodę `C` wystąpienia, która nie ma żadnych argumentów. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest odwołaniem o wartości null. Przekazany delegat reprezentuje metodę otwartego wystąpienia, a wystąpienie `C` musi być dostarczone przy każdym wywołaniu.  
  
-   `D`może reprezentować metodę statyczną przyjmującą jeden argument `C`typu, która ta metoda może należeć do dowolnego typu. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest odwołaniem o wartości null. Przekazany delegat reprezentuje statyczną metodę, a wystąpienie `C` musi być dostarczone przy każdym wywołaniu.  
  
-   `D`może reprezentować metodę statyczną, która `F` należy do typu, i ma dwa `F` argumenty typu `C`i typu. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest wystąpieniem `F`. Otrzymany delegat reprezentuje statyczną metodę, która jest zamknięta dla `F`tego wystąpienia. Należy zauważyć, że w przypadku `F` gdy `C` i są tego samego typu, metoda statyczna ma dwa argumenty tego typu. (W tym przypadku jest `D` zamknięty w odniesieniu do wartości `firstArgument` null, jeśli jest odwołaniem o wartości null).  
  
   
  
## Examples  
 Ta sekcja zawiera trzy przykłady kodu. W pierwszym przykładzie pokazano cztery rodzaje delegatów, które można utworzyć: zamknięte przez metodę wystąpienia, Otwórz w metodzie wystąpienia, Otwórz za pomocą metody statycznej i zamknięte przez metodę statyczną.  
  
 Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 Trzeci przykład kodu definiuje pojedynczy typ delegata i pokazuje wszystkie metody, które może reprezentować typ delegata.  
  
 **Przykład 1**  
  
 Poniższy przykład kodu demonstruje cztery sposoby tworzenia delegata przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, które określają `firstArgument` i a <xref:System.Reflection.MethodInfo>; ich funkcjonalność jest taka sama, z tą różnicą, że jedna z nich pozwala określić, czy zgłaszać błąd w przypadku niepowodzenia, a drugie. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład `C` deklaruje klasę z metodą `M2` statyczną i metodą `M1`wystąpienia, a `C` trzy typy delegatów: `D1` przyjmuje wystąpienie i ciąg, `D2` Pobiera ciąg i `D3`nie ma argumentów.  
  
 Druga klasa o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegat typu `D2`, zamknięty w `C`wystąpieniu, jest tworzony dla metody `M1`wystąpienia. Jest wywoływana z innymi ciągami, aby pokazać, że powiązane wystąpienie `C` jest zawsze używane.  
  
-   Delegat typu `D1`, reprezentujący otwartą metodę wystąpienia, jest tworzony dla metody `M1`wystąpienia. Wystąpienie musi zostać przekazane podczas wywoływania delegata.  
  
-   Delegat typu `D2`, reprezentujący otwartą metodę statyczną, jest tworzony dla metody `M2`statycznej.  
  
-   Na koniec, delegat typu `D3`, zamknięty w ciągu, jest tworzony dla metody `M2`statycznej. Metoda jest wywoływana, aby pokazać, że używa powiązanego ciągu.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
> [!NOTE]
>  Ten przykład kodu używa <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenia metody. Użycie innych przeciążeń <xref:System.Reflection.MethodInfo> jest podobne.  
  
 Przykładowy kod definiuje klasę bazową o nazwie `Base` i klasę o nazwie `Derived` , która dziedziczy `Base`z. Klasa pochodna `static` ma metodę (`Shared` w Visual Basic) o nazwie `MyMethod` z jednym `Derived`parametrem typu `Base` i typem zwracanym. Przykład kodu definiuje także delegat o nazwie `Example` , który ma jeden parametr typu `Derived` `Base`i zwracany typ.  
  
 Przykład kodu pokazuje, że delegat o nazwie `Example` może służyć do reprezentowania metody. `MyMethod` Metodę można powiązać z delegatem, ponieważ:  
  
-   Typ`Derived`parametru delegata () jest bardziej restrykcyjny niż `MyMethod` typ parametru (`Base`), dzięki czemu zawsze można bezpiecznie przekazać argument delegata do `MyMethod`.  
  
-   Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpiecznie do rzutowania zwracanego typu metody na zwracany typ delegata.  
  
 W przykładowym kodzie nie są generowane żadne dane wyjściowe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Przykład 3**  
  
 Poniższy przykład kodu przedstawia wszystkie metody, które może reprezentować pojedynczy typ delegata, <xref:System.Delegate.CreateDelegate%2A> przy użyciu metody do tworzenia delegatów.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, które określają `firstArgument` i a <xref:System.Reflection.MethodInfo>; ich funkcjonalność jest taka sama, z tą różnicą, że jedna z nich pozwala określić, czy zgłaszać błąd w przypadku niepowodzenia, a drugie. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład kodu definiuje dwie klasy `C` , i `F`i typ `D` delegata z jednym argumentem typu `C`. Klasy mają zgodne metody `M1`static i instance, `M3`klasy `C` i `M4`, a także mają metodę `M2` wystąpienia, która nie ma argumentów.  
  
 Trzecia Klasa o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegaty są tworzone dla metody `M1` wystąpienia typu `C` i typu `F`; każda z nich jest zamknięta na wystąpieniu odpowiedniego typu. Metoda `M1` typu `C` wyświetla`ID` właściwości wystąpienia powiązanego i argumentu.  
  
-   Obiekt delegowany jest tworzony dla `M2` metody typu `C`. Jest to delegata otwartego wystąpienia, w którym argument delegata reprezentuje ukryty pierwszy argument metody Instance. Metoda nie ma innych argumentów. Jest on wywoływany tak, jakby był metodą statyczną.  
  
-   Delegaty są tworzone dla statycznej `M3` metody `C` typu i `F`typu; są to otwarte elementy delegowane static.  
  
-   Na koniec są tworzone Delegaty dla statycznej `M4` metody `C` typu i `F`typu; każda metoda ma typ deklarujący jako pierwszy argument, a wystąpienie typu jest dostarczane, więc Delegaty są zamykane w ramach swoich pierwszych argumentów . Metoda `M4` typu `C` wyświetla`ID` właściwości wystąpienia powiązanego i argumentu.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" />nie <see langword="RuntimeType" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="method" />nie można powiązać.  
  
—lub— 
 <paramref name="method" />nie <see langword="RuntimeMethodInfo" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Delegat do utworzenia.</param>
        <param name="target">Wystąpienie klasy, na którym <paramref name="method" /> jest wywoływane.</param>
        <param name="method">Nazwa metody wystąpienia, która ma być reprezentowana przez delegata.</param>
        <summary>Tworzy delegat określonego typu, który reprezentuje określoną metodę wystąpienia do wywołania w określonym wystąpieniu klasy.</summary>
        <returns>Delegat określonego typu reprezentujący określoną metodę wystąpienia do wywołania w określonym wystąpieniu klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów tylko dla metod wystąpienia. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 To Przeciążenie metody jest równoważne wywołaniu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> metody przeciążenia, określając `false` dla `ignoreCase` i `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="target" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" />nie <see langword="RuntimeType" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="method" />nie jest metodą wystąpienia.  
  
—lub— 
 <paramref name="method" />nie można powiązać, na przykład ponieważ nie można go znaleźć.</exception>
        <exception cref="T:System.MissingMethodException">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Delegat do utworzenia.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Opisywanie metody statycznej lub instancji, która ma być reprezentowana przez delegata.</param>
        <param name="throwOnBindFailure"><see langword="true" />Aby zgłosić wyjątek, <paramref name="method" /> <see langword="false" />Jeśli nie można go powiązać; w przeciwnym razie.</param>
        <summary>Tworzy delegat określonego typu reprezentujący określoną metodę statyczną, z określonym zachowaniem dotyczącym niepowodzenia powiązania.</summary>
        <returns>Delegat określonego typu reprezentujący określoną metodę statyczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie metody może utworzyć elementy delegowane typu Open static i otworzyć metodę wystąpienia, czyli delegatów, które uwidaczniają ukryty pierwszy argument metod wystąpień. Aby uzyskać szczegółowe wyjaśnienie, zobacz bardziej ogólne <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> Przeciążenie metody, które pozwala na tworzenie wszystkich kombinacji otwartych lub zamkniętych delegatów dla wystąpień lub metod statycznych.  
  
> [!NOTE]
>  Tego przeciążenia metody należy użyć, gdy delegat nie jest zamknięty nad jego pierwszym argumentem, ponieważ jest nieco szybszy w tym przypadku.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Zgodne typy parametrów i zwracany typ  
 Typy parametrów i typ zwracany delegata muszą być zgodne z typami parametrów i zwracanym typem metody reprezentowanej przez delegata; typy nie muszą dokładnie pasować.  
  
> [!NOTE]
>  W .NET Framework w wersji 1,0 i 1,1 typy muszą dokładnie pasować.  
  
 Parametr delegata jest zgodny z odpowiadającym mu parametrem metody, jeśli typ parametru delegata jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przesłany do delegata może być bezpiecznie przekazywać do Metoda.  
  
 Analogicznie, zwracany typ delegata jest zgodny z typem zwracanym metody, Jeśli zwracany typ metody jest bardziej restrykcyjny niż typ zwracany delegata, ponieważ gwarantuje to, że wartość zwracana metody może być bezpiecznie rzutowana na typ zwracany e delegata.  
  
 Na przykład delegat <xref:System.Collections.Hashtable> z parametrem typu i <xref:System.Object> typem zwracanym może reprezentować metodę z parametrem typu <xref:System.Object> i wartością zwracaną typu <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. W pierwszym przykładzie pokazano dwa rodzaje delegatów, które można utworzyć za pomocą tego przeciążenia metody: Otwórz za pomocą metody Instance i Otwórz za pomocą metody statycznej.  
  
 Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 **Przykład 1**  
  
 Poniższy przykład kodu demonstruje dwa sposoby tworzenia delegata przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, które <xref:System.Reflection.MethodInfo> określają, ale nie pierwszy argument; ich funkcjonalność jest taka sama, z tą różnicą, że jedna pozwala określić, czy zgłaszać błąd w przypadku niepowodzenia powiązania, a drugie zawsze zwraca wartość. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład `C` deklaruje klasę z metodą `M2` statyczną i metodą `M1`wystąpienia, a `C` dwa typy delegatów: `D1` przyjmuje wystąpienie i ciąg i `D2` Pobiera ciąg.  
  
 Druga klasa o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegat typu `D1`, reprezentujący otwartą metodę wystąpienia, jest tworzony dla metody `M1`wystąpienia. Wystąpienie musi zostać przekazane podczas wywoływania delegata.  
  
-   Delegat typu `D2`, reprezentujący otwartą metodę statyczną, jest tworzony dla metody `M2`statycznej.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
> [!NOTE]
>  Ten przykład kodu używa <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenia metody. Użycie innych przeciążeń <xref:System.Reflection.MethodInfo> jest podobne.  
  
 Przykładowy kod definiuje klasę bazową o nazwie `Base` i klasę o nazwie `Derived` , która dziedziczy `Base`z. Klasa pochodna `static` ma metodę (`Shared` w Visual Basic) o nazwie `MyMethod` z jednym `Derived`parametrem typu `Base` i typem zwracanym. Przykład kodu definiuje także delegat o nazwie `Example` , który ma jeden parametr typu `Derived` `Base`i zwracany typ.  
  
 Przykład kodu pokazuje, że delegat o nazwie `Example` może służyć do reprezentowania metody. `MyMethod` Metodę można powiązać z delegatem, ponieważ:  
  
-   Typ`Derived`parametru delegata () jest bardziej restrykcyjny niż `MyMethod` typ parametru (`Base`), dzięki czemu zawsze można bezpiecznie przekazać argument delegata do `MyMethod`.  
  
-   Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpiecznie do rzutowania zwracanego typu metody na zwracany typ delegata.  
  
 W przykładowym kodzie nie są generowane żadne dane wyjściowe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" />nie <see langword="RuntimeType" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="method" />nie można powiązać <paramref name="throwOnBindFailure" />. <see langword="true" />  
  
—lub— 
 <paramref name="method" />nie <see langword="RuntimeMethodInfo" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Delegat do utworzenia.</param>
        <param name="target">Reprezentuje klasę, która implementuje <paramref name="method" />. <see cref="T:System.Type" /></param>
        <param name="method">Nazwa metody statycznej, która ma być reprezentowana przez delegata.</param>
        <summary>Tworzy delegat określonego typu, który reprezentuje określoną metodę statyczną określonej klasy.</summary>
        <returns>Delegat określonego typu, który reprezentuje określoną metodę statyczną określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów tylko dla metod statycznych. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 To Przeciążenie metody jest równoważne wywołaniu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> metody przeciążenia, określając `false` dla `ignoreCase` i `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="target" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" />nie <see langword="RuntimeType" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="target" />nie <see langword="RuntimeType" />jest.  
  
—lub— 
 <paramref name="target" />jest otwartym typem ogólnym. Oznacza to, że <see cref="P:System.Type.ContainsGenericParameters" /> jego właściwość <see langword="true" />jest.  
  
—lub— 
 <paramref name="method" />nie <see langword="static" /> jest metodą (<see langword="Shared" /> Metoda w Visual Basic).  
  
—lub— 
 <paramref name="method" />nie można powiązać, na przykład, ponieważ nie można go znaleźć i <paramref name="throwOnBindFailure" /> ma <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Reprezentujący typ delegata, który ma zostać utworzony.</param>
        <param name="firstArgument"><see cref="T:System.Object" /> Jest to pierwszy argument metody reprezentowanej przez delegata. Dla metod instancji musi być zgodna z typem wystąpienia.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Opisywanie metody statycznej lub instancji, która ma być reprezentowana przez delegata.</param>
        <param name="throwOnBindFailure"><see langword="true" />Aby zgłosić wyjątek, <paramref name="method" /> <see langword="false" />Jeśli nie można go powiązać; w przeciwnym razie.</param>
        <summary>Tworzy delegat określonego typu, który reprezentuje określoną metodę statyczną lub wystąpienie, z określonym pierwszym argumentem i określonym zachowaniem w przypadku niepowodzenia powiązania.</summary>
        <returns>Delegat określonego typu, który reprezentuje określoną <see langword="null" /> metodę statyczną lub obiektową, lub jeśli <paramref name="throwOnBindFailure" /> jest <see langword="false" /> i delegat nie może być powiązany z <paramref name="method" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przeciążona <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> i Przeciążenie metody, która zawsze zgłasza błąd do powiązania, zapewnia najbardziej elastyczny sposób tworzenia delegatów. Można ich użyć do tworzenia delegatów dla metod statycznych lub wystąpień, z lub bez pierwszego argumentu.  
  
> [!NOTE]
>  Jeśli nie podasz pierwszego argumentu, użyj <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenia metody w celu uzyskania lepszej wydajności.  
  
 Typ delegata i Metoda muszą mieć zgodne typy zwracane. Oznacza to, że zwracany typ `method` musi być możliwy do przypisania do `type`typu zwracanego.  
  
 Jeśli `firstArgument` jest podany, jest przekazywany do `method` każdego momentu wywołania delegata; `firstArgument` jest określana jako powiązana z delegatem, a delegat jest określany jako zamknięty w pierwszym argumencie. Jeśli `method` jest `static` ( `method` `firstArgument` w Visual Basic), lista argumentów dostarczona podczas wywoływania delegata zawiera wszystkie parametry z wyjątkiem pierwszej; jeśli jest to metoda wystąpienia, zostaje przekazana do wystąpienia ukrytego`Shared` parametr (reprezentowany przez `this` w C#, lub `Me` w Visual Basic).  
  
 Jeśli `firstArgument` jest podany, pierwszy parametr elementu `method` musi być typem referencyjnym i `firstArgument` musi być zgodny z tym typem.  
  
> [!IMPORTANT]
>  Jeśli `method` jest `static` ( <xref:System.Object> wVisualBasic<xref:System.ValueType>) i jego`firstArgument` pierwszy parametr jest typu lub, może być typem wartości.`Shared` W tym przypadku `firstArgument` jest automatycznie opakowany. Automatyczne pakowanie nie występuje dla żadnych innych argumentów, tak jak w przypadku C# wywołania funkcji lub Visual Basic.  
  
 Jeśli `firstArgument` jest odwołaniem o wartości `method` null i jest metodą wystąpienia, wynik zależy od sygnatur typu `type` delegata i `method`:  
  
-   Jeśli podpis `type` jawnie obejmuje ukryty pierwszy `method`parametr, delegat jest reprezentowany do reprezentowania metody otwartego wystąpienia. Gdy obiekt delegowany jest wywoływany, pierwszy argument na liście argumentów jest przenoszona do ukrytego wystąpienia parametru `method`.  
  
-   Jeśli sygnatury `method` i `type` są zgodne (to oznacza, że wszystkie typy parametrów są zgodne), delegat jest określany jako zamknięty w odniesieniu do wartości null. Wywoływanie delegata jest podobne do wywołania metody wystąpienia w wystąpieniu o wartości null, która nie jest szczególnie przydatna.  
  
 Jeśli `firstArgument` jest odwołaniem null i `method` jest statyczna, wynik zależy od sygnatur typu `type` delegata i `method`:  
  
-   Jeśli sygnatura `method` i `type` dopasowanie (to oznacza, że wszystkie typy parametrów są zgodne), delegat jest reprezentowany jako otwarta metoda statyczna. Jest to najbardziej typowy przypadek dla metod statycznych. W takim przypadku można uzyskać nieco lepszą wydajność przy użyciu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenia metody.  
  
-   Jeśli sygnatura `type` zaczyna się od drugiego `method` parametru, a pozostałe typy parametrów są zgodne, delegat jest uznawany za zamknięty w odniesieniu do wartości null. Gdy obiekt delegowany jest wywoływany, odwołanie o wartości null jest przesyłane do pierwszego `method`parametru.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Zgodne typy parametrów i zwracany typ  
 Typy parametrów i typ zwracany delegata muszą być zgodne z typami parametrów i zwracanym typem metody reprezentowanej przez delegata; typy nie muszą dokładnie pasować.  
  
> [!NOTE]
>  W .NET Framework w wersji 1,0 i 1,1 typy muszą dokładnie pasować.  
  
 Parametr delegata jest zgodny z odpowiadającym mu parametrem metody, jeśli typ parametru delegata jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przesłany do delegata może być bezpiecznie przekazywać do Metoda.  
  
 Analogicznie, zwracany typ delegata jest zgodny z typem zwracanym metody, Jeśli zwracany typ metody jest bardziej restrykcyjny niż typ zwracany delegata, ponieważ gwarantuje to, że wartość zwracana metody może być bezpiecznie rzutowana na typ zwracany e delegata.  
  
 Na przykład delegat <xref:System.Collections.Hashtable> z parametrem typu i <xref:System.Object> typem zwracanym może reprezentować metodę z parametrem typu <xref:System.Object> i wartością zwracaną typu <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Określenie metod, które może reprezentować delegat  
 Innym przydatnym sposobem, aby określić elastyczność zapewnianą przez to Przeciążenie <xref:System.Delegate.CreateDelegate%2A> , jest to, że każdy delegat może reprezentować cztery różne kombinacje sygnatur metody i rodzaju metody (statyczny a wystąpienie). Należy wziąć pod uwagę `D` typ delegata z jednym `C`argumentem typu. Poniżej opisano metody `D` , które mogą reprezentować, ignorowanie zwracanego typu, ponieważ musi on być zgodny we wszystkich przypadkach:  
  
-   `D`może reprezentować każdą metodę wystąpienia, która ma dokładnie jeden `C`argument typu, bez względu na typ, do którego należy metoda wystąpienia. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` to wystąpienie typu `method` należy do, a otrzymany delegat jest wskazany do zamknięcia tego wystąpienia. (W prosty sposób `D` można także zamknąć odwołanie o wartości null, jeśli `firstArgument` jest `null`).  
  
-   `D`może reprezentować metodę `C` wystąpienia, która nie ma żadnych argumentów. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest odwołaniem o wartości null. Przekazany delegat reprezentuje metodę otwartego wystąpienia, a wystąpienie `C` musi być dostarczone przy każdym wywołaniu.  
  
-   `D`może reprezentować metodę statyczną przyjmującą jeden argument `C`typu, która ta metoda może należeć do dowolnego typu. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest odwołaniem o wartości null. Przekazany delegat reprezentuje statyczną metodę, a wystąpienie `C` musi być dostarczone przy każdym wywołaniu.  
  
-   `D`może reprezentować metodę statyczną, która `F` należy do typu, i ma dwa `F` argumenty typu `C`i typu. Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest wystąpieniem `F`. Otrzymany delegat reprezentuje statyczną metodę, która jest zamknięta dla `F`tego wystąpienia. Należy zauważyć, że w przypadku `F` gdy `C` i są tego samego typu, metoda statyczna ma dwa argumenty tego typu. (W tym przypadku jest `D` zamknięte przez odwołanie o wartości null, `firstArgument` Jeśli `null`jest).  
  
   
  
## Examples  
 Ta sekcja zawiera trzy przykłady kodu. W pierwszym przykładzie pokazano cztery rodzaje delegatów, które można utworzyć: zamknięte przez metodę wystąpienia, Otwórz w metodzie wystąpienia, Otwórz za pomocą metody statycznej i zamknięte przez metodę statyczną.  
  
 Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
 Trzeci przykład kodu definiuje pojedynczy typ delegata i pokazuje wszystkie metody, które może reprezentować typ delegata.  
  
 **Przykład 1**  
  
 Poniższy przykład kodu demonstruje cztery sposoby tworzenia delegata przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, które określają `firstArgument` i a <xref:System.Reflection.MethodInfo>; ich funkcjonalność jest taka sama, z tą różnicą, że jedna z nich pozwala określić, czy zgłaszać błąd w przypadku niepowodzenia, a drugie. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład `C` deklaruje klasę z metodą `M2` statyczną i metodą `M1`wystąpienia, a `C` trzy typy delegatów: `D1` przyjmuje wystąpienie i ciąg, `D2` Pobiera ciąg i `D3`nie ma argumentów.  
  
 Druga klasa o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegat typu `D2`, zamknięty w `C`wystąpieniu, jest tworzony dla metody `M1`wystąpienia. Jest wywoływana z innymi ciągami, aby pokazać, że powiązane wystąpienie `C` jest zawsze używane.  
  
-   Delegat typu `D1`, reprezentujący otwartą metodę wystąpienia, jest tworzony dla metody `M1`wystąpienia. Wystąpienie musi zostać przekazane podczas wywoływania delegata.  
  
-   Delegat typu `D2`, reprezentujący otwartą metodę statyczną, jest tworzony dla metody `M2`statycznej.  
  
-   Na koniec, delegat typu `D3`, zamknięty w ciągu, jest tworzony dla metody `M2`statycznej. Metoda jest wywoływana, aby pokazać, że używa powiązanego ciągu.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.  
  
> [!NOTE]
>  Ten przykład kodu używa <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenia metody. Użycie innych przeciążeń <xref:System.Reflection.MethodInfo> jest podobne.  
  
 Przykładowy kod definiuje klasę bazową o nazwie `Base` i klasę o nazwie `Derived` , która dziedziczy `Base`z. Klasa pochodna `static` ma metodę (`Shared` w Visual Basic) o nazwie `MyMethod` z jednym `Derived`parametrem typu `Base` i typem zwracanym. Przykład kodu definiuje także delegat o nazwie `Example` , który ma jeden parametr typu `Derived` `Base`i zwracany typ.  
  
 Przykład kodu pokazuje, że delegat o nazwie `Example` może służyć do reprezentowania metody. `MyMethod` Metodę można powiązać z delegatem, ponieważ:  
  
-   Typ`Derived`parametru delegata () jest bardziej restrykcyjny niż `MyMethod` typ parametru (`Base`), dzięki czemu zawsze można bezpiecznie przekazać argument delegata do `MyMethod`.  
  
-   Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpiecznie do rzutowania zwracanego typu metody na zwracany typ delegata.  
  
 W przykładowym kodzie nie są generowane żadne dane wyjściowe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Przykład 3**  
  
 Poniższy przykład kodu przedstawia wszystkie metody, które może reprezentować pojedynczy typ delegata.  
  
> [!NOTE]
>  Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, które określają `firstArgument` i a <xref:System.Reflection.MethodInfo>; ich funkcjonalność jest taka sama, z tą różnicą, że jedna z nich pozwala określić, czy zgłaszać błąd w przypadku niepowodzenia, a drugie. W tym przykładzie kodu są używane oba przeciążenia.  
  
 Przykład kodu definiuje dwie klasy `C` , i `F`i typ `D` delegata z jednym argumentem typu `C`. Klasy mają zgodne metody `M1`static i instance, `M3`klasy `C` i `M4`, a także mają metodę `M2` wystąpienia, która nie ma argumentów.  
  
 Trzecia Klasa o nazwie `Example` zawiera kod, który tworzy delegatów.  
  
-   Delegaty są tworzone dla metody `M1` wystąpienia typu `C` i typu `F`; każda z nich jest zamknięta na wystąpieniu odpowiedniego typu. Metoda `M1` typu `C` wyświetla`ID` właściwości wystąpienia powiązanego i argumentu.  
  
-   Obiekt delegowany jest tworzony dla `M2` metody typu `C`. Jest to delegata otwartego wystąpienia, w którym argument delegata reprezentuje ukryty pierwszy argument metody Instance. Metoda nie ma innych argumentów.  
  
-   Delegaty są tworzone dla statycznej `M3` metody `C` typu i `F`typu; są to otwarte elementy delegowane static.  
  
-   Na koniec są tworzone Delegaty dla statycznej `M4` metody `C` typu i `F`typu; każda metoda ma typ deklarujący jako pierwszy argument, a wystąpienie typu jest dostarczane, więc Delegaty są zamykane w ramach swoich pierwszych argumentów . Metoda `M4` typu `C` wyświetla`ID` właściwości wystąpienia powiązanego i argumentu.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" />nie <see langword="RuntimeType" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="method" />nie można powiązać <paramref name="throwOnBindFailure" />. <see langword="true" />  
  
—lub— 
 <paramref name="method" />nie <see langword="RuntimeMethodInfo" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Delegat do utworzenia.</param>
        <param name="target">Wystąpienie klasy, na którym <paramref name="method" /> jest wywoływane.</param>
        <param name="method">Nazwa metody wystąpienia, która ma być reprezentowana przez delegata.</param>
        <param name="ignoreCase">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</param>
        <summary>Tworzy delegat określonego typu, który reprezentuje określoną metodę wystąpienia do wywołania w określonym wystąpieniu klasy o określonej wielkości liter.</summary>
        <returns>Delegat określonego typu reprezentujący określoną metodę wystąpienia do wywołania w określonym wystąpieniu klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów tylko dla metod wystąpienia. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 To Przeciążenie metody jest równoważne wywołaniu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> metody przeciążenia, określając `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="target" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" />nie <see langword="RuntimeType" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="method" />nie jest metodą wystąpienia.  
  
—lub— 
 <paramref name="method" />nie można powiązać, na przykład ponieważ nie można go znaleźć.</exception>
        <exception cref="T:System.MissingMethodException">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Delegat do utworzenia.</param>
        <param name="target">Reprezentuje klasę, która implementuje <paramref name="method" />. <see cref="T:System.Type" /></param>
        <param name="method">Nazwa metody statycznej, która ma być reprezentowana przez delegata.</param>
        <param name="ignoreCase">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</param>
        <summary>Tworzy delegat określonego typu, który reprezentuje określoną metodę statyczną określonej klasy, z określoną rozróżnianiem wielkości liter.</summary>
        <returns>Delegat określonego typu, który reprezentuje określoną metodę statyczną określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów tylko dla metod statycznych. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 To Przeciążenie metody jest równoważne wywołaniu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> metody przeciążenia, określając `true` dla `throwOnBindFailure`.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="target" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" />nie <see langword="RuntimeType" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="target" />nie <see langword="RuntimeType" />jest.  
  
—lub— 
 <paramref name="target" />jest otwartym typem ogólnym. Oznacza to, że <see cref="P:System.Type.ContainsGenericParameters" /> jego właściwość <see langword="true" />jest.  
  
—lub— 
 <paramref name="method" />nie <see langword="static" /> jest metodą (<see langword="Shared" /> Metoda w Visual Basic).  
  
—lub— 
 <paramref name="method" />nie można powiązać, na przykład ponieważ nie można go znaleźć.</exception>
        <exception cref="T:System.MissingMethodException">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Delegat do utworzenia.</param>
        <param name="target">Wystąpienie klasy, na którym <paramref name="method" /> jest wywoływane.</param>
        <param name="method">Nazwa metody wystąpienia, która ma być reprezentowana przez delegata.</param>
        <param name="ignoreCase">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</param>
        <param name="throwOnBindFailure"><see langword="true" />Aby zgłosić wyjątek, <paramref name="method" /> <see langword="false" />Jeśli nie można go powiązać; w przeciwnym razie.</param>
        <summary>Tworzy delegat określonego typu, który reprezentuje określoną metodę wystąpienia do wywołania w określonym wystąpieniu klasy, z określoną wielkością liter i określonym zachowaniem w przypadku niepowodzenia powiązania.</summary>
        <returns>Delegat określonego typu reprezentujący określoną metodę wystąpienia do wywołania w określonym wystąpieniu klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów tylko dla metod wystąpienia. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="target" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" />nie <see langword="RuntimeType" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="method" />nie jest metodą wystąpienia.  
  
—lub— 
 <paramref name="method" />nie można powiązać, na przykład, ponieważ nie można go znaleźć i <paramref name="throwOnBindFailure" /> ma <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Delegat do utworzenia.</param>
        <param name="target">Reprezentuje klasę, która implementuje <paramref name="method" />. <see cref="T:System.Type" /></param>
        <param name="method">Nazwa metody statycznej, która ma być reprezentowana przez delegata.</param>
        <param name="ignoreCase">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</param>
        <param name="throwOnBindFailure"><see langword="true" />Aby zgłosić wyjątek, <paramref name="method" /> <see langword="false" />Jeśli nie można go powiązać; w przeciwnym razie.</param>
        <summary>Tworzy delegat określonego typu, który reprezentuje określoną metodę statyczną określonej klasy, z określoną wielkością liter i określonym zachowaniem w przypadku niepowodzenia powiązania.</summary>
        <returns>Delegat określonego typu, który reprezentuje określoną metodę statyczną określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy delegatów tylko dla metod statycznych. Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="target" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.  
  
—lub— 
 <paramref name="type" />nie <see langword="RuntimeType" />jest. Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
—lub— 
 <paramref name="target" />nie <see langword="RuntimeType" />jest.  
  
—lub— 
 <paramref name="target" />jest otwartym typem ogólnym. Oznacza to, że <see cref="P:System.Type.ContainsGenericParameters" /> jego właściwość <see langword="true" />jest.  
  
—lub— 
 <paramref name="method" />nie <see langword="static" /> jest metodą (<see langword="Shared" /> Metoda w Visual Basic).  
  
—lub— 
 <paramref name="method" />nie można powiązać, na przykład, ponieważ nie można go znaleźć i <paramref name="throwOnBindFailure" /> ma <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Tablica obiektów, które są argumentami, które mają zostać przekazane do metody reprezentowanej przez bieżącego delegata.  
  
—lub— 
 <see langword="null" />, jeśli metoda reprezentowana przez bieżącego delegata nie wymaga argumentów.</param>
        <summary>Dynamicznie wywołuje (późne wiązanie) metodę reprezentowaną przez bieżącego delegata.</summary>
        <returns>Obiekt zwrócony przez metodę reprezentowaną przez delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.Delegate.DynamicInvokeImpl%2A> metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).  
  
—lub— 
Liczba, kolejność lub typ parametrów wymienionych w <paramref name="args" /> jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentException">Metoda reprezentowana przez delegata jest wywoływana dla obiektu lub klasy, która go nie obsługuje.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Metoda reprezentowana przez delegata jest metodą wystąpienia, a obiektem docelowym jest <see langword="null" />.  
  
—lub— 
Jedna z metod hermetyzowanych zgłasza wyjątek.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args">Tablica obiektów, które są argumentami, które mają zostać przekazane do metody reprezentowanej przez bieżącego delegata.  
  
—lub— 
 <see langword="null" />, jeśli metoda reprezentowana przez bieżącego delegata nie wymaga argumentów.</param>
        <summary>Dynamicznie wywołuje (późne wiązanie) metodę reprezentowaną przez bieżącego delegata.</summary>
        <returns>Obiekt zwrócony przez metodę reprezentowaną przez delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje <xref:System.Delegate.DynamicInvoke%2A> metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).  
  
—lub— 
Liczba, kolejność lub typ parametrów wymienionych w <paramref name="args" /> jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentException">Metoda reprezentowana przez delegata jest wywoływana dla obiektu lub klasy, która go nie obsługuje.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Metoda reprezentowana przez delegata jest metodą wystąpienia, a obiektem docelowym jest <see langword="null" />.  
  
—lub— 
Jedna z metod hermetyzowanych zgłasza wyjątek.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z bieżącym delegatem.</param>
        <summary>Określa, czy określony obiekt i bieżący delegat są tego samego typu i mają te same cele, metody i listę wywołań.</summary>
        <returns><see langword="true" />Jeśli <paramref name="obj" /> i bieżący delegat ma te same cele, metody i listę wywołań; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dwa Delegaty nie są tego samego typu, nie są uważane za równe.  
  
> [!IMPORTANT]
>  W .NET Framework w wersji 1,0 i 1,1 dwa Delegaty zostały uznane za równe, jeśli ich obiekty docelowe, metody i Lista wywołań były równe, nawet jeśli Delegaty mają różne typy.  
  
 Metody i cele są porównywane pod kątem równości w następujący sposób:  
  
-   Jeśli dwie metody, które są porównywane, są zarówno statyczne, jak i są tymi samymi metodami w tej samej klasie, metody są uważane za równe, a obiekty docelowe są również traktowane jako równe.  
  
-   Jeśli dwie metody, które są porównywane są metodami wystąpień i są tej samej metody dla tego samego obiektu, metody są uważane za równe, a obiekty docelowe są również traktowane jako równe.  
  
-   W przeciwnym razie metody nie są uważane za równe, a elementy docelowe również nie są traktowane jako równe.  
  
 Dwa wywołania są uważane za identyczne tylko wtedy, gdy mają takie same kolejność, a odpowiednie elementy z dwóch list reprezentują tę samą metodę i element docelowy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu delegata.</summary>
        <returns>Kod skrótu delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana tej metody nie może być utrwalona z dwóch przyczyn. Po pierwsze funkcja skrótu klasy może zostać zmieniona w celu wygenerowania lepszej dystrybucji, co spowoduje, że wszystkie wartości ze starej funkcji mieszania są bezużyteczne. Po drugie, domyślna implementacja tej klasy nie gwarantuje, że ta sama wartość zostanie zwrócona przez różne wystąpienia.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę wywołań delegata.</summary>
        <returns>Tablica delegatów reprezentujących listę wywołań bieżącego delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy delegat w tablicy reprezentuje dokładnie jedną metodę.  
  
 Kolejność delegatów w tablicy jest taka sama jak kolejność, w której bieżący delegat wywołuje metody, które reprezentują te Delegaty.  
  
   
  
## Examples  
 Poniższy przykład przypisuje trzy metody do delegata. Następnie wywołuje <xref:System.Delegate.GetInvocationList%2A> metodę, aby uzyskać łączną liczbę metod przypisanych do delegata, do wykonywania delegatów w odwrotnej kolejności oraz do wykonywania metod, których nazwa nie zawiera podciągu "File".  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera metodę statyczną reprezentowaną przez bieżącego delegata.</summary>
        <returns><see cref="T:System.Reflection.MethodInfo" /> Opis metody statycznej reprezentowanej przez bieżącego delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma zastosowanie tylko wtedy, gdy bieżący delegat reprezentuje metodę statyczną.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Nieobsługiwane.</param>
        <param name="context">Nieobsługiwane.</param>
        <summary>Nieobsługiwane.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obsługiwana.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metodę reprezentowaną przez delegata.</summary>
        <value>A <see cref="T:System.Reflection.MethodInfo" /> opisywanie metody reprezentowanej przez delegata.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Pierwszy delegat do porównania.</param>
        <param name="d2">Drugi delegat do porównania.</param>
        <summary>Określa, czy określone Delegaty są równe.</summary>
        <returns><see langword="true" />Jeśli <paramref name="d1" /> jest <see langword="false" />równa; w przeciwnym razie,. <paramref name="d2" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa Delegaty tego samego typu z tymi samymi obiektami docelowymi, metodami i listami wywołań są uważane za równe.  
  
 Jeśli dwa Delegaty nie są tego samego typu, nie są uważane za równe.  
  
> [!IMPORTANT]
>  W .NET Framework w wersji 1,0 i 1,1 dwa Delegaty zostały uznane za równe, jeśli ich obiekty docelowe, metody i Lista wywołań były równe, nawet jeśli Delegaty mają różne typy.  
  
 Metody i cele są porównywane pod kątem równości w następujący sposób:  
  
-   Jeśli dwie metody, które są porównywane, są zarówno statyczne, jak i są tymi samymi metodami w tej samej klasie, metody są uważane za równe, a obiekty docelowe są również traktowane jako równe.  
  
-   Jeśli dwie metody, które są porównywane są metodami wystąpień i są tej samej metody dla tego samego obiektu, metody są uważane za równe, a obiekty docelowe są również traktowane jako równe.  
  
-   W przeciwnym razie metody nie są uważane za równe, a elementy docelowe również nie są traktowane jako równe.  
  
 Dwa wywołania list są uważane za identyczne, jeśli mają taką samą kolejność, a odpowiednie elementy z dwóch list reprezentują tę samą metodę i cel.  
  
 Równoważna Metoda dla tego operatora to<xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Pierwszy delegat do porównania.</param>
        <param name="d2">Drugi delegat do porównania.</param>
        <summary>Określa, czy określone Delegaty nie są równe.</summary>
        <returns><see langword="true" />Jeśli <paramref name="d1" /> nie jest <paramref name="d2" />równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa Delegaty są uważane za nierówne, jeśli są różnymi typami lub mają różne metody, różne elementy docelowe lub różne listy wywołań.  
  
 Jeśli dwa Delegaty nie są tego samego typu, nie są uważane za równe.  
  
> [!IMPORTANT]
>  W .NET Framework w wersji 1,0 i 1,1 dwa Delegaty są uważane za równe, jeśli ich obiekty docelowe, metody i Lista wywołań były równe, nawet jeśli Delegaty mają różne typy.  
  
 Metody i cele są porównywane pod kątem równości w następujący sposób:  
  
-   Jeśli dwie metody, które są porównywane, są zarówno statyczne, jak i są tymi samymi metodami w tej samej klasie, metody są uważane za równe, a obiekty docelowe są również traktowane jako równe.  
  
-   Jeśli dwie metody, które są porównywane są metodami wystąpień i są tej samej metody dla tego samego obiektu, metody są uważane za równe, a obiekty docelowe są również traktowane jako równe.  
  
-   W przeciwnym razie metody nie są uważane za równe, a elementy docelowe również nie są traktowane jako równe.  
  
 Dwa wywołania nie są równe, jeśli mają różne rozmiary, jeśli są uporządkowane inaczej lub jeśli co najmniej jeden element z jednej listy reprezentuje metodę lub obiekt docelowy, który jest inny niż ten, który jest reprezentowany przez odpowiadający mu element na drugiej liście.  
  
 Równoważna Metoda dla tego operatora to<xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Delegat, z którego ma zostać usunięta lista <paramref name="value" />wywołań.</param>
        <param name="value">Delegat, który dostarcza listę wywołań do usunięcia z listy <paramref name="source" />wywołań.</param>
        <summary>Usuwa ostatnią liczbę wywołań listy delegatów z listy wywołań innego delegata.</summary>
        <returns>Nowy delegat <paramref name="source" /> z listą wywołania utworzoną przez pobranie listy wywołań i usunięcie ostatniego wystąpienia <paramref name="value" />listy wywołań, jeśli lista <paramref name="value" /> wywołań znajduje się na liście wywołań elementu <paramref name="source" />w elemencie. Zwraca <paramref name="source" /> wartość <paramref name="value" /> , <see langword="null" /> jeśli jest lub jeśli nie można odnaleźć <paramref name="value" /> listy wywołań w wywołaniu listy <paramref name="source" />. Zwraca odwołanie o wartości null, jeśli lista <paramref name="value" /> wywołań jest równa <paramref name="source" /> liście wywołań lub jeśli <paramref name="source" /> jest odwołaniem o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli lista `value` wywołań `value` jest zgodna z ciągłym zestawem elementów na `source`liście wywołań, wówczas Lista wywołań jest określana na liście wywołań elementu `source`. Jeśli lista `value` wywołań występuje więcej niż jeden raz na `source`liście wywołań, ostatnie wystąpienie zostanie usunięte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <exception cref="T:System.ArgumentException">Typy delegatów nie są zgodne.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Delegat, z którego ma zostać usunięta lista <paramref name="value" />wywołań.</param>
        <param name="value">Delegat, który dostarcza listę wywołań do usunięcia z listy <paramref name="source" />wywołań.</param>
        <summary>Usuwa wszystkie wystąpienia list wywołania delegata z listy wywołań innego delegata.</summary>
        <returns>Nowy delegat <paramref name="source" /> z listą wywołania utworzoną przez pobranie listy wywołań i usunięcie wszystkich wystąpień <paramref name="value" />listy wywołań, jeśli lista <paramref name="value" /> wywołań znajduje się na liście wywołań elementu <paramref name="source" />w elemencie. Zwraca <paramref name="source" /> wartość <paramref name="value" /> , <see langword="null" /> jeśli jest lub jeśli nie można odnaleźć <paramref name="value" /> listy wywołań w wywołaniu listy <paramref name="source" />. Zwraca odwołanie o wartości null, <paramref name="value" /> Jeśli lista wywołań jest równa liście wywołań elementu <paramref name="source" />, jeśli <paramref name="source" /> zawiera tylko serie list wywołań, które <paramref name="value" />są równe liście wywołań, lub jeśli <paramref name="source" /> ma wartość null odwoła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli lista `value` wywołań `value` jest zgodna z ciągłym zestawem elementów na `source`liście wywołań, wówczas Lista wywołań jest określana na liście wywołań elementu `source`. Jeśli lista `value` wywołań występuje więcej niż jeden raz na liście wywołań elementu `source`, wszystkie wystąpienia są usuwane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <exception cref="T:System.ArgumentException">Typy delegatów nie są zgodne.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">Delegat, który dostarcza listę wywołań do usunięcia z listy wywołań bieżącego delegata.</param>
        <summary>Usuwa listę wywołań delegata z listy wywołań innego delegata.</summary>
        <returns>Nowy delegat z listą wywołania utworzoną przez pobranie listy wywołań bieżącego delegata i usunięcie listy <paramref name="value" />wywołań, jeśli <paramref name="value" /> Lista wywołań znajduje się na liście wywołań bieżącego delegata. Zwraca bieżący delegat, jeśli <paramref name="value" /> jest <see langword="null" /> lub jeśli lista <paramref name="value" /> wywołań nie została znaleziona w obrębie listy wywołań bieżącego delegata. Zwraca <see langword="null" /> czy<paramref name="value" /> Lista wywołań jest równa bieżącej liście wywołań obiektu delegowanego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli lista `value` wywołań pasuje do ciągłego zestawu elementów na liście wywołań bieżącego delegata, `value` Lista wywołań jest określana na liście wywołań bieżącego delegata. Jeśli lista `value` wywołań występuje więcej niż raz na liście wywołań bieżącego delegata, ostatnie wystąpienie zostanie usunięte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wystąpienie klasy, dla którego bieżący delegat wywołuje metodę wystąpienia.</summary>
        <value>Obiekt, na którym bieżący delegat wywołuje metodę wystąpienia, jeśli delegat reprezentuje metodę wystąpienia; <see langword="null" /> Jeśli delegat reprezentuje metodę statyczną.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.  
  
 Jeśli delegat wywołuje jedną lub więcej metod wystąpienia, ta właściwość zwraca element docelowy ostatniej instancji metody na liście wywołań.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>

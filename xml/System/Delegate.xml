<Type Name="Delegate" FullName="System.Delegate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="49bd802fa8ffc3122beb07d490740f9cf8d7af4c" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69406631" /></Metadata><TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="4aab0-101">Reprezentuje delegata, który jest strukturą danych, która odwołuje się do metody statycznej lub do wystąpienia klasy i metody wystąpienia tej klasy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-101">Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-102"><xref:System.Delegate> Klasa jest klasą bazową dla typów delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-102">The <xref:System.Delegate> class is the base class for delegate types.</span></span> <span data-ttu-id="4aab0-103">Jednak tylko system i kompilatory mogą pochodzić jawnie z <xref:System.Delegate> klasy lub <xref:System.MulticastDelegate> z klasy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-103">However, only the system and compilers can derive explicitly from the <xref:System.Delegate> class or from the <xref:System.MulticastDelegate> class.</span></span> <span data-ttu-id="4aab0-104">Nie jest również dozwolone uzyskanie nowego typu z typu delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-104">It is also not permissible to derive a new type from a delegate type.</span></span> <span data-ttu-id="4aab0-105"><xref:System.Delegate> Klasa nie jest uważana za typ delegata; jest to Klasa używana do wyprowadzania typów delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-105">The <xref:System.Delegate> class is not considered a delegate type; it is a class used to derive delegate types.</span></span>  
  
 <span data-ttu-id="4aab0-106">Większość języków implementuje `delegate` słowo kluczowe i kompilatory dla tych języków mogą dziedziczyć <xref:System.MulticastDelegate> z klasy, w związku z czym użytkownicy powinni używać `delegate` słowa kluczowego dostarczonego przez język.</span><span class="sxs-lookup"><span data-stu-id="4aab0-106">Most languages implement a `delegate` keyword, and compilers for those languages are able to derive from the <xref:System.MulticastDelegate> class; therefore, users should use the `delegate` keyword provided by the language.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-107">Środowisko uruchomieniowe języka wspólnego udostępnia `Invoke` metodę dla każdego typu delegata z tą samą sygnaturą co delegat.</span><span class="sxs-lookup"><span data-stu-id="4aab0-107">The common language runtime provides an `Invoke` method for each delegate type, with the same signature as the delegate.</span></span> <span data-ttu-id="4aab0-108">Nie trzeba jawnie wywoływać tej metody z C#, Visual Basic lub wizualizacji C++, ponieważ kompilatory automatycznie wywołują tę metodę.</span><span class="sxs-lookup"><span data-stu-id="4aab0-108">You do not have to call this method explicitly from C#, Visual Basic, or Visual C++, because the compilers call it automatically.</span></span> <span data-ttu-id="4aab0-109">Metoda jest przydatna podczas odbicia, gdy chcesz znaleźć podpis typu delegata. [](~/docs/framework/reflection-and-codedom/reflection.md) `Invoke`</span><span class="sxs-lookup"><span data-stu-id="4aab0-109">The `Invoke` method is useful in [reflection](~/docs/framework/reflection-and-codedom/reflection.md) when you want to find the signature of the delegate type.</span></span>  
  
 <span data-ttu-id="4aab0-110">Środowisko uruchomieniowe języka wspólnego zapewnia każdy typ delegata `EndInvoke` z `BeginInvoke` metodami i, aby umożliwić asynchroniczne wywołanie delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-110">The common language runtime provides each delegate type with `BeginInvoke` and `EndInvoke` methods, to enable asynchronous invocation of the delegate.</span></span> <span data-ttu-id="4aab0-111">Aby uzyskać więcej informacji na temat tych metod, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="4aab0-111">For more information about these methods, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
 <span data-ttu-id="4aab0-112">Deklaracja typu delegata ustanawia kontrakt, który określa podpis jednej lub kilku metod.</span><span class="sxs-lookup"><span data-stu-id="4aab0-112">The declaration of a delegate type establishes a contract that specifies the signature of one or more methods.</span></span> <span data-ttu-id="4aab0-113">Delegat jest wystąpieniem typu delegata, do którego odwołuje się:</span><span class="sxs-lookup"><span data-stu-id="4aab0-113">A delegate is an instance of a delegate type that has references to:</span></span>  
  
-   <span data-ttu-id="4aab0-114">Metoda wystąpienia typu i obiektu docelowego można przypisać do tego typu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-114">An instance method of a type and a target object assignable to that type.</span></span>  
  
-   <span data-ttu-id="4aab0-115">Metoda wystąpienia typu, z ukrytym `this` parametrem uwidocznionym na liście parametrów formalnych.</span><span class="sxs-lookup"><span data-stu-id="4aab0-115">An instance method of a type, with the hidden `this` parameter exposed in the formal parameter list.</span></span> <span data-ttu-id="4aab0-116">Delegat jest nazywany delegatem otwartego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-116">The delegate is said to be an open instance delegate.</span></span>  
  
-   <span data-ttu-id="4aab0-117">Metoda statyczna.</span><span class="sxs-lookup"><span data-stu-id="4aab0-117">A static method.</span></span>  
  
-   <span data-ttu-id="4aab0-118">Metoda statyczna i obiekt docelowy można przypisać do pierwszego parametru metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-118">A static method and a target object assignable to the first parameter of the method.</span></span> <span data-ttu-id="4aab0-119">Delegat jest określany jako zamknięty w pierwszym argumencie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-119">The delegate is said to be closed over its first argument.</span></span>  
  
 <span data-ttu-id="4aab0-120">Aby uzyskać więcej informacji na temat powiązania delegata <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> , zobacz Przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-120">For more information on delegate binding, see the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-121">W .NET Framework wersje 1,0 i 1,1 delegat może reprezentować metodę tylko wtedy, gdy podpis metody dokładnie pasuje do podpisu określonego przez typ delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-121">In the .NET Framework versions 1.0 and 1.1, a delegate can represent a method only if the signature of the method exactly matches the signature specified by the delegate type.</span></span> <span data-ttu-id="4aab0-122">W tym celu obsługiwane są tylko pierwsze i trzecie punktory na poprzedniej liście, a pierwszy punktor wymaga dokładnego dopasowania typu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-122">Thus, only the first and third bullets in the preceding list are supported, and the first bullet requires an exact type match.</span></span>  
  
 <span data-ttu-id="4aab0-123">Gdy delegat reprezentuje metodę wystąpienia zamkniętą względem pierwszego argumentu (najczęściej używany przypadek), delegat przechowuje odwołanie do punktu wejścia metody i odwołanie do obiektu, nazywany obiektem docelowym, który jest typu, który można przypisać do typu, który definiuje Method.</span><span class="sxs-lookup"><span data-stu-id="4aab0-123">When a delegate represents an instance method closed over its first argument (the most common case), the delegate stores a reference to the method's entry point and a reference to an object, called the target, which is of a type assignable to the type that defined the method.</span></span> <span data-ttu-id="4aab0-124">Gdy delegat reprezentuje metodę otwartego wystąpienia, przechowuje odwołanie do punktu wejścia metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-124">When a delegate represents an open instance method, it stores a reference to the method's entry point.</span></span> <span data-ttu-id="4aab0-125">Podpis delegata musi zawierać ukryty `this` parametr na liście parametrów formalnych. w tym przypadku delegat nie ma odwołania do obiektu docelowego, a obiekt docelowy musi być dostarczony, gdy delegat jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="4aab0-125">The delegate signature must include the hidden `this` parameter in its formal parameter list; in this case, the delegate does not have a reference to a target object, and a target object must be supplied when the delegate is invoked.</span></span>  
  
 <span data-ttu-id="4aab0-126">Gdy delegat reprezentuje metodę statyczną, delegat przechowuje odwołanie do punktu wejścia metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-126">When a delegate represents a static method, the delegate stores a reference to the method's entry point.</span></span> <span data-ttu-id="4aab0-127">Gdy delegat reprezentuje statyczną metodę zamkniętą względem pierwszego argumentu, delegat przechowuje odwołanie do punktu wejścia metody i odwołanie do obiektu docelowego można przypisać do typu pierwszego argumentu metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-127">When a delegate represents a static method closed over its first argument, the delegate stores a reference to the method's entry point and a reference to a target object assignable to the type of the method's first argument.</span></span> <span data-ttu-id="4aab0-128">Gdy delegat jest wywoływany, pierwszy argument metody statycznej otrzymuje obiekt docelowy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-128">When the delegate is invoked, the first argument of the static method receives the target object.</span></span>  
  
 <span data-ttu-id="4aab0-129">Lista wywołań delegata jest uporządkowanym zestawem delegatów, w których każdy element listy wywołuje dokładnie jedną z metod reprezentowanych przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-129">The invocation list of a delegate is an ordered set of delegates in which each element of the list invokes exactly one of the methods represented by the delegate.</span></span> <span data-ttu-id="4aab0-130">Lista wywołań może zawierać zduplikowane metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-130">An invocation list can contain duplicate methods.</span></span> <span data-ttu-id="4aab0-131">W trakcie wywołania metody są wywoływane w kolejności, w jakiej występują na liście wywołań.</span><span class="sxs-lookup"><span data-stu-id="4aab0-131">During an invocation, methods are invoked in the order in which they appear in the invocation list.</span></span> <span data-ttu-id="4aab0-132">Delegat próbuje wywołać każdą metodę na swojej liście wywołań; duplikaty są wywoływane raz dla każdej chwili, gdy pojawiają się na liście wywołań.</span><span class="sxs-lookup"><span data-stu-id="4aab0-132">A delegate attempts to invoke every method in its invocation list; duplicates are invoked once for each time they appear in the invocation list.</span></span> <span data-ttu-id="4aab0-133">Delegaty są niezmienne; Po utworzeniu Lista wywołań delegata nie zmienia się.</span><span class="sxs-lookup"><span data-stu-id="4aab0-133">Delegates are immutable; once created, the invocation list of a delegate does not change.</span></span>  
  
 <span data-ttu-id="4aab0-134">Delegaty nazywa się multiemisją lub kombinacją, ponieważ delegat może wywołać jedną lub więcej metod i może być używany w operacjach łączenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-134">Delegates are referred to as multicast, or combinable, because a delegate can invoke one or more methods and can be used in combining operations.</span></span>  
  
 <span data-ttu-id="4aab0-135">Łączenie operacji, takich jak <xref:System.Delegate.Combine%2A> i <xref:System.Delegate.Remove%2A>, nie zmieniaj istniejących delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-135">Combining operations, such as <xref:System.Delegate.Combine%2A> and <xref:System.Delegate.Remove%2A>, do not alter existing delegates.</span></span> <span data-ttu-id="4aab0-136">Zamiast tego, taka operacja zwraca nowy delegat zawierający wyniki operacji, niezmieniony delegata lub `null`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-136">Instead, such an operation returns a new delegate that contains the results of the operation, an unchanged delegate, or `null`.</span></span> <span data-ttu-id="4aab0-137">Operacja łączenia zwraca `null` , gdy wynik operacji jest delegatem, który nie odwołuje się do co najmniej jednej metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-137">A combining operation returns `null` when the result of the operation is a delegate that does not reference at least one method.</span></span> <span data-ttu-id="4aab0-138">Operacja łączenia zwraca niezmieniony delegata, gdy żądana operacja nie ma żadnego wpływu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-138">A combining operation returns an unchanged delegate when the requested operation has no effect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-139">Języki zarządzane używają <xref:System.Delegate.Combine%2A> metod i <xref:System.Delegate.Remove%2A> do implementowania operacji delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-139">Managed languages use the <xref:System.Delegate.Combine%2A> and <xref:System.Delegate.Remove%2A> methods to implement delegate operations.</span></span> <span data-ttu-id="4aab0-140">Przykłady zawierają `AddHandler` instrukcje i `RemoveHandler` w Visual Basic oraz operatory + = i-= w typach delegatów w. C#</span><span class="sxs-lookup"><span data-stu-id="4aab0-140">Examples include the `AddHandler` and `RemoveHandler` statements in Visual Basic and the += and -= operators on delegate types in C#.</span></span>  
  
 <span data-ttu-id="4aab0-141">Począwszy od, typy delegatów ogólnych mogą zawierać parametry typu variant. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="4aab0-141">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], generic delegate types can have variant type parameters.</span></span> <span data-ttu-id="4aab0-142">Parametry typu kontrawariantne mogą być używane jako typy parametrów delegata, a jako typ zwracany można użyć parametru typu współwariantowego.</span><span class="sxs-lookup"><span data-stu-id="4aab0-142">Contravariant type parameters can be used as parameter types of the delegate, and a covariant type parameter can be used as the return type.</span></span> <span data-ttu-id="4aab0-143">Ta funkcja umożliwia ogólne typy delegatów, które są tworzone na podstawie tej samej definicji typu ogólnego, tak aby były zgodne z przypisaniem, jeśli ich argumenty typu są typami odwołań z relacją dziedziczenia, jak wyjaśniono w [kowariancji i kontrawariancja ](~/docs/standard/generics/covariance-and-contravariance.md).</span><span class="sxs-lookup"><span data-stu-id="4aab0-143">This feature allows generic delegate types that are constructed from the same generic type definition to be assignment-compatible if their type arguments are reference types with an inheritance relationship, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-144">Delegaty ogólne, które są zgodne z przypisaniem ze względu na wariancję, nie muszą być kombinacją.</span><span class="sxs-lookup"><span data-stu-id="4aab0-144">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="4aab0-145">Aby można było połączyć, typy muszą dokładnie pasować.</span><span class="sxs-lookup"><span data-stu-id="4aab0-145">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="4aab0-146">Załóżmy na przykład, że Klasa o nazwie `Derived` pochodzi od klasy o nazwie. `Base`</span><span class="sxs-lookup"><span data-stu-id="4aab0-146">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="4aab0-147">Delegat typu `Action<Base>` (`Action(Of Base)` w Visual Basic) można przypisać do zmiennej typu `Action<Derived>`, ale nie można łączyć dwóch delegatów, ponieważ typy nie są dokładnie zgodne.</span><span class="sxs-lookup"><span data-stu-id="4aab0-147">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="4aab0-148">Jeśli wywołana metoda zgłasza wyjątek, Metoda przerywa wykonywanie, wyjątek jest przenoszona z powrotem do obiektu wywołującego delegata, a pozostałe metody na liście wywołań nie są wywoływane.</span><span class="sxs-lookup"><span data-stu-id="4aab0-148">If an invoked method throws an exception, the method stops executing, the exception is passed back to the caller of the delegate, and remaining methods in the invocation list are not invoked.</span></span> <span data-ttu-id="4aab0-149">Przechwytywanie wyjątku w obiekcie wywołującym nie zmienia tego zachowania.</span><span class="sxs-lookup"><span data-stu-id="4aab0-149">Catching the exception in the caller does not alter this behavior.</span></span>  
  
 <span data-ttu-id="4aab0-150">Gdy sygnatura metod wywoływanych przez delegata zawiera wartość zwracaną, delegat zwraca wartość zwracaną ostatniego elementu na liście wywołań.</span><span class="sxs-lookup"><span data-stu-id="4aab0-150">When the signature of the methods invoked by a delegate includes a return value, the delegate returns the return value of the last element in the invocation list.</span></span> <span data-ttu-id="4aab0-151">Gdy podpis zawiera parametr, który jest przesyłany przez odwołanie, końcowa wartość parametru jest wynikiem każdej metody na liście wywołań, która wykonuje sekwencyjne i aktualizuje wartość parametru.</span><span class="sxs-lookup"><span data-stu-id="4aab0-151">When the signature includes a parameter that is passed by reference, the final value of the parameter is the result of every method in the invocation list executing sequentially and updating the parameter's value.</span></span>  
  
 <span data-ttu-id="4aab0-152">Najbliższy odpowiednik delegata w C jest wskaźnikiem funkcji.</span><span class="sxs-lookup"><span data-stu-id="4aab0-152">The closest equivalent of a delegate in C is a function pointer.</span></span> <span data-ttu-id="4aab0-153">Delegat może reprezentować metodę statyczną lub metodę wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-153">A delegate can represent a static method or an instance method.</span></span> <span data-ttu-id="4aab0-154">Gdy delegat reprezentuje metodę wystąpienia, delegat przechowuje nie tylko odwołanie do punktu wejścia metody, ale również odwołanie do wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-154">When the delegate represents an instance method, the delegate stores not only a reference to the method's entry point, but also a reference to the class instance.</span></span> <span data-ttu-id="4aab0-155">W przeciwieństwie do wskaźników funkcji Delegaty są zorientowane obiektowo i typu bezpieczne.</span><span class="sxs-lookup"><span data-stu-id="4aab0-155">Unlike function pointers, delegates are object oriented and type safe.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4aab0-156">Poniższy przykład pokazuje, jak zdefiniować delegata o nazwie `myMethodDelegate`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-156">The following example shows how to define a delegate named `myMethodDelegate`.</span></span> <span data-ttu-id="4aab0-157">Wystąpienia tego delegata są tworzone dla metody wystąpienia i statycznej metody klasy zagnieżdżonej `mySampleClass` .</span><span class="sxs-lookup"><span data-stu-id="4aab0-157">Instances of this delegate are created for an instance method and a static method of the nested `mySampleClass` class.</span></span> <span data-ttu-id="4aab0-158">Delegat dla metody Instance wymaga wystąpienia `mySampleClass`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-158">The delegate for the instance method requires an instance of `mySampleClass`.</span></span> <span data-ttu-id="4aab0-159">Wystąpienie jest zapisywane w zmiennej o nazwie `mySC`. `mySampleClass`</span><span class="sxs-lookup"><span data-stu-id="4aab0-159">The `mySampleClass` instance is saved in a variable named `mySC`.</span></span>  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb"><span data-ttu-id="4aab0-160">Wywołanie metod synchronicznych w sposób asynchroniczny</span><span class="sxs-lookup"><span data-stu-id="4aab0-160">Calling Synchronous Methods Asynchronously</span></span></related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md"><span data-ttu-id="4aab0-161">Delegaty (Przewodnik programowania w języku C#)</span><span class="sxs-lookup"><span data-stu-id="4aab0-161">Delegates (C# Programming Guide)</span></span></related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md"><span data-ttu-id="4aab0-162">Delegaty (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="4aab0-162">Delegates (Visual Basic)</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8"><span data-ttu-id="4aab0-163">Instrukcje: Definiowanie delegatów (C++/CLI) i korzystanie z nich</span><span class="sxs-lookup"><span data-stu-id="4aab0-163">How to: Define and Use Delegates (C++/CLI)</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f"><span data-ttu-id="4aab0-164">Obsługa i wywoływanie zdarzeń</span><span class="sxs-lookup"><span data-stu-id="4aab0-164">Handling and Raising Events</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4aab0-165">Inicjuje nowy delegat.</span><span class="sxs-lookup"><span data-stu-id="4aab0-165">Initializes a new delegate.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="4aab0-166">Wystąpienie klasy, na którym jest wywoływany <paramref name="method" />delegat.</span><span class="sxs-lookup"><span data-stu-id="4aab0-166">The class instance on which the delegate invokes <paramref name="method" />.</span></span></param>
        <param name="method"><span data-ttu-id="4aab0-167">Nazwa metody wystąpienia reprezentowanej przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-167">The name of the instance method that the delegate represents.</span></span></param>
        <summary><span data-ttu-id="4aab0-168">Inicjuje delegata, który wywołuje określoną metodę wystąpienia w określonym wystąpieniu klasy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-168">Initializes a delegate that invokes the specified instance method on the specified class instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-169">Tego konstruktora nie można używać w kodzie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4aab0-169">This constructor cannot be used in application code.</span></span> <span data-ttu-id="4aab0-170">Aby utworzyć delegata poprzez określenie nazwy metody wystąpienia, Użyj przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, która określa nazwę metody i obiekt docelowy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-170">To create a delegate by specifying the name of an instance method, use an overload of the <xref:System.Delegate.CreateDelegate%2A> method that specifies a method name and a target object.</span></span> <span data-ttu-id="4aab0-171">Na przykład <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> Przeciążenie metody tworzy delegata dla metody wystąpienia o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-171">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> method overload creates a delegate for an instance method with a specified name.</span></span>  
  
 <span data-ttu-id="4aab0-172">Ten konstruktor tworzy delegatów tylko dla metod wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-172">This constructor creates delegates for instance methods only.</span></span> <span data-ttu-id="4aab0-173">Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.</span><span class="sxs-lookup"><span data-stu-id="4aab0-173">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4aab0-174"><paramref name="target" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-174"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-175">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-175">-or-</span></span> 
 <span data-ttu-id="4aab0-176"><paramref name="method" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-176"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-177">Wystąpił błąd podczas tworzenia powiązania z metodą docelową.</span><span class="sxs-lookup"><span data-stu-id="4aab0-177">There was an error binding to the target method.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-178">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-178">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-179">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-179">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="4aab0-180">Reprezentuje klasę, która definiuje <paramref name="method" />. <see cref="T:System.Type" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-180">The <see cref="T:System.Type" /> representing the class that defines <paramref name="method" />.</span></span></param>
        <param name="method"><span data-ttu-id="4aab0-181">Nazwa metody statycznej reprezentowanej przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-181">The name of the static method that the delegate represents.</span></span></param>
        <summary><span data-ttu-id="4aab0-182">Inicjuje delegata, który wywołuje określoną metodę statyczną z określonej klasy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-182">Initializes a delegate that invokes the specified static method from the specified class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-183">Tego konstruktora nie można używać w kodzie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4aab0-183">This constructor cannot be used in application code.</span></span> <span data-ttu-id="4aab0-184">Aby utworzyć delegata poprzez określenie nazwy metody statycznej, Użyj przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, która określa nazwę metody, ale nie określa obiektu docelowego.</span><span class="sxs-lookup"><span data-stu-id="4aab0-184">To create a delegate by specifying the name of a static method, use an overload of the <xref:System.Delegate.CreateDelegate%2A> method that specifies a method name but does not specify a target object.</span></span> <span data-ttu-id="4aab0-185">Na przykład <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> Przeciążenie metody tworzy statyczny delegat dla metody o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-185">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> method overload creates a static delegate for a method with a specified name.</span></span>  
  
 <span data-ttu-id="4aab0-186">Ten konstruktor tworzy delegatów tylko dla metod statycznych.</span><span class="sxs-lookup"><span data-stu-id="4aab0-186">This constructor creates delegates for static methods only.</span></span> <span data-ttu-id="4aab0-187">Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.</span><span class="sxs-lookup"><span data-stu-id="4aab0-187">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4aab0-188"><paramref name="target" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-188"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-189">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-189">-or-</span></span> 
 <span data-ttu-id="4aab0-190"><paramref name="method" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-190"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-191"><paramref name="target" />nie <see langword="RuntimeType" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-191"><paramref name="target" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="4aab0-192">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-192">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="4aab0-193">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-193">-or-</span></span> 
 <span data-ttu-id="4aab0-194"><paramref name="target" />reprezentuje otwarty typ ogólny.</span><span class="sxs-lookup"><span data-stu-id="4aab0-194"><paramref name="target" /> represents an open generic type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-195">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-195">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-196">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-196">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aab0-197">Tworzy skróconą kopię delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-197">Creates a shallow copy of the delegate.</span></span></summary>
        <returns><span data-ttu-id="4aab0-198">Skrócona kopia delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-198">A shallow copy of the delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-199">Klon ma taką samą <xref:System.Type>, docelową, metodę i listę wywołań jak oryginalny delegat.</span><span class="sxs-lookup"><span data-stu-id="4aab0-199">The clone has the same <xref:System.Type>, target, method, and invocation list as the original delegate.</span></span>  
  
 <span data-ttu-id="4aab0-200">Kopia płytki tworzy nowe wystąpienie tego samego typu co oryginalny obiekt, a następnie kopiuje pola niestatyczne oryginalnego obiektu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-200">A shallow copy creates a new instance of the same type as the original object, and then copies the nonstatic fields of the original object.</span></span> <span data-ttu-id="4aab0-201">Jeśli pole jest typu wartości, zostanie przeprowadzona bitowa kopia przez bit pola.</span><span class="sxs-lookup"><span data-stu-id="4aab0-201">If the field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="4aab0-202">Jeśli pole jest typem referencyjnym, odwołanie jest kopiowane, ale określony obiekt nie jest; w związku z tym odwołanie w oryginalnym obiekcie i odwołanie w klonie wskazuje na ten sam obiekt.</span><span class="sxs-lookup"><span data-stu-id="4aab0-202">If the field is a reference type, the reference is copied but the referred object is not; therefore, the reference in the original object and the reference in the clone point to the same object.</span></span> <span data-ttu-id="4aab0-203">W przeciwieństwie do głębokiej kopii obiektu duplikuje wszystkie elementy, które bezpośrednio lub pośrednio odwołują się do pól w obiekcie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-203">In contrast, a deep copy of an object duplicates everything directly or indirectly referenced by the fields in the object.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-204">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-204">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-205">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-205">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4aab0-206">Łączy listy wywołań określonych obiektów delegowanych multiemisji (połączonych).</span><span class="sxs-lookup"><span data-stu-id="4aab0-206">Concatenates the invocation lists of the specified multicast (combinable) delegates.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates"><span data-ttu-id="4aab0-207">Tablica delegatów do połączenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-207">The array of delegates to combine.</span></span></param>
        <summary><span data-ttu-id="4aab0-208">Łączy listy wywołań tablicy delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-208">Concatenates the invocation lists of an array of delegates.</span></span></summary>
        <returns><span data-ttu-id="4aab0-209">Nowy delegat z listą wywołań, który łączy listy wywołań delegatów w <paramref name="delegates" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-209">A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <paramref name="delegates" /> array.</span></span> <span data-ttu-id="4aab0-210">Zwraca <see langword="null" /> wartość <paramref name="delegates" /> , <see langword="null" />jeśli jest <paramref name="delegates" /> , jeśli zawiera elementy zero lub jeśli każdy wpis <paramref name="delegates" /> w <see langword="null" />ma wartość.</span><span class="sxs-lookup"><span data-stu-id="4aab0-210">Returns <see langword="null" /> if <paramref name="delegates" /> is <see langword="null" />, if <paramref name="delegates" /> contains zero elements, or if every entry in <paramref name="delegates" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-211">Jeśli tablica zawiera wpisy, które są `null`ignorowane. `delegates`</span><span class="sxs-lookup"><span data-stu-id="4aab0-211">If the `delegates` array contains entries that are `null`, those entries are ignored.</span></span>  
  
 <span data-ttu-id="4aab0-212">Lista wywołań może zawierać zduplikowane wpisy; oznacza to, że wpisy odwołujące się do tej samej metody w tym samym obiekcie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-212">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-213">Delegaty ogólne, które są zgodne z przypisaniem ze względu na wariancję, nie muszą być kombinacją.</span><span class="sxs-lookup"><span data-stu-id="4aab0-213">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="4aab0-214">Aby można było połączyć, typy muszą dokładnie pasować.</span><span class="sxs-lookup"><span data-stu-id="4aab0-214">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="4aab0-215">Załóżmy na przykład, że Klasa o nazwie `Derived` pochodzi od klasy o nazwie. `Base`</span><span class="sxs-lookup"><span data-stu-id="4aab0-215">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="4aab0-216">Delegat typu `Action<Base>` (`Action(Of Base)` w Visual Basic) można przypisać do zmiennej typu `Action<Derived>`, jak wyjaśniono w kowariancji [i kontrawariancja](~/docs/standard/generics/covariance-and-contravariance.md), ale nie można łączyć dwóch delegatów, ponieważ typy nie są dokładnie zgodne.</span><span class="sxs-lookup"><span data-stu-id="4aab0-216">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md), but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="4aab0-217"><xref:System.Delegate.Combine%2A>jest przydatne do tworzenia programów obsługi zdarzeń, które wywołują wiele metod przy każdym wystąpieniu zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-217"><xref:System.Delegate.Combine%2A> is useful for creating event handlers that call multiple methods each time an event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-218">Nie wszystkie wpisy inne niż null w programie <paramref name="delegates" /> są wystąpieniami tego samego typu delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-218">Not all the non-null entries in <paramref name="delegates" /> are instances of the same delegate type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-219">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-219">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-220">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-220">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="4aab0-221">Delegat, którego lista wywołania jest połączona jako pierwsza.</span><span class="sxs-lookup"><span data-stu-id="4aab0-221">The delegate whose invocation list comes first.</span></span></param>
        <param name="b"><span data-ttu-id="4aab0-222">Delegat, którego lista wywołań jest Ostatnia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-222">The delegate whose invocation list comes last.</span></span></param>
        <summary><span data-ttu-id="4aab0-223">Łączy listy wywołań dwóch delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-223">Concatenates the invocation lists of two delegates.</span></span></summary>
        <returns><span data-ttu-id="4aab0-224">Nowy delegat z listą wywołań, który łączy listy <paramref name="a" /> wywołań i <paramref name="b" /> w tej kolejności.</span><span class="sxs-lookup"><span data-stu-id="4aab0-224">A new delegate with an invocation list that concatenates the invocation lists of <paramref name="a" /> and <paramref name="b" /> in that order.</span></span> <span data-ttu-id="4aab0-225">Zwraca <paramref name="a" /> Jeśli <paramref name="a" /> <paramref name="b" /> is jest <see langword="null" />, zwraca<paramref name="b" /> wartość, jeśli jest odwołaniem null i zwraca odwołanie o wartości <paramref name="a" /> null, jeśli oba i są odwołaniami o wartości null. <paramref name="b" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-225">Returns <paramref name="a" /> if <paramref name="b" /> is <see langword="null" />, returns <paramref name="b" /> if <paramref name="a" /> is a null reference, and returns a null reference if both <paramref name="a" /> and <paramref name="b" /> are null references.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-226">Lista wywołań może zawierać zduplikowane wpisy; oznacza to, że wpisy odwołujące się do tej samej metody w tym samym obiekcie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-226">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-227">Delegaty ogólne, które są zgodne z przypisaniem ze względu na wariancję, nie muszą być kombinacją.</span><span class="sxs-lookup"><span data-stu-id="4aab0-227">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="4aab0-228">Aby można było połączyć, typy muszą dokładnie pasować.</span><span class="sxs-lookup"><span data-stu-id="4aab0-228">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="4aab0-229">Załóżmy na przykład, że Klasa o nazwie `Derived` pochodzi od klasy o nazwie. `Base`</span><span class="sxs-lookup"><span data-stu-id="4aab0-229">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="4aab0-230">Delegat typu `Action<Base>` (`Action(Of Base)` w Visual Basic) można przypisać do zmiennej typu `Action<Derived>`, jak wyjaśniono w kowariancji [i kontrawariancja](~/docs/standard/generics/covariance-and-contravariance.md), ale nie można łączyć dwóch delegatów, ponieważ typy nie są dokładnie zgodne.</span><span class="sxs-lookup"><span data-stu-id="4aab0-230">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md), but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="4aab0-231"><xref:System.Delegate.Combine%2A>jest przydatne do tworzenia programów obsługi zdarzeń, które wywołują wiele metod przy każdym wystąpieniu zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-231"><xref:System.Delegate.Combine%2A> is useful for creating event handlers that call multiple methods each time an event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-232">Oba <paramref name="a" /> obiekty <paramref name="b" /> i nie <see langword="null" /> są<paramref name="a" /> wystąpieniami tego samego typu delegata. <paramref name="b" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-232">Both <paramref name="a" /> and <paramref name="b" /> are not <see langword="null" />, and <paramref name="a" /> and <paramref name="b" /> are not instances of the same delegate type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-233">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-233">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-234">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-234">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="4aab0-235">Obiekt delegowany multiemisji (z kombinacją), którego lista wywołania zostanie dołączona na końcu listy wywołań bieżącego multiemisji (z zakresem).</span><span class="sxs-lookup"><span data-stu-id="4aab0-235">The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</span></span></param>
        <summary><span data-ttu-id="4aab0-236">Łączy listy wywołań określonego delegata multiemisji (z połączeniem) i bieżącego delegata multiemisji (połączonego).</span><span class="sxs-lookup"><span data-stu-id="4aab0-236">Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</span></span></summary>
        <returns><span data-ttu-id="4aab0-237">Nowy obiekt delegowany multiemisji (połączony) z listą wywołań, który łączy listę wywołań bieżącego obiektu delegowanego multiemisji (połączonego) i listę <paramref name="d" />wywołań lub bieżący delegat multiemisji (z połączeniem), jeśli jest <paramref name="d" /> <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-237">A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <paramref name="d" />, or the current multicast (combinable) delegate if <paramref name="d" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-238">Ta metoda ma zastosowanie tylko wtedy, gdy bieżący delegat jest multiemisją (z możliwych do przyłączania).</span><span class="sxs-lookup"><span data-stu-id="4aab0-238">This method applies only if the current delegate is multicast (combinable).</span></span>  
  
 <span data-ttu-id="4aab0-239">Bieżąca implementacja po prostu zgłasza <xref:System.MulticastNotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="4aab0-239">The current implementation simply throws a <xref:System.MulticastNotSupportedException>.</span></span>  
  
 <span data-ttu-id="4aab0-240">Lista wywołań może zawierać zduplikowane wpisy; oznacza to, że wpisy odwołujące się do tej samej metody w tym samym obiekcie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-240">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException"><span data-ttu-id="4aab0-241">Zawsze generowany.</span><span class="sxs-lookup"><span data-stu-id="4aab0-241">Always thrown.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-242">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-242">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-243">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-243">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4aab0-244">Tworzy delegata określonego typu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-244">Creates a delegate of the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="4aab0-245"><see cref="T:System.Type" /> Delegat do utworzenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-245">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="method"><span data-ttu-id="4aab0-246"><see cref="T:System.Reflection.MethodInfo" /> Opisywanie metody statycznej lub instancji, która ma być reprezentowana przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-246">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span></span> <span data-ttu-id="4aab0-247">W .NET Framework w wersji 1,0 i 1,1 obsługiwane są tylko metody statyczne.</span><span class="sxs-lookup"><span data-stu-id="4aab0-247">Only static methods are supported in the .NET Framework version 1.0 and 1.1.</span></span></param>
        <summary><span data-ttu-id="4aab0-248">Tworzy delegat określonego typu do reprezentowania określonej metody statycznej.</span><span class="sxs-lookup"><span data-stu-id="4aab0-248">Creates a delegate of the specified type to represent the specified static method.</span></span></summary>
        <returns><span data-ttu-id="4aab0-249">Delegat określonego typu reprezentujący określoną metodę statyczną.</span><span class="sxs-lookup"><span data-stu-id="4aab0-249">A delegate of the specified type to represent the specified static method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-250">W .NET Framework w wersji 1,0 i 1,1 to Przeciążenie metody tworzy delegatów tylko dla metod statycznych.</span><span class="sxs-lookup"><span data-stu-id="4aab0-250">In the .NET Framework version 1.0 and 1.1, this method overload creates delegates for static methods only.</span></span> <span data-ttu-id="4aab0-251">W .NET Framework w wersji 2,0, to Przeciążenie metody również może utworzyć delegatów metody otwartego wystąpienia; oznacza to, że Delegaty jawnie dostarczają ukryty pierwszy argument metod wystąpień.</span><span class="sxs-lookup"><span data-stu-id="4aab0-251">In the .NET Framework version 2.0, this method overload also can create open instance method delegates; that is, delegates that explicitly supply the hidden first argument of instance methods.</span></span> <span data-ttu-id="4aab0-252">Aby uzyskać szczegółowe wyjaśnienie, zobacz bardziej ogólne <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> Przeciążenie metody, które pozwala na tworzenie wszystkich kombinacji otwartych lub zamkniętych delegatów dla wystąpień lub metod statycznych, a opcjonalnie określić pierwszy argument.</span><span class="sxs-lookup"><span data-stu-id="4aab0-252">For a detailed explanation, see the more general <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods, and optionally to specify a first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-253">Tego przeciążenia metody należy użyć, gdy delegat nie jest zamknięty nad jego pierwszym argumentem, ponieważ jest nieco szybszy w tym przypadku.</span><span class="sxs-lookup"><span data-stu-id="4aab0-253">This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</span></span>  
  
 <span data-ttu-id="4aab0-254">To Przeciążenie metody jest równoważne wywołaniu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> metody przeciążenia i określanie `true` dla `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-254">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload and specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-255">Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję.</span><span class="sxs-lookup"><span data-stu-id="4aab0-255">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="4aab0-256">(Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).</span><span class="sxs-lookup"><span data-stu-id="4aab0-256">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="4aab0-257">Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.</span><span class="sxs-lookup"><span data-stu-id="4aab0-257">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="4aab0-258">Zgodne typy parametrów i zwracany typ</span><span class="sxs-lookup"><span data-stu-id="4aab0-258">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="4aab0-259">W .NET Framework w wersji 2,0 typy parametrów i zwracany typ delegata utworzonego przy użyciu tego przeciążenia metody muszą być zgodne z typami parametrów i zwracanym typem metody reprezentowanej przez delegata; typy nie muszą dokładnie pasować.</span><span class="sxs-lookup"><span data-stu-id="4aab0-259">In the .NET Framework version 2.0, the parameter types and return type of a delegate created using this method overload must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span> <span data-ttu-id="4aab0-260">Reprezentuje to złagodzenie zachowania powiązania w .NET Framework w wersji 1,0 i 1,1, gdzie typy muszą dokładnie pasować.</span><span class="sxs-lookup"><span data-stu-id="4aab0-260">This represents a relaxation of the binding behavior in the .NET Framework version 1.0 and 1.1, where the types must match exactly.</span></span>  
  
 <span data-ttu-id="4aab0-261">Parametr delegata jest zgodny z odpowiadającym mu parametrem metody, jeśli typ parametru delegata jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przesłany do delegata może być bezpiecznie przekazywać do Metoda.</span><span class="sxs-lookup"><span data-stu-id="4aab0-261">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="4aab0-262">Analogicznie, zwracany typ delegata jest zgodny z typem zwracanym metody, Jeśli zwracany typ metody jest bardziej restrykcyjny niż typ zwracany delegata, ponieważ gwarantuje to, że wartość zwracana metody może być bezpiecznie rzutowana na typ zwracany e delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-262">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="4aab0-263">Na przykład delegat <xref:System.Collections.Hashtable> z parametrem typu i <xref:System.Object> typem zwracanym może reprezentować metodę z parametrem typu <xref:System.Object> i wartością zwracaną typu <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="4aab0-263">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4aab0-264">Ten rozdział zawiera dwa przykłady kodu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-264">This section contains two code examples.</span></span> <span data-ttu-id="4aab0-265">W pierwszym przykładzie pokazano dwa rodzaje delegatów, które można utworzyć za pomocą tego przeciążenia metody: Otwórz za pomocą metody Instance i Otwórz za pomocą metody statycznej.</span><span class="sxs-lookup"><span data-stu-id="4aab0-265">The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</span></span>  
  
 <span data-ttu-id="4aab0-266">Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-266">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="4aab0-267">**Przykład 1**</span><span class="sxs-lookup"><span data-stu-id="4aab0-267">**Example 1**</span></span>  
  
 <span data-ttu-id="4aab0-268">Poniższy przykład kodu demonstruje dwa sposoby tworzenia delegata przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-268">The following code example demonstrates the two ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-269">Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, które <xref:System.Reflection.MethodInfo> określają, ale nie pierwszy argument; ich funkcjonalność jest taka sama, z tą różnicą, że jedna pozwala określić, czy zgłaszać błąd w przypadku niepowodzenia powiązania, a drugie zawsze zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="4aab0-269">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify a <xref:System.Reflection.MethodInfo> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="4aab0-270">W tym przykładzie kodu są używane oba przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-270">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="4aab0-271">Przykład `C` deklaruje klasę z metodą `M2` statyczną i metodą `M1`wystąpienia, a `C` dwa typy delegatów: `D1` przyjmuje wystąpienie i ciąg i `D2` Pobiera ciąg.</span><span class="sxs-lookup"><span data-stu-id="4aab0-271">The example declares a class `C` with a static method `M2` and an instance method `M1`, and two delegate types: `D1` takes an instance of `C` and a string, and `D2` takes a string.</span></span>  
  
 <span data-ttu-id="4aab0-272">Druga klasa o nazwie `Example` zawiera kod, który tworzy delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-272">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="4aab0-273">Delegat typu `D1`, reprezentujący otwartą metodę wystąpienia, jest tworzony dla metody `M1`wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-273">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="4aab0-274">Wystąpienie musi zostać przekazane podczas wywoływania delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-274">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="4aab0-275">Delegat typu `D2`, reprezentujący otwartą metodę statyczną, jest tworzony dla metody `M2`statycznej.</span><span class="sxs-lookup"><span data-stu-id="4aab0-275">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="4aab0-276">**Przykład 2**</span><span class="sxs-lookup"><span data-stu-id="4aab0-276">**Example 2**</span></span>  
  
 <span data-ttu-id="4aab0-277">Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-277">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
 <span data-ttu-id="4aab0-278">Przykładowy kod definiuje klasę bazową o nazwie `Base` i klasę o nazwie `Derived` , która dziedziczy `Base`z.</span><span class="sxs-lookup"><span data-stu-id="4aab0-278">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="4aab0-279">Klasa pochodna `static` ma metodę (`Shared` w Visual Basic) o nazwie `MyMethod` z jednym `Derived`parametrem typu `Base` i typem zwracanym.</span><span class="sxs-lookup"><span data-stu-id="4aab0-279">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="4aab0-280">Przykład kodu definiuje także delegat o nazwie `Example` , który ma jeden parametr typu `Derived` `Base`i zwracany typ.</span><span class="sxs-lookup"><span data-stu-id="4aab0-280">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="4aab0-281">Przykład kodu pokazuje, że delegat o nazwie `Example` może służyć do reprezentowania metody. `MyMethod`</span><span class="sxs-lookup"><span data-stu-id="4aab0-281">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="4aab0-282">Metodę można powiązać z delegatem, ponieważ:</span><span class="sxs-lookup"><span data-stu-id="4aab0-282">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="4aab0-283">Typ`Derived`parametru delegata () jest bardziej restrykcyjny niż `MyMethod` typ parametru (`Base`), dzięki czemu zawsze można bezpiecznie przekazać argument delegata do `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-283">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="4aab0-284">Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpiecznie do rzutowania zwracanego typu metody na zwracany typ delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-284">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="4aab0-285">W przykładowym kodzie nie są generowane żadne dane wyjściowe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-285">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4aab0-286"><paramref name="type" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-286"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-287">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-287">-or-</span></span> 
 <span data-ttu-id="4aab0-288"><paramref name="method" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-288"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-289"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-289"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="4aab0-290">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-290">-or-</span></span> 
 <span data-ttu-id="4aab0-291"><paramref name="type" />nie <see langword="RuntimeType" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-291"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="4aab0-292">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-292">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="4aab0-293">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-293">-or-</span></span> 
 <span data-ttu-id="4aab0-294"><paramref name="method" />nie jest metodą statyczną, a wersja .NET Framework to 1,0 lub 1,1.</span><span class="sxs-lookup"><span data-stu-id="4aab0-294"><paramref name="method" /> is not a static method, and the .NET Framework version is 1.0 or 1.1.</span></span>  
  
<span data-ttu-id="4aab0-295">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-295">-or-</span></span> 
 <span data-ttu-id="4aab0-296"><paramref name="method" />nie można powiązać.</span><span class="sxs-lookup"><span data-stu-id="4aab0-296"><paramref name="method" /> cannot be bound.</span></span>  
  
<span data-ttu-id="4aab0-297">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-297">-or-</span></span> 
 <span data-ttu-id="4aab0-298"><paramref name="method" />nie <see langword="RuntimeMethodInfo" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-298"><paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span></span> <span data-ttu-id="4aab0-299">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-299">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="4aab0-300">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-300">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="4aab0-301">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-301">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-302">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-302">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-303">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-303">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="4aab0-304"><see cref="T:System.Type" /> Delegat do utworzenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-304">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="firstArgument"><span data-ttu-id="4aab0-305">Obiekt, z którym jest powiązany <see langword="null" /> delegat, lub do traktowania <paramref name="method" /> jako <see langword="static" /> (<see langword="Shared" /> w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4aab0-305">The object to which the delegate is bound, or <see langword="null" /> to treat <paramref name="method" /> as <see langword="static" /> (<see langword="Shared" /> in Visual Basic).</span></span></param>
        <param name="method"><span data-ttu-id="4aab0-306"><see cref="T:System.Reflection.MethodInfo" /> Opisywanie metody statycznej lub instancji, która ma być reprezentowana przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-306">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span></span></param>
        <summary><span data-ttu-id="4aab0-307">Tworzy delegat określonego typu, który reprezentuje określoną metodę statyczną lub wystąpienie, z określonym pierwszym argumentem.</span><span class="sxs-lookup"><span data-stu-id="4aab0-307">Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</span></span></summary>
        <returns><span data-ttu-id="4aab0-308">Delegat określonego typu, który reprezentuje określoną metodę static lub instance.</span><span class="sxs-lookup"><span data-stu-id="4aab0-308">A delegate of the specified type that represents the specified static or instance method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-309">Wywołanie tego przeciążenia metody jest równoznaczne z wywołaniem <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenia metody i określanie `throwOnBindFailure` `true` dla.</span><span class="sxs-lookup"><span data-stu-id="4aab0-309">Calling this method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload and specifying `true` for `throwOnBindFailure`.</span></span> <span data-ttu-id="4aab0-310">Te dwa przeciążenia zapewniają najbardziej elastyczny sposób tworzenia delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-310">These two overloads provide the most flexible way to create delegates.</span></span> <span data-ttu-id="4aab0-311">Można ich użyć do tworzenia delegatów dla metod statycznych lub wystąpień oraz opcjonalnie określić pierwszy argument.</span><span class="sxs-lookup"><span data-stu-id="4aab0-311">You can use them to create delegates for either static or instance methods, and optionally to specify the first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-312">Jeśli nie podasz pierwszego argumentu, użyj <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenia metody w celu uzyskania lepszej wydajności.</span><span class="sxs-lookup"><span data-stu-id="4aab0-312">If you do not supply a first argument, use the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload for better performance.</span></span>  
  
 <span data-ttu-id="4aab0-313">Typ delegata i Metoda muszą mieć zgodne typy zwracane.</span><span class="sxs-lookup"><span data-stu-id="4aab0-313">The delegate type and the method must have compatible return types.</span></span> <span data-ttu-id="4aab0-314">Oznacza to, że zwracany typ `method` musi być możliwy do przypisania do `type`typu zwracanego.</span><span class="sxs-lookup"><span data-stu-id="4aab0-314">That is, the return type of `method` must be assignable to the return type of `type`.</span></span>  
  
 <span data-ttu-id="4aab0-315">Jeśli `firstArgument` jest podany, jest przekazywany do `method` każdego momentu wywołania delegata; `firstArgument` jest określana jako powiązana z delegatem, a delegat jest określany jako zamknięty w pierwszym argumencie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-315">If `firstArgument` is supplied, it is passed to `method` every time the delegate is invoked; `firstArgument` is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</span></span> <span data-ttu-id="4aab0-316">Jeśli `method` jest `static` ( `method` `firstArgument` w Visual Basic), lista argumentów dostarczona podczas wywoływania delegata zawiera wszystkie parametry z wyjątkiem pierwszej; jeśli jest to metoda wystąpienia, zostaje przekazana do wystąpienia ukrytego`Shared` parametr (reprezentowany przez `this` w C#, lub `Me` w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4aab0-316">If `method` is `static` (`Shared` in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if `method` is an instance method, then `firstArgument` is passed to the hidden instance parameter (represented by `this` in C#, or by `Me` in Visual Basic).</span></span>  
  
 <span data-ttu-id="4aab0-317">Jeśli `firstArgument` jest podany, pierwszy parametr elementu `method` musi być typem referencyjnym i `firstArgument` musi być zgodny z tym typem.</span><span class="sxs-lookup"><span data-stu-id="4aab0-317">If `firstArgument` is supplied, the first parameter of `method` must be a reference type, and `firstArgument` must be compatible with that type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4aab0-318">Jeśli `method` jest `static` ( <xref:System.Object> wVisualBasic<xref:System.ValueType>) i jego`firstArgument` pierwszy parametr jest typu lub, może być typem wartości.`Shared`</span><span class="sxs-lookup"><span data-stu-id="4aab0-318">If `method` is `static` (`Shared` in Visual Basic) and its first parameter is of type <xref:System.Object> or <xref:System.ValueType>, then `firstArgument` can be a value type.</span></span> <span data-ttu-id="4aab0-319">W tym przypadku `firstArgument` jest automatycznie opakowany.</span><span class="sxs-lookup"><span data-stu-id="4aab0-319">In this case `firstArgument` is automatically boxed.</span></span> <span data-ttu-id="4aab0-320">Automatyczne pakowanie nie występuje dla żadnych innych argumentów, tak jak w przypadku C# wywołania funkcji lub Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="4aab0-320">Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</span></span>  
  
 <span data-ttu-id="4aab0-321">Jeśli `firstArgument` jest odwołaniem o wartości `method` null i jest metodą wystąpienia, wynik zależy od sygnatur typu `type` delegata i `method`:</span><span class="sxs-lookup"><span data-stu-id="4aab0-321">If `firstArgument` is a null reference and `method` is an instance method, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="4aab0-322">Jeśli podpis `type` jawnie obejmuje ukryty pierwszy `method`parametr, delegat jest reprezentowany do reprezentowania metody otwartego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-322">If the signature of `type` explicitly includes the hidden first parameter of `method`, the delegate is said to represent an open instance method.</span></span> <span data-ttu-id="4aab0-323">Gdy obiekt delegowany jest wywoływany, pierwszy argument na liście argumentów jest przenoszona do ukrytego wystąpienia parametru `method`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-323">When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of `method`.</span></span>  
  
-   <span data-ttu-id="4aab0-324">Jeśli sygnatury `method` i `type` są zgodne (to oznacza, że wszystkie typy parametrów są zgodne), delegat jest określany jako zamknięty w odniesieniu do wartości null.</span><span class="sxs-lookup"><span data-stu-id="4aab0-324">If the signatures of `method` and `type` match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="4aab0-325">Wywoływanie delegata jest podobne do wywołania metody wystąpienia w wystąpieniu o wartości null, która nie jest szczególnie przydatna.</span><span class="sxs-lookup"><span data-stu-id="4aab0-325">Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</span></span>  
  
 <span data-ttu-id="4aab0-326">Jeśli `firstArgument` jest odwołaniem null i `method` jest statyczna, wynik zależy od sygnatur typu `type` delegata i `method`:</span><span class="sxs-lookup"><span data-stu-id="4aab0-326">If `firstArgument` is a null reference and `method` is static, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="4aab0-327">Jeśli sygnatura `method` i `type` dopasowanie (to oznacza, że wszystkie typy parametrów są zgodne), delegat jest reprezentowany jako otwarta metoda statyczna.</span><span class="sxs-lookup"><span data-stu-id="4aab0-327">If the signature of `method` and `type` match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</span></span> <span data-ttu-id="4aab0-328">Jest to najbardziej typowy przypadek dla metod statycznych.</span><span class="sxs-lookup"><span data-stu-id="4aab0-328">This is the most common case for static methods.</span></span> <span data-ttu-id="4aab0-329">W takim przypadku można uzyskać nieco lepszą wydajność przy użyciu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-329">In this case, you can get slightly better performance by using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span>  
  
-   <span data-ttu-id="4aab0-330">Jeśli sygnatura `type` zaczyna się od drugiego `method` parametru, a pozostałe typy parametrów są zgodne, delegat jest uznawany za zamknięty w odniesieniu do wartości null.</span><span class="sxs-lookup"><span data-stu-id="4aab0-330">If the signature of `type` begins with the second parameter of `method` and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="4aab0-331">Gdy obiekt delegowany jest wywoływany, odwołanie o wartości null jest przesyłane do pierwszego `method`parametru.</span><span class="sxs-lookup"><span data-stu-id="4aab0-331">When the delegate is invoked, a null reference is passed to the first parameter of `method`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-332">Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję.</span><span class="sxs-lookup"><span data-stu-id="4aab0-332">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="4aab0-333">(Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).</span><span class="sxs-lookup"><span data-stu-id="4aab0-333">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="4aab0-334">Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.</span><span class="sxs-lookup"><span data-stu-id="4aab0-334">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="4aab0-335">Zgodne typy parametrów i zwracany typ</span><span class="sxs-lookup"><span data-stu-id="4aab0-335">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="4aab0-336">Typy parametrów i typ zwracany delegata muszą być zgodne z typami parametrów i zwracanym typem metody reprezentowanej przez delegata; typy nie muszą dokładnie pasować.</span><span class="sxs-lookup"><span data-stu-id="4aab0-336">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-337">W .NET Framework w wersji 1,0 i 1,1 typy muszą dokładnie pasować.</span><span class="sxs-lookup"><span data-stu-id="4aab0-337">In the .NET Framework version 1.0 and 1.1, the types must match exactly.</span></span>  
  
 <span data-ttu-id="4aab0-338">Parametr delegata jest zgodny z odpowiadającym mu parametrem metody, jeśli typ parametru delegata jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przesłany do delegata może być bezpiecznie przekazywać do Metoda.</span><span class="sxs-lookup"><span data-stu-id="4aab0-338">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="4aab0-339">Analogicznie, zwracany typ delegata jest zgodny z typem zwracanym metody, Jeśli zwracany typ metody jest bardziej restrykcyjny niż typ zwracany delegata, ponieważ gwarantuje to, że wartość zwracana metody może być bezpiecznie rzutowana na typ zwracany e delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-339">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="4aab0-340">Na przykład delegat <xref:System.Collections.Hashtable> z parametrem typu i <xref:System.Object> typem zwracanym może reprezentować metodę z parametrem typu <xref:System.Object> i wartością zwracaną typu <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="4aab0-340">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a><span data-ttu-id="4aab0-341">Określenie metod, które może reprezentować delegat</span><span class="sxs-lookup"><span data-stu-id="4aab0-341">Determining the Methods a Delegate Can Represent</span></span>  
 <span data-ttu-id="4aab0-342">Innym przydatnym sposobem, aby określić elastyczność zapewnianą przez to Przeciążenie <xref:System.Delegate.CreateDelegate%2A> , jest to, że każdy delegat może reprezentować cztery różne kombinacje sygnatur metody i rodzaju metody (statyczny a wystąpienie).</span><span class="sxs-lookup"><span data-stu-id="4aab0-342">Another useful way to think of the flexibility provided by this overload of <xref:System.Delegate.CreateDelegate%2A> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</span></span> <span data-ttu-id="4aab0-343">Należy wziąć pod uwagę `D` typ delegata z jednym `C`argumentem typu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-343">Consider a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="4aab0-344">Poniżej opisano metody `D` , które mogą reprezentować, ignorowanie zwracanego typu, ponieważ musi on być zgodny we wszystkich przypadkach:</span><span class="sxs-lookup"><span data-stu-id="4aab0-344">The following describes the methods `D` can represent, ignoring the return type since it must match in all cases:</span></span>  
  
-   <span data-ttu-id="4aab0-345">`D`może reprezentować każdą metodę wystąpienia, która ma dokładnie jeden `C`argument typu, bez względu na typ, do którego należy metoda wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-345">`D` can represent any instance method that has exactly one argument of type `C`, regardless of what type the instance method belongs to.</span></span> <span data-ttu-id="4aab0-346">Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` to wystąpienie typu `method` należy do, a otrzymany delegat jest wskazany do zamknięcia tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-346">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of the type `method` belongs to, and the resulting delegate is said to be closed over that instance.</span></span> <span data-ttu-id="4aab0-347">(Prosta, można `D` także zamknąć odwołanie o wartości null, jeśli `firstArgument` jest odwołaniem o wartości null).</span><span class="sxs-lookup"><span data-stu-id="4aab0-347">(Trivially, `D` can also be closed over a null reference if `firstArgument` is a null reference.)</span></span>  
  
-   <span data-ttu-id="4aab0-348">`D`może reprezentować metodę `C` wystąpienia, która nie ma żadnych argumentów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-348">`D` can represent an instance method of `C` that has no arguments.</span></span> <span data-ttu-id="4aab0-349">Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="4aab0-349">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="4aab0-350">Przekazany delegat reprezentuje metodę otwartego wystąpienia, a wystąpienie `C` musi być dostarczone przy każdym wywołaniu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-350">The resulting delegate represents an open instance method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="4aab0-351">`D`może reprezentować metodę statyczną przyjmującą jeden argument `C`typu, która ta metoda może należeć do dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-351">`D` can represent a static method that takes one argument of type `C`, and that method can belong to any type.</span></span> <span data-ttu-id="4aab0-352">Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="4aab0-352">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="4aab0-353">Przekazany delegat reprezentuje statyczną metodę, a wystąpienie `C` musi być dostarczone przy każdym wywołaniu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-353">The resulting delegate represents an open static method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="4aab0-354">`D`może reprezentować metodę statyczną, która `F` należy do typu, i ma dwa `F` argumenty typu `C`i typu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-354">`D` can represent a static method that belongs to type `F` and has two arguments, of type `F` and type `C`.</span></span> <span data-ttu-id="4aab0-355">Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest wystąpieniem `F`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-355">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of `F`.</span></span> <span data-ttu-id="4aab0-356">Otrzymany delegat reprezentuje statyczną metodę, która jest zamknięta dla `F`tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-356">The resulting delegate represents a static method that is closed over that instance of `F`.</span></span> <span data-ttu-id="4aab0-357">Należy zauważyć, że w przypadku `F` gdy `C` i są tego samego typu, metoda statyczna ma dwa argumenty tego typu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-357">Note that in the case where `F` and `C` are the same type, the static method has two arguments of that type.</span></span> <span data-ttu-id="4aab0-358">(W tym przypadku jest `D` zamknięty w odniesieniu do wartości `firstArgument` null, jeśli jest odwołaniem o wartości null).</span><span class="sxs-lookup"><span data-stu-id="4aab0-358">(In this case, `D` is closed over a null reference if `firstArgument` is a null reference.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4aab0-359">Ta sekcja zawiera trzy przykłady kodu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-359">This section contains three code examples.</span></span> <span data-ttu-id="4aab0-360">W pierwszym przykładzie pokazano cztery rodzaje delegatów, które można utworzyć: zamknięte przez metodę wystąpienia, Otwórz w metodzie wystąpienia, Otwórz za pomocą metody statycznej i zamknięte przez metodę statyczną.</span><span class="sxs-lookup"><span data-stu-id="4aab0-360">The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</span></span>  
  
 <span data-ttu-id="4aab0-361">Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-361">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="4aab0-362">Trzeci przykład kodu definiuje pojedynczy typ delegata i pokazuje wszystkie metody, które może reprezentować typ delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-362">The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</span></span>  
  
 <span data-ttu-id="4aab0-363">**Przykład 1**</span><span class="sxs-lookup"><span data-stu-id="4aab0-363">**Example 1**</span></span>  
  
 <span data-ttu-id="4aab0-364">Poniższy przykład kodu demonstruje cztery sposoby tworzenia delegata przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-364">The following code example demonstrates the four ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-365">Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, które określają `firstArgument` i a <xref:System.Reflection.MethodInfo>; ich funkcjonalność jest taka sama, z tą różnicą, że jedna z nich pozwala określić, czy zgłaszać błąd w przypadku niepowodzenia, a drugie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-365">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="4aab0-366">W tym przykładzie kodu są używane oba przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-366">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="4aab0-367">Przykład `C` deklaruje klasę z metodą `M2` statyczną i metodą `M1`wystąpienia, a `C` trzy typy delegatów: `D1` przyjmuje wystąpienie i ciąg, `D2` Pobiera ciąg i `D3`nie ma argumentów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-367">The example declares a class `C` with a static method `M2` and an instance method `M1`, and three delegate types: `D1` takes an instance of `C` and a string, `D2` takes a string, and `D3` has no arguments.</span></span>  
  
 <span data-ttu-id="4aab0-368">Druga klasa o nazwie `Example` zawiera kod, który tworzy delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-368">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="4aab0-369">Delegat typu `D2`, zamknięty w `C`wystąpieniu, jest tworzony dla metody `M1`wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-369">A delegate of type `D2`, closed over an instance of `C`, is created for the instance method `M1`.</span></span> <span data-ttu-id="4aab0-370">Jest wywoływana z innymi ciągami, aby pokazać, że powiązane wystąpienie `C` jest zawsze używane.</span><span class="sxs-lookup"><span data-stu-id="4aab0-370">It is invoked with different strings, to show that the bound instance of `C` is always used.</span></span>  
  
-   <span data-ttu-id="4aab0-371">Delegat typu `D1`, reprezentujący otwartą metodę wystąpienia, jest tworzony dla metody `M1`wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-371">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="4aab0-372">Wystąpienie musi zostać przekazane podczas wywoływania delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-372">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="4aab0-373">Delegat typu `D2`, reprezentujący otwartą metodę statyczną, jest tworzony dla metody `M2`statycznej.</span><span class="sxs-lookup"><span data-stu-id="4aab0-373">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
-   <span data-ttu-id="4aab0-374">Na koniec, delegat typu `D3`, zamknięty w ciągu, jest tworzony dla metody `M2`statycznej.</span><span class="sxs-lookup"><span data-stu-id="4aab0-374">Finally, a delegate of type `D3`, closed over a string, is created for the static method `M2`.</span></span> <span data-ttu-id="4aab0-375">Metoda jest wywoływana, aby pokazać, że używa powiązanego ciągu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-375">The method is invoked to show that it uses the bound string.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="4aab0-376">**Przykład 2**</span><span class="sxs-lookup"><span data-stu-id="4aab0-376">**Example 2**</span></span>  
  
 <span data-ttu-id="4aab0-377">Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-377">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-378">Ten przykład kodu używa <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-378">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="4aab0-379">Użycie innych przeciążeń <xref:System.Reflection.MethodInfo> jest podobne.</span><span class="sxs-lookup"><span data-stu-id="4aab0-379">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="4aab0-380">Przykładowy kod definiuje klasę bazową o nazwie `Base` i klasę o nazwie `Derived` , która dziedziczy `Base`z.</span><span class="sxs-lookup"><span data-stu-id="4aab0-380">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="4aab0-381">Klasa pochodna `static` ma metodę (`Shared` w Visual Basic) o nazwie `MyMethod` z jednym `Derived`parametrem typu `Base` i typem zwracanym.</span><span class="sxs-lookup"><span data-stu-id="4aab0-381">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="4aab0-382">Przykład kodu definiuje także delegat o nazwie `Example` , który ma jeden parametr typu `Derived` `Base`i zwracany typ.</span><span class="sxs-lookup"><span data-stu-id="4aab0-382">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="4aab0-383">Przykład kodu pokazuje, że delegat o nazwie `Example` może służyć do reprezentowania metody. `MyMethod`</span><span class="sxs-lookup"><span data-stu-id="4aab0-383">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="4aab0-384">Metodę można powiązać z delegatem, ponieważ:</span><span class="sxs-lookup"><span data-stu-id="4aab0-384">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="4aab0-385">Typ`Derived`parametru delegata () jest bardziej restrykcyjny niż `MyMethod` typ parametru (`Base`), dzięki czemu zawsze można bezpiecznie przekazać argument delegata do `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-385">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="4aab0-386">Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpiecznie do rzutowania zwracanego typu metody na zwracany typ delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-386">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="4aab0-387">W przykładowym kodzie nie są generowane żadne dane wyjściowe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-387">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 <span data-ttu-id="4aab0-388">**Przykład 3**</span><span class="sxs-lookup"><span data-stu-id="4aab0-388">**Example 3**</span></span>  
  
 <span data-ttu-id="4aab0-389">Poniższy przykład kodu przedstawia wszystkie metody, które może reprezentować pojedynczy typ delegata, <xref:System.Delegate.CreateDelegate%2A> przy użyciu metody do tworzenia delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-389">The following code example shows all the methods a single delegate type can represent, using the <xref:System.Delegate.CreateDelegate%2A> method to create the delegates.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-390">Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, które określają `firstArgument` i a <xref:System.Reflection.MethodInfo>; ich funkcjonalność jest taka sama, z tą różnicą, że jedna z nich pozwala określić, czy zgłaszać błąd w przypadku niepowodzenia, a drugie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-390">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="4aab0-391">W tym przykładzie kodu są używane oba przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-391">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="4aab0-392">Przykład kodu definiuje dwie klasy `C` , i `F`i typ `D` delegata z jednym argumentem typu `C`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-392">The code example defines two classes, `C` and `F`, and a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="4aab0-393">Klasy mają zgodne metody `M1`static i instance, `M3`klasy `C` i `M4`, a także mają metodę `M2` wystąpienia, która nie ma argumentów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-393">The classes have matching static and instance methods `M1`, `M3`, and `M4`, and class `C` also has an instance method `M2` that has no arguments.</span></span>  
  
 <span data-ttu-id="4aab0-394">Trzecia Klasa o nazwie `Example` zawiera kod, który tworzy delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-394">A third class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="4aab0-395">Delegaty są tworzone dla metody `M1` wystąpienia typu `C` i typu `F`; każda z nich jest zamknięta na wystąpieniu odpowiedniego typu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-395">Delegates are created for instance method `M1` of type `C` and type `F`; each is closed over an instance of the respective type.</span></span> <span data-ttu-id="4aab0-396">Metoda `M1` typu `C` wyświetla`ID` właściwości wystąpienia powiązanego i argumentu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-396">Method `M1` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
-   <span data-ttu-id="4aab0-397">Obiekt delegowany jest tworzony dla `M2` metody typu `C`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-397">A delegate is created for method `M2` of type `C`.</span></span> <span data-ttu-id="4aab0-398">Jest to delegata otwartego wystąpienia, w którym argument delegata reprezentuje ukryty pierwszy argument metody Instance.</span><span class="sxs-lookup"><span data-stu-id="4aab0-398">This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</span></span> <span data-ttu-id="4aab0-399">Metoda nie ma innych argumentów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-399">The method has no other arguments.</span></span> <span data-ttu-id="4aab0-400">Jest on wywoływany tak, jakby był metodą statyczną.</span><span class="sxs-lookup"><span data-stu-id="4aab0-400">It is called as if it were a static method.</span></span>  
  
-   <span data-ttu-id="4aab0-401">Delegaty są tworzone dla statycznej `M3` metody `C` typu i `F`typu; są to otwarte elementy delegowane static.</span><span class="sxs-lookup"><span data-stu-id="4aab0-401">Delegates are created for static method `M3` of type `C` and type `F`; these are open static delegates.</span></span>  
  
-   <span data-ttu-id="4aab0-402">Na koniec są tworzone Delegaty dla statycznej `M4` metody `C` typu i `F`typu; każda metoda ma typ deklarujący jako pierwszy argument, a wystąpienie typu jest dostarczane, więc Delegaty są zamykane w ramach swoich pierwszych argumentów .</span><span class="sxs-lookup"><span data-stu-id="4aab0-402">Finally, delegates are created for static method `M4` of type `C` and type `F`; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</span></span> <span data-ttu-id="4aab0-403">Metoda `M4` typu `C` wyświetla`ID` właściwości wystąpienia powiązanego i argumentu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-403">Method `M4` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4aab0-404"><paramref name="type" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-404"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-405">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-405">-or-</span></span> 
 <span data-ttu-id="4aab0-406"><paramref name="method" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-406"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-407"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-407"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="4aab0-408">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-408">-or-</span></span> 
 <span data-ttu-id="4aab0-409"><paramref name="type" />nie <see langword="RuntimeType" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-409"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="4aab0-410">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-410">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="4aab0-411">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-411">-or-</span></span> 
 <span data-ttu-id="4aab0-412"><paramref name="method" />nie można powiązać.</span><span class="sxs-lookup"><span data-stu-id="4aab0-412"><paramref name="method" /> cannot be bound.</span></span>  
  
<span data-ttu-id="4aab0-413">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-413">-or-</span></span> 
 <span data-ttu-id="4aab0-414"><paramref name="method" />nie <see langword="RuntimeMethodInfo" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-414"><paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span></span> <span data-ttu-id="4aab0-415">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-415">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="4aab0-416">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-416">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="4aab0-417">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-417">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-418">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-418">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-419">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-419">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="4aab0-420"><see cref="T:System.Type" /> Delegat do utworzenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-420">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="4aab0-421">Wystąpienie klasy, na którym <paramref name="method" /> jest wywoływane.</span><span class="sxs-lookup"><span data-stu-id="4aab0-421">The class instance on which <paramref name="method" /> is invoked.</span></span></param>
        <param name="method"><span data-ttu-id="4aab0-422">Nazwa metody wystąpienia, która ma być reprezentowana przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-422">The name of the instance method that the delegate is to represent.</span></span></param>
        <summary><span data-ttu-id="4aab0-423">Tworzy delegat określonego typu, który reprezentuje określoną metodę wystąpienia do wywołania w określonym wystąpieniu klasy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-423">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span></span></summary>
        <returns><span data-ttu-id="4aab0-424">Delegat określonego typu reprezentujący określoną metodę wystąpienia do wywołania w określonym wystąpieniu klasy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-424">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-425">Ta metoda tworzy delegatów tylko dla metod wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-425">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="4aab0-426">Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.</span><span class="sxs-lookup"><span data-stu-id="4aab0-426">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="4aab0-427">To Przeciążenie metody jest równoważne wywołaniu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> metody przeciążenia, określając `false` dla `ignoreCase` i `true` dla `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-427">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `false` for `ignoreCase` and `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-428">Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję.</span><span class="sxs-lookup"><span data-stu-id="4aab0-428">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="4aab0-429">(Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).</span><span class="sxs-lookup"><span data-stu-id="4aab0-429">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="4aab0-430">Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.</span><span class="sxs-lookup"><span data-stu-id="4aab0-430">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4aab0-431"><paramref name="type" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-431"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-432">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-432">-or-</span></span> 
 <span data-ttu-id="4aab0-433"><paramref name="target" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-433"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-434">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-434">-or-</span></span> 
 <span data-ttu-id="4aab0-435"><paramref name="method" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-435"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-436"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-436"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="4aab0-437">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-437">-or-</span></span> 
 <span data-ttu-id="4aab0-438"><paramref name="type" />nie <see langword="RuntimeType" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-438"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="4aab0-439">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-439">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="4aab0-440">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-440">-or-</span></span> 
 <span data-ttu-id="4aab0-441"><paramref name="method" />nie jest metodą wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-441"><paramref name="method" /> is not an instance method.</span></span>  
  
<span data-ttu-id="4aab0-442">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-442">-or-</span></span> 
 <span data-ttu-id="4aab0-443"><paramref name="method" />nie można powiązać, na przykład ponieważ nie można go znaleźć.</span><span class="sxs-lookup"><span data-stu-id="4aab0-443"><paramref name="method" /> cannot be bound, for example because it cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="4aab0-444">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-444">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="4aab0-445">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-445">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-446">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-446">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-447">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-447">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="4aab0-448"><see cref="T:System.Type" /> Delegat do utworzenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-448">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="method"><span data-ttu-id="4aab0-449"><see cref="T:System.Reflection.MethodInfo" /> Opisywanie metody statycznej lub instancji, która ma być reprezentowana przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-449">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span></span></param>
        <param name="throwOnBindFailure"><span data-ttu-id="4aab0-450"><see langword="true" />Aby zgłosić wyjątek, <paramref name="method" /> <see langword="false" />Jeśli nie można go powiązać; w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-450"><see langword="true" /> to throw an exception if <paramref name="method" /> cannot be bound; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="4aab0-451">Tworzy delegat określonego typu reprezentujący określoną metodę statyczną, z określonym zachowaniem dotyczącym niepowodzenia powiązania.</span><span class="sxs-lookup"><span data-stu-id="4aab0-451">Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</span></span></summary>
        <returns><span data-ttu-id="4aab0-452">Delegat określonego typu reprezentujący określoną metodę statyczną.</span><span class="sxs-lookup"><span data-stu-id="4aab0-452">A delegate of the specified type to represent the specified static method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-453">To Przeciążenie metody może utworzyć elementy delegowane typu Open static i otworzyć metodę wystąpienia, czyli delegatów, które uwidaczniają ukryty pierwszy argument metod wystąpień.</span><span class="sxs-lookup"><span data-stu-id="4aab0-453">This method overload can create open static method delegates and open instance method delegates - that is, delegates that expose the hidden first argument of instance methods.</span></span> <span data-ttu-id="4aab0-454">Aby uzyskać szczegółowe wyjaśnienie, zobacz bardziej ogólne <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> Przeciążenie metody, które pozwala na tworzenie wszystkich kombinacji otwartych lub zamkniętych delegatów dla wystąpień lub metod statycznych.</span><span class="sxs-lookup"><span data-stu-id="4aab0-454">For a detailed explanation, see the more general <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-455">Tego przeciążenia metody należy użyć, gdy delegat nie jest zamknięty nad jego pierwszym argumentem, ponieważ jest nieco szybszy w tym przypadku.</span><span class="sxs-lookup"><span data-stu-id="4aab0-455">This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-456">Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję.</span><span class="sxs-lookup"><span data-stu-id="4aab0-456">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="4aab0-457">(Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).</span><span class="sxs-lookup"><span data-stu-id="4aab0-457">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="4aab0-458">Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.</span><span class="sxs-lookup"><span data-stu-id="4aab0-458">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="4aab0-459">Zgodne typy parametrów i zwracany typ</span><span class="sxs-lookup"><span data-stu-id="4aab0-459">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="4aab0-460">Typy parametrów i typ zwracany delegata muszą być zgodne z typami parametrów i zwracanym typem metody reprezentowanej przez delegata; typy nie muszą dokładnie pasować.</span><span class="sxs-lookup"><span data-stu-id="4aab0-460">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-461">W .NET Framework w wersji 1,0 i 1,1 typy muszą dokładnie pasować.</span><span class="sxs-lookup"><span data-stu-id="4aab0-461">In the .NET Framework version 1.0 and 1.1, the types must match exactly.</span></span>  
  
 <span data-ttu-id="4aab0-462">Parametr delegata jest zgodny z odpowiadającym mu parametrem metody, jeśli typ parametru delegata jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przesłany do delegata może być bezpiecznie przekazywać do Metoda.</span><span class="sxs-lookup"><span data-stu-id="4aab0-462">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="4aab0-463">Analogicznie, zwracany typ delegata jest zgodny z typem zwracanym metody, Jeśli zwracany typ metody jest bardziej restrykcyjny niż typ zwracany delegata, ponieważ gwarantuje to, że wartość zwracana metody może być bezpiecznie rzutowana na typ zwracany e delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-463">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="4aab0-464">Na przykład delegat <xref:System.Collections.Hashtable> z parametrem typu i <xref:System.Object> typem zwracanym może reprezentować metodę z parametrem typu <xref:System.Object> i wartością zwracaną typu <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="4aab0-464">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4aab0-465">Ten rozdział zawiera dwa przykłady kodu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-465">This section contains two code examples.</span></span> <span data-ttu-id="4aab0-466">W pierwszym przykładzie pokazano dwa rodzaje delegatów, które można utworzyć za pomocą tego przeciążenia metody: Otwórz za pomocą metody Instance i Otwórz za pomocą metody statycznej.</span><span class="sxs-lookup"><span data-stu-id="4aab0-466">The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</span></span>  
  
 <span data-ttu-id="4aab0-467">Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-467">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="4aab0-468">**Przykład 1**</span><span class="sxs-lookup"><span data-stu-id="4aab0-468">**Example 1**</span></span>  
  
 <span data-ttu-id="4aab0-469">Poniższy przykład kodu demonstruje dwa sposoby tworzenia delegata przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-469">The following code example demonstrates the two ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-470">Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, które <xref:System.Reflection.MethodInfo> określają, ale nie pierwszy argument; ich funkcjonalność jest taka sama, z tą różnicą, że jedna pozwala określić, czy zgłaszać błąd w przypadku niepowodzenia powiązania, a drugie zawsze zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="4aab0-470">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify a <xref:System.Reflection.MethodInfo> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="4aab0-471">W tym przykładzie kodu są używane oba przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-471">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="4aab0-472">Przykład `C` deklaruje klasę z metodą `M2` statyczną i metodą `M1`wystąpienia, a `C` dwa typy delegatów: `D1` przyjmuje wystąpienie i ciąg i `D2` Pobiera ciąg.</span><span class="sxs-lookup"><span data-stu-id="4aab0-472">The example declares a class `C` with a static method `M2` and an instance method `M1`, and two delegate types: `D1` takes an instance of `C` and a string, and `D2` takes a string.</span></span>  
  
 <span data-ttu-id="4aab0-473">Druga klasa o nazwie `Example` zawiera kod, który tworzy delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-473">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="4aab0-474">Delegat typu `D1`, reprezentujący otwartą metodę wystąpienia, jest tworzony dla metody `M1`wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-474">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="4aab0-475">Wystąpienie musi zostać przekazane podczas wywoływania delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-475">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="4aab0-476">Delegat typu `D2`, reprezentujący otwartą metodę statyczną, jest tworzony dla metody `M2`statycznej.</span><span class="sxs-lookup"><span data-stu-id="4aab0-476">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="4aab0-477">**Przykład 2**</span><span class="sxs-lookup"><span data-stu-id="4aab0-477">**Example 2**</span></span>  
  
 <span data-ttu-id="4aab0-478">Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-478">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-479">Ten przykład kodu używa <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-479">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="4aab0-480">Użycie innych przeciążeń <xref:System.Reflection.MethodInfo> jest podobne.</span><span class="sxs-lookup"><span data-stu-id="4aab0-480">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="4aab0-481">Przykładowy kod definiuje klasę bazową o nazwie `Base` i klasę o nazwie `Derived` , która dziedziczy `Base`z.</span><span class="sxs-lookup"><span data-stu-id="4aab0-481">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="4aab0-482">Klasa pochodna `static` ma metodę (`Shared` w Visual Basic) o nazwie `MyMethod` z jednym `Derived`parametrem typu `Base` i typem zwracanym.</span><span class="sxs-lookup"><span data-stu-id="4aab0-482">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="4aab0-483">Przykład kodu definiuje także delegat o nazwie `Example` , który ma jeden parametr typu `Derived` `Base`i zwracany typ.</span><span class="sxs-lookup"><span data-stu-id="4aab0-483">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="4aab0-484">Przykład kodu pokazuje, że delegat o nazwie `Example` może służyć do reprezentowania metody. `MyMethod`</span><span class="sxs-lookup"><span data-stu-id="4aab0-484">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="4aab0-485">Metodę można powiązać z delegatem, ponieważ:</span><span class="sxs-lookup"><span data-stu-id="4aab0-485">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="4aab0-486">Typ`Derived`parametru delegata () jest bardziej restrykcyjny niż `MyMethod` typ parametru (`Base`), dzięki czemu zawsze można bezpiecznie przekazać argument delegata do `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-486">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="4aab0-487">Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpiecznie do rzutowania zwracanego typu metody na zwracany typ delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-487">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="4aab0-488">W przykładowym kodzie nie są generowane żadne dane wyjściowe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-488">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4aab0-489"><paramref name="type" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-489"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-490">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-490">-or-</span></span> 
 <span data-ttu-id="4aab0-491"><paramref name="method" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-491"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-492"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-492"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="4aab0-493">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-493">-or-</span></span> 
 <span data-ttu-id="4aab0-494"><paramref name="type" />nie <see langword="RuntimeType" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-494"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="4aab0-495">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-495">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="4aab0-496">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-496">-or-</span></span> 
 <span data-ttu-id="4aab0-497"><paramref name="method" />nie można powiązać <paramref name="throwOnBindFailure" />. <see langword="true" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-497"><paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span></span>  
  
<span data-ttu-id="4aab0-498">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-498">-or-</span></span> 
 <span data-ttu-id="4aab0-499"><paramref name="method" />nie <see langword="RuntimeMethodInfo" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-499"><paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span></span> <span data-ttu-id="4aab0-500">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-500">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="4aab0-501">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-501">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="4aab0-502">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-502">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-503">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-503">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-504">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-504">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="4aab0-505"><see cref="T:System.Type" /> Delegat do utworzenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-505">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="4aab0-506">Reprezentuje klasę, która implementuje <paramref name="method" />. <see cref="T:System.Type" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-506">The <see cref="T:System.Type" /> representing the class that implements <paramref name="method" />.</span></span></param>
        <param name="method"><span data-ttu-id="4aab0-507">Nazwa metody statycznej, która ma być reprezentowana przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-507">The name of the static method that the delegate is to represent.</span></span></param>
        <summary><span data-ttu-id="4aab0-508">Tworzy delegat określonego typu, który reprezentuje określoną metodę statyczną określonej klasy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-508">Creates a delegate of the specified type that represents the specified static method of the specified class.</span></span></summary>
        <returns><span data-ttu-id="4aab0-509">Delegat określonego typu, który reprezentuje określoną metodę statyczną określonej klasy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-509">A delegate of the specified type that represents the specified static method of the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-510">Ta metoda tworzy delegatów tylko dla metod statycznych.</span><span class="sxs-lookup"><span data-stu-id="4aab0-510">This method creates delegates for static methods only.</span></span> <span data-ttu-id="4aab0-511">Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.</span><span class="sxs-lookup"><span data-stu-id="4aab0-511">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="4aab0-512">To Przeciążenie metody jest równoważne wywołaniu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> metody przeciążenia, określając `false` dla `ignoreCase` i `true` dla `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-512">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `false` for `ignoreCase` and `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-513">Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję.</span><span class="sxs-lookup"><span data-stu-id="4aab0-513">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="4aab0-514">(Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).</span><span class="sxs-lookup"><span data-stu-id="4aab0-514">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="4aab0-515">Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.</span><span class="sxs-lookup"><span data-stu-id="4aab0-515">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4aab0-516"><paramref name="type" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-516"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-517">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-517">-or-</span></span> 
 <span data-ttu-id="4aab0-518"><paramref name="target" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-518"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-519">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-519">-or-</span></span> 
 <span data-ttu-id="4aab0-520"><paramref name="method" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-520"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-521"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-521"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="4aab0-522">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-522">-or-</span></span> 
 <span data-ttu-id="4aab0-523"><paramref name="type" />nie <see langword="RuntimeType" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-523"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="4aab0-524">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-524">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="4aab0-525">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-525">-or-</span></span> 
 <span data-ttu-id="4aab0-526"><paramref name="target" />nie <see langword="RuntimeType" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-526"><paramref name="target" /> is not a <see langword="RuntimeType" />.</span></span>  
  
<span data-ttu-id="4aab0-527">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-527">-or-</span></span> 
 <span data-ttu-id="4aab0-528"><paramref name="target" />jest otwartym typem ogólnym.</span><span class="sxs-lookup"><span data-stu-id="4aab0-528"><paramref name="target" /> is an open generic type.</span></span> <span data-ttu-id="4aab0-529">Oznacza to, że <see cref="P:System.Type.ContainsGenericParameters" /> jego właściwość <see langword="true" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-529">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span></span>  
  
<span data-ttu-id="4aab0-530">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-530">-or-</span></span> 
 <span data-ttu-id="4aab0-531"><paramref name="method" />nie <see langword="static" /> jest metodą (<see langword="Shared" /> Metoda w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4aab0-531"><paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span></span>  
  
<span data-ttu-id="4aab0-532">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-532">-or-</span></span> 
 <span data-ttu-id="4aab0-533"><paramref name="method" />nie można powiązać, na przykład, ponieważ nie można go znaleźć i <paramref name="throwOnBindFailure" /> ma <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-533"><paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="4aab0-534">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-534">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="4aab0-535">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-535">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-536">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-536">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-537">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-537">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="4aab0-538"><see cref="T:System.Type" /> Reprezentujący typ delegata, który ma zostać utworzony.</span><span class="sxs-lookup"><span data-stu-id="4aab0-538">A <see cref="T:System.Type" /> representing the type of delegate to create.</span></span></param>
        <param name="firstArgument"><span data-ttu-id="4aab0-539"><see cref="T:System.Object" /> Jest to pierwszy argument metody reprezentowanej przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-539">An <see cref="T:System.Object" /> that is the first argument of the method the delegate represents.</span></span> <span data-ttu-id="4aab0-540">Dla metod instancji musi być zgodna z typem wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-540">For instance methods, it must be compatible with the instance type.</span></span></param>
        <param name="method"><span data-ttu-id="4aab0-541"><see cref="T:System.Reflection.MethodInfo" /> Opisywanie metody statycznej lub instancji, która ma być reprezentowana przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-541">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span></span></param>
        <param name="throwOnBindFailure"><span data-ttu-id="4aab0-542"><see langword="true" />Aby zgłosić wyjątek, <paramref name="method" /> <see langword="false" />Jeśli nie można go powiązać; w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-542"><see langword="true" /> to throw an exception if <paramref name="method" /> cannot be bound; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="4aab0-543">Tworzy delegat określonego typu, który reprezentuje określoną metodę statyczną lub wystąpienie, z określonym pierwszym argumentem i określonym zachowaniem w przypadku niepowodzenia powiązania.</span><span class="sxs-lookup"><span data-stu-id="4aab0-543">Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</span></span></summary>
        <returns><span data-ttu-id="4aab0-544">Delegat określonego typu, który reprezentuje określoną <see langword="null" /> metodę statyczną lub obiektową, lub jeśli <paramref name="throwOnBindFailure" /> jest <see langword="false" /> i delegat nie może być powiązany z <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-544">A delegate of the specified type that represents the specified static or instance method, or <see langword="null" /> if <paramref name="throwOnBindFailure" /> is <see langword="false" /> and the delegate cannot be bound to <paramref name="method" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-545">Ta metoda jest przeciążona <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> i Przeciążenie metody, która zawsze zgłasza błąd do powiązania, zapewnia najbardziej elastyczny sposób tworzenia delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-545">This method overload and the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> method overload, which always throws on failure to bind, provide the most flexible way to create delegates.</span></span> <span data-ttu-id="4aab0-546">Można ich użyć do tworzenia delegatów dla metod statycznych lub wystąpień, z lub bez pierwszego argumentu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-546">You can use them to create delegates for either static or instance methods, with or without a first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-547">Jeśli nie podasz pierwszego argumentu, użyj <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenia metody w celu uzyskania lepszej wydajności.</span><span class="sxs-lookup"><span data-stu-id="4aab0-547">If you do not supply a first argument, use the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload for better performance.</span></span>  
  
 <span data-ttu-id="4aab0-548">Typ delegata i Metoda muszą mieć zgodne typy zwracane.</span><span class="sxs-lookup"><span data-stu-id="4aab0-548">The delegate type and the method must have compatible return types.</span></span> <span data-ttu-id="4aab0-549">Oznacza to, że zwracany typ `method` musi być możliwy do przypisania do `type`typu zwracanego.</span><span class="sxs-lookup"><span data-stu-id="4aab0-549">That is, the return type of `method` must be assignable to the return type of `type`.</span></span>  
  
 <span data-ttu-id="4aab0-550">Jeśli `firstArgument` jest podany, jest przekazywany do `method` każdego momentu wywołania delegata; `firstArgument` jest określana jako powiązana z delegatem, a delegat jest określany jako zamknięty w pierwszym argumencie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-550">If `firstArgument` is supplied, it is passed to `method` every time the delegate is invoked; `firstArgument` is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</span></span> <span data-ttu-id="4aab0-551">Jeśli `method` jest `static` ( `method` `firstArgument` w Visual Basic), lista argumentów dostarczona podczas wywoływania delegata zawiera wszystkie parametry z wyjątkiem pierwszej; jeśli jest to metoda wystąpienia, zostaje przekazana do wystąpienia ukrytego`Shared` parametr (reprezentowany przez `this` w C#, lub `Me` w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4aab0-551">If `method` is `static` (`Shared` in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if `method` is an instance method, then `firstArgument` is passed to the hidden instance parameter (represented by `this` in C#, or by `Me` in Visual Basic).</span></span>  
  
 <span data-ttu-id="4aab0-552">Jeśli `firstArgument` jest podany, pierwszy parametr elementu `method` musi być typem referencyjnym i `firstArgument` musi być zgodny z tym typem.</span><span class="sxs-lookup"><span data-stu-id="4aab0-552">If `firstArgument` is supplied, the first parameter of `method` must be a reference type, and `firstArgument` must be compatible with that type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4aab0-553">Jeśli `method` jest `static` ( <xref:System.Object> wVisualBasic<xref:System.ValueType>) i jego`firstArgument` pierwszy parametr jest typu lub, może być typem wartości.`Shared`</span><span class="sxs-lookup"><span data-stu-id="4aab0-553">If `method` is `static` (`Shared` in Visual Basic) and its first parameter is of type <xref:System.Object> or <xref:System.ValueType>, then `firstArgument` can be a value type.</span></span> <span data-ttu-id="4aab0-554">W tym przypadku `firstArgument` jest automatycznie opakowany.</span><span class="sxs-lookup"><span data-stu-id="4aab0-554">In this case `firstArgument` is automatically boxed.</span></span> <span data-ttu-id="4aab0-555">Automatyczne pakowanie nie występuje dla żadnych innych argumentów, tak jak w przypadku C# wywołania funkcji lub Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="4aab0-555">Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</span></span>  
  
 <span data-ttu-id="4aab0-556">Jeśli `firstArgument` jest odwołaniem o wartości `method` null i jest metodą wystąpienia, wynik zależy od sygnatur typu `type` delegata i `method`:</span><span class="sxs-lookup"><span data-stu-id="4aab0-556">If `firstArgument` is a null reference and `method` is an instance method, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="4aab0-557">Jeśli podpis `type` jawnie obejmuje ukryty pierwszy `method`parametr, delegat jest reprezentowany do reprezentowania metody otwartego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-557">If the signature of `type` explicitly includes the hidden first parameter of `method`, the delegate is said to represent an open instance method.</span></span> <span data-ttu-id="4aab0-558">Gdy obiekt delegowany jest wywoływany, pierwszy argument na liście argumentów jest przenoszona do ukrytego wystąpienia parametru `method`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-558">When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of `method`.</span></span>  
  
-   <span data-ttu-id="4aab0-559">Jeśli sygnatury `method` i `type` są zgodne (to oznacza, że wszystkie typy parametrów są zgodne), delegat jest określany jako zamknięty w odniesieniu do wartości null.</span><span class="sxs-lookup"><span data-stu-id="4aab0-559">If the signatures of `method` and `type` match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="4aab0-560">Wywoływanie delegata jest podobne do wywołania metody wystąpienia w wystąpieniu o wartości null, która nie jest szczególnie przydatna.</span><span class="sxs-lookup"><span data-stu-id="4aab0-560">Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</span></span>  
  
 <span data-ttu-id="4aab0-561">Jeśli `firstArgument` jest odwołaniem null i `method` jest statyczna, wynik zależy od sygnatur typu `type` delegata i `method`:</span><span class="sxs-lookup"><span data-stu-id="4aab0-561">If `firstArgument` is a null reference and `method` is static, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="4aab0-562">Jeśli sygnatura `method` i `type` dopasowanie (to oznacza, że wszystkie typy parametrów są zgodne), delegat jest reprezentowany jako otwarta metoda statyczna.</span><span class="sxs-lookup"><span data-stu-id="4aab0-562">If the signature of `method` and `type` match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</span></span> <span data-ttu-id="4aab0-563">Jest to najbardziej typowy przypadek dla metod statycznych.</span><span class="sxs-lookup"><span data-stu-id="4aab0-563">This is the most common case for static methods.</span></span> <span data-ttu-id="4aab0-564">W takim przypadku można uzyskać nieco lepszą wydajność przy użyciu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-564">In this case, you can get slightly better performance by using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload.</span></span>  
  
-   <span data-ttu-id="4aab0-565">Jeśli sygnatura `type` zaczyna się od drugiego `method` parametru, a pozostałe typy parametrów są zgodne, delegat jest uznawany za zamknięty w odniesieniu do wartości null.</span><span class="sxs-lookup"><span data-stu-id="4aab0-565">If the signature of `type` begins with the second parameter of `method` and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="4aab0-566">Gdy obiekt delegowany jest wywoływany, odwołanie o wartości null jest przesyłane do pierwszego `method`parametru.</span><span class="sxs-lookup"><span data-stu-id="4aab0-566">When the delegate is invoked, a null reference is passed to the first parameter of `method`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-567">Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję.</span><span class="sxs-lookup"><span data-stu-id="4aab0-567">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="4aab0-568">(Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).</span><span class="sxs-lookup"><span data-stu-id="4aab0-568">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="4aab0-569">Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.</span><span class="sxs-lookup"><span data-stu-id="4aab0-569">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="4aab0-570">Zgodne typy parametrów i zwracany typ</span><span class="sxs-lookup"><span data-stu-id="4aab0-570">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="4aab0-571">Typy parametrów i typ zwracany delegata muszą być zgodne z typami parametrów i zwracanym typem metody reprezentowanej przez delegata; typy nie muszą dokładnie pasować.</span><span class="sxs-lookup"><span data-stu-id="4aab0-571">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-572">W .NET Framework w wersji 1,0 i 1,1 typy muszą dokładnie pasować.</span><span class="sxs-lookup"><span data-stu-id="4aab0-572">In the .NET Framework version 1.0 and 1.1 the types must match exactly.</span></span>  
  
 <span data-ttu-id="4aab0-573">Parametr delegata jest zgodny z odpowiadającym mu parametrem metody, jeśli typ parametru delegata jest bardziej restrykcyjny niż typ parametru metody, ponieważ gwarantuje to, że argument przesłany do delegata może być bezpiecznie przekazywać do Metoda.</span><span class="sxs-lookup"><span data-stu-id="4aab0-573">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="4aab0-574">Analogicznie, zwracany typ delegata jest zgodny z typem zwracanym metody, Jeśli zwracany typ metody jest bardziej restrykcyjny niż typ zwracany delegata, ponieważ gwarantuje to, że wartość zwracana metody może być bezpiecznie rzutowana na typ zwracany e delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-574">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="4aab0-575">Na przykład delegat <xref:System.Collections.Hashtable> z parametrem typu i <xref:System.Object> typem zwracanym może reprezentować metodę z parametrem typu <xref:System.Object> i wartością zwracaną typu <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="4aab0-575">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a><span data-ttu-id="4aab0-576">Określenie metod, które może reprezentować delegat</span><span class="sxs-lookup"><span data-stu-id="4aab0-576">Determining the Methods a Delegate Can Represent</span></span>  
 <span data-ttu-id="4aab0-577">Innym przydatnym sposobem, aby określić elastyczność zapewnianą przez to Przeciążenie <xref:System.Delegate.CreateDelegate%2A> , jest to, że każdy delegat może reprezentować cztery różne kombinacje sygnatur metody i rodzaju metody (statyczny a wystąpienie).</span><span class="sxs-lookup"><span data-stu-id="4aab0-577">Another useful way to think of the flexibility provided by this overload of <xref:System.Delegate.CreateDelegate%2A> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</span></span> <span data-ttu-id="4aab0-578">Należy wziąć pod uwagę `D` typ delegata z jednym `C`argumentem typu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-578">Consider a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="4aab0-579">Poniżej opisano metody `D` , które mogą reprezentować, ignorowanie zwracanego typu, ponieważ musi on być zgodny we wszystkich przypadkach:</span><span class="sxs-lookup"><span data-stu-id="4aab0-579">The following describes the methods `D` can represent, ignoring the return type since it must match in all cases:</span></span>  
  
-   <span data-ttu-id="4aab0-580">`D`może reprezentować każdą metodę wystąpienia, która ma dokładnie jeden `C`argument typu, bez względu na typ, do którego należy metoda wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-580">`D` can represent any instance method that has exactly one argument of type `C`, regardless of what type the instance method belongs to.</span></span> <span data-ttu-id="4aab0-581">Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` to wystąpienie typu `method` należy do, a otrzymany delegat jest wskazany do zamknięcia tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-581">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of the type `method` belongs to, and the resulting delegate is said to be closed over that instance.</span></span> <span data-ttu-id="4aab0-582">(W prosty sposób `D` można także zamknąć odwołanie o wartości null, jeśli `firstArgument` jest `null`).</span><span class="sxs-lookup"><span data-stu-id="4aab0-582">(Trivially, `D` can also be closed over a null reference if `firstArgument` is `null`.)</span></span>  
  
-   <span data-ttu-id="4aab0-583">`D`może reprezentować metodę `C` wystąpienia, która nie ma żadnych argumentów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-583">`D` can represent an instance method of `C` that has no arguments.</span></span> <span data-ttu-id="4aab0-584">Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="4aab0-584">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="4aab0-585">Przekazany delegat reprezentuje metodę otwartego wystąpienia, a wystąpienie `C` musi być dostarczone przy każdym wywołaniu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-585">The resulting delegate represents an open instance method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="4aab0-586">`D`może reprezentować metodę statyczną przyjmującą jeden argument `C`typu, która ta metoda może należeć do dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-586">`D` can represent a static method that takes one argument of type `C`, and that method can belong to any type.</span></span> <span data-ttu-id="4aab0-587">Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="4aab0-587">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="4aab0-588">Przekazany delegat reprezentuje statyczną metodę, a wystąpienie `C` musi być dostarczone przy każdym wywołaniu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-588">The resulting delegate represents an open static method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="4aab0-589">`D`może reprezentować metodę statyczną, która `F` należy do typu, i ma dwa `F` argumenty typu `C`i typu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-589">`D` can represent a static method that belongs to type `F` and has two arguments, of type `F` and type `C`.</span></span> <span data-ttu-id="4aab0-590">Gdy <xref:System.Delegate.CreateDelegate%2A> jest wywoływana, `firstArgument` jest wystąpieniem `F`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-590">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of `F`.</span></span> <span data-ttu-id="4aab0-591">Otrzymany delegat reprezentuje statyczną metodę, która jest zamknięta dla `F`tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-591">The resulting delegate represents a static method that is closed over that instance of `F`.</span></span> <span data-ttu-id="4aab0-592">Należy zauważyć, że w przypadku `F` gdy `C` i są tego samego typu, metoda statyczna ma dwa argumenty tego typu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-592">Note that in the case where `F` and `C` are the same type, the static method has two arguments of that type.</span></span> <span data-ttu-id="4aab0-593">(W tym przypadku jest `D` zamknięte przez odwołanie o wartości null, `firstArgument` Jeśli `null`jest).</span><span class="sxs-lookup"><span data-stu-id="4aab0-593">(In this case, `D` is closed over a null reference if `firstArgument` is `null`.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4aab0-594">Ta sekcja zawiera trzy przykłady kodu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-594">This section contains three code examples.</span></span> <span data-ttu-id="4aab0-595">W pierwszym przykładzie pokazano cztery rodzaje delegatów, które można utworzyć: zamknięte przez metodę wystąpienia, Otwórz w metodzie wystąpienia, Otwórz za pomocą metody statycznej i zamknięte przez metodę statyczną.</span><span class="sxs-lookup"><span data-stu-id="4aab0-595">The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</span></span>  
  
 <span data-ttu-id="4aab0-596">Drugi przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-596">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="4aab0-597">Trzeci przykład kodu definiuje pojedynczy typ delegata i pokazuje wszystkie metody, które może reprezentować typ delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-597">The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</span></span>  
  
 <span data-ttu-id="4aab0-598">**Przykład 1**</span><span class="sxs-lookup"><span data-stu-id="4aab0-598">**Example 1**</span></span>  
  
 <span data-ttu-id="4aab0-599">Poniższy przykład kodu demonstruje cztery sposoby tworzenia delegata przy użyciu tego przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-599">The following code example demonstrates the four ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-600">Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, które określają `firstArgument` i a <xref:System.Reflection.MethodInfo>; ich funkcjonalność jest taka sama, z tą różnicą, że jedna z nich pozwala określić, czy zgłaszać błąd w przypadku niepowodzenia, a drugie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-600">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="4aab0-601">W tym przykładzie kodu są używane oba przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-601">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="4aab0-602">Przykład `C` deklaruje klasę z metodą `M2` statyczną i metodą `M1`wystąpienia, a `C` trzy typy delegatów: `D1` przyjmuje wystąpienie i ciąg, `D2` Pobiera ciąg i `D3`nie ma argumentów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-602">The example declares a class `C` with a static method `M2` and an instance method `M1`, and three delegate types: `D1` takes an instance of `C` and a string, `D2` takes a string, and `D3` has no arguments.</span></span>  
  
 <span data-ttu-id="4aab0-603">Druga klasa o nazwie `Example` zawiera kod, który tworzy delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-603">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="4aab0-604">Delegat typu `D2`, zamknięty w `C`wystąpieniu, jest tworzony dla metody `M1`wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-604">A delegate of type `D2`, closed over an instance of `C`, is created for the instance method `M1`.</span></span> <span data-ttu-id="4aab0-605">Jest wywoływana z innymi ciągami, aby pokazać, że powiązane wystąpienie `C` jest zawsze używane.</span><span class="sxs-lookup"><span data-stu-id="4aab0-605">It is invoked with different strings, to show that the bound instance of `C` is always used.</span></span>  
  
-   <span data-ttu-id="4aab0-606">Delegat typu `D1`, reprezentujący otwartą metodę wystąpienia, jest tworzony dla metody `M1`wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-606">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="4aab0-607">Wystąpienie musi zostać przekazane podczas wywoływania delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-607">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="4aab0-608">Delegat typu `D2`, reprezentujący otwartą metodę statyczną, jest tworzony dla metody `M2`statycznej.</span><span class="sxs-lookup"><span data-stu-id="4aab0-608">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
-   <span data-ttu-id="4aab0-609">Na koniec, delegat typu `D3`, zamknięty w ciągu, jest tworzony dla metody `M2`statycznej.</span><span class="sxs-lookup"><span data-stu-id="4aab0-609">Finally, a delegate of type `D3`, closed over a string, is created for the static method `M2`.</span></span> <span data-ttu-id="4aab0-610">Metoda jest wywoływana, aby pokazać, że używa powiązanego ciągu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-610">The method is invoked to show that it uses the bound string.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="4aab0-611">**Przykład 2**</span><span class="sxs-lookup"><span data-stu-id="4aab0-611">**Example 2**</span></span>  
  
 <span data-ttu-id="4aab0-612">Poniższy przykład kodu ilustruje zgodność typów parametrów i zwracanych typów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-612">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-613">Ten przykład kodu używa <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-613">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="4aab0-614">Użycie innych przeciążeń <xref:System.Reflection.MethodInfo> jest podobne.</span><span class="sxs-lookup"><span data-stu-id="4aab0-614">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="4aab0-615">Przykładowy kod definiuje klasę bazową o nazwie `Base` i klasę o nazwie `Derived` , która dziedziczy `Base`z.</span><span class="sxs-lookup"><span data-stu-id="4aab0-615">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="4aab0-616">Klasa pochodna `static` ma metodę (`Shared` w Visual Basic) o nazwie `MyMethod` z jednym `Derived`parametrem typu `Base` i typem zwracanym.</span><span class="sxs-lookup"><span data-stu-id="4aab0-616">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="4aab0-617">Przykład kodu definiuje także delegat o nazwie `Example` , który ma jeden parametr typu `Derived` `Base`i zwracany typ.</span><span class="sxs-lookup"><span data-stu-id="4aab0-617">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="4aab0-618">Przykład kodu pokazuje, że delegat o nazwie `Example` może służyć do reprezentowania metody. `MyMethod`</span><span class="sxs-lookup"><span data-stu-id="4aab0-618">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="4aab0-619">Metodę można powiązać z delegatem, ponieważ:</span><span class="sxs-lookup"><span data-stu-id="4aab0-619">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="4aab0-620">Typ`Derived`parametru delegata () jest bardziej restrykcyjny niż `MyMethod` typ parametru (`Base`), dzięki czemu zawsze można bezpiecznie przekazać argument delegata do `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-620">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="4aab0-621">Zwracany typ `MyMethod` (`Derived`) jest bardziej restrykcyjny niż typ parametru delegata (`Base`), dzięki czemu zawsze jest bezpiecznie do rzutowania zwracanego typu metody na zwracany typ delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-621">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="4aab0-622">W przykładowym kodzie nie są generowane żadne dane wyjściowe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-622">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 <span data-ttu-id="4aab0-623">**Przykład 3**</span><span class="sxs-lookup"><span data-stu-id="4aab0-623">**Example 3**</span></span>  
  
 <span data-ttu-id="4aab0-624">Poniższy przykład kodu przedstawia wszystkie metody, które może reprezentować pojedynczy typ delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-624">The following code example shows all the methods a single delegate type can represent.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-625">Istnieją dwa przeciążenia <xref:System.Delegate.CreateDelegate%2A> metody, które określają `firstArgument` i a <xref:System.Reflection.MethodInfo>; ich funkcjonalność jest taka sama, z tą różnicą, że jedna z nich pozwala określić, czy zgłaszać błąd w przypadku niepowodzenia, a drugie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-625">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="4aab0-626">W tym przykładzie kodu są używane oba przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-626">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="4aab0-627">Przykład kodu definiuje dwie klasy `C` , i `F`i typ `D` delegata z jednym argumentem typu `C`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-627">The code example defines two classes, `C` and `F`, and a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="4aab0-628">Klasy mają zgodne metody `M1`static i instance, `M3`klasy `C` i `M4`, a także mają metodę `M2` wystąpienia, która nie ma argumentów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-628">The classes have matching static and instance methods `M1`, `M3`, and `M4`, and class `C` also has an instance method `M2` that has no arguments.</span></span>  
  
 <span data-ttu-id="4aab0-629">Trzecia Klasa o nazwie `Example` zawiera kod, który tworzy delegatów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-629">A third class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="4aab0-630">Delegaty są tworzone dla metody `M1` wystąpienia typu `C` i typu `F`; każda z nich jest zamknięta na wystąpieniu odpowiedniego typu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-630">Delegates are created for instance method `M1` of type `C` and type `F`; each is closed over an instance of the respective type.</span></span> <span data-ttu-id="4aab0-631">Metoda `M1` typu `C` wyświetla`ID` właściwości wystąpienia powiązanego i argumentu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-631">Method `M1` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
-   <span data-ttu-id="4aab0-632">Obiekt delegowany jest tworzony dla `M2` metody typu `C`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-632">A delegate is created for method `M2` of type `C`.</span></span> <span data-ttu-id="4aab0-633">Jest to delegata otwartego wystąpienia, w którym argument delegata reprezentuje ukryty pierwszy argument metody Instance.</span><span class="sxs-lookup"><span data-stu-id="4aab0-633">This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</span></span> <span data-ttu-id="4aab0-634">Metoda nie ma innych argumentów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-634">The method has no other arguments.</span></span>  
  
-   <span data-ttu-id="4aab0-635">Delegaty są tworzone dla statycznej `M3` metody `C` typu i `F`typu; są to otwarte elementy delegowane static.</span><span class="sxs-lookup"><span data-stu-id="4aab0-635">Delegates are created for static method `M3` of type `C` and type `F`; these are open static delegates.</span></span>  
  
-   <span data-ttu-id="4aab0-636">Na koniec są tworzone Delegaty dla statycznej `M4` metody `C` typu i `F`typu; każda metoda ma typ deklarujący jako pierwszy argument, a wystąpienie typu jest dostarczane, więc Delegaty są zamykane w ramach swoich pierwszych argumentów .</span><span class="sxs-lookup"><span data-stu-id="4aab0-636">Finally, delegates are created for static method `M4` of type `C` and type `F`; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</span></span> <span data-ttu-id="4aab0-637">Metoda `M4` typu `C` wyświetla`ID` właściwości wystąpienia powiązanego i argumentu.</span><span class="sxs-lookup"><span data-stu-id="4aab0-637">Method `M4` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4aab0-638"><paramref name="type" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-638"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-639">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-639">-or-</span></span> 
 <span data-ttu-id="4aab0-640"><paramref name="method" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-640"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-641"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-641"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="4aab0-642">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-642">-or-</span></span> 
 <span data-ttu-id="4aab0-643"><paramref name="type" />nie <see langword="RuntimeType" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-643"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="4aab0-644">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-644">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="4aab0-645">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-645">-or-</span></span> 
 <span data-ttu-id="4aab0-646"><paramref name="method" />nie można powiązać <paramref name="throwOnBindFailure" />. <see langword="true" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-646"><paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span></span>  
  
<span data-ttu-id="4aab0-647">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-647">-or-</span></span> 
 <span data-ttu-id="4aab0-648"><paramref name="method" />nie <see langword="RuntimeMethodInfo" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-648"><paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span></span> <span data-ttu-id="4aab0-649">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-649">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="4aab0-650">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-650">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="4aab0-651">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-651">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-652">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-652">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-653">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-653">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="4aab0-654"><see cref="T:System.Type" /> Delegat do utworzenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-654">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="4aab0-655">Wystąpienie klasy, na którym <paramref name="method" /> jest wywoływane.</span><span class="sxs-lookup"><span data-stu-id="4aab0-655">The class instance on which <paramref name="method" /> is invoked.</span></span></param>
        <param name="method"><span data-ttu-id="4aab0-656">Nazwa metody wystąpienia, która ma być reprezentowana przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-656">The name of the instance method that the delegate is to represent.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="4aab0-657">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="4aab0-657">A Boolean indicating whether to ignore the case when comparing the name of the method.</span></span></param>
        <summary><span data-ttu-id="4aab0-658">Tworzy delegat określonego typu, który reprezentuje określoną metodę wystąpienia do wywołania w określonym wystąpieniu klasy o określonej wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="4aab0-658">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</span></span></summary>
        <returns><span data-ttu-id="4aab0-659">Delegat określonego typu reprezentujący określoną metodę wystąpienia do wywołania w określonym wystąpieniu klasy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-659">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-660">Ta metoda tworzy delegatów tylko dla metod wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-660">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="4aab0-661">Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.</span><span class="sxs-lookup"><span data-stu-id="4aab0-661">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="4aab0-662">To Przeciążenie metody jest równoważne wywołaniu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> metody przeciążenia, określając `true` dla `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-662">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-663">Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję.</span><span class="sxs-lookup"><span data-stu-id="4aab0-663">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="4aab0-664">(Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).</span><span class="sxs-lookup"><span data-stu-id="4aab0-664">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="4aab0-665">Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.</span><span class="sxs-lookup"><span data-stu-id="4aab0-665">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4aab0-666"><paramref name="type" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-666"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-667">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-667">-or-</span></span> 
 <span data-ttu-id="4aab0-668"><paramref name="target" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-668"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-669">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-669">-or-</span></span> 
 <span data-ttu-id="4aab0-670"><paramref name="method" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-670"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-671"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-671"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="4aab0-672">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-672">-or-</span></span> 
 <span data-ttu-id="4aab0-673"><paramref name="type" />nie <see langword="RuntimeType" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-673"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="4aab0-674">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-674">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="4aab0-675">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-675">-or-</span></span> 
 <span data-ttu-id="4aab0-676"><paramref name="method" />nie jest metodą wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-676"><paramref name="method" /> is not an instance method.</span></span>  
  
<span data-ttu-id="4aab0-677">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-677">-or-</span></span> 
 <span data-ttu-id="4aab0-678"><paramref name="method" />nie można powiązać, na przykład ponieważ nie można go znaleźć.</span><span class="sxs-lookup"><span data-stu-id="4aab0-678"><paramref name="method" /> cannot be bound, for example because it cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="4aab0-679">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-679">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="4aab0-680">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-680">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-681">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-681">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-682">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-682">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="4aab0-683"><see cref="T:System.Type" /> Delegat do utworzenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-683">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="4aab0-684">Reprezentuje klasę, która implementuje <paramref name="method" />. <see cref="T:System.Type" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-684">The <see cref="T:System.Type" /> representing the class that implements <paramref name="method" />.</span></span></param>
        <param name="method"><span data-ttu-id="4aab0-685">Nazwa metody statycznej, która ma być reprezentowana przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-685">The name of the static method that the delegate is to represent.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="4aab0-686">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="4aab0-686">A Boolean indicating whether to ignore the case when comparing the name of the method.</span></span></param>
        <summary><span data-ttu-id="4aab0-687">Tworzy delegat określonego typu, który reprezentuje określoną metodę statyczną określonej klasy, z określoną rozróżnianiem wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="4aab0-687">Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</span></span></summary>
        <returns><span data-ttu-id="4aab0-688">Delegat określonego typu, który reprezentuje określoną metodę statyczną określonej klasy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-688">A delegate of the specified type that represents the specified static method of the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-689">Ta metoda tworzy delegatów tylko dla metod statycznych.</span><span class="sxs-lookup"><span data-stu-id="4aab0-689">This method creates delegates for static methods only.</span></span> <span data-ttu-id="4aab0-690">Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.</span><span class="sxs-lookup"><span data-stu-id="4aab0-690">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="4aab0-691">To Przeciążenie metody jest równoważne wywołaniu <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> metody przeciążenia, określając `true` dla `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-691">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-692">Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję.</span><span class="sxs-lookup"><span data-stu-id="4aab0-692">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="4aab0-693">(Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).</span><span class="sxs-lookup"><span data-stu-id="4aab0-693">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="4aab0-694">Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.</span><span class="sxs-lookup"><span data-stu-id="4aab0-694">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4aab0-695"><paramref name="type" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-695"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-696">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-696">-or-</span></span> 
 <span data-ttu-id="4aab0-697"><paramref name="target" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-697"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-698">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-698">-or-</span></span> 
 <span data-ttu-id="4aab0-699"><paramref name="method" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-699"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-700"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-700"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="4aab0-701">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-701">-or-</span></span> 
 <span data-ttu-id="4aab0-702"><paramref name="type" />nie <see langword="RuntimeType" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-702"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="4aab0-703">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-703">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="4aab0-704">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-704">-or-</span></span> 
 <span data-ttu-id="4aab0-705"><paramref name="target" />nie <see langword="RuntimeType" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-705"><paramref name="target" /> is not a <see langword="RuntimeType" />.</span></span>  
  
<span data-ttu-id="4aab0-706">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-706">-or-</span></span> 
 <span data-ttu-id="4aab0-707"><paramref name="target" />jest otwartym typem ogólnym.</span><span class="sxs-lookup"><span data-stu-id="4aab0-707"><paramref name="target" /> is an open generic type.</span></span> <span data-ttu-id="4aab0-708">Oznacza to, że <see cref="P:System.Type.ContainsGenericParameters" /> jego właściwość <see langword="true" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-708">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span></span>  
  
<span data-ttu-id="4aab0-709">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-709">-or-</span></span> 
 <span data-ttu-id="4aab0-710"><paramref name="method" />nie <see langword="static" /> jest metodą (<see langword="Shared" /> Metoda w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4aab0-710"><paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span></span>  
  
<span data-ttu-id="4aab0-711">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-711">-or-</span></span> 
 <span data-ttu-id="4aab0-712"><paramref name="method" />nie można powiązać, na przykład ponieważ nie można go znaleźć.</span><span class="sxs-lookup"><span data-stu-id="4aab0-712"><paramref name="method" /> cannot be bound, for example because it cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="4aab0-713">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-713">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="4aab0-714">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-714">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-715">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-715">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-716">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-716">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="4aab0-717"><see cref="T:System.Type" /> Delegat do utworzenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-717">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="4aab0-718">Wystąpienie klasy, na którym <paramref name="method" /> jest wywoływane.</span><span class="sxs-lookup"><span data-stu-id="4aab0-718">The class instance on which <paramref name="method" /> is invoked.</span></span></param>
        <param name="method"><span data-ttu-id="4aab0-719">Nazwa metody wystąpienia, która ma być reprezentowana przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-719">The name of the instance method that the delegate is to represent.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="4aab0-720">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="4aab0-720">A Boolean indicating whether to ignore the case when comparing the name of the method.</span></span></param>
        <param name="throwOnBindFailure"><span data-ttu-id="4aab0-721"><see langword="true" />Aby zgłosić wyjątek, <paramref name="method" /> <see langword="false" />Jeśli nie można go powiązać; w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-721"><see langword="true" /> to throw an exception if <paramref name="method" /> cannot be bound; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="4aab0-722">Tworzy delegat określonego typu, który reprezentuje określoną metodę wystąpienia do wywołania w określonym wystąpieniu klasy, z określoną wielkością liter i określonym zachowaniem w przypadku niepowodzenia powiązania.</span><span class="sxs-lookup"><span data-stu-id="4aab0-722">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</span></span></summary>
        <returns><span data-ttu-id="4aab0-723">Delegat określonego typu reprezentujący określoną metodę wystąpienia do wywołania w określonym wystąpieniu klasy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-723">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-724">Ta metoda tworzy delegatów tylko dla metod wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-724">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="4aab0-725">Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.</span><span class="sxs-lookup"><span data-stu-id="4aab0-725">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-726">Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję.</span><span class="sxs-lookup"><span data-stu-id="4aab0-726">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="4aab0-727">(Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).</span><span class="sxs-lookup"><span data-stu-id="4aab0-727">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="4aab0-728">Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.</span><span class="sxs-lookup"><span data-stu-id="4aab0-728">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4aab0-729"><paramref name="type" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-729"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-730">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-730">-or-</span></span> 
 <span data-ttu-id="4aab0-731"><paramref name="target" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-731"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-732">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-732">-or-</span></span> 
 <span data-ttu-id="4aab0-733"><paramref name="method" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-733"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-734"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-734"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="4aab0-735">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-735">-or-</span></span> 
 <span data-ttu-id="4aab0-736"><paramref name="type" />nie <see langword="RuntimeType" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-736"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="4aab0-737">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-737">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="4aab0-738">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-738">-or-</span></span> 
 <span data-ttu-id="4aab0-739"><paramref name="method" />nie jest metodą wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-739"><paramref name="method" /> is not an instance method.</span></span>  
  
<span data-ttu-id="4aab0-740">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-740">-or-</span></span> 
 <span data-ttu-id="4aab0-741"><paramref name="method" />nie można powiązać, na przykład, ponieważ nie można go znaleźć i <paramref name="throwOnBindFailure" /> ma <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-741"><paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="4aab0-742">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-742">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="4aab0-743">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-743">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-744">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-744">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-745">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-745">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="4aab0-746"><see cref="T:System.Type" /> Delegat do utworzenia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-746">The <see cref="T:System.Type" /> of delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="4aab0-747">Reprezentuje klasę, która implementuje <paramref name="method" />. <see cref="T:System.Type" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-747">The <see cref="T:System.Type" /> representing the class that implements <paramref name="method" />.</span></span></param>
        <param name="method"><span data-ttu-id="4aab0-748">Nazwa metody statycznej, która ma być reprezentowana przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-748">The name of the static method that the delegate is to represent.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="4aab0-749">Wartość logiczna wskazująca, podczas porównywania nazwy metody ma być ignorowana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="4aab0-749">A Boolean indicating whether to ignore the case when comparing the name of the method.</span></span></param>
        <param name="throwOnBindFailure"><span data-ttu-id="4aab0-750"><see langword="true" />Aby zgłosić wyjątek, <paramref name="method" /> <see langword="false" />Jeśli nie można go powiązać; w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-750"><see langword="true" /> to throw an exception if <paramref name="method" /> cannot be bound; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="4aab0-751">Tworzy delegat określonego typu, który reprezentuje określoną metodę statyczną określonej klasy, z określoną wielkością liter i określonym zachowaniem w przypadku niepowodzenia powiązania.</span><span class="sxs-lookup"><span data-stu-id="4aab0-751">Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</span></span></summary>
        <returns><span data-ttu-id="4aab0-752">Delegat określonego typu, który reprezentuje określoną metodę statyczną określonej klasy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-752">A delegate of the specified type that represents the specified static method of the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-753">Ta metoda tworzy delegatów tylko dla metod statycznych.</span><span class="sxs-lookup"><span data-stu-id="4aab0-753">This method creates delegates for static methods only.</span></span> <span data-ttu-id="4aab0-754">Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.</span><span class="sxs-lookup"><span data-stu-id="4aab0-754">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4aab0-755">Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do metod niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw przyznanych metod niepublicznych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję.</span><span class="sxs-lookup"><span data-stu-id="4aab0-755">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="4aab0-756">(Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).</span><span class="sxs-lookup"><span data-stu-id="4aab0-756">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="4aab0-757">Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.</span><span class="sxs-lookup"><span data-stu-id="4aab0-757">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4aab0-758"><paramref name="type" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-758"><paramref name="type" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-759">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-759">-or-</span></span> 
 <span data-ttu-id="4aab0-760"><paramref name="target" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-760"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-761">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-761">-or-</span></span> 
 <span data-ttu-id="4aab0-762"><paramref name="method" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-762"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-763"><paramref name="type" />nie dziedziczy <see cref="T:System.MulticastDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-763"><paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span></span>  
  
<span data-ttu-id="4aab0-764">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-764">-or-</span></span> 
 <span data-ttu-id="4aab0-765"><paramref name="type" />nie <see langword="RuntimeType" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-765"><paramref name="type" /> is not a <see langword="RuntimeType" />.</span></span> <span data-ttu-id="4aab0-766">Zobacz [typy środowiska uruchomieniowego w odbiciu](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span><span class="sxs-lookup"><span data-stu-id="4aab0-766">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span></span>  
  
<span data-ttu-id="4aab0-767">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-767">-or-</span></span> 
 <span data-ttu-id="4aab0-768"><paramref name="target" />nie <see langword="RuntimeType" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-768"><paramref name="target" /> is not a <see langword="RuntimeType" />.</span></span>  
  
<span data-ttu-id="4aab0-769">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-769">-or-</span></span> 
 <span data-ttu-id="4aab0-770"><paramref name="target" />jest otwartym typem ogólnym.</span><span class="sxs-lookup"><span data-stu-id="4aab0-770"><paramref name="target" /> is an open generic type.</span></span> <span data-ttu-id="4aab0-771">Oznacza to, że <see cref="P:System.Type.ContainsGenericParameters" /> jego właściwość <see langword="true" />jest.</span><span class="sxs-lookup"><span data-stu-id="4aab0-771">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span></span>  
  
<span data-ttu-id="4aab0-772">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-772">-or-</span></span> 
 <span data-ttu-id="4aab0-773"><paramref name="method" />nie <see langword="static" /> jest metodą (<see langword="Shared" /> Metoda w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4aab0-773"><paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span></span>  
  
<span data-ttu-id="4aab0-774">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-774">-or-</span></span> 
 <span data-ttu-id="4aab0-775"><paramref name="method" />nie można powiązać, na przykład, ponieważ nie można go znaleźć i <paramref name="throwOnBindFailure" /> ma <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-775"><paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="4aab0-776">Nie <see langword="Invoke" /> znaleziono<paramref name="type" /> metody.</span><span class="sxs-lookup"><span data-stu-id="4aab0-776">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="4aab0-777">Obiekt wywołujący nie ma uprawnień niezbędnych do uzyskania dostępu <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-777">The caller does not have the permissions necessary to access <paramref name="method" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-778">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-778">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-779">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-779">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="4aab0-780">Tablica obiektów, które są argumentami, które mają zostać przekazane do metody reprezentowanej przez bieżącego delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-780">An array of objects that are the arguments to pass to the method represented by the current delegate.</span></span>  
  
<span data-ttu-id="4aab0-781">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-781">-or-</span></span> 
 <span data-ttu-id="4aab0-782"><see langword="null" />, jeśli metoda reprezentowana przez bieżącego delegata nie wymaga argumentów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-782"><see langword="null" />, if the method represented by the current delegate does not require arguments.</span></span></param>
        <summary><span data-ttu-id="4aab0-783">Dynamicznie wywołuje (późne wiązanie) metodę reprezentowaną przez bieżącego delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-783">Dynamically invokes (late-bound) the method represented by the current delegate.</span></span></summary>
        <returns><span data-ttu-id="4aab0-784">Obiekt zwrócony przez metodę reprezentowaną przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-784">The object returned by the method represented by the delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-785">Ta metoda wywołuje <xref:System.Delegate.DynamicInvokeImpl%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="4aab0-785">This method calls the <xref:System.Delegate.DynamicInvokeImpl%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="4aab0-786">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</span><span class="sxs-lookup"><span data-stu-id="4aab0-786">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span>  
  
<span data-ttu-id="4aab0-787">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-787">-or-</span></span> 
<span data-ttu-id="4aab0-788">Liczba, kolejność lub typ parametrów wymienionych w <paramref name="args" /> jest nieprawidłowa.</span><span class="sxs-lookup"><span data-stu-id="4aab0-788">The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-789">Metoda reprezentowana przez delegata jest wywoływana dla obiektu lub klasy, która go nie obsługuje.</span><span class="sxs-lookup"><span data-stu-id="4aab0-789">The method represented by the delegate is invoked on an object or a class that does not support it.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="4aab0-790">Metoda reprezentowana przez delegata jest metodą wystąpienia, a obiektem docelowym jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-790">The method represented by the delegate is an instance method and the target object is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-791">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-791">-or-</span></span> 
<span data-ttu-id="4aab0-792">Jedna z metod hermetyzowanych zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="4aab0-792">One of the encapsulated methods throws an exception.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-793">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-793">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-794">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-794">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="4aab0-795">Tablica obiektów, które są argumentami, które mają zostać przekazane do metody reprezentowanej przez bieżącego delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-795">An array of objects that are the arguments to pass to the method represented by the current delegate.</span></span>  
  
<span data-ttu-id="4aab0-796">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-796">-or-</span></span> 
 <span data-ttu-id="4aab0-797"><see langword="null" />, jeśli metoda reprezentowana przez bieżącego delegata nie wymaga argumentów.</span><span class="sxs-lookup"><span data-stu-id="4aab0-797"><see langword="null" />, if the method represented by the current delegate does not require arguments.</span></span></param>
        <summary><span data-ttu-id="4aab0-798">Dynamicznie wywołuje (późne wiązanie) metodę reprezentowaną przez bieżącego delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-798">Dynamically invokes (late-bound) the method represented by the current delegate.</span></span></summary>
        <returns><span data-ttu-id="4aab0-799">Obiekt zwrócony przez metodę reprezentowaną przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-799">The object returned by the method represented by the delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-800">Ta metoda implementuje <xref:System.Delegate.DynamicInvoke%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="4aab0-800">This method implements the <xref:System.Delegate.DynamicInvoke%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="4aab0-801">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</span><span class="sxs-lookup"><span data-stu-id="4aab0-801">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span>  
  
<span data-ttu-id="4aab0-802">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-802">-or-</span></span> 
<span data-ttu-id="4aab0-803">Liczba, kolejność lub typ parametrów wymienionych w <paramref name="args" /> jest nieprawidłowa.</span><span class="sxs-lookup"><span data-stu-id="4aab0-803">The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-804">Metoda reprezentowana przez delegata jest wywoływana dla obiektu lub klasy, która go nie obsługuje.</span><span class="sxs-lookup"><span data-stu-id="4aab0-804">The method represented by the delegate is invoked on an object or a class that does not support it.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="4aab0-805">Metoda reprezentowana przez delegata jest metodą wystąpienia, a obiektem docelowym jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-805">The method represented by the delegate is an instance method and the target object is <see langword="null" />.</span></span>  
  
<span data-ttu-id="4aab0-806">—lub—</span><span class="sxs-lookup"><span data-stu-id="4aab0-806">-or-</span></span> 
<span data-ttu-id="4aab0-807">Jedna z metod hermetyzowanych zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="4aab0-807">One of the encapsulated methods throws an exception.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-808">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-808">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-809">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-809">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="4aab0-810">Obiekt do porównania z bieżącym delegatem.</span><span class="sxs-lookup"><span data-stu-id="4aab0-810">The object to compare with the current delegate.</span></span></param>
        <summary><span data-ttu-id="4aab0-811">Określa, czy określony obiekt i bieżący delegat są tego samego typu i mają te same cele, metody i listę wywołań.</span><span class="sxs-lookup"><span data-stu-id="4aab0-811">Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</span></span></summary>
        <returns><span data-ttu-id="4aab0-812"><see langword="true" />Jeśli <paramref name="obj" /> i bieżący delegat ma te same cele, metody i listę wywołań; w przeciwnym razie, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-812"><see langword="true" /> if <paramref name="obj" /> and the current delegate have the same targets, methods, and invocation list; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-813">Jeśli dwa Delegaty nie są tego samego typu, nie są uważane za równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-813">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4aab0-814">W .NET Framework w wersji 1,0 i 1,1 dwa Delegaty zostały uznane za równe, jeśli ich obiekty docelowe, metody i Lista wywołań były równe, nawet jeśli Delegaty mają różne typy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-814">In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="4aab0-815">Metody i cele są porównywane pod kątem równości w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="4aab0-815">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="4aab0-816">Jeśli dwie metody, które są porównywane, są zarówno statyczne, jak i są tymi samymi metodami w tej samej klasie, metody są uważane za równe, a obiekty docelowe są również traktowane jako równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-816">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="4aab0-817">Jeśli dwie metody, które są porównywane są metodami wystąpień i są tej samej metody dla tego samego obiektu, metody są uważane za równe, a obiekty docelowe są również traktowane jako równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-817">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="4aab0-818">W przeciwnym razie metody nie są uważane za równe, a elementy docelowe również nie są traktowane jako równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-818">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="4aab0-819">Dwa wywołania są uważane za identyczne tylko wtedy, gdy mają takie same kolejność, a odpowiednie elementy z dwóch list reprezentują tę samą metodę i element docelowy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-819">Two invocation lists are considered identical only if they have the same order and the corresponding elements from the two lists represent the same method and target.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="4aab0-820">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</span><span class="sxs-lookup"><span data-stu-id="4aab0-820">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-821">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-821">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-822">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-822">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aab0-823">Zwraca kod skrótu delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-823">Returns a hash code for the delegate.</span></span></summary>
        <returns><span data-ttu-id="4aab0-824">Kod skrótu delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-824">A hash code for the delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-825">Wartość zwracana tej metody nie może być utrwalona z dwóch przyczyn.</span><span class="sxs-lookup"><span data-stu-id="4aab0-825">The return value of this method must not be persisted for two reasons.</span></span> <span data-ttu-id="4aab0-826">Po pierwsze funkcja skrótu klasy może zostać zmieniona w celu wygenerowania lepszej dystrybucji, co spowoduje, że wszystkie wartości ze starej funkcji mieszania są bezużyteczne.</span><span class="sxs-lookup"><span data-stu-id="4aab0-826">First, the hash function of a class might be altered to generate a better distribution, rendering any values from the old hash function useless.</span></span> <span data-ttu-id="4aab0-827">Po drugie, domyślna implementacja tej klasy nie gwarantuje, że ta sama wartość zostanie zwrócona przez różne wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-827">Second, the default implementation of this class does not guarantee that the same value will be returned by different instances.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-828">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-828">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-829">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-829">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aab0-830">Zwraca listę wywołań delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-830">Returns the invocation list of the delegate.</span></span></summary>
        <returns><span data-ttu-id="4aab0-831">Tablica delegatów reprezentujących listę wywołań bieżącego delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-831">An array of delegates representing the invocation list of the current delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-832">Każdy delegat w tablicy reprezentuje dokładnie jedną metodę.</span><span class="sxs-lookup"><span data-stu-id="4aab0-832">Each delegate in the array represents exactly one method.</span></span>  
  
 <span data-ttu-id="4aab0-833">Kolejność delegatów w tablicy jest taka sama jak kolejność, w której bieżący delegat wywołuje metody, które reprezentują te Delegaty.</span><span class="sxs-lookup"><span data-stu-id="4aab0-833">The order of the delegates in the array is the same order in which the current delegate invokes the methods that those delegates represent.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4aab0-834">Poniższy przykład przypisuje trzy metody do delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-834">The following example assigns three methods to a delegate.</span></span> <span data-ttu-id="4aab0-835">Następnie wywołuje <xref:System.Delegate.GetInvocationList%2A> metodę, aby uzyskać łączną liczbę metod przypisanych do delegata, do wykonywania delegatów w odwrotnej kolejności oraz do wykonywania metod, których nazwa nie zawiera podciągu "File".</span><span class="sxs-lookup"><span data-stu-id="4aab0-835">It then calls the  <xref:System.Delegate.GetInvocationList%2A> method to get a total count of the methods assigned to the delegate, to execute the delegates in reverse order, and to execute the methods whose name do not include the substring "File".</span></span>  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-836">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-836">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-837">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-837">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aab0-838">Pobiera metodę statyczną reprezentowaną przez bieżącego delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-838">Gets the static method represented by the current delegate.</span></span></summary>
        <returns><span data-ttu-id="4aab0-839"><see cref="T:System.Reflection.MethodInfo" /> Opis metody statycznej reprezentowanej przez bieżącego delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-839">A <see cref="T:System.Reflection.MethodInfo" /> describing the static method represented by the current delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-840">Ta metoda ma zastosowanie tylko wtedy, gdy bieżący delegat reprezentuje metodę statyczną.</span><span class="sxs-lookup"><span data-stu-id="4aab0-840">This method applies only if the current delegate represents a static method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="4aab0-841">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</span><span class="sxs-lookup"><span data-stu-id="4aab0-841">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-842">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-842">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-843">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-843">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="4aab0-844">Nieobsługiwane.</span><span class="sxs-lookup"><span data-stu-id="4aab0-844">Not supported.</span></span></param>
        <param name="context"><span data-ttu-id="4aab0-845">Nieobsługiwane.</span><span class="sxs-lookup"><span data-stu-id="4aab0-845">Not supported.</span></span></param>
        <summary><span data-ttu-id="4aab0-846">Nieobsługiwane.</span><span class="sxs-lookup"><span data-stu-id="4aab0-846">Not supported.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4aab0-847">Ta metoda nie jest obsługiwana.</span><span class="sxs-lookup"><span data-stu-id="4aab0-847">This method is not supported.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4aab0-848">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="4aab0-848">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="4aab0-849">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="4aab0-849">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aab0-850">Pobiera metodę reprezentowaną przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-850">Gets the method represented by the delegate.</span></span></summary>
        <value><span data-ttu-id="4aab0-851">A <see cref="T:System.Reflection.MethodInfo" /> opisywanie metody reprezentowanej przez delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-851">A <see cref="T:System.Reflection.MethodInfo" /> describing the method represented by the delegate.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="4aab0-852">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</span><span class="sxs-lookup"><span data-stu-id="4aab0-852">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-853">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-853">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-854">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-854">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1"><span data-ttu-id="4aab0-855">Pierwszy delegat do porównania.</span><span class="sxs-lookup"><span data-stu-id="4aab0-855">The first delegate to compare.</span></span></param>
        <param name="d2"><span data-ttu-id="4aab0-856">Drugi delegat do porównania.</span><span class="sxs-lookup"><span data-stu-id="4aab0-856">The second delegate to compare.</span></span></param>
        <summary><span data-ttu-id="4aab0-857">Określa, czy określone Delegaty są równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-857">Determines whether the specified delegates are equal.</span></span></summary>
        <returns><span data-ttu-id="4aab0-858"><see langword="true" />Jeśli <paramref name="d1" /> jest <see langword="false" />równa; w przeciwnym razie,. <paramref name="d2" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-858"><see langword="true" /> if <paramref name="d1" /> is equal to <paramref name="d2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-859">Dwa Delegaty tego samego typu z tymi samymi obiektami docelowymi, metodami i listami wywołań są uważane za równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-859">Two delegates of the same type with the same targets, methods, and invocation lists are considered equal.</span></span>  
  
 <span data-ttu-id="4aab0-860">Jeśli dwa Delegaty nie są tego samego typu, nie są uważane za równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-860">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4aab0-861">W .NET Framework w wersji 1,0 i 1,1 dwa Delegaty zostały uznane za równe, jeśli ich obiekty docelowe, metody i Lista wywołań były równe, nawet jeśli Delegaty mają różne typy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-861">In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="4aab0-862">Metody i cele są porównywane pod kątem równości w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="4aab0-862">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="4aab0-863">Jeśli dwie metody, które są porównywane, są zarówno statyczne, jak i są tymi samymi metodami w tej samej klasie, metody są uważane za równe, a obiekty docelowe są również traktowane jako równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-863">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="4aab0-864">Jeśli dwie metody, które są porównywane są metodami wystąpień i są tej samej metody dla tego samego obiektu, metody są uważane za równe, a obiekty docelowe są również traktowane jako równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-864">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="4aab0-865">W przeciwnym razie metody nie są uważane za równe, a elementy docelowe również nie są traktowane jako równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-865">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="4aab0-866">Dwa wywołania list są uważane za identyczne, jeśli mają taką samą kolejność, a odpowiednie elementy z dwóch list reprezentują tę samą metodę i cel.</span><span class="sxs-lookup"><span data-stu-id="4aab0-866">Two invocation lists are considered identical if they have the same order and the corresponding elements from the two lists represent the same method and target.</span></span>  
  
 <span data-ttu-id="4aab0-867">Równoważna Metoda dla tego operatora to<xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="4aab0-867">The equivalent method for this operator is <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-868">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-868">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-869">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-869">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1"><span data-ttu-id="4aab0-870">Pierwszy delegat do porównania.</span><span class="sxs-lookup"><span data-stu-id="4aab0-870">The first delegate to compare.</span></span></param>
        <param name="d2"><span data-ttu-id="4aab0-871">Drugi delegat do porównania.</span><span class="sxs-lookup"><span data-stu-id="4aab0-871">The second delegate to compare.</span></span></param>
        <summary><span data-ttu-id="4aab0-872">Określa, czy określone Delegaty nie są równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-872">Determines whether the specified delegates are not equal.</span></span></summary>
        <returns><span data-ttu-id="4aab0-873"><see langword="true" />Jeśli <paramref name="d1" /> nie jest <paramref name="d2" />równe; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-873"><see langword="true" /> if <paramref name="d1" /> is not equal to <paramref name="d2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-874">Dwa Delegaty są uważane za nierówne, jeśli są różnymi typami lub mają różne metody, różne elementy docelowe lub różne listy wywołań.</span><span class="sxs-lookup"><span data-stu-id="4aab0-874">Two delegates are considered not equal if they are of different types, or have different methods, different targets, or different invocation lists.</span></span>  
  
 <span data-ttu-id="4aab0-875">Jeśli dwa Delegaty nie są tego samego typu, nie są uważane za równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-875">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4aab0-876">W .NET Framework w wersji 1,0 i 1,1 dwa Delegaty są uważane za równe, jeśli ich obiekty docelowe, metody i Lista wywołań były równe, nawet jeśli Delegaty mają różne typy.</span><span class="sxs-lookup"><span data-stu-id="4aab0-876">In the .NET Framework version 1.0 and 1.1, two delegates are considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="4aab0-877">Metody i cele są porównywane pod kątem równości w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="4aab0-877">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="4aab0-878">Jeśli dwie metody, które są porównywane, są zarówno statyczne, jak i są tymi samymi metodami w tej samej klasie, metody są uważane za równe, a obiekty docelowe są również traktowane jako równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-878">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="4aab0-879">Jeśli dwie metody, które są porównywane są metodami wystąpień i są tej samej metody dla tego samego obiektu, metody są uważane za równe, a obiekty docelowe są również traktowane jako równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-879">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="4aab0-880">W przeciwnym razie metody nie są uważane za równe, a elementy docelowe również nie są traktowane jako równe.</span><span class="sxs-lookup"><span data-stu-id="4aab0-880">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="4aab0-881">Dwa wywołania nie są równe, jeśli mają różne rozmiary, jeśli są uporządkowane inaczej lub jeśli co najmniej jeden element z jednej listy reprezentuje metodę lub obiekt docelowy, który jest inny niż ten, który jest reprezentowany przez odpowiadający mu element na drugiej liście.</span><span class="sxs-lookup"><span data-stu-id="4aab0-881">Two invocation lists are not equal if they have different sizes, if they are ordered differently, or if at least one element from one list represents a method or target that is different from that represented by its corresponding element in the other list.</span></span>  
  
 <span data-ttu-id="4aab0-882">Równoważna Metoda dla tego operatora to<xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="4aab0-882">The equivalent method for this operator is <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-883">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-883">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-884">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-884">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="4aab0-885">Delegat, z którego ma zostać usunięta lista <paramref name="value" />wywołań.</span><span class="sxs-lookup"><span data-stu-id="4aab0-885">The delegate from which to remove the invocation list of <paramref name="value" />.</span></span></param>
        <param name="value"><span data-ttu-id="4aab0-886">Delegat, który dostarcza listę wywołań do usunięcia z listy <paramref name="source" />wywołań.</span><span class="sxs-lookup"><span data-stu-id="4aab0-886">The delegate that supplies the invocation list to remove from the invocation list of <paramref name="source" />.</span></span></param>
        <summary><span data-ttu-id="4aab0-887">Usuwa ostatnią liczbę wywołań listy delegatów z listy wywołań innego delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-887">Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</span></span></summary>
        <returns><span data-ttu-id="4aab0-888">Nowy delegat <paramref name="source" /> z listą wywołania utworzoną przez pobranie listy wywołań i usunięcie ostatniego wystąpienia <paramref name="value" />listy wywołań, jeśli lista <paramref name="value" /> wywołań znajduje się na liście wywołań elementu <paramref name="source" />w elemencie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-888">A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing the last occurrence of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />.</span></span> <span data-ttu-id="4aab0-889">Zwraca <paramref name="source" /> wartość <paramref name="value" /> , <see langword="null" /> jeśli jest lub jeśli nie można odnaleźć <paramref name="value" /> listy wywołań w wywołaniu listy <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-889">Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />.</span></span> <span data-ttu-id="4aab0-890">Zwraca odwołanie o wartości null, jeśli lista <paramref name="value" /> wywołań jest równa <paramref name="source" /> liście wywołań lub jeśli <paramref name="source" /> jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="4aab0-890">Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" /> or if <paramref name="source" /> is a null reference.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-891">Jeśli lista `value` wywołań `value` jest zgodna z ciągłym zestawem elementów na `source`liście wywołań, wówczas Lista wywołań jest określana na liście wywołań elementu `source`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-891">If the invocation list of `value` matches a contiguous set of elements in the invocation list of `source`, then the invocation list of `value` is said to occur within the invocation list of `source`.</span></span> <span data-ttu-id="4aab0-892">Jeśli lista `value` wywołań występuje więcej niż jeden raz na `source`liście wywołań, ostatnie wystąpienie zostanie usunięte.</span><span class="sxs-lookup"><span data-stu-id="4aab0-892">If the invocation list of `value` occurs more than once in the invocation list of `source`, the last occurrence is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="4aab0-893">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</span><span class="sxs-lookup"><span data-stu-id="4aab0-893">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-894">Typy delegatów nie są zgodne.</span><span class="sxs-lookup"><span data-stu-id="4aab0-894">The delegate types do not match.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-895">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-895">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-896">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-896">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="4aab0-897">Delegat, z którego ma zostać usunięta lista <paramref name="value" />wywołań.</span><span class="sxs-lookup"><span data-stu-id="4aab0-897">The delegate from which to remove the invocation list of <paramref name="value" />.</span></span></param>
        <param name="value"><span data-ttu-id="4aab0-898">Delegat, który dostarcza listę wywołań do usunięcia z listy <paramref name="source" />wywołań.</span><span class="sxs-lookup"><span data-stu-id="4aab0-898">The delegate that supplies the invocation list to remove from the invocation list of <paramref name="source" />.</span></span></param>
        <summary><span data-ttu-id="4aab0-899">Usuwa wszystkie wystąpienia list wywołania delegata z listy wywołań innego delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-899">Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</span></span></summary>
        <returns><span data-ttu-id="4aab0-900">Nowy delegat <paramref name="source" /> z listą wywołania utworzoną przez pobranie listy wywołań i usunięcie wszystkich wystąpień <paramref name="value" />listy wywołań, jeśli lista <paramref name="value" /> wywołań znajduje się na liście wywołań elementu <paramref name="source" />w elemencie.</span><span class="sxs-lookup"><span data-stu-id="4aab0-900">A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing all occurrences of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />.</span></span> <span data-ttu-id="4aab0-901">Zwraca <paramref name="source" /> wartość <paramref name="value" /> , <see langword="null" /> jeśli jest lub jeśli nie można odnaleźć <paramref name="value" /> listy wywołań w wywołaniu listy <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="4aab0-901">Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />.</span></span> <span data-ttu-id="4aab0-902">Zwraca odwołanie o wartości null, <paramref name="value" /> Jeśli lista wywołań jest równa liście wywołań elementu <paramref name="source" />, jeśli <paramref name="source" /> zawiera tylko serie list wywołań, które <paramref name="value" />są równe liście wywołań, lub jeśli <paramref name="source" /> ma wartość null odwoła.</span><span class="sxs-lookup"><span data-stu-id="4aab0-902">Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" />, if <paramref name="source" /> contains only a series of invocation lists that are equal to the invocation list of <paramref name="value" />, or if <paramref name="source" /> is a null reference.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-903">Jeśli lista `value` wywołań `value` jest zgodna z ciągłym zestawem elementów na `source`liście wywołań, wówczas Lista wywołań jest określana na liście wywołań elementu `source`.</span><span class="sxs-lookup"><span data-stu-id="4aab0-903">If the invocation list of `value` matches a contiguous set of elements in the invocation list of `source`, then the invocation list of `value` is said to occur within the invocation list of `source`.</span></span> <span data-ttu-id="4aab0-904">Jeśli lista `value` wywołań występuje więcej niż jeden raz na liście wywołań elementu `source`, wszystkie wystąpienia są usuwane.</span><span class="sxs-lookup"><span data-stu-id="4aab0-904">If the invocation list of `value` occurs more than once in the invocation list of `source`, all occurrences are removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="4aab0-905">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</span><span class="sxs-lookup"><span data-stu-id="4aab0-905">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4aab0-906">Typy delegatów nie są zgodne.</span><span class="sxs-lookup"><span data-stu-id="4aab0-906">The delegate types do not match.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-907">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-907">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-908">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-908">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="4aab0-909">Delegat, który dostarcza listę wywołań do usunięcia z listy wywołań bieżącego delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-909">The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</span></span></param>
        <summary><span data-ttu-id="4aab0-910">Usuwa listę wywołań delegata z listy wywołań innego delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-910">Removes the invocation list of a delegate from the invocation list of another delegate.</span></span></summary>
        <returns><span data-ttu-id="4aab0-911">Nowy delegat z listą wywołania utworzoną przez pobranie listy wywołań bieżącego delegata i usunięcie listy <paramref name="value" />wywołań, jeśli <paramref name="value" /> Lista wywołań znajduje się na liście wywołań bieżącego delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-911">A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the current delegate's invocation list.</span></span> <span data-ttu-id="4aab0-912">Zwraca bieżący delegat, jeśli <paramref name="value" /> jest <see langword="null" /> lub jeśli lista <paramref name="value" /> wywołań nie została znaleziona w obrębie listy wywołań bieżącego delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-912">Returns the current delegate if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the current delegate's invocation list.</span></span> <span data-ttu-id="4aab0-913">Zwraca <see langword="null" /> czy<paramref name="value" /> Lista wywołań jest równa bieżącej liście wywołań obiektu delegowanego.</span><span class="sxs-lookup"><span data-stu-id="4aab0-913">Returns <see langword="null" /> if the invocation list of <paramref name="value" /> is equal to the current delegate's invocation list.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-914">Jeśli lista `value` wywołań pasuje do ciągłego zestawu elementów na liście wywołań bieżącego delegata, `value` Lista wywołań jest określana na liście wywołań bieżącego delegata.</span><span class="sxs-lookup"><span data-stu-id="4aab0-914">If the invocation list of `value` matches a contiguous set of elements in the current delegate's invocation list, then the invocation list of `value` is said to occur within the current delegate's invocation list.</span></span> <span data-ttu-id="4aab0-915">Jeśli lista `value` wywołań występuje więcej niż raz na liście wywołań bieżącego delegata, ostatnie wystąpienie zostanie usunięte.</span><span class="sxs-lookup"><span data-stu-id="4aab0-915">If the invocation list of `value` occurs more than once in the current delegate's invocation list, the last occurrence is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="4aab0-916">Obiekt wywołujący nie ma dostępu do metody reprezentowanej przez delegata (na przykład jeśli metoda jest prywatna).</span><span class="sxs-lookup"><span data-stu-id="4aab0-916">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-917">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-917">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-918">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-918">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aab0-919">Pobiera wystąpienie klasy, dla którego bieżący delegat wywołuje metodę wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4aab0-919">Gets the class instance on which the current delegate invokes the instance method.</span></span></summary>
        <value><span data-ttu-id="4aab0-920">Obiekt, na którym bieżący delegat wywołuje metodę wystąpienia, jeśli delegat reprezentuje metodę wystąpienia; <see langword="null" /> Jeśli delegat reprezentuje metodę statyczną.</span><span class="sxs-lookup"><span data-stu-id="4aab0-920">The object on which the current delegate invokes the instance method, if the delegate represents an instance method; <see langword="null" /> if the delegate represents a static method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aab0-921">Metoda wystąpienia to metoda, która jest skojarzona z wystąpieniem klasy, natomiast metoda statyczna jest skojarzona z samą klasą.</span><span class="sxs-lookup"><span data-stu-id="4aab0-921">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="4aab0-922">Jeśli delegat wywołuje jedną lub więcej metod wystąpienia, ta właściwość zwraca element docelowy ostatniej instancji metody na liście wywołań.</span><span class="sxs-lookup"><span data-stu-id="4aab0-922">If the delegate invokes one or more instance methods, this property returns the target of the last instance method in the invocation list.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="4aab0-923">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="4aab0-923">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="4aab0-924">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="4aab0-924">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>

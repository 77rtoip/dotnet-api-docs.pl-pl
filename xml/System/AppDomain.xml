<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8193f1d65725a40b2301463ace7d4d95fbe76d8c" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69439292" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje domenę aplikacji, czyli środowisko izolowane, w którym są wykonywane aplikacje. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domeny aplikacji, które są reprezentowane przez <xref:System.AppDomain> obiekty, zapewniają izolację, wyładowywanie i granice zabezpieczeń na potrzeby wykonywania kodu zarządzanego.  
  
-   Używanie domen aplikacji do izolowania zadań, które mogą spowodować przeprowadzenie procesu. Jeśli stan <xref:System.AppDomain> wykonywanego zadania stanie się niestabilny <xref:System.AppDomain> , można go zwolnić bez wpływu na proces. Jest to ważne, gdy proces musi być uruchomiony przez długie okresy bez ponownego uruchamiania. Możesz również użyć domen aplikacji do izolowania zadań, które nie powinny udostępniać danych.  
  
-   Jeśli zestaw jest ładowany do domyślnej domeny aplikacji, nie można go zwolnić z pamięci, gdy proces jest uruchomiony. Jeśli jednak otworzysz drugą domenę aplikacji w celu załadowania i wykonania zestawu, zestaw zostanie zwolniony, gdy domena aplikacji zostanie zwolniona. Ta technika służy do minimalizowania zestawu roboczego długotrwałych procesów, które czasami używają dużych bibliotek DLL.  
  
 > [!NOTE]
 >  W przypadku platformy .NET Core <xref:System.AppDomain> implementacja jest ograniczona przez konstrukcję i nie zapewnia izolacji, zwalniania ani granic zabezpieczeń. W przypadku platformy .NET Core istnieje tylko jeden <xref:System.AppDomain>. Izolacja i wyładowywanie są <xref:System.Runtime.Loader.AssemblyLoadContext>udostępniane w systemie. Granice zabezpieczeń powinny być zapewnione przez granice procesu i odpowiednie techniki komunikacji zdalnej.
 
 Wiele domen aplikacji może działać w jednym procesie; nie istnieje jednak korelacja jeden-do-jednego między domenami aplikacji i wątkami. Kilka wątków może należeć do jednej domeny aplikacji, a podczas gdy dany wątek nie jest ograniczony do pojedynczej domeny aplikacji, w danym momencie wątek jest wykonywany w jednej domenie aplikacji.  
  
 Domeny aplikacji są tworzone przy użyciu <xref:System.AppDomain.CreateDomain%2A> metody. <xref:System.AppDomain>wystąpienia są używane do ładowania i uruchamiania zestawów (<xref:System.Reflection.Assembly>). Gdy element <xref:System.AppDomain> nie jest już używany, można go zwolnić.  
  
 <xref:System.AppDomain> Klasa implementuje zestaw zdarzeń, które umożliwiają aplikacjom reagowanie w przypadku załadowania zestawu, gdy domena aplikacji zostanie zwolniona lub gdy zostanie zgłoszony nieobsługiwany wyjątek.  
  
 Aby uzyskać więcej informacji o korzystaniu z domen aplikacji, zobacz [domeny aplikacji](~/docs/framework/app-domains/application-domains.md).  
  
 Ta klasa implementuje <xref:System.MarshalByRefObject>interfejsy, <xref:System._AppDomain>i. <xref:System.Security.IEvidenceFactory>  
  
 Nigdy nie należy tworzyć otoki zdalnej dla <xref:System.AppDomain> obiektu. Dzięki temu można opublikować zdalne odwołanie do tego, <xref:System.AppDomain>wykorzystując metody, takie jak <xref:System.AppDomain.CreateInstance%2A> dostęp zdalny i skutecznie niszczyją zabezpieczenia dostępu kodu dla tego <xref:System.AppDomain>programu. Złośliwi klienci łączący się z <xref:System.AppDomain> zdalnie mogą uzyskać dostęp do dowolnego zasobu <xref:System.AppDomain> , do którego sam ma dostęp. Nie należy tworzyć otok zdalnych dla dowolnego typu, który rozszerza <xref:System.MarshalByRefObject> i implementujący metody, które mogą być używane przez złośliwych klientów do pomijania systemu zabezpieczeń.  
  
> [!CAUTION]
>  Wartość <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> domyślna właściwości to `false`. To ustawienie jest niebezpieczne dla usług. Aby zapobiec pobieraniu częściowo zaufanego kodu przez usługi, należy ustawić `true`tę właściwość na.  
  
   
  
## Examples  
 Ten przykład pokazuje, jak utworzyć nowy <xref:System.AppDomain>, utworzyć wystąpienie typu w nowej <xref:System.AppDomain>i komunikować się z obiektem tego typu. Ponadto w tym przykładzie pokazano, jak zwolnić <xref:System.AppDomain> obiekt, który ma zostać wyrzucony.  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">Instrukcje: Konfigurowanie domeny aplikacji</related>
    <related type="Article" href="https://msdn.microsoft.com/library/ba1fa43e-49f5-47d9-bd7f-3024af16f4ba">Instrukcje: Tworzenie domeny aplikacji</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1432aa2d-bd83-4346-bf3b-a1b7920e2aa9">Instrukcje: Ładowanie zestawów do domeny aplikacji</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f356116d-e415-4f7c-a332-6e6a60227192">Instrukcje: Zwolnienie domeny aplikacji</related>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kontekst aktywacji dla bieżącej domeny aplikacji.</summary>
        <value>Obiekt reprezentujący kontekst aktywacji dla bieżącej domeny aplikacji lub <see langword="null" /> Jeśli domena nie ma kontekstu aktywacji.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa katalogu, który ma zostać dołączony do ścieżki prywatnej.</param>
        <summary>Dołącza określoną nazwę katalogu do listy ścieżek prywatnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie tej właściwości nie jest zalecane, ponieważ może zmienić ścieżkę Bing dla zestawów po ich załadowaniu. Zamiast tego użyj właściwości. <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>  
  
 Ścieżka prywatna lub względna ścieżka wyszukiwania jest ścieżką względną do katalogu podstawowego, w którym sondy programu rozpoznawania zestawu dla prywatnych zestawów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tożsamość aplikacji w domenie aplikacji.</summary>
        <value>Obiekt, który identyfikuje aplikację w domenie aplikacji.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje opisujące uprawnienia przyznane aplikacji oraz określa, czy aplikacja ma poziom zaufania, który umożliwia jego uruchomienie.</summary>
        <value>Obiekt, który hermetyzuje informacje o uprawnieniach i zaufaniu aplikacji w domenie aplikacji.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa wyświetlana zestawu, w postaci dostarczonej przez <see cref="P:System.Reflection.Assembly.FullName" /> właściwość.</param>
        <summary>Zwraca nazwę wyświetlaną zestawu po zastosowaniu zasad.</summary>
        <returns>Ciąg zawierający nazwę wyświetlaną zestawu po zastosowaniu zasad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ApplyPolicy%2A> Metoda przyjmuje nazwę wyświetlaną zestawu i zwraca nazwę wyświetlaną po wprowadzeniu zasad. Jest to przydatne, jeśli zachodzi potrzeba załadowania zestawu przy użyciu zasad, ponieważ kontekst tylko odbicia nie stosuje zasad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po załadowaniu zestawu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AssemblyLoadEventHandler> Delegat dla tego zdarzenia wskazuje, jaki zestaw został załadowany.  
  
 Aby zarejestrować procedurę obsługi zdarzeń dla tego zdarzenia, musisz mieć wymagane uprawnienia lub <xref:System.Security.SecurityException> zgłaszać.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.AppDomain.AssemblyLoad> zdarzenie.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy rozpoznanie zestawu zakończy się niepowodzeniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest odpowiedzialny <xref:System.ResolveEventHandler> za to zdarzenie, aby zwrócić zestaw, który jest określony <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> przez właściwość, lub zwrócić wartość null, jeśli zestaw nie został rozpoznany. Zestaw musi być załadowany do kontekstu wykonywania; Jeśli zostanie załadowany do kontekstu tylko odbicia, obciążenie, które spowodowało wystąpienie tego zdarzenia, nie powiedzie się.  
  
 Aby uzyskać wskazówki dotyczące korzystania z tego zdarzenia, zobacz [rozpoznawanie obciążeń zestawu](~/docs/framework/app-domains/resolve-assembly-loads.md).  
  
 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]Począwszy od<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> , właściwość zwraca zestaw, który zażądał obciążenia zestawu, którego nie można rozpoznać. Na przykład moduł ładujący może nie być w stanie załadować zależności zestawu żądającego, ponieważ nie znajduje się on w ścieżce do sondowania. Wiedząc, że tożsamość zestawu żądającego może być przydatna do lokalizowania zależności lub do identyfikowania poprawnej wersji, jeśli dostępna jest więcej niż jedna wersja zależności. Aby uzyskać więcej informacji, zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]Począwszy od<xref:System.ResolveEventHandler> , zdarzenie jest zgłaszane dla wszystkich zestawów, w tym zestawów zasobów. We wcześniejszych wersjach zdarzenie nie zostało zgłoszone dla zestawów zasobów. Jeśli system operacyjny jest zlokalizowany, program obsługi może być wywoływany wiele razy: raz dla każdej kultury w łańcuchu powrotu.  
  
 Dla tego zdarzenia <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> Właściwość zwraca nazwę zestawu przed zastosowaniem zasad.  
  
> [!IMPORTANT]
>  Jeśli dla tego zdarzenia zarejestrowano więcej niż jeden program obsługi zdarzeń, programy obsługi zdarzeń są wywoływane w kolejności, aż program obsługi zdarzeń zwróci wartość, `null`która nie jest. Kolejne programy obsługi zdarzeń są ignorowane.
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.AppDomain.AssemblyResolve> zdarzenie.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
        <related type="Article" href="https://msdn.microsoft.com/library/5099e549-f4fd-49fb-a290-549edd456c6a">Rozwiązywanie załadowań zestawów</related>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera katalog podstawowy używany przez program rozpoznawania zestawu do sondowania dla zestawów.</summary>
        <value>Katalog podstawowy używany przez program rozpoznawania zestawu do sondowania zestawów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość odpowiada <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> właściwości. Można go również pobrać przy użyciu <xref:System.AppDomain.GetData%2A> metody z ciągiem "appbase".  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nową domenę aplikacji, określając katalog podstawowy, który ma być używany podczas wyszukiwania zestawów do załadowania do domeny. W przykładzie zostanie użyta <xref:System.AppDomain.BaseDirectory%2A> właściwość w celu uzyskania ścieżki katalogu podstawowego do wyświetlania w konsoli programu.  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji w samej ścieżce, w tym, jeśli ścieżka ma postać "File://" lub \\\UNC\dir lub "c:\\". Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje ścieżkę określającą lokalizację prywatnych zestawów do pustego ciągu ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ścieżka prywatna jest ścieżką względną do katalogu podstawowego, który przeszukuje środowisko uruchomieniowe języka wspólnego w celu lokalizowania prywatnych zestawów.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.AppDomain.ClearPrivatePath%2A> metody do usuwania wszystkich wpisów z listy ścieżek prywatnych do przeszukiwania po załadowaniu zestawów.  
  
 Ta metoda jest obecnie przestarzała i nie należy jej używać w nowych wdrożeniach.  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje listę katalogów zawierających skopiowane zestawy w tle do pustego ciągu ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ścieżka kopii w tle to lista katalogów, w których są przechowywane skopiowane zestawy w tle.  
  
 Aby uzyskać więcej informacji, <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> Zobacz i [zestawy kopiowania w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="F:System.String.Empty" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie określonego typu COM.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku zawierającego zestaw, który definiuje żądany typ.</param>
        <param name="typeName">Nazwa żądanego typu.</param>
        <summary>Tworzy nowe wystąpienie określonego typu COM. Parametry określają nazwę pliku, który zawiera zestaw zawierający typ i nazwę typu.</summary>
        <returns>Obiekt, który jest otoką dla nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody do zdalnego tworzenia obiektów bez konieczności lokalnego ładowania typu.  
  
 Aby można było uzyskać dostęp do rzeczywistego obiektu, zwracana wartość musi być odopakowana.  
  
 Atrybut o wartości musi być stosowany jawnie lub domyślnie do typu com dla tej metody, <xref:System.TypeLoadException> aby można było utworzyć wystąpienie tego typu; w przeciwnym razie jest zgłaszany. `true` <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>  
  
   
  
## Examples  
 Poniższy przykład demonstruje  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Nie można załadować typu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono publicznego konstruktora bez parametrów.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MemberAccessException"><paramref name="typeName" />jest klasą abstrakcyjną.  
  
—lub— 
Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyName" />jest pustym ciągiem ("").</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">Obiekt COM, do którego odwołuje się to <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku zawierającego zestaw, który definiuje żądany typ.</param>
        <param name="typeName">Nazwa żądanego typu.</param>
        <param name="hashValue">Reprezentuje wartość obliczanego kodu skrótu.</param>
        <param name="hashAlgorithm">Reprezentuje algorytm wyznaczania wartości skrótu używany przez manifest zestawu.</param>
        <summary>Tworzy nowe wystąpienie określonego typu COM. Parametry określają nazwę pliku, który zawiera zestaw zawierający typ i nazwę typu.</summary>
        <returns>Obiekt, który jest otoką dla nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody do zdalnego tworzenia obiektów bez konieczności lokalnego ładowania typu.  
  
 Aby można było uzyskać dostęp do rzeczywistego obiektu, zwracana wartość musi być odopakowana.  
  
 Atrybut o wartości musi być stosowany jawnie lub domyślnie do typu com dla tej metody, <xref:System.TypeLoadException> aby można było utworzyć wystąpienie tego typu; w przeciwnym razie jest zgłaszany. `true` <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Nie można załadować typu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono publicznego konstruktora bez parametrów.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.MemberAccessException"><paramref name="typeName" />jest klasą abstrakcyjną.  
  
—lub— 
Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" />jest ciągiem pustym ("").</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">Obiekt COM, do którego odwołuje się to <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzenie nowej domeny aplikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny.</param>
        <summary>Tworzy nową domenę aplikacji o określonej nazwie.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `friendlyName` Parametr jest przeznaczony do identyfikowania domeny w sposób zrozumiały dla ludzi. Ten ciąg powinien być odpowiedni do wyświetlania w interfejsie użytkownika.  
  
 To Przeciążenie metody używa <xref:System.AppDomainSetup> informacji z domyślnej domeny aplikacji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć domenę przy użyciu jednego z <xref:System.AppDomain.CreateDomain%2A> przeciążeń.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metoda nie jest obsługiwana w programie .NET Core.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> , aby użyć dowodu bieżącej domeny aplikacji.</param>
        <summary>Tworzy nową domenę aplikacji o podanej nazwie przy użyciu dostarczonych dowodów.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie metody używa <xref:System.AppDomainSetup> informacji z domyślnej domeny aplikacji.  
  
 Jeśli `securityInfo` nie zostanie podany, zostaną użyte dowody z bieżącej domeny aplikacji.  
  
> [!IMPORTANT]
>  Nie należy używać tego przeciążenia metody do tworzenia domen aplikacji w trybie piaskownicy. Począwszy od `securityInfo` , dostarczony dowód nie ma już wpływu na zestaw uprawnień domeny aplikacji. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] Użyj przeciążenia <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> metody do tworzenia domen aplikacji w trybie piaskownicy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć domenę przy użyciu jednego z <xref:System.AppDomain.CreateDomain%2A> przeciążeń.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="info" Type="System.AppDomainSetup" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> , aby użyć dowodu bieżącej domeny aplikacji.</param>
        <param name="info">Obiekt, który zawiera informacje o inicjalizacji domeny aplikacji.</param>
        <summary>Tworzy nową domenę aplikacji przy użyciu określonej nazwy, dowodów i informacji o konfiguracji domeny aplikacji.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `info` nie jest podany, Przeciążenie metody <xref:System.AppDomainSetup> używa informacji z domyślnej domeny aplikacji.  
  
 Jeśli `securityInfo` nie zostanie podany, zostaną użyte dowody z bieżącej domeny aplikacji.  
  
> [!IMPORTANT]
>  Nie należy używać tego przeciążenia metody do tworzenia domen aplikacji w trybie piaskownicy. Począwszy od `securityInfo` , dostarczony dowód nie ma już wpływu na zestaw uprawnień domeny aplikacji. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] Użyj przeciążenia <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> metody do tworzenia domen aplikacji w trybie piaskownicy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć domenę przy użyciu jednego z <xref:System.AppDomain.CreateDomain%2A> przeciążeń.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="info" Type="System.AppDomainSetup" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz Opis <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> , aby użyć dowodu bieżącej domeny aplikacji.</param>
        <param name="info">Obiekt, który zawiera informacje o inicjalizacji domeny aplikacji.</param>
        <param name="grantSet">Domyślny zestaw uprawnień przyznany wszystkim zestawom załadowanym do domeny nowej aplikacji, które nie mają określonych dotacji.</param>
        <param name="fullTrustAssemblies">Tablica silnych nazw reprezentujących zestawy, które mają być uznawane za w pełni zaufane w nowej domenie aplikacji.</param>
        <summary>Tworzy nową domenę aplikacji przy użyciu określonej nazwy, dowodów, informacji o konfiguracji domeny aplikacji, domyślnego zestawu uprawnień i tablicy w pełni zaufanych zestawów.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy ustawić <xref:System.AppDomainSetup.ApplicationBase%2A> Właściwość <xref:System.AppDomainSetup> obiektu, dla `info`którego podano. W przeciwnym razie jest zgłaszany wyjątek.  
  
 Jeśli `securityInfo` nie zostanie podany, zostaną użyte dowody z bieżącej domeny aplikacji.  
  
 Informacje podane dla `grantSet` i `fullTrustAssemblies` są używane do tworzenia obiektudlanowejdomenyaplikacji.<xref:System.Security.Policy.ApplicationTrust>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Domena aplikacji to <see langword="null" />.  
  
—lub— 
Właściwość nie jest ustawiona <see cref="T:System.AppDomainSetup" /> dla obiektu dostarczonego dla <paramref name="info" />. <see cref="P:System.AppDomainSetup.ApplicationBase" /></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Tworzenia domeny aplikacji i wykonywanie na niej operacji. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appBasePath" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> , aby użyć dowodu bieżącej domeny aplikacji.</param>
        <param name="appBasePath">Katalog podstawowy używany przez program rozpoznawania zestawu do sondowania zestawów. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Ścieżka względna do katalogu podstawowego, w którym program rozpoznawania zestawu powinien sondować dla zestawów prywatnych. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">Jeśli <see langword="true" />kopia w tle zestawu jest załadowana do tej domeny aplikacji.</param>
        <summary>Tworzy nową domenę aplikacji o podaną nazwę, używając dowodów, ścieżki bazowej aplikacji, ścieżki wyszukiwania względnego i parametru, który określa, czy kopia w tle zestawu ma zostać załadowana do domeny aplikacji.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `securityInfo` nie zostanie podany, zostaną użyte dowody z bieżącej domeny aplikacji.  
  
 Aby uzyskać więcej informacji na temat kopiowania w <xref:System.AppDomain.ShadowCopyFiles%2A> tle, zobacz i [zestawy kopiowania w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Nie należy używać tego przeciążenia metody do tworzenia domen aplikacji w trybie piaskownicy. Począwszy od `securityInfo` , dostarczony dowód nie ma już wpływu na zestaw uprawnień domeny aplikacji. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] Użyj przeciążenia <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> metody do tworzenia domen aplikacji w trybie piaskownicy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć domenę przy użyciu jednego z <xref:System.AppDomain.CreateDomain%2A> przeciążeń.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appBasePath" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="adInitArgs" Type="System.String[]" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> , aby użyć dowodu bieżącej domeny aplikacji.</param>
        <param name="appBasePath">Katalog podstawowy używany przez program rozpoznawania zestawu do sondowania zestawów. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Ścieżka względna do katalogu podstawowego, w którym program rozpoznawania zestawu powinien sondować dla zestawów prywatnych. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles"><see langword="true" />Aby załadować kopię w tle zestawu do domeny aplikacji.</param>
        <param name="adInit">Delegat reprezentujący metodę wywołania zwrotnego do wywołania po zainicjowaniu nowego <see cref="T:System.AppDomain" /> obiektu. <see cref="T:System.AppDomainInitializer" /></param>
        <param name="adInitArgs">Tablica argumentów ciągu do przesłania do wywołania zwrotnego reprezentowanego przez <paramref name="adInit" />, po zainicjowaniu nowego <see cref="T:System.AppDomain" /> obiektu.</param>
        <summary>Tworzy nową domenę aplikacji o podaną nazwę, używając dowodów, ścieżki bazowej aplikacji, ścieżki wyszukiwania względnego i parametru, który określa, czy kopia w tle zestawu ma zostać załadowana do domeny aplikacji. Określa metodę wywołania zwrotnego, która jest wywoływana, gdy domena aplikacji zostanie zainicjowana, i tablicę argumentów ciągu do przekazania metody wywołania zwrotnego.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda reprezentowana przez `adInit` jest wykonywana w kontekście nowo utworzonej domeny aplikacji.  
  
 Jeśli `securityInfo` nie zostanie podany, zostaną użyte dowody z bieżącej domeny aplikacji.  
  
 Aby uzyskać więcej informacji na temat kopiowania w <xref:System.AppDomain.ShadowCopyFiles%2A> tle, zobacz i [zestawy kopiowania w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Nie należy używać tego przeciążenia metody do tworzenia domen aplikacji w trybie piaskownicy. Począwszy od `securityInfo` , dostarczony dowód nie ma już wpływu na zestaw uprawnień domeny aplikacji. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] Użyj przeciążenia <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> metody do tworzenia domen aplikacji w trybie piaskownicy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowane w określonym zestawie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym zestawie.</summary>
        <returns>Obiekt, który jest otoką dla nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje konstruktora bez parametrów dla `typeName`.  
  
 Zobacz <xref:System.Reflection.AssemblyName> , aby uzyskać `assemblyName`format.  
  
 Próba wywołania <xref:System.AppDomain.CreateInstance%2A> w docelowej domenie aplikacji, która nie jest bieżącą domeną aplikacji, spowoduje pomyślne załadowanie zestawu w domenie aplikacji docelowej. Ponieważ nie <xref:System.Reflection.Assembly> <xref:System.MarshalByRefObject>jest, gdy ta <xref:System.Reflection.Assembly> Metoda próbuje zwrócić pakiet dla załadowanego zestawu do domeny bieżącej aplikacji, środowisko uruchomieniowe języka wspólnego podejmie próbę załadowania zestawu do domeny bieżącej aplikacji i Ładowanie może zakończyć się niepowodzeniem. Jeśli ustawienia ścieżek obu domen aplikacji są różne, zestaw ładowany do bieżącej domeny aplikacji może się różnić od zestawu, który został załadowany po raz pierwszy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyName" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym zestawie. Parametr określa tablicę atrybutów aktywacji.</summary>
        <returns>Obiekt, który jest otoką dla nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje konstruktora bez parametrów dla `typeName`.  
  
 Zobacz <xref:System.Reflection.AssemblyName> , aby uzyskać `assemblyName`format.  
  
 Próba wywołania <xref:System.AppDomain.CreateInstance%2A> w docelowej domenie aplikacji, która nie jest bieżącą domeną aplikacji, spowoduje pomyślne załadowanie zestawu w domenie aplikacji docelowej. Ponieważ nie <xref:System.Reflection.Assembly> <xref:System.MarshalByRefObject>jest, gdy ta <xref:System.Reflection.Assembly> Metoda próbuje zwrócić pakiet dla załadowanego zestawu do domeny bieżącej aplikacji, środowisko uruchomieniowe języka wspólnego podejmie próbę załadowania zestawu do domeny bieżącej aplikacji i Ładowanie może zakończyć się niepowodzeniem. Jeśli ustawienia ścieżek obu domen aplikacji są różne, zestaw ładowany do bieżącej domeny aplikacji może się różnić od zestawu, który został załadowany po raz pierwszy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyName" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie, przekształcenie typów argumentów, wywoływanie elementów członkowskich oraz pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przy użyciu odbicia. Jeśli <paramref name="binder" /> ma wartość null, używany jest domyślny spinacz.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli preferowany <paramref name="args" /> Konstruktor bez parametrów musi być pustą tablicą lub wartością null.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="typeName" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym zestawie. Parametry określają spinacz, flagi powiązań, argumenty konstruktora, informacje specyficzne dla kultury używane do interpretowania argumentów i opcjonalne atrybuty aktywacji.</summary>
        <returns>Obiekt, który jest otoką dla nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Reflection.AssemblyName> , aby uzyskać `assemblyName`format.  
  
 Próba wywołania <xref:System.AppDomain.CreateInstance%2A> w docelowej domenie aplikacji, która nie jest bieżącą domeną aplikacji, spowoduje pomyślne załadowanie zestawu w domenie aplikacji docelowej. Ponieważ nie <xref:System.Reflection.Assembly> <xref:System.MarshalByRefObject>jest, gdy ta <xref:System.Reflection.Assembly> Metoda próbuje zwrócić pakiet dla załadowanego zestawu do domeny bieżącej aplikacji, środowisko uruchomieniowe języka wspólnego podejmie próbę załadowania zestawu do domeny bieżącej aplikacji i Ładowanie może zakończyć się niepowodzeniem. Jeśli ustawienia ścieżek obu domen aplikacji są różne, zestaw ładowany do bieżącej domeny aplikacji może się różnić od zestawu, który został załadowany po raz pierwszy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyName" />Program został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie, przekształcenie typów argumentów, wywoływanie elementów członkowskich oraz pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przy użyciu odbicia. Jeśli <paramref name="binder" /> ma wartość null, używany jest domyślny spinacz.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli preferowany <paramref name="args" /> Konstruktor bez parametrów musi być pustą tablicą lub wartością null.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="typeName" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do autoryzacji tworzenia <paramref name="typeName" />.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym zestawie. Parametry określają spinacz, flagi powiązania, argumenty konstruktora, informacje specyficzne dla kultury służące do interpretowania argumentów, atrybutów aktywacji i autoryzacji w celu utworzenia typu.</summary>
        <returns>Obiekt, który jest otoką dla nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Reflection.AssemblyName> , aby uzyskać `assemblyName`format.  
  
 Próba wywołania <xref:System.AppDomain.CreateInstance%2A> w docelowej domenie aplikacji, która nie jest bieżącą domeną aplikacji, spowoduje pomyślne załadowanie zestawu w domenie aplikacji docelowej. Ponieważ nie <xref:System.Reflection.Assembly> <xref:System.MarshalByRefObject>jest, gdy ta <xref:System.Reflection.Assembly> Metoda próbuje zwrócić pakiet dla załadowanego zestawu do domeny bieżącej aplikacji, środowisko uruchomieniowe języka wspólnego podejmie próbę załadowania zestawu do domeny bieżącej aplikacji i Ładowanie może zakończyć się niepowodzeniem. Jeśli ustawienia ścieżek obu domen aplikacji są różne, zestaw ładowany do bieżącej domeny aplikacji może się różnić od zestawu, który został załadowany po raz pierwszy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyName" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.  
  
—lub— 
 <paramref name="securityAttributes" />nie <see langword="null" />jest. Gdy zasady starszych wersji urzędów certyfikacji nie <paramref name="securityAttributes" /> są włączone, powinny być<see langword="null." /></exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie określonego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <summary>Tworzy nowe wystąpienie określonego typu. Parametry określają zestaw, w którym jest zdefiniowany typ, i nazwę typu.</summary>
        <returns>Wystąpienie obiektu określonego przez <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która <xref:System.AppDomain.CreateInstance%2A> łączy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>i. Ta metoda wywołuje konstruktora bez parametrów dla `typeName`.  
  
 Zobacz <xref:System.Reflection.AssemblyName> , aby uzyskać `assemblyName`format. Zapoznaj się z `typeName` właściwościąformatu.<xref:System.Type.FullName%2A?displayProperty=nameWithType>  
  
> [!NOTE]
>  Jeśli utworzysz `M` wczesne wywołanie metody obiektu typu `T1` , który został zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i ta metoda sprawia, że wczesne wywołanie metody obiektu typu `T2` w zestawie `C` innym niż bieżący zestaw lub zestaw zawierający `T1`, zestaw `C` jest ładowany do domeny bieżącej aplikacji. To ładowanie występuje nawet wtedy, gdy wczesne wywołanie `T1.M()` zostało wykonane w treści a <xref:System.Reflection.Emit.DynamicMethod>lub w innym dynamicznie generowanym kodzie. Jeśli bieżąca domena jest domeną domyślną, zestawu `C` nie można zwolnić do momentu zakończenia procesu. Jeśli bieżąca domena później podejmie próbę załadowania `C`zestawu, obciążenie może się nie powieść.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje najprostszy sposób wykonywania kodu w innej domenie aplikacji. W przykładzie zdefiniowano klasę o `Worker` nazwie, która <xref:System.MarshalByRefObject>dziedziczy z. `Worker` Klasa definiuje metodę, która wyświetla nazwę domeny aplikacji, w której jest wykonywane. Przykład tworzy wystąpienia `Worker` w domyślnej domenie aplikacji i w nowej domenie aplikacji.  
  
> [!NOTE]
>  Zestaw, który zawiera `Worker` musi być załadowany do obu domen aplikacji, ale może ładować inne zestawy, które istnieją tylko w nowej domenie aplikacji.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyName" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">możliwość odczytywania pliku zawierającego manifest zestawu lub tworzenia typu z modułu innego niż plik manifestu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu. Parametry określają zestaw, w którym jest zdefiniowany typ, nazwę typu i tablicę atrybutów aktywacji.</summary>
        <returns>Wystąpienie obiektu określonego przez <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która <xref:System.AppDomain.CreateInstance%2A> łączy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>i. Ta metoda wywołuje konstruktora bez parametrów dla `typeName`.  
  
 Zobacz <xref:System.Reflection.AssemblyName> , aby uzyskać `assemblyName`format. Zapoznaj się z `typeName` właściwościąformatu.<xref:System.Type.FullName%2A?displayProperty=nameWithType>  
  
> [!NOTE]
>  Jeśli utworzysz `M` wczesne wywołanie metody obiektu typu `T1` , który został zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i ta metoda sprawia, że wczesne wywołanie metody obiektu typu `T2` w zestawie `C` innym niż bieżący zestaw lub zestaw zawierający `T1`, zestaw `C` jest ładowany do domeny bieżącej aplikacji. To ładowanie występuje nawet wtedy, gdy wczesne wywołanie `T1.M()` zostało wykonane w treści a <xref:System.Reflection.Emit.DynamicMethod>lub w innym dynamicznie generowanym kodzie. Jeśli bieżąca domena jest domeną domyślną, zestawu `C` nie można zwolnić do momentu zakończenia procesu. Jeśli bieżąca domena później podejmie próbę załadowania `C`zestawu, obciążenie może się nie powieść.  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyName" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie, przekształcenie typów argumentów, wywoływanie elementów członkowskich oraz pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przy użyciu odbicia. Jeśli <paramref name="binder" /> ma wartość null, używany jest domyślny spinacz.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli preferowany <paramref name="args" /> Konstruktor bez parametrów musi być pustą tablicą lub wartością null.</param>
        <param name="culture">Obiekt specyficzny dla kultury używany do zarządzania przymusem typów. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see langword="CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt. Określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowane w określonym zestawie, określając, czy przypadek nazwy typu jest ignorowany; atrybuty powiązania i spinacz, które są używane do wybierania typu, który ma zostać utworzony; argumenty konstruktora; Kultura; i atrybuty aktywacji.</summary>
        <returns>Wystąpienie obiektu określonego przez <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która <xref:System.AppDomain.CreateInstance%2A> łączy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>i.  
  
 Zobacz <xref:System.Reflection.AssemblyName> , aby uzyskać `assemblyName`format. Zapoznaj się z `typeName` właściwościąformatu.<xref:System.Type.FullName%2A?displayProperty=nameWithType>  
  
> [!NOTE]
>  Jeśli utworzysz `M` wczesne wywołanie metody obiektu typu `T1` , który został zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i ta metoda sprawia, że wczesne wywołanie metody obiektu typu `T2` w zestawie `C` innym niż bieżący zestaw lub zestaw zawierający `T1`, zestaw `C` jest ładowany do domeny bieżącej aplikacji. To ładowanie występuje nawet wtedy, gdy wczesne wywołanie `T1.M()` zostało wykonane w treści a <xref:System.Reflection.Emit.DynamicMethod>lub w innym dynamicznie generowanym kodzie. Jeśli bieżąca domena jest domeną domyślną, zestawu `C` nie można zwolnić do momentu zakończenia procesu. Jeśli bieżąca domena później podejmie próbę załadowania `C`zestawu, obciążenie może się nie powieść.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie `ignoreCase` parametru.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyName" />Program został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie, przekształcenie typów argumentów, wywoływanie elementów członkowskich oraz pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przy użyciu odbicia. Jeśli <paramref name="binder" /> ma wartość null, używany jest domyślny spinacz.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli preferowany <paramref name="args" /> Konstruktor bez parametrów musi być pustą tablicą lub wartością null.</param>
        <param name="culture">Obiekt specyficzny dla kultury używany do zarządzania przymusem typów. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see langword="CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do autoryzacji tworzenia <paramref name="typeName" />.</param>
        <summary>Tworzy nowe wystąpienie określonego typu. Parametry określają nazwę typu oraz sposób ich znajdowania i tworzenia.</summary>
        <returns>Wystąpienie obiektu określonego przez <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która <xref:System.AppDomain.CreateInstance%2A> łączy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>i.  
  
 Zobacz <xref:System.Reflection.AssemblyName> , aby uzyskać `assemblyName`format. Zapoznaj się z `typeName` właściwościąformatu.<xref:System.Type.FullName%2A?displayProperty=nameWithType>  
  
> [!NOTE]
>  Jeśli utworzysz `M` wczesne wywołanie metody obiektu typu `T1` , który został zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i ta metoda sprawia, że wczesne wywołanie metody obiektu typu `T2` w zestawie `C` innym niż bieżący zestaw lub zestaw zawierający `T1`, zestaw `C` jest ładowany do domeny bieżącej aplikacji. To ładowanie występuje nawet wtedy, gdy wczesne wywołanie `T1.M()` zostało wykonane w treści a <xref:System.Reflection.Emit.DynamicMethod>lub w innym dynamicznie generowanym kodzie. Jeśli bieżąca domena jest domeną domyślną, zestawu `C` nie można zwolnić do momentu zakończenia procesu. Jeśli bieżąca domena później podejmie próbę załadowania `C`zestawu, obciążenie może się nie powieść.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie `ignoreCase` parametru.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyName" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie danego typu zdefiniowane w określonym pliku zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa (łącznie ze ścieżką) pliku zawierającego zestaw, który definiuje żądany typ. Zestaw jest ładowany przy użyciu <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> metody.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Obiekt, który jest otoką dla nowego wystąpienia lub <see langword="null" /> <paramref name="typeName" /> nie można go znaleźć. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływany jest Konstruktor bez `typeName` parametrów dla elementu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metodę.  
  
 <xref:System.AppDomain.CreateInstanceFrom%2A> Gdy metoda jest używana do tworzenia wystąpienia w domenie aplikacji docelowej, z wyjątkiem domeny aplikacji, z której wykonano wywołanie, zestaw jest ładowany w domenie aplikacji docelowej. Jeśli jednak wystąpienie nie zostanie rozwinięte w domenie aplikacji wywołującej, użycie nierozwiniętych instancji w określony sposób może spowodować załadowanie zestawu do domeny aplikacji wywołującej. Na przykład po rozwinięciu danego wystąpienia można zażądać informacji o typie, aby wywołać jego metody z późnym wiązaniem. Podczas ładowania zestawu do domeny aplikacji wywołującej mogą wystąpić wyjątki.  
  
-   Jeśli inna wersja tego samego zestawu została wcześniej załadowana do domeny aplikacji wywołującej lub ścieżka ładowania domeny aplikacji wywołującej różni się od domeny aplikacji docelowej, mogą wystąpić wyjątki takie jak <xref:System.MissingMethodException> .  
  
-   Jeśli domena aplikacji wywołującej wywołuje wczesne powiązania z typem wystąpienia, może być <xref:System.InvalidCastException> zgłaszane, gdy podejmowana jest próba rzutowania wystąpienia.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> jak używać przeciążenia metody w celu utworzenia wystąpienia obiektu w domenie aplikacji docelowej i wywołania jego metod.  
  
 W przykładzie zdefiniowano `MarshalableExample` klasę, która może być organizowana między granicami domeny aplikacji. Przykład tworzy ścieżkę do aktualnie wykonywanego zestawu, tworzy domenę aplikacji docelowej i używa <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> przeciążenia metody do ładowania przykładowego zestawu do domeny aplikacji docelowej i tworzenia `MarshalableExample`wystąpienia.  
  
> [!NOTE]
>  Ścieżka jest bezwzględna w tym przykładzie, ale ścieżka względna również będzie działała <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> , ponieważ metoda jest używana do ładowania zestawu.  
  
 Po rozpakowaniu uchwytu obiektu przykład ilustruje trzy sposoby używania obiektu w domenie aplikacji docelowej:  
  
-   Wywoływanie metody z późnym wiązaniem przy użyciu odbicia. Wymaga to informacji o typie, co powoduje, że zestaw jest ładowany do domeny aplikacji obiektu wywołującego. (W tym przykładzie jest już załadowany).  
  
-   Rzutowanie obiektu do interfejsu znanego zarówno obiektowi wywołującemu, jak i elementowi wywoływanemu. Jeśli interfejs jest zdefiniowany w zestawie wywołującym lub w trzecim zestawie, do którego odwołuje się zarówno obiekt wywołujący, jak i wywoływany, wywoływany zestaw nie jest ładowany do domeny aplikacji obiektu wywołującego.  
  
-   Używanie obiektu bezpośrednio, gdy jego typ jest znany obiektowi wywołującemu. Zestaw musi być załadowany do domeny aplikacji obiektu wywołującego.  
  
 Innym sposobem na uniknięcie ładowania wywołanego zestawu do domeny aplikacji wywołującego jest odmowa od <xref:System.MarshalByRefObject> klasy i zdefiniowanie metody, która może być uruchamiana w domenie aplikacji docelowej. Ta metoda może użyć odbicia do sprawdzenia zestawu docelowego, ponieważ zestaw docelowy jest już załadowany do domeny aplikacji docelowej. Zobacz przykład dla <xref:System.AppDomain.DynamicDirectory%2A> właściwości.  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" />nie została znaleziona <paramref name="assemblyFile" />w.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono konstruktora publicznego bez parametrów.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyFile" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa (łącznie ze ścieżką) pliku zawierającego zestaw, który definiuje żądany typ. Zestaw jest ładowany przy użyciu <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> metody.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Obiekt, który jest otoką dla nowego wystąpienia lub <see langword="null" /> <paramref name="typeName" /> nie można go znaleźć. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływany jest Konstruktor bez `typeName` parametrów dla elementu.  
  
 Aby uzyskać więcej informacji na temat tej metody, <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Zobacz metodę.  
  
 <xref:System.AppDomain.CreateInstanceFrom%2A> Gdy metoda jest używana do tworzenia wystąpienia w domenie aplikacji docelowej, z wyjątkiem domeny aplikacji, z której wykonano wywołanie, zestaw jest ładowany w domenie aplikacji docelowej. Jeśli jednak wystąpienie nie zostanie rozwinięte w domenie aplikacji wywołującej, użycie nierozwiniętych instancji w określony sposób może spowodować załadowanie zestawu do domeny aplikacji wywołującej. Na przykład po rozwinięciu danego wystąpienia można zażądać informacji o typie, aby wywołać jego metody z późnym wiązaniem. Podczas ładowania zestawu do domeny aplikacji wywołującej mogą wystąpić wyjątki.  
  
-   Jeśli inna wersja tego samego zestawu została wcześniej załadowana do domeny aplikacji wywołującej lub ścieżka ładowania domeny aplikacji wywołującej różni się od domeny aplikacji docelowej, mogą wystąpić wyjątki takie jak <xref:System.MissingMethodException> .  
  
-   Jeśli domena aplikacji wywołującej wywołuje wczesne powiązania z typem wystąpienia, może być <xref:System.InvalidCastException> zgłaszane, gdy podejmowana jest próba rzutowania wystąpienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" />nie została znaleziona <paramref name="assemblyFile" />w.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyFile" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa (łącznie ze ścieżką) pliku zawierającego zestaw, który definiuje żądany typ. Zestaw jest ładowany przy użyciu <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> metody.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie, przekształcenie typów argumentów, wywoływanie elementów członkowskich oraz pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów poprzez odbicie. Jeśli <paramref name="binder" /> ma wartość null, używany jest domyślny spinacz.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli preferowany <paramref name="args" /> Konstruktor bez parametrów musi być pustą tablicą lub wartością null.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="typeName" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Obiekt, który jest otoką dla nowego wystąpienia lub <see langword="null" /> <paramref name="typeName" /> nie można go znaleźć. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metodę.  
  
 <xref:System.AppDomain.CreateInstanceFrom%2A> Gdy metoda jest używana do tworzenia wystąpienia w domenie aplikacji docelowej, z wyjątkiem domeny aplikacji, z której wykonano wywołanie, zestaw jest ładowany w domenie aplikacji docelowej. Jeśli jednak wystąpienie nie zostanie rozwinięte w domenie aplikacji wywołującej, użycie nierozwiniętych instancji w określony sposób może spowodować załadowanie zestawu do domeny aplikacji wywołującej. Na przykład po rozwinięciu danego wystąpienia można zażądać informacji o typie, aby wywołać jego metody z późnym wiązaniem. Podczas ładowania zestawu do domeny aplikacji wywołującej mogą wystąpić wyjątki.  
  
-   Jeśli inna wersja tego samego zestawu została wcześniej załadowana do domeny aplikacji wywołującej lub ścieżka ładowania domeny aplikacji wywołującej różni się od domeny aplikacji docelowej, mogą wystąpić wyjątki takie jak <xref:System.MissingMethodException> .  
  
-   Jeśli domena aplikacji wywołującej wywołuje wczesne powiązania z typem wystąpienia, może być <xref:System.InvalidCastException> zgłaszane, gdy podejmowana jest próba rzutowania wystąpienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" />nie została znaleziona <paramref name="assemblyFile" />w.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyFile" />Program został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa (łącznie ze ścieżką) pliku zawierającego zestaw, który definiuje żądany typ. Zestaw jest ładowany przy użyciu <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> metody.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie, przekształcenie typów argumentów, wywoływanie elementów członkowskich oraz pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów poprzez odbicie. Jeśli <paramref name="binder" /> ma wartość null, używany jest domyślny spinacz.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli preferowany <paramref name="args" /> Konstruktor bez parametrów musi być pustą tablicą lub wartością null.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="typeName" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do autoryzacji tworzenia <paramref name="typeName" />.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Obiekt, który jest otoką dla nowego wystąpienia lub <see langword="null" /> <paramref name="typeName" /> nie można go znaleźć. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat tej metody, <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Zobacz metodę.  
  
 <xref:System.AppDomain.CreateInstanceFrom%2A> Gdy metoda jest używana do tworzenia wystąpienia w domenie aplikacji docelowej, z wyjątkiem domeny aplikacji, z której wykonano wywołanie, zestaw jest ładowany w domenie aplikacji docelowej. Jeśli jednak wystąpienie nie zostanie rozwinięte w domenie aplikacji wywołującej, użycie nierozwiniętych instancji w określony sposób może spowodować załadowanie zestawu do domeny aplikacji wywołującej. Na przykład po rozwinięciu danego wystąpienia można zażądać informacji o typie, aby wywołać jego metody z późnym wiązaniem. Podczas ładowania zestawu do domeny aplikacji wywołującej mogą wystąpić wyjątki.  
  
-   Jeśli inna wersja tego samego zestawu została wcześniej załadowana do domeny aplikacji wywołującej lub ścieżka ładowania domeny aplikacji wywołującej różni się od domeny aplikacji docelowej, mogą wystąpić wyjątki takie jak <xref:System.MissingMethodException> .  
  
-   Jeśli domena aplikacji wywołującej wywołuje wczesne powiązania z typem wystąpienia, może być <xref:System.InvalidCastException> zgłaszane, gdy podejmowana jest próba rzutowania wystąpienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.  
  
—lub— 
 <paramref name="securityAttributes" />nie <see langword="null" />jest. Jeśli starsze zasady urzędów certyfikacji nie są <paramref name="securityAttributes" /> włączone, <see langword="null" />powinny być.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" />nie została znaleziona <paramref name="assemblyFile" />w.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyFile" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie danego typu zdefiniowane w określonym pliku zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyFile As String, typeName As String) As Object" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName);" FrameworkAlternate="netcore-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku i ścieżka zestawu definiują żądany typ.</param>
        <param name="assemblyFile">To be added.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Żądany obiekt lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która <xref:System.AppDomain.CreateInstanceFrom%2A> łączy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>i. Ta metoda wywołuje konstruktora bez parametrów dla `typeName`.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono konstruktora publicznego bez parametrów.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyName" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, object[] activationAttributes);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyFile As String, typeName As String, activationAttributes As Object()) As Object" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netcore-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku i ścieżka zestawu definiują żądany typ.</param>
        <param name="assemblyFile">To be added.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw (zobacz <see cref="P:System.Type.FullName" /> Właściwość).</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Żądany obiekt lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która <xref:System.AppDomain.CreateInstanceFrom%2A> łączy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>i. Ta metoda wywołuje konstruktora bez parametrów dla `typeName`.  
  
 Aby uzyskać więcej informacji na temat tej metody, <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Zobacz metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono konstruktora publicznego bez parametrów.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyName" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku i ścieżka zestawu definiują żądany typ.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie, przekształcenie typów argumentów, wywoływanie elementów członkowskich oraz pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów poprzez odbicie. Jeśli <paramref name="binder" /> ma wartość null, używany jest domyślny spinacz.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli preferowany <paramref name="args" /> Konstruktor bez parametrów musi być pustą tablicą lub wartością null.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="typeName" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowane w określonym pliku zestawu, określając, czy przypadek nazwy typu jest ignorowany; atrybuty powiązania i spinacz, które są używane do wybierania typu, który ma zostać utworzony; argumenty konstruktora; Kultura; i atrybuty aktywacji.</summary>
        <returns>Żądany obiekt lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która <xref:System.AppDomain.CreateInstanceFrom%2A> łączy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>i.  
  
 Aby uzyskać więcej informacji na temat tej metody, <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Zobacz metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyName" />Program został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku i ścieżka zestawu definiują żądany typ.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw, jak zwracany przez <see cref="P:System.Type.FullName" /> właściwość.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie, przekształcenie typów argumentów, wywoływanie elementów członkowskich oraz pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów poprzez odbicie. Jeśli <paramref name="binder" /> ma wartość null, używany jest domyślny spinacz.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli preferowany <paramref name="args" /> Konstruktor bez parametrów musi być pustą tablicą lub wartością null.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="typeName" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do autoryzacji tworzenia <paramref name="typeName" />.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Żądany obiekt lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która <xref:System.AppDomain.CreateInstanceFrom%2A> łączy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>i.  
  
 Aby uzyskać więcej informacji na temat tej metody, <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Zobacz metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyName" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącą domenę aplikacji dla bieżącego <see cref="T:System.Threading.Thread" />.</summary>
        <value>Bieżąca domena aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy nową domenę aplikacji. Właściwość służy do <xref:System.AppDomain> uzyskania obiektu, który reprezentuje bieżącą domenę aplikacji. <xref:System.AppDomain.CurrentDomain%2A> <xref:System.AppDomain.FriendlyName%2A> Właściwość zawiera nazwę bieżącej domeny aplikacji, która jest następnie wyświetlana w wierszu polecenia.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje dynamiczny zestaw w bieżącej domenie aplikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb dostępu do dynamicznego zestawu.</param>
        <summary>Definiuje dynamiczny zestaw z określoną nazwą i trybem dostępu.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i trybem dostępu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Przeciążenie metody.  
  
> [!NOTE]
>  Podczas opracowywania kodu, który emituje zestawy dynamiczne, zaleca się użycie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowody i uprawnienia, Dostarcz dowód, który ma mieć zestaw dynamiczny, i Dołącz do <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> `refusedPermissions`. <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Dołączenie `refusedPermissions` do parametru gwarantuje, że MSIL zostanie zweryfikowane. Ograniczenie tej metody polega na tym, że jest to <xref:System.Security.SecurityException> również przyczyną zgłoszenia, gdy jest używany z kodem, który wymaga pełnego zaufania.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę i <xref:System.AppDomain.AssemblyResolve> zdarzenie.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość ma wartość<see langword="null" />. <see langword="Name" /> <paramref name="name" />  
  
—lub— 
<see langword="Name" /> Właściwośćzaczynasięodbiałegoznakulubzawieraukośnik<paramref name="name" /> do przodu lub wstecz.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb dostępu do dynamicznego zestawu.</param>
        <param name="assemblyAttributes">Wyliczalna lista atrybutów do zastosowania do zestawu lub <see langword="null" /> Jeśli nie ma żadnych atrybutów.</param>
        <summary>Definiuje dynamiczny zestaw z określoną nazwą, trybem dostępu i atrybutami niestandardowymi.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeciążenia służy do określania atrybutów, które nie będą działać poprawnie, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład atrybuty zabezpieczeń, takie jak <xref:System.Security.SecurityTransparentAttribute> i <xref:System.Security.SecurityCriticalAttribute> nie działają poprawnie, jeśli są dodawane po utworzeniu zestawu dynamicznego.  
  
 Ta metoda powinna być używana tylko do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji na temat tego ograniczenia, <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Zobacz Przeciążenie metody.  
  
 To Przeciążenie metody zostało wprowadzone w [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Security.SecurityTransparentAttribute>jak utworzyć zestaw dynamiczny, który ma. Atrybut musi być określony jako element tablicy <xref:System.Reflection.Emit.CustomAttributeBuilder> obiektów.  
  
 Pierwszym krokiem tworzenia programu <xref:System.Reflection.Emit.CustomAttributeBuilder> jest uzyskanie konstruktora dla atrybutu. Konstruktor nie ma parametrów, dlatego <xref:System.Type.GetConstructor%2A> Metoda jest wywoływana z pustą <xref:System.Type> tablicą obiektów do reprezentowania typów parametrów. Drugim krokiem jest przekazanie obiektu wyników <xref:System.Reflection.ConstructorInfo> do konstruktora <xref:System.Reflection.Emit.CustomAttributeBuilder> dla klasy, wraz z pustą tablicą typu <xref:System.Object> reprezentującą argumenty.  
  
 Wynik <xref:System.Reflection.Emit.CustomAttributeBuilder> jest następnie przesyłany <xref:System.AppDomain.DefineDynamicAssembly%2A> do metody jako jedyny element tablicy.  
  
 Przykładowy kod definiuje moduł i typ w nowym zestawie dynamicznym, a następnie wyświetla atrybuty zestawu.  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość ma wartość<see langword="null" />. <see langword="Name" /> <paramref name="name" />  
  
—lub— 
<see langword="Name" /> Właściwośćzaczynasięodbiałegoznakulubzawieraukośnik<paramref name="name" /> do przodu lub wstecz.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <summary>Definiuje zestaw dynamiczny przy użyciu określonej nazwy, trybu dostępu i dowodu.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko w pełni zaufane obiekty wywołujące mogą `evidence` podawać ich podczas definiowania <xref:System.Reflection.Assembly>dynamicznego. Środowisko uruchomieniowe mapuje <xref:System.Security.Policy.Evidence> zasady zabezpieczeń w celu określenia przyznanych uprawnień. Częściowo zaufane obiekty wywołujące muszą podawać wartość `evidence`null. Jeśli `evidence` <xref:System.Reflection.Assembly> <xref:System.Reflection.Assembly> tak `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżące zestawy Grant i Deny, od obiektu wywołującego do zdefiniowanego dynamicznego i oznacza zasady jako rozwiązane.  
  
 Jeśli dynamiczny <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejne obciążenia będą otrzymywać dotacje na podstawie zasad skojarzonych z lokalizacją, <xref:System.Reflection.Assembly> w której zapisano.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Przeciążenie metody.  
  
> [!NOTE]
>  Podczas opracowywania kodu, który emituje zestawy dynamiczne, zaleca się użycie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowody i uprawnienia, Dostarcz dowód, który ma mieć zestaw dynamiczny, i Dołącz do <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> `refusedPermissions`. <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Dołączenie `refusedPermissions` do parametru gwarantuje, że MSIL zostanie zweryfikowane. Ograniczenie tej metody polega na tym, że jest to <xref:System.Security.SecurityException> również przyczyną zgłoszenia, gdy jest używany z kodem, który wymaga pełnego zaufania.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę <xref:System.AppDomain.AssemblyResolve> i zdarzenie.  
  
 Najpierw kod przykładu próbuje utworzyć wystąpienie `MyDynamicType` przez <xref:System.AppDomain.CreateInstance%2A> wywołanie metody z nieprawidłową nazwą zestawu i przechwycenie wynikłego wyjątku.  
  
 Przykład kodu dodaje procedurę obsługi zdarzeń dla <xref:System.AppDomain.AssemblyResolve> zdarzenia i ponownie próbuje utworzyć`MyDynamicType`wystąpienie. W trakcie wywołania do <xref:System.AppDomain.CreateInstance%2A> <xref:System.AppDomain.AssemblyResolve> , zdarzenie jest wywoływane dla nieprawidłowego zestawu. Program obsługi zdarzeń tworzy dynamiczny zestaw, który zawiera typ o nazwie `MyDynamicType`, nadaje typ konstruktora bez parametrów i zwraca nowy zestaw dynamiczny. Wywołanie do i <xref:System.AppDomain.CreateInstance%2A> zakończy się pomyślnie, a `MyDynamicType` Konstruktor wyświetla komunikat w konsoli.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość ma wartość<see langword="null" />. <see langword="Name" /> <paramref name="name" />  
  
—lub— 
<see langword="Name" /> Właściwośćzaczynasięodbiałegoznakulubzawieraukośnik<paramref name="name" /> do przodu lub wstecz.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli <paramref name="dir" /> jest<see langword="null" />, katalog domyślnie jest bieżącym katalogiem.</param>
        <summary>Definiuje zestaw dynamiczny przy użyciu określonej nazwy, trybu dostępu i katalogu magazynu.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Przeciążenie metody.  
  
> [!NOTE]
>  Podczas opracowywania kodu, który emituje zestawy dynamiczne, zaleca się użycie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowody i uprawnienia, Dostarcz dowód, który ma mieć zestaw dynamiczny, i Dołącz do <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> `refusedPermissions`. <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Dołączenie `refusedPermissions` do parametru gwarantuje, że MSIL zostanie zweryfikowane. Ograniczenie tej metody polega na tym, że jest to <xref:System.Security.SecurityException> również przyczyną zgłoszenia, gdy jest używany z kodem, który wymaga pełnego zaufania.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę i <xref:System.AppDomain.AssemblyResolve> zdarzenie.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość ma wartość<see langword="null" />. <see langword="Name" /> <paramref name="name" />  
  
—lub— 
<see langword="Name" /> Właściwośćzaczynasięodbiałegoznakulubzawieraukośnik<paramref name="name" /> do przodu lub wstecz.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb dostępu do dynamicznego zestawu.</param>
        <param name="assemblyAttributes">Wyliczalna lista atrybutów do zastosowania do zestawu lub <see langword="null" /> Jeśli nie ma żadnych atrybutów.</param>
        <param name="securityContextSource">Źródło kontekstu zabezpieczeń.</param>
        <summary>Definiuje dynamiczny zestaw z określoną nazwą, trybem dostępu i atrybutami niestandardowymi oraz przy użyciu określonego źródła dla jego kontekstu zabezpieczeń.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeciążenia służy do określania atrybutów, które nie będą działać poprawnie, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład atrybuty zabezpieczeń, takie jak <xref:System.Security.SecurityTransparentAttribute> i <xref:System.Security.SecurityCriticalAttribute> nie działają poprawnie, jeśli są dodawane po utworzeniu zestawu dynamicznego.  
  
 Ta metoda powinna być używana tylko do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji na temat tego ograniczenia, <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Zobacz Przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość ma wartość<see langword="null" />. <see langword="Name" /> <paramref name="name" />  
  
—lub— 
<see langword="Name" /> Właściwośćzaczynasięodbiałegoznakulubzawieraukośnik<paramref name="name" /> do przodu lub wstecz.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="securityContextSource" /> nie jest jedną z wartości wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli <paramref name="dir" /> jest<see langword="null" />, katalog domyślnie jest bieżącym katalogiem.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <summary>Definiuje zestaw dynamiczny przy użyciu określonej nazwy, trybu dostępu, katalogu magazynu i dowodu.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko w pełni zaufane obiekty wywołujące mogą `evidence` podawać ich podczas definiowania <xref:System.Reflection.Assembly>dynamicznego. Środowisko uruchomieniowe mapuje <xref:System.Security.Policy.Evidence> zasady zabezpieczeń w celu określenia przyznanych uprawnień. Częściowo zaufane obiekty wywołujące muszą podawać wartość `evidence`null. Jeśli `evidence` <xref:System.Reflection.Assembly> <xref:System.Reflection.Assembly> tak `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżące zestawy Grant i Deny, od obiektu wywołującego do zdefiniowanego dynamicznego i oznacza zasady jako rozwiązane.  
  
 Jeśli dynamiczny <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejne obciążenia będą otrzymywać dotacje na podstawie zasad skojarzonych z lokalizacją, <xref:System.Reflection.Assembly> w której zapisano.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Przeciążenie metody.  
  
> [!NOTE]
>  Podczas opracowywania kodu, który emituje zestawy dynamiczne, zaleca się użycie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowody i uprawnienia, Dostarcz dowód, który ma mieć zestaw dynamiczny, i Dołącz do <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> `refusedPermissions`. <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Dołączenie `refusedPermissions` do parametru gwarantuje, że MSIL zostanie zweryfikowane. Ograniczenie tej metody polega na tym, że jest to <xref:System.Security.SecurityException> również przyczyną zgłoszenia, gdy jest używany z kodem, który wymaga pełnego zaufania.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę i <xref:System.AppDomain.AssemblyResolve> zdarzenie.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość ma wartość<see langword="null" />. <see langword="Name" /> <paramref name="name" />  
  
—lub— 
<see langword="Name" /> Właściwośćzaczynasięodbiałegoznakulubzawieraukośnik<paramref name="name" /> do przodu lub wstecz.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <summary>Definiuje zestaw dynamiczny przy użyciu określonej nazwy, trybu dostępu i żądań uprawnień.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądania uprawnień określone dla `requiredPermissions`, i `optionalPermissions` `refusedPermissions` nie są używane, chyba że dynamiczny zestaw został zapisany i ponownie załadowany do pamięci. Aby określić żądania uprawnień dla zestawu przejściowego, który nigdy nie jest zapisywany na dysku, Użyj przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowody, a także żądane uprawnienia i <xref:System.Security.Policy.Evidence> Podaj obiekt.  
  
> [!NOTE]
>  Podczas opracowywania kodu, który emituje zestawy dynamiczne, zaleca się użycie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowody i uprawnienia, Dostarcz dowód, który ma mieć zestaw dynamiczny, i Dołącz do <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> `refusedPermissions`. <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Dołączenie `refusedPermissions` do parametru gwarantuje, że MSIL zostanie zweryfikowane. Ograniczenie tej metody polega na tym, że jest to <xref:System.Security.SecurityException> również przyczyną zgłoszenia, gdy jest używany z kodem, który wymaga pełnego zaufania.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Przeciążenie metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę i <xref:System.AppDomain.AssemblyResolve> zdarzenie.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość ma wartość<see langword="null" />. <see langword="Name" /> <paramref name="name" />  
  
—lub— 
<see langword="Name" /> Właściwośćzaczynasięodbiałegoznakulubzawieraukośnik<paramref name="name" /> do przodu lub wstecz.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw dynamiczny. Jeśli <paramref name="dir" /> jest<see langword="null" />, używany jest bieżący katalog.</param>
        <param name="isSynchronized"><see langword="true" />Aby zsynchronizować tworzenie modułów, typów i elementów członkowskich w zestawie dynamicznym; w przeciwnym razie. <see langword="false" /></param>
        <param name="assemblyAttributes">Wyliczalna lista atrybutów do zastosowania do zestawu lub <see langword="null" /> Jeśli nie ma żadnych atrybutów.</param>
        <summary>Definiuje zestaw dynamiczny przy użyciu określonej nazwy, trybu dostępu, katalogu magazynu i opcji synchronizacji.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeciążenia służy do określania atrybutów, które nie będą działać poprawnie, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład atrybuty zabezpieczeń, takie jak <xref:System.Security.SecurityTransparentAttribute> i <xref:System.Security.SecurityCriticalAttribute> nie działają poprawnie, jeśli są dodawane po utworzeniu zestawu dynamicznego.  
  
 Jeśli `isSynchronized` <xref:System.Reflection.Emit.AssemblyBuilder> <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>tak <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> ,zostanązsynchronizowane<xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>następujące metody wyniku:,, ,,<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>i. <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> `true` Jeśli dwie z tych metod są wywoływane w różnych wątkach, jeden zablokuje do momentu zakończenia drugiego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość ma wartość<see langword="null" />. <see langword="Name" /> <paramref name="name" />  
  
—lub— 
<see langword="Name" /> Właściwośćzaczynasięodbiałegoznakulubzawieraukośnik<paramref name="name" /> do przodu lub wstecz.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <summary>Definiuje zestaw dynamiczny przy użyciu określonej nazwy, trybu dostępu, dowodów i żądań uprawnień.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądania uprawnień określone `requiredPermissions`dla, `optionalPermissions`i `refusedPermissions` są używane tylko wtedy, gdy `evidence` jest również dostarczone, lub jeśli zestaw dynamiczny został zapisany i ponownie załadowany do pamięci.  
  
> [!NOTE]
>  Podczas opracowywania kodu, który emituje zestawy dynamiczne, zaleca się uwzględnienie <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w. `refusedPermissions` <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Dołączenie `refusedPermissions` do parametru gwarantuje, że MSIL zostanie zweryfikowane. Ograniczenie tej metody polega na tym, że jest to <xref:System.Security.SecurityException> również przyczyną zgłoszenia, gdy jest używany z kodem, który wymaga pełnego zaufania.  
  
 Tylko w pełni zaufane obiekty wywołujące mogą `evidence` podawać ich podczas definiowania <xref:System.Reflection.Assembly>dynamicznego. Środowisko uruchomieniowe mapuje <xref:System.Security.Policy.Evidence> zasady zabezpieczeń w celu określenia przyznanych uprawnień. Częściowo zaufane obiekty wywołujące muszą podawać wartość `evidence`null. Jeśli `evidence` <xref:System.Reflection.Assembly> <xref:System.Reflection.Assembly> tak `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżące zestawy Grant i Deny, od obiektu wywołującego do zdefiniowanego dynamicznego i oznacza zasady jako rozwiązane.  
  
 Jeśli dynamiczny <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejne obciążenia będą otrzymywać dotacje na podstawie zasad skojarzonych z lokalizacją, <xref:System.Reflection.Assembly> w której zapisano.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Przeciążenie metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę i <xref:System.AppDomain.AssemblyResolve> zdarzenie.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość ma wartość<see langword="null" />. <see langword="Name" /> <paramref name="name" />  
  
—lub— 
<see langword="Name" /> Właściwośćzaczynasięodbiałegoznakulubzawieraukośnik<paramref name="name" /> do przodu lub wstecz.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli <paramref name="dir" /> jest<see langword="null" />, katalog domyślnie jest bieżącym katalogiem.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <summary>Definiuje zestaw dynamiczny przy użyciu określonej nazwy, trybu dostępu, katalogu magazynu i żądań uprawnień.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądania uprawnień określone dla `requiredPermissions`, i `optionalPermissions` `refusedPermissions` nie są używane, chyba że dynamiczny zestaw został zapisany i ponownie załadowany do pamięci. Aby określić żądania uprawnień dla zestawu przejściowego, który nigdy nie jest zapisywany na dysku, Użyj przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowody, a także żądane uprawnienia i <xref:System.Security.Policy.Evidence> Podaj obiekt.  
  
> [!NOTE]
>  Podczas opracowywania kodu, który emituje zestawy dynamiczne, zaleca się użycie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowody i uprawnienia, Dostarcz dowód, który ma mieć zestaw dynamiczny, i Dołącz do <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> `refusedPermissions`. <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Dołączenie `refusedPermissions` do parametru gwarantuje, że MSIL zostanie zweryfikowane. Ograniczenie tej metody polega na tym, że jest to <xref:System.Security.SecurityException> również przyczyną zgłoszenia, gdy jest używany z kodem, który wymaga pełnego zaufania.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Przeciążenie metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę i <xref:System.AppDomain.AssemblyResolve> zdarzenie.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość ma wartość<see langword="null" />. <see langword="Name" /> <paramref name="name" />  
  
—lub— 
<see langword="Name" /> Właściwośćzaczynasięodbiałegoznakulubzawieraukośnik<paramref name="name" /> do przodu lub wstecz.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli <paramref name="dir" /> jest<see langword="null" />, katalog domyślnie jest bieżącym katalogiem.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <summary>Definiuje zestaw dynamiczny przy użyciu określonej nazwy, trybu dostępu, katalogu magazynu, dowodów i żądań uprawnień.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądania uprawnień określone `requiredPermissions`dla, `optionalPermissions`i `refusedPermissions` są używane tylko wtedy, gdy `evidence` jest również dostarczone, lub jeśli zestaw dynamiczny został zapisany i ponownie załadowany do pamięci.  
  
> [!NOTE]
>  Podczas opracowywania kodu, który emituje zestawy dynamiczne, zaleca się uwzględnienie <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w. `refusedPermissions` <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Dołączenie `refusedPermissions` do parametru gwarantuje, że MSIL zostanie zweryfikowane. Ograniczenie tej metody polega na tym, że jest to <xref:System.Security.SecurityException> również przyczyną zgłoszenia, gdy jest używany z kodem, który wymaga pełnego zaufania.  
  
 Tylko w pełni zaufane obiekty wywołujące mogą `evidence` podawać ich podczas definiowania <xref:System.Reflection.Assembly>dynamicznego. Środowisko uruchomieniowe mapuje <xref:System.Security.Policy.Evidence> zasady zabezpieczeń w celu określenia przyznanych uprawnień. Częściowo zaufane obiekty wywołujące muszą podawać wartość `evidence`null. Jeśli `evidence` <xref:System.Reflection.Assembly> <xref:System.Reflection.Assembly> tak `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżące zestawy Grant i Deny, od obiektu wywołującego do zdefiniowanego dynamicznego i oznacza zasady jako rozwiązane.  
  
 Jeśli dynamiczny <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejne obciążenia będą otrzymywać dotacje na podstawie zasad skojarzonych z lokalizacją, <xref:System.Reflection.Assembly> w której zapisano.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Przeciążenie metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę i <xref:System.AppDomain.AssemblyResolve> zdarzenie.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość ma wartość<see langword="null" />. <see langword="Name" /> <paramref name="name" />  
  
—lub— 
<see langword="Name" /> Właściwośćzaczynasięodbiałegoznakulubzawieraukośnik<paramref name="name" /> do przodu lub wstecz.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw dynamiczny. Jeśli <paramref name="dir" /> jest<see langword="null" />, katalog domyślnie jest bieżącym katalogiem.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <param name="isSynchronized"><see langword="true" />Aby zsynchronizować tworzenie modułów, typów i elementów członkowskich w zestawie dynamicznym; w przeciwnym razie. <see langword="false" /></param>
        <summary>Definiuje zestaw dynamiczny przy użyciu określonej nazwy, trybu dostępu, katalogu magazynu, dowodów, żądań uprawnień i opcji synchronizacji.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądania uprawnień określone `requiredPermissions`dla, `optionalPermissions`i `refusedPermissions` są używane tylko wtedy, gdy `evidence` jest również dostarczone, lub jeśli zestaw dynamiczny został zapisany i ponownie załadowany do pamięci.  
  
> [!NOTE]
>  Podczas opracowywania kodu, który emituje zestawy dynamiczne, zaleca się uwzględnienie <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w. `refusedPermissions` <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> Dołączenie `refusedPermissions` do parametru gwarantuje, że MSIL zostanie zweryfikowane. Ograniczenie tej metody polega na tym, że jest to <xref:System.Security.SecurityException> również przyczyną zgłoszenia, gdy jest używany z kodem, który wymaga pełnego zaufania.  
  
 Tylko w pełni zaufane obiekty wywołujące mogą podawać swoje dowody podczas definiowania <xref:System.Reflection.Assembly>dynamicznego. Środowisko uruchomieniowe mapuje <xref:System.Security.Policy.Evidence> zasady zabezpieczeń w celu określenia przyznanych uprawnień. Częściowo zaufane obiekty wywołujące muszą `null` podawać `evidence` parametr. Jeśli `evidence` <xref:System.Reflection.Assembly> <xref:System.Reflection.Assembly> tak `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżące zestawy Grant i Deny, od obiektu wywołującego do zdefiniowanego dynamicznego i oznacza zasady jako rozwiązane.  
  
 Jeśli dynamiczny <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejne obciążenia będą otrzymywać dotacje na podstawie zasad skojarzonych z lokalizacją, <xref:System.Reflection.Assembly> w której zapisano.  
  
 Jeśli `isSynchronized` <xref:System.Reflection.Emit.AssemblyBuilder> <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>tak <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> ,zostanązsynchronizowane<xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>następujące metody wyniku:,, ,,<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>i. <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> `true` Jeśli dwie z tych metod są wywoływane w różnych wątkach, jeden zablokuje do momentu zakończenia drugiego.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę i <xref:System.AppDomain.AssemblyResolve> zdarzenie.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość ma wartość<see langword="null" />. <see langword="Name" /> <paramref name="name" />  
  
—lub— 
<see langword="Name" /> Właściwośćzaczynasięodbiałegoznakulubzawieraukośnik<paramref name="name" /> do przodu lub wstecz.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="7" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="8" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw dynamiczny. Jeśli <paramref name="dir" /> jest<see langword="null" />, używany jest bieżący katalog.</param>
        <param name="evidence">Dowody dostarczone dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <param name="isSynchronized"><see langword="true" />Aby zsynchronizować tworzenie modułów, typów i elementów członkowskich w zestawie dynamicznym; w przeciwnym razie. <see langword="false" /></param>
        <param name="assemblyAttributes">Wyliczalna lista atrybutów do zastosowania do zestawu lub <see langword="null" /> Jeśli nie ma żadnych atrybutów.</param>
        <summary>Definiuje dynamiczny zestaw z określoną nazwą, trybem dostępu, katalogiem magazynu, dowodem, żądaniami uprawnień, opcjami synchronizacji i atrybutami niestandardowymi.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeciążenia służy do określania atrybutów, które nie będą działać poprawnie, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład atrybuty zabezpieczeń, takie jak <xref:System.Security.SecurityTransparentAttribute> i <xref:System.Security.SecurityCriticalAttribute> nie działają poprawnie, jeśli są dodawane po utworzeniu zestawu dynamicznego.  
  
 Żądania `requiredPermissions`uprawnień określone dla parametrów, `optionalPermissions`i `refusedPermissions` są używane tylko wtedy, gdy `evidence` parametr jest również dostarczony, lub jeśli zestaw dynamiczny został zapisany i ponownie załadowany do pamięci.  
  
> [!NOTE]
>  Podczas opracowywania kodu, który emituje zestawy dynamiczne, Zalecamy dołączenie <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> flagi `refusedPermissions` do parametru. Włączenie tej flagi gwarantuje, że zostanie zweryfikowany język pośredni (MSIL) firmy Microsoft. Ta technika wykrywa niezamierzoną generację kodu niemożliwego do zweryfikowania, który w przeciwnym razie jest bardzo trudny do wykrycia. Ograniczenie tej metody polega na tym, że jest to <xref:System.Security.SecurityException> również przyczyną zgłoszenia, gdy jest używany z kodem, który wymaga pełnego zaufania.  
  
 Tylko w pełni zaufane obiekty wywołujące mogą podawać dowody podczas definiowania <xref:System.Reflection.Assembly>dynamicznego. Środowisko uruchomieniowe mapuje <xref:System.Security.Policy.Evidence> za pomocą zasad zabezpieczeń w celu określenia przyznanych uprawnień. Częściowo zaufane obiekty wywołujące muszą `null` podawać `evidence` parametr. Jeśli `evidence` tak`null`, środowisko uruchomieniowe kopiuje zestawy uprawnień (czyli bieżące zestawy Grant i Deny) z zestawu wywołującego do definiowanego dynamicznego zestawu i oznacza zasady jako rozwiązane.  
  
 Jeśli dynamiczny zestaw jest zapisywany na dysku, kolejne obciążenia będą otrzymywać dotacje na podstawie zasad skojarzonych z lokalizacją, w której zapisano zestaw dynamiczny.  
  
 Jeśli `isSynchronized` <xref:System.Reflection.Emit.AssemblyBuilder> <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>tak <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> ,zostanązsynchronizowane<xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>następujące metody wyniku:,, ,,<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>i. <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> `true` Jeśli dwie z tych metod są wywoływane w różnych wątkach, jeden zablokuje do momentu zakończenia drugiego.  
  
 To Przeciążenie metody zostało wprowadzone w [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość ma wartość<see langword="null" />. <see langword="Name" /> <paramref name="name" />  
  
—lub— 
<see langword="Name" /> Właściwośćzaczynasięodbiałegoznakulubzawieraukośnik<paramref name="name" /> do przodu lub wstecz.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">Delegat, który określa metodę do wywołania.</param>
        <summary>Wykonuje kod w innej domenie aplikacji, który jest identyfikowany przez określony delegat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate`można określić zorganizowany przez wartość, <xref:System.MarshalByRefObject>lub. <xref:System.ContextBoundObject>  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie metody statycznej <xref:System.AppDomain.DoCallBack%2A> .  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 Poniższy przykład demonstruje użycie <xref:System.AppDomain.DoCallBack%2A> metody przez wartość.  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 Poniższy przykład demonstruje użycie <xref:System.AppDomain.DoCallBack%2A> metody przez odwołanie.  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBackDelegate" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Menedżera domeny, który został dostarczony przez hosta po zainicjowaniu domeny aplikacji.</summary>
        <value>Obiekt reprezentujący Menedżera domeny dostarczony przez hosta, gdy domena aplikacji została zainicjowana, lub <see langword="null" /> Jeśli nie podano żadnego Menedżera domeny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezarządzany host środowiska uruchomieniowego języka wspólnego (CLR) może zapewnić Menedżera domeny. Menedżer domeny może uczestniczyć w inicjowaniu nowej domeny aplikacji i dostarczać innych menedżerów, takich jak <xref:System.Security.HostSecurityManager>, które uczestniczą w operacjach domeny aplikacji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="T:System.AppDomain" /> gdy zostanie zwolniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler> Delegat dla tego zdarzenia może wykonać wszelkie działania związane z zakończeniem, zanim domena aplikacji zostanie zwolniona.  
  
 Każda domena aplikacji, która musi wykonać przetwarzanie, gdy jest zwolniona, powinna rejestrować procedurę obsługi zdarzeń dla tego zdarzenia. Nie można użyć współużytkowanego zdarzenia, ponieważ <xref:System.EventHandler> delegat nie identyfikuje domeny, która jest zwalniana.  
  
> [!NOTE]
>  To zdarzenie nigdy nie jest zgłaszane w domyślnej domenie aplikacji.  
  
 Nie należy tworzyć założeń dotyczących wątku, w którym zdarzenie jest zgłaszane. Zdarzenie może być wywoływane w innym wątku niż ten, który wywołał <xref:System.AppDomain.Unload%2A> metodę.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera katalog używany przez program rozpoznawania zestawu do sondowania dla dynamicznie utworzonych zestawów.</summary>
        <value>Katalog używany przez program rozpoznawania zestawu do sondowania dla dynamicznie utworzonych zestawów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ustawić katalog dynamiczny, przypisz ścieżkę katalogu podstawowego do <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> właściwości <xref:System.AppDomainSetup> obiektu, który zostanie użyty do utworzenia nowej domeny aplikacji. Ścieżka do katalogu podstawowego przypisywana do właściwości jest modyfikowana przez dodanie podkatalogu, którego prosta nazwa jest kodem skrótu ciągu, który jest przypisany do <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> właściwości, więc format katalogu podstawowego jest ścieżką ** \\ oryginalną *kod skrótu*. Katalog dynamiczny jest podkatalogiem tego katalogu podstawowego. Jego <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> prostą nazwą jest wartość właściwości, więc jej format jest oryginalną *ścieżką*\\*nazwy aplikacji**kod*\\skrótu.  
  
   
  
## Examples  
 Poniższy przykład tworzy domenę aplikacji z katalogiem dla zestawów dynamicznych, emituje zestaw dynamiczny i zapisuje je w katalogu dynamicznym, a następnie ładuje zestaw do nowej domeny aplikacji i używa go.  
  
 Przykład tworzy <xref:System.AppDomainSetup> obiekt i ustawia jego <xref:System.AppDomainSetup.ApplicationName%2A> właściwość na "przykład" i jego <xref:System.AppDomainSetup.DynamicBase%2A> właściwość na "C:\DynamicAssemblyDir". W przykładzie zostanie wyświetlona <xref:System.AppDomainSetup.DynamicBase%2A> właściwość, aby pokazać, że kod skrótu nazwy aplikacji został dołączony jako podkatalog ścieżki, która została pierwotnie przypisana.  
  
> [!NOTE]
>  Katalog podstawowy w tym przykładzie ma być poza ścieżką do sondowania przykładowej aplikacji. Zadbaj o skompilowanie przykładu w innej lokalizacji. Usuń katalog podstawowy i wszystkie jego podkatalogi przy każdym uruchomieniu przykładu.  
  
 Przykład tworzy nową domenę aplikacji przy użyciu <xref:System.AppDomainSetup> obiektu. W przykładzie zastosowano <xref:System.AppDomain.DynamicDirectory%2A> właściwość w celu pobrania nazwy katalogu, aby można było utworzyć katalog. (Przykładem może być jak najłatwiej utworzyć katalog, łącząc oryginalną ścieżkę, kod skrótu nazwy aplikacji i nazwę aplikacji).  
  
 Przykład ma `GenerateDynamicAssembly` metodę, która emituje zestaw o nazwie `DynamicHelloWorld.dll` i zapisuje je w katalogu dynamicznym nowej domeny aplikacji. Zestaw dynamiczny zawiera jeden typ, `HelloWorld`który ma metodę statyczną (`Shared` Metoda w Visual Basic) o nazwie `HelloFromAD`. Wywołanie tej metody powoduje wyświetlenie nazwy domeny aplikacji.  
  
 Klasa pochodzi od <xref:System.MarshalByRefObject>, więc przykład może utworzyć wystąpienie klasy w nowej domenie `Test` aplikacji i wywołać metodę. `Example` Metoda ładuje dynamiczny zestaw według jego nazwy wyświetlanej i wywołuje metodę statyczną `HelloFromAD`. `Test`  
  
 Możesz pokazać, że katalog dynamiczny jest przeszukiwany po normalnej ścieżce sondowania, pisząc kod dla zestawu o `DynamicHelloWorld.dll` nazwie i kompilując go w tym samym katalogu, co w tym przykładzie. Zestaw musi mieć klasę o nazwie `HelloWorld` z metodą statyczną o nazwie. `HelloFromAD` Ta metoda nie musi mieć takich samych funkcji jak w przykładzie; może po prostu wyświetlić ciąg w konsoli programu. Zestaw musi mieć <xref:System.Reflection.AssemblyVersionAttribute> również atrybut, który ustawia jego wersję na 1.0.0.0. Po uruchomieniu przykładu zestaw skompilowany w bieżącym katalogu zostanie znaleziony przed przeszukaniem katalogu dynamicznego.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Security.Policy.Evidence" /> Pobiera skojarzoną z tą domeną aplikacji.</summary>
        <value>Dowody skojarzone z tą domeną aplikacji.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje zestaw zawarty w określonym pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <summary>Wykonuje zestaw zawarty w określonym pliku.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Zestawy można również wykonywać przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody, która ładuje zestawy <xref:System.Reflection.Assembly.Load%2A> przy użyciu metody.  
  
 Aby utworzyć <xref:System.AppDomain> do załadowania i wykonania, <xref:System.AppDomain.CreateDomain%2A> Użyj metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyFile" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary>Wykonuje zestaw zawarty w określonym pliku przy użyciu określonych dowodów.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 <xref:System.AppDomain.ExecuteAssembly%2A> Metoda nie tworzy nowego procesu ani domeny aplikacji i nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Zestawy można również wykonywać przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody, która ładuje zestawy <xref:System.Reflection.Assembly.Load%2A> przy użyciu metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyFile" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="args">Argumenty punktu wejścia w zestawie.</param>
        <summary>Wykonuje zestaw zawarty w określonym pliku przy użyciu określonych argumentów.</summary>
        <returns>Wartość, która jest zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Zestawy można również wykonywać przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody, która ładuje zestawy <xref:System.Reflection.Assembly.Load%2A> przy użyciu metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyFile" />Program został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="assemblySecurity">Dostarczone dowody dla zestawu.</param>
        <param name="args">Argumenty punktu wejścia w zestawie.</param>
        <summary>Wykonuje zestaw zawarty w określonym pliku przy użyciu określonych dowodów i argumentów.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Zestawy można również wykonywać przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody, która ładuje zestawy <xref:System.Reflection.Assembly.Load%2A> przy użyciu metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyFile" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="assemblySecurity" />nie <see langword="null" />jest. Jeśli starsze zasady urzędów certyfikacji nie są <paramref name="assemblySecurity" /> włączone, <see langword="null" />powinny być.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="args">Argumenty punktu wejścia w zestawie.</param>
        <param name="hashValue">Reprezentuje wartość obliczanego kodu skrótu.</param>
        <param name="hashAlgorithm">Reprezentuje algorytm wyznaczania wartości skrótu używany przez manifest zestawu.</param>
        <summary>Wykonuje zestaw zawarty w określonym pliku, używając określonych argumentów, wartości skrótu i algorytmu wyznaczania wartości skrótu.</summary>
        <returns>Wartość, która jest zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Zestawy można również wykonywać przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody, która ładuje zestawy <xref:System.Reflection.Assembly.Load%2A> przy użyciu metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyFile" />Program został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="assemblySecurity">Dostarczone dowody dla zestawu.</param>
        <param name="args">Argumenty punktu wejścia w zestawie.</param>
        <param name="hashValue">Reprezentuje wartość obliczanego kodu skrótu.</param>
        <param name="hashAlgorithm">Reprezentuje algorytm wyznaczania wartości skrótu używany przez manifest zestawu.</param>
        <summary>Wykonuje zestaw zawarty w określonym pliku przy użyciu określonych dowodów, argumentów, wartości skrótu i algorytmu wyznaczania wartości skrótu.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Zestawy można również wykonywać przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody, która ładuje zestawy <xref:System.Reflection.Assembly.Load%2A> przy użyciu metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyFile" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="assemblySecurity" />nie <see langword="null" />jest. Jeśli starsze zasady urzędów certyfikacji nie są <paramref name="assemblySecurity" /> włączone, <see langword="null" />powinny być.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje zestaw.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Wykonuje zestaw z nazwą wyświetlaną.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zapewnia podobną funkcjonalność <xref:System.AppDomain.ExecuteAssembly%2A> do metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie według lokalizacji pliku. <xref:System.AppDomain.ExecuteAssemblyByName%2A> W związku <xref:System.Reflection.Assembly.LoadFile%2A> <xref:System.Reflection.Assembly.Load%2A> z tym ładujezestawyprzyużyciu<xref:System.AppDomain.ExecuteAssemblyByName%2A> metody zamiast metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Aby utworzyć <xref:System.AppDomain> do załadowania i wykonania, <xref:System.AppDomain.CreateDomain%2A> Użyj metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono zestawu określonego <paramref name="assemblyName" /> przez.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw określony przez <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyName" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Znaleziono zestaw określony przez <paramref name="assemblyName" /> , ale nie można go załadować.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><see cref="T:System.Reflection.AssemblyName" /> Obiekt reprezentujący nazwę zestawu.</param>
        <param name="args">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Wykonuje zestaw <see cref="T:System.Reflection.AssemblyName" />za pomocą podanych argumentów.</summary>
        <returns>Wartość, która jest zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zapewnia podobną funkcjonalność <xref:System.AppDomain.ExecuteAssembly%2A> do metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie według lokalizacji pliku. <xref:System.AppDomain.ExecuteAssemblyByName%2A> W związku <xref:System.Reflection.Assembly.LoadFile%2A> <xref:System.Reflection.Assembly.Load%2A> z tym ładujezestawyprzyużyciu<xref:System.AppDomain.ExecuteAssemblyByName%2A> metody zamiast metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono zestawu określonego <paramref name="assemblyName" /> przez.</exception>
        <exception cref="T:System.IO.FileLoadException">Znaleziono zestaw określony przez <paramref name="assemblyName" /> , ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw określony przez <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyName" />Program został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary>Wykonuje zestaw z nazwą wyświetlaną, używając określonego dowodu.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zapewnia podobną funkcjonalność <xref:System.AppDomain.ExecuteAssembly%2A> do metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie według lokalizacji pliku. <xref:System.AppDomain.ExecuteAssemblyByName%2A> W związku <xref:System.Reflection.Assembly.LoadFile%2A> <xref:System.Reflection.Assembly.Load%2A> z tym ładujezestawyprzyużyciu<xref:System.AppDomain.ExecuteAssemblyByName%2A> metody zamiast metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda nie tworzy nowego procesu ani domeny aplikacji i nie wykonuje metody punktu wejścia w nowym wątku.  
  
> [!NOTE]
>  Gdy używasz <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody <xref:System.Security.Policy.Evidence> z parametrem, fragmenty dowodów są scalane. Elementy dowodu dostarczone jako argument do <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody zastępują fragmenty dowodów dostarczone przez moduł ładujący.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono zestawu określonego <paramref name="assemblyName" /> przez.</exception>
        <exception cref="T:System.IO.FileLoadException">Znaleziono zestaw określony przez <paramref name="assemblyName" /> , ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw określony przez <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyName" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="args">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Wykonuje zestaw z nazwą wyświetlaną, używając określonych argumentów.</summary>
        <returns>Wartość, która jest zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zapewnia podobną funkcjonalność <xref:System.AppDomain.ExecuteAssembly%2A> do metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie według lokalizacji pliku. <xref:System.AppDomain.ExecuteAssemblyByName%2A> W związku <xref:System.Reflection.Assembly.LoadFile%2A> <xref:System.Reflection.Assembly.Load%2A> z tym ładujezestawyprzyużyciu<xref:System.AppDomain.ExecuteAssemblyByName%2A> metody zamiast metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono zestawu określonego <paramref name="assemblyName" /> przez.</exception>
        <exception cref="T:System.IO.FileLoadException">Znaleziono zestaw określony przez <paramref name="assemblyName" /> , ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw określony przez <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyName" />Program został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><see cref="T:System.Reflection.AssemblyName" /> Obiekt reprezentujący nazwę zestawu.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <param name="args">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Wykonuje zestaw <see cref="T:System.Reflection.AssemblyName" />przy użyciu określonych dowodów i argumentów.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zapewnia podobną funkcjonalność <xref:System.AppDomain.ExecuteAssembly%2A> do metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie według lokalizacji pliku. <xref:System.AppDomain.ExecuteAssemblyByName%2A> W związku <xref:System.Reflection.Assembly.LoadFile%2A> <xref:System.Reflection.Assembly.Load%2A> z tym ładujezestawyprzyużyciu<xref:System.AppDomain.ExecuteAssemblyByName%2A> metody zamiast metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
> [!NOTE]
>  Gdy używasz <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody <xref:System.Security.Policy.Evidence> z parametrem, fragmenty dowodów są scalane. Elementy dowodu dostarczone jako argument do <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody zastępują fragmenty dowodów dostarczone przez moduł ładujący.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono zestawu określonego <paramref name="assemblyName" /> przez.</exception>
        <exception cref="T:System.IO.FileLoadException">Znaleziono zestaw określony przez <paramref name="assemblyName" /> , ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw określony przez <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyName" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="assemblySecurity" />nie <see langword="null" />jest. Jeśli starsze zasady urzędów certyfikacji nie są <paramref name="assemblySecurity" /> włączone, <see langword="null" />powinny być.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <param name="args">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Wykonuje zestaw z nazwą wyświetlaną, przy użyciu określonych dowodów i argumentów.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zapewnia podobną funkcjonalność <xref:System.AppDomain.ExecuteAssembly%2A> do metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie według lokalizacji pliku. <xref:System.AppDomain.ExecuteAssemblyByName%2A> W związku <xref:System.Reflection.Assembly.LoadFile%2A> <xref:System.Reflection.Assembly.Load%2A> z tym ładujezestawyprzyużyciu<xref:System.AppDomain.ExecuteAssemblyByName%2A> metody zamiast metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
> [!NOTE]
>  Gdy używasz <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody <xref:System.Security.Policy.Evidence> z parametrem, fragmenty dowodów są scalane. Elementy dowodu dostarczone jako argument do <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody zastępują fragmenty dowodów dostarczone przez moduł ładujący.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono zestawu określonego <paramref name="assemblyName" /> przez.</exception>
        <exception cref="T:System.IO.FileLoadException">Znaleziono zestaw określony przez <paramref name="assemblyName" /> , ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw określony przez <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyName" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="assemblySecurity" />nie <see langword="null" />jest. Jeśli starsze zasady urzędów certyfikacji nie są <paramref name="assemblySecurity" /> włączone, <see langword="null" />powinny być.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek jest zgłaszany w kodzie zarządzanym, zanim środowisko uruchomieniowe przeszuka stos wywołań dla programu obsługi wyjątków w domenie aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie dotyczy tylko powiadomienia. Obsługa tego zdarzenia nie obsługuje wyjątku ani nie ma wpływu na następną obsługę wyjątków. Po podniesieniu zdarzenia i wywołaniu procedur obsługi zdarzeń, środowisko uruchomieniowe języka wspólnego (CLR) rozpoczyna wyszukiwanie programu obsługi wyjątku. <xref:System.AppDomain.FirstChanceException>zapewnia domenę aplikacji z pierwszą szansą, aby przeanalizować dowolny wyjątek zarządzany.  
  
 Zdarzenie może być obsługiwane dla każdej domeny aplikacji. Jeśli wątek przechodzi przez wiele domen aplikacji podczas wykonywania wywołania, zdarzenie jest zgłaszane w każdej domenie aplikacji, która zarejestrowała procedurę obsługi zdarzeń, zanim środowisko CLR zacznie wyszukiwać pasującą procedurę obsługi wyjątków w tej domenie aplikacji. Po obsłudze zdarzenia zostanie wykonane wyszukiwanie zgodnego programu obsługi wyjątków w tej domenie aplikacji. Jeśli nie zostanie znaleziona, zdarzenie zostanie zgłoszone w następnej domenie aplikacji.  
  
 Należy obsługiwać wszystkie wyjątki, które występują w programie obsługi zdarzeń dla <xref:System.AppDomain.FirstChanceException> zdarzenia. W przeciwnym razie jest uruchamiany rekursywnie. <xref:System.AppDomain.FirstChanceException> Może to spowodować przepełnienie stosu i zakończenie działania aplikacji. Zalecamy zaimplementowanie obsługi zdarzeń dla tego zdarzenia jako regionów z ograniczeniami wykonywania (CERs), aby zachować wyjątki związane z infrastrukturą, takie jak brak pamięci lub przepełnienie stosu wpływające na maszynę wirtualną w trakcie powiadomienia o wyjątku Trwa przetwarzanie.  
  
 To zdarzenie nie jest wywoływane w przypadku wyjątków wskazujących uszkodzenie stanu procesu, takich jak naruszenia zasad dostępu, chyba że program obsługi zdarzeń ma krytyczne znaczenie dla zabezpieczeń <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> i ma atrybut.  
  
 Wstrzymanie wątku środowiska uruchomieniowego języka wspólnego w trakcie obsługi tego zdarzenia powiadamiania.  
  
   
  
## Examples  
 Poniższy przykład tworzy serię domen aplikacji o nazwie `AD0` za pomocą `AD3`, z `Worker` obiektem w każdej domenie aplikacji. Każdy `Worker` obiekt ma odwołanie `Worker` do obiektu w następnej `Worker` domenie aplikacji, z wyjątkiem w ostatniej domenie aplikacji. Zdarzenie jest obsługiwane we wszystkich domenach aplikacji z `AD1`wyjątkiem. <xref:System.AppDomain.FirstChanceException>  
  
> [!NOTE]
>  Oprócz tego przykładu, który pokazuje powiadomienia o wyjątkach pierwszej szansy w wielu domenach aplikacji, można znaleźć proste przypadki użycia [w temacie How to: Odbieraj powiadomienia o](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)wyjątkach pierwszej szansy.  
  
 Po utworzeniu domen aplikacji domyślna domena aplikacji wywołuje `TestException` metodę dla pierwszej domeny aplikacji. Każdy `Worker` obiekt `Worker` wywołuje metodę dla następnej domeny aplikacji, aż do ostatniego zgłasza wyjątek, który jest obsługiwany lub nieobsługiwany. `TestException` W rezultacie bieżący wątek przechodzi przez wszystkie domeny aplikacji i `TestException` jest dodawany do stosu w każdej domenie aplikacji.  
  
 Gdy ostatni `Worker` obiekt obsługuje wyjątek <xref:System.AppDomain.FirstChanceException> , zdarzenie jest zgłaszane tylko w ostatniej domenie aplikacji. Inne domeny aplikacji nigdy nie uzyskają możliwości obsługi wyjątku, więc zdarzenie nie zostanie zgłoszone.  
  
 Gdy ostatni `Worker` obiekt nie obsługuje wyjątku <xref:System.AppDomain.FirstChanceException> , zdarzenie jest zgłaszane w każdej domenie aplikacji, która ma procedurę obsługi zdarzeń. Po zakończeniu każdego programu obsługi zdarzeń stos pozostaje nieprzerwany do momentu przechwyconego przez domyślną domenę aplikacji.  
  
> [!NOTE]
>  Aby zobaczyć, w jaki sposób wyświetlacz stosu rośnie, gdy zdarzenie jest wywoływane bliżej i bliżej domyślnej domeny aplikacji, Zmień `e.Exception.Message` na `e.Exception` w programie `FirstChanceHandler` obsługi zdarzeń. Należy zauważyć, `TestException` że gdy jest wywoływana między granicami domeny aplikacji, występuje dwa razy: jeden dla serwera proxy i jeden raz dla elementu zastępczego.  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
        <related type="Article" href="https://msdn.microsoft.com/library/66f002b8-a97d-4a6e-a503-2cec01689113">Instrukcje: Odbieranie powiadomień o wyjątkach pierwszej szansy</related>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przyjazną nazwę tej domeny aplikacji.</summary>
        <value>Przyjazna nazwa tej domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przyjazna nazwa domyślnej domeny aplikacji jest nazwą pliku wykonywalnego procesu. Na przykład, jeśli plik wykonywalny używany do uruchomienia tego procesu `"c:\MyAppDirectory\MyAssembly.exe"`ma przyjazną nazwę domyślnej `"MyAssembly.exe"`domeny aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu używa właściwości, <xref:System.AppDomain.FriendlyName%2A> Aby uzyskać przyjazną nazwę bieżącej domeny aplikacji. W przypadku domyślnej domeny aplikacji przyjazna nazwa jest nazwą pliku wykonywalnego aplikacji. W przykładzie kodu są również wyświetlane dodatkowe informacje o domenie aplikacji.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera zestawy, które zostały załadowane do kontekstu wykonywania tej domeny aplikacji.</summary>
        <returns>Tablica zestawów w tej domenie aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu używa <xref:System.AppDomain.GetAssemblies%2A> metody, aby uzyskać listę wszystkich zestawów, które zostały załadowane do domeny aplikacji. Zestawy są następnie wyświetlane w konsoli programu.  
  
 Aby uruchomić ten przykład kodu, należy utworzyć zestaw o nazwie `CustomLibrary.dll`lub zmienić nazwę zestawu, który jest przesyłany <xref:System.AppDomain.GetAssemblies%2A> do metody.  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera bieżący identyfikator wątku.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem, która jest identyfikatorem bieżącego wątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> Użyj właściwości, która jest stabilna nawet wtedy, gdy .NET Framework jest hostowana przez środowisko obsługujące włókien (czyli lekkie wątki).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywołać tę metodę. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa wstępnie zdefiniowanej właściwości domeny aplikacji lub nazwa zdefiniowanej właściwości domeny aplikacji.</param>
        <summary>Pobiera wartość przechowywaną w bieżącej domenie aplikacji dla określonej nazwy.</summary>
        <returns>Wartość <paramref name="name" /> właściwości lub <see langword="null" /> Jeśli właściwość nie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby pobrać wartość wpisu w wewnętrznej pamięci podręcznej par nazwa-dane, które opisują właściwości tego wystąpienia <xref:System.AppDomain>. Należy zauważyć, że porównanie `name` z nazwą par klucz-wartość jest rozróżniana wielkość liter.  
  
 Pamięć podręczna programu automatycznie zawiera wstępnie zdefiniowane wpisy systemowe, które są wstawiane podczas tworzenia domeny aplikacji. Można sprawdzić ich wartości za pomocą <xref:System.AppDomain.GetData%2A> metody lub równoważne <xref:System.AppDomainSetup> właściwości.  
  
 Możesz wstawić lub zmodyfikować własne pary nazwa-dane zdefiniowane przez użytkownika przy użyciu <xref:System.AppDomain.SetData%2A> metody i zbadać ich wartości <xref:System.AppDomain.GetData%2A> za pomocą metody.  
  
 W poniższej tabeli opisano `name` każdy wstępnie zdefiniowany wpis systemowy i odpowiadającą mu <xref:System.AppDomainSetup> właściwość.  
  
|Wartość parametru "name"|Właściwość|  
|---------------------|--------------|  
|"APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|(brak właściwości)<br /><br /> "APP_LAUNCH_URL" reprezentuje adres URL pierwotnie żądany przez użytkownika przed przekazaniem. Jest on dostępny tylko wtedy, gdy aplikacja została uruchomiona z przeglądarką, taką jak Internet Explorer. Nie wszystkie przeglądarki zapewniają tę wartość.|  
|"APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|(brak właściwości)|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|"FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|"LICENSE_FILE" lub ciąg specyficzny dla aplikacji|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|"LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|"LOCATION_URI"|(brak właściwości)|  
|"PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> "REGEX_DEFAULT_MATCH_TIMEOUT" nie jest wpisem systemowym, a jego wartość można ustawić przez wywołanie <xref:System.AppDomain.SetData%2A> metody.|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 Poniższy przykład tworzy nową domenę aplikacji, ustawia wartość dostarczoną przez system dla domeny i dodaje nową parę wartości dla domeny. W przykładzie pokazano, jak za pomocą <xref:System.AppDomain.GetData%2A> metody pobrać dane z tych par wartości i wyświetlić je w konsoli programu.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji w samej ścieżce, jeśli właściwość ma zastosowanie do ścieżki. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typ bieżącego wystąpienia.</summary>
        <returns>Typ bieżącego wystąpienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę całkowitą, która jednoznacznie identyfikuje domenę aplikacji w ramach procesu.</summary>
        <value>Liczba całkowita, która identyfikuje domenę aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy drugą domenę aplikacji i wyświetla informacje o domenie domyślnej i nowej domenie.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.AppDomain" /> Zapewnia nieskończony okres istnienia, uniemożliwiając utworzenie dzierżawy.</summary>
        <returns>Zawsze <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Przełącznik zgodności do przetestowania.</param>
        <summary>Pobiera wartość logiczną null, która wskazuje, czy są ustawione wszystkie przełączniki zgodności, a jeśli tak, to czy ustawiony jest określony przełącznik zgodności.</summary>
        <returns>Odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic), jeśli nie ustawiono żadnych przełączników zgodności; w przeciwnym razie wartość logiczna wskazująca, czy przełącznik zgodności określony <paramref name="value" /> przez jest ustawiony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy określony przełącznik zgodności został ustawiony dla bieżącej domeny aplikacji. Przełączniki zgodności zwykle przywracają zachowanie (na przykład sposób sortowania ciągów), które zostały zmienione między wersjami .NET Framework.  Są one ustawiane przez wywołanie <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> metody przed utworzeniem domeny aplikacji.  
  
 W poniższej tabeli przedstawiono przykłady przełączników zgodności, które można ustawić w celu przywrócenia zachowania wcześniejszych wersji .NET Framework.  
  
|Przełącznik|Znaczenie|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Zabezpieczenia dostępu kodu (CAS) dla programu [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] są włączone w tej domenie aplikacji. [ Zobacz&lt;elementNetFx40_LegacySecurityPolicy&gt; ](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Wartości domyślne sortowania ciągu dla [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] programu są włączone w tej domenie aplikacji. Jego powodzenie wymaga zainstalowania sort00001000. dll. [ Zobacz&lt;elementCompatSortNLSVersion&gt; ](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Wartości domyślne sortowania ciągów dla [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]i Unicode 5,0 są włączone w tej domenie aplikacji. Jego powodzenie wymaga zainstalowania sort00060101. dll.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan>zachowanie formatowania dla programu [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] jest włączone w tej domenie aplikacji.  <xref:System.TimeSpan> Zobacz [ &lt;elementTimeSpan_LegacyFormatMode&gt; ](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) oraz sekcję "Przywracanie starszego formatowania TimeSpan" w temacie.|  
|"UseRandomizedStringHashAlgorithm"|Środowisko uruchomieniowe oblicza kody skrótów dla ciągów na podstawie poszczególnych domen aplikacji zamiast używać jednego algorytmu skrótu, który tworzy spójny kod skrótu w domenach aplikacji. [ Zobacz&lt;elementUseRandomizedStringHashAlgorithm&gt; ](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy domena aplikacji jest domyślną domeną dla procesu.</summary>
        <returns><see langword="true" />Jeśli bieżący <see cref="T:System.AppDomain" /> obiekt reprezentuje domyślną domenę aplikacji dla tego procesu; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy zarządzany proces ma domyślną domenę aplikacji. Wykonanie rozpocznie się w domenie domyślnej.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy drugą domenę aplikacji i wyświetla informacje o domenie domyślnej i nowej domenie.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy ta domena aplikacji jest wyładowywanie, a zawarte w niej obiekty są finalizowane przez środowisko uruchomieniowe języka wspólnego.</summary>
        <returns><see langword="true" />Jeśli ta domena aplikacji jest wyładowania i środowisko uruchomieniowe języka wspólnego rozpoczęło wywoływanie finalizatorów; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda finalizowania dla obiektu zapewnia możliwość wykonania wszelkich niezbędnych operacji czyszczenia, zanim obiekt zostanie pobrany jako element bezużyteczny. Po sfinalizowaniu obiekt jest dostępny, ale w nieprawidłowym stanie i dlatego nie można go użyć. Ostatecznie wyrzucanie elementów bezużytecznych kończy się i przejmuje obiekt.  
  
 Metoda finalizowania obiektu jest wywoływana w jednej z następujących sytuacji: podczas wyrzucania elementów bezużytecznych, gdy trwa zamykanie środowiska uruchomieniowego języka wspólnego lub gdy domena aplikacji, która zawiera obiekt jest zwolniona. Metoda zwraca `true` tylko w ostatnim przypadku; nie zwraca `true` , jeśli finalizacja wynika z rutynowego odzyskiwania pamięci lub z zamykania środowiska CLR. <xref:System.AppDomain.IsFinalizingForUnload%2A>  
  
> [!NOTE]
>  Aby ustalić, czy finalizowanie jest spowodowane zamknięciem środowiska CLR, <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> Użyj właściwości. Zwraca wartość `true` , jeśli finalizacja jest spowodowana przez zwolnioną domenę aplikacji lub zamknięcie środowiska CLR.  
  
 Podczas wykonywania w metodzie finalizowania podczas zwalniania domeny możesz chcieć uzyskać dostęp do innego obiektu, do którego odwołuje się pole statyczne i która ma metodę finalizacji. Nie można jednak wykonać niezawodnej, ponieważ obiekt, do którego uzyskano dostęp, mógł już zostać sfinalizowany.  
  
> [!NOTE]
>  Wyjątkiem od <xref:System.Console> tej reguły jest Klasa, która zawiera pola statyczne, które odwołują się do obiektów strumienia, ale jest implementowane w taki sposób, aby zawsze można było zapisywać dane w konsoli systemowej nawet podczas wyładowywania z domeny lub zamknięcia systemu.  
  
 Użyj tej metody w metodzie finalizowania obiektu, aby określić, czy domena aplikacji, która zawiera obiekt, jest zwalniana. W takim przypadku nie można w sposób niezawodny uzyskać dostępu do żadnego obiektu, który ma metodę finalizacji i jest przywoływany przez pole statyczne.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy zestawy, które są ładowane do bieżącej domeny aplikacji, są wykonywane z pełnym zaufaniem.</summary>
        <value><see langword="true" />Jeśli zestawy, które są ładowane do bieżącej domeny aplikacji, są wykonywane z pełnym zaufaniem; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zawsze zwraca `true` wartość dla domyślnej domeny aplikacji działającej na pulpicie. Zwraca `false` dla domeny aplikacji w trybie piaskownicy, która została utworzona przy <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> użyciu przeciążenia metody, chyba że uprawnienia przyznane domenie aplikacji są równoważne z pełnym zaufaniem.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.AppDomain.IsFullyTrusted%2A> Właściwość <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i właściwość z w pełni zaufanych i częściowo zaufanych domenach aplikacji. W pełni zaufana domena aplikacji jest domyślną domeną aplikacji dla aplikacji. Domena częściowo zaufanej aplikacji jest tworzona przy użyciu <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> przeciążenia metody.  
  
 W przykładzie zastosowano `Worker` klasę, która pochodzi <xref:System.MarshalByRefObject>od, dlatego można ją zorganizować między granicami domeny aplikacji. Przykład tworzy `Worker` obiekt w domenie domyślnej aplikacji. Następnie wywołuje `TestIsFullyTrusted` metodę, aby wyświetlić wartość właściwości dla domeny aplikacji i dla dwóch zestawów, które są ładowane do domeny aplikacji: mscorlib, która jest częścią .NET Framework i przykładowym zestawem. Domena aplikacji jest w pełni zaufana, dlatego oba zestawy są w pełni zaufane.  
  
 Przykład tworzy inny `Worker` obiekt w domenie aplikacji w trybie piaskownicy i ponownie `TestIsFullyTrusted` wywołuje metodę. Element mscorlib jest zawsze zaufany, nawet w domenie częściowo zaufanej aplikacji, ale przykładowy zestaw jest częściowo zaufany.  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżąca domena aplikacji ma zestaw uprawnień, które są przydzielane do wszystkich zestawów, które są ładowane do domeny aplikacji.</summary>
        <value><see langword="true" />Jeśli bieżąca domena aplikacji ma jednorodny zestaw uprawnień; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `true` dla domen aplikacji w trybie piaskownicy, które zostały utworzone <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> przy użyciu przeciążenia metody. Domeny aplikacji w trybie piaskownicy mają jednorodny zestaw uprawnień; oznacza to, że ten sam zestaw uprawnień jest przyznawany dla wszystkich częściowo zaufanych zestawów, które są ładowane do domeny aplikacji. Domena aplikacji w trybie piaskownicy opcjonalnie ma listę zestawów o silnych nazwach, które są wykluczone z tego zestawu uprawnień, a zamiast tego są uruchamiane z pełnym zaufaniem.  
  
 W pełni zaufany kod może użyć <xref:System.AppDomain.PermissionSet%2A> właściwości, aby określić jednorodny zbiór uprawnień domeny aplikacji w trybie piaskownicy.  
  
 Ta właściwość zwraca `true` również dla domyślnej domeny aplikacji klasycznej, ponieważ ta domena aplikacji przyznaje pełne zaufanie do wszystkich zestawów.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Reflection.Assembly" /> Ładuje do tej domeny aplikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica typu <see langword="byte" /> , który jest obrazem opartym na formacie COFF zawierającym emitowany zestaw.</param>
        <summary>Ładuje obraz <see cref="T:System.Reflection.Assembly" />ze standardowym formatem plików (COFF) zawierający emitowany element. <see cref="T:System.Reflection.Assembly" /></summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od, poziom zaufania zestawu, który jest ładowany przy użyciu tej metody, jest taki sam jak poziom zaufania domeny aplikacji. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]  
  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest zapewniana jako wygoda dla wywołujących współdziałających, którzy <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> nie mogą wywołać metody statycznej. Aby załadować zestawy do innych domen aplikacji, należy użyć metody takiej jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje wspólne dla wszystkich przeciążeń tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Przeciążenie metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie ładowania pierwotnego zestawu.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" />jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="rawAssembly" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Obiekt, który opisuje zestaw do załadowania.</param>
        <summary><see cref="T:System.Reflection.Assembly" /> Ładuje<see cref="T:System.Reflection.AssemblyName" />dany element.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest zapewniana jako wygoda dla wywołujących współdziałających, którzy <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> nie mogą wywołać metody statycznej. Aby załadować zestawy do innych domen aplikacji, należy użyć metody takiej jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Jeśli wersja żądanego zestawu jest już załadowana, Metoda ta zwraca załadowany zestaw, nawet jeśli zażądano innej wersji.  
  
 Dostarczenie częściowej nazwy zestawu dla `assemblyRef` nie jest zalecane. (Częściowa nazwa pomija co najmniej jedną kulturę, wersję lub token klucza publicznego. W przypadku przeciążeń, które pobierają <xref:System.Reflection.AssemblyName> ciąg zamiast obiektu, "z zestawu, Version = 1.0.0.0" jest przykładem częściowej nazwy i "webassembly, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 18ab3442da84b47" jest przykładem pełnej nazwy.) Korzystanie z nazw częściowych ma negatywny wpływ na wydajność. Ponadto częściowa nazwa zestawu może ładować zestaw z globalnej pamięci podręcznej zestawów tylko wtedy, gdy istnieje dokładna kopia zestawu w katalogu podstawowym aplikacji (<xref:System.AppDomain.BaseDirectory%2A> lub <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).  
  
 Jeśli bieżący <xref:System.AppDomain> obiekt reprezentuje domenę `A`aplikacji, a <xref:System.AppDomain.Load%2A> Metoda jest wywoływana z domeny `B`aplikacji, zestaw jest ładowany do obu domen aplikacji. Na przykład poniższy kod ładuje `MyAssembly` do nowej domeny `ChildDomain` aplikacji, a także do domeny aplikacji, w której wykonywany jest kod:  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 Zestaw jest ładowany do obu domen, ponieważ <xref:System.Reflection.Assembly> nie pochodzi od <xref:System.MarshalByRefObject>, i <xref:System.AppDomain.Load%2A> w związku z tym nie można zorganizować wartości zwracanej przez metodę. Zamiast tego środowisko uruchomieniowe języka wspólnego próbuje załadować zestaw do domeny aplikacji wywołującej. Zestawy, które są ładowane do dwóch domen aplikacji mogą się różnić, jeśli ustawienia ścieżki dla dwóch domen aplikacji są różne.  
  
> [!NOTE]
>  Jeśli właściwość i właściwość są ustawione, podczas pierwszej próby załadowania zestawu zostanie użyta nazwa wyświetlana (w tym wersja, kultura itd.) <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> , która jest zwracana przez właściwość. <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> Jeśli plik nie zostanie znaleziony, <xref:System.Reflection.AssemblyName.CodeBase%2A> właściwość jest używana do wyszukiwania zestawu. Jeśli zestaw zostanie znaleziony przy użyciu <xref:System.Reflection.AssemblyName.CodeBase%2A>, nazwa wyświetlana zostanie dopasowana do zestawu. Jeśli dopasowanie nie powiedzie się <xref:System.IO.FileLoadException> , zostanie zgłoszony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef" />nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyRef" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary><see cref="T:System.Reflection.Assembly" /> Ładuje podaną nazwę wyświetlaną.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest zapewniana jako wygoda dla wywołujących współdziałających, którzy <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> nie mogą wywołać metody statycznej. Aby załadować zestawy do innych domen aplikacji, należy użyć metody takiej jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje wspólne dla wszystkich przeciążeń tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" />była<see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" />nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyString" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica typu <see langword="byte" /> , który jest obrazem opartym na formacie COFF zawierającym emitowany zestaw.</param>
        <param name="rawSymbolStore">Tablica typu <see langword="byte" /> zawierającego nieprzetworzone bajty reprezentujące symbole dla zestawu.</param>
        <summary>Ładuje obraz <see cref="T:System.Reflection.Assembly" />ze standardowym formatem plików (COFF) zawierający emitowany element. <see cref="T:System.Reflection.Assembly" /> Bajty pierwotne reprezentujące symbole dla <see cref="T:System.Reflection.Assembly" /> programu są również ładowane.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od, poziom zaufania zestawu, który jest ładowany przy użyciu tej metody, jest taki sam jak poziom zaufania domeny aplikacji. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]  
  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest zapewniana jako wygoda dla wywołujących współdziałających, którzy <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> nie mogą wywołać metody statycznej. Aby załadować zestawy do innych domen aplikacji, należy użyć metody takiej jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje wspólne dla wszystkich przeciążeń tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Przeciążenie metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie ładowania pierwotnego zestawu.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" />jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="rawAssembly" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Obiekt, który opisuje zestaw do załadowania.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary><see cref="T:System.Reflection.Assembly" /> Ładuje<see cref="T:System.Reflection.AssemblyName" />dany element.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest zapewniana jako wygoda dla wywołujących współdziałających, którzy <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> nie mogą wywołać metody statycznej. Aby załadować zestawy do innych domen aplikacji, należy użyć metody takiej jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje wspólne dla wszystkich przeciążeń tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" />była<see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef" />nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyRef" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania ścieżki, która nie jest w postaci "File://" lub "\\\UNC\dir\\" lub "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary><see cref="T:System.Reflection.Assembly" /> Ładuje podaną nazwę wyświetlaną.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest zapewniana jako wygoda dla wywołujących współdziałających, którzy <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> nie mogą wywołać metody statycznej. Aby załadować zestawy do innych domen aplikacji, należy użyć metody takiej jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje wspólne dla wszystkich przeciążeń tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" />była<see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" />nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="assemblyString" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania ścieżki, która nie jest w postaci "File://" lub "\\\UNC\dir\\" lub "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica typu <see langword="byte" /> , który jest obrazem opartym na formacie COFF zawierającym emitowany zestaw.</param>
        <param name="rawSymbolStore">Tablica typu <see langword="byte" /> zawierającego nieprzetworzone bajty reprezentujące symbole dla zestawu.</param>
        <param name="securityEvidence">Dowód ładowania zestawu.</param>
        <summary>Ładuje obraz <see cref="T:System.Reflection.Assembly" />ze standardowym formatem plików (COFF) zawierający emitowany element. <see cref="T:System.Reflection.Assembly" /> Bajty pierwotne reprezentujące symbole dla <see cref="T:System.Reflection.Assembly" /> programu są również ładowane.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od, poziom zaufania zestawu, który jest ładowany przy użyciu tej metody, jest taki sam jak poziom zaufania domeny aplikacji. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]  
  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest zapewniana jako wygoda dla wywołujących współdziałających, którzy <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> nie mogą wywołać metody statycznej. Aby załadować zestawy do innych domen aplikacji, należy użyć metody takiej jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje wspólne dla wszystkich przeciążeń tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> Przeciążenie metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie ładowania pierwotnego zestawu.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" />jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" />nie jest prawidłowym zestawem.  
  
—lub— 
Wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego jest aktualnie załadowana i <paramref name="rawAssembly" /> została skompilowana przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="securityEvidence" />nie <see langword="null" />jest. Jeśli starsze zasady urzędów certyfikacji nie są <paramref name="securityEvidence" /> włączone, <see langword="null" />powinny być.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania ścieżki, która nie jest w postaci "File://" lub "\\\UNC\dir\\" lub "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy dla bieżącego procesu jest włączone monitorowanie procesora CPU i pamięci dla domen aplikacji. Po włączeniu monitorowania dla procesu nie można go wyłączyć.</summary>
        <value><see langword="true" />Jeśli monitorowanie jest włączone; w <see langword="false" />przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta `static` Właściwość (`Shared` właściwość w Visual Basic) służy do kontrolowania monitorowania procesora i pamięci wszystkich domen aplikacji w procesie.  
  
 Jeśli podjęto próbę ustawienia tej właściwości `false`na <xref:System.ArgumentException> , zgłaszany jest wyjątek, nawet jeśli bieżąca wartość właściwości jest `false`.  
  
 Po <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>włączeniu monitorowania można użyć właściwości wystąpienia, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>i <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> , aby monitorować użycie procesora i pamięci poszczególnych domen aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący proces podjął próbę przypisania wartości <see langword="false" /> do tej właściwości.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Monitorowanie zasobów domen aplikacji</related>
        <related type="Article" href="https://msdn.microsoft.com/library/02119ab6-1e91-448e-97ad-e7b2e5c4bbbd">&lt;appdomainResourceMonitoring&gt; , element</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę bajtów, które przeżyły ostatnią kolekcję i które są znane do odwołania przez bieżącą domenę aplikacji.</summary>
        <value>Liczba pozostałych bajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statystyki są aktualizowane przy użyciu poszczególnych wyrzucania elementów bezużytecznych. Jednak są one gwarantowane dokładne tylko po pełnej, blokującej kolekcji; oznacza to, że kolekcja obejmująca wszystkie generacje i która zatrzyma aplikację podczas zbierania. Na przykład <xref:System.GC.Collect?displayProperty=nameWithType> Przeciążenie metody wykonuje pełną, blokującą kolekcję. (Współbieżna kolekcja odbywa się w tle i nie blokuje aplikacji).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość <see langword="static" /> ( <see cref="P:System.AppDomain.MonitoringIsEnabled" /> wVisualBasic<see langword="false" />) ma ustawioną wartość.<see langword="Shared" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Monitorowanie zasobów domen aplikacji</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączną liczbę bajtów przetworzonych z ostatniej kolekcji dla wszystkich domen aplikacji w procesie.</summary>
        <value>Całkowita liczba pozostałych bajtów dla procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po pełnej, blokującej kolekcji ta liczba reprezentuje liczbę bajtów, które są obecnie przechowywane na stertach zarządzanych. Powinien być blisko liczby zgłoszonej przez <xref:System.GC.GetTotalMemory%2A> metodę. Po utworzeniu tymczasowej kolekcji ta liczba reprezentuje liczbę aktualnie przechowywanych bajtów w tymczasowych generacjach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość <see langword="static" /> ( <see cref="P:System.AppDomain.MonitoringIsEnabled" /> wVisualBasic<see langword="false" />) ma ustawioną wartość.<see langword="Shared" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Monitorowanie zasobów domen aplikacji</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączny rozmiar (w bajtach) wszystkich alokacji pamięci wykonanych przez domenę aplikacji od momentu utworzenia, bez odejmowania pamięci, która została zebrana.</summary>
        <value>Łączny rozmiar wszystkich alokacji pamięci.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość <see langword="static" /> ( <see cref="P:System.AppDomain.MonitoringIsEnabled" /> wVisualBasic<see langword="false" />) ma ustawioną wartość.<see langword="Shared" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Monitorowanie zasobów domen aplikacji</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączny czas procesora, który był używany przez wszystkie wątki podczas wykonywania w bieżącej domenie aplikacji, od momentu rozpoczęcia procesu.</summary>
        <value>Łączny czas procesora dla bieżącej domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Łączny czas, który jest raportowany dla domeny aplikacji, obejmuje czas spędzony przez każdy wątek w procesie w tej domenie aplikacji.  
  
 Wątek, który wywołuje kod niezarządzany, jest nadal skojarzony z domeną aplikacji, a czas procesora poświęcony na wykonywanie kodu niezarządzanego jest raportowany dla domeny aplikacji, w której wykonano wywołanie.  
  
 Gdy wątek jest zablokowany lub uśpiony, nie zużywa czasu procesora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość <see langword="static" /> ( <see cref="P:System.AppDomain.MonitoringIsEnabled" /> wVisualBasic<see langword="false" />) ma ustawioną wartość.<see langword="Shared" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Monitorowanie zasobów domen aplikacji</related>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestaw uprawnień domeny aplikacji w trybie piaskownicy.</summary>
        <value>Zestaw uprawnień domeny aplikacji w trybie piaskownicy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domeny aplikacji w trybie piaskownicy, które zostały utworzone <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> przy użyciu przeciążenia metody, mają jednorodny zestaw uprawnień. oznacza to, że ten sam zestaw uprawnień jest przyznawany wszystkim częściowo zaufanym zestawom, które są ładowane do domeny aplikacji. Domena aplikacji w trybie piaskownicy opcjonalnie ma listę zestawów o silnych nazwach, które są wykluczone z tego zestawu uprawnień, a zamiast tego są uruchamiane z pełnym zaufaniem.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy domyślny proces nadrzędny domeny aplikacji zostanie zakończony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler> Dla tego zdarzenia można wykonać działania zakończenia, takie jak zamykanie plików, zwalnianie magazynu i tak dalej, zanim zakończy się proces.  
  
 Począwszy od .NET Framework w wersji 2,0, to zdarzenie jest zgłaszane w każdej domenie aplikacji, która rejestruje procedurę obsługi zdarzeń.  
  
> [!NOTE]
>  W .NET Framework łączny czas wykonywania wszystkich <xref:System.AppDomain.ProcessExit> programów obsługi zdarzeń jest ograniczony, tak jak całkowity czas wykonywania wszystkich finalizatorów jest ograniczony podczas zamykania procesu. Wartość domyślna to dwie sekundy. Niezarządzany host może zmienić ten czas wykonywania, wywołując metodę [ICLRPolicyManager:: setTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) z wartością wyliczenia [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) . Ten limit czasu nie istnieje w programie .NET Core.  
  
 W .NET Framework wersje 1,0 i 1,1 to zdarzenie jest wywoływane tylko w domenie aplikacji domyślnej i tylko wtedy, gdy program obsługi zdarzeń jest zarejestrowany w domyślnej domenie aplikacji.  
  
 Aby zarejestrować procedurę obsługi zdarzeń dla tego zdarzenia, musisz mieć wymagane uprawnienia lub <xref:System.Security.SecurityException> zgłaszać.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy rozpoznawanie zestawu zakończy się niepowodzeniem w kontekście tylko odbicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kontekście tylko odbicia zależności nie są rozwiązywane automatycznie. Muszą być wstępnie załadowane lub zwrócone przez program obsługi dla tego zdarzenia. To zdarzenie jest zgłaszane, gdy zestaw ma zależność, która nie została jeszcze załadowana do kontekstu tylko odbicie. Brakująca zależność jest określona przez <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> właściwość. <xref:System.ResolveEventHandler> Dla tego zdarzenia należy zwrócić zestaw, który spełnia zależność. Zestaw, który jest zwracany, musi być załadowany do kontekstu tylko odbicie.  
  
> [!IMPORTANT]
>  To zdarzenie jest wywoływane tylko w przypadku brakujących zależności zestawu, które są ładowane do kontekstu tylko odbicie (na przykład za pomocą <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> metody). Nie zostanie zgłoszony, jeśli nie można odnaleźć zestawu, który ładujesz.  
  
 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]Począwszy od<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> , właściwość zwraca zestaw, który zażądał obciążenia zestawu, którego nie można rozpoznać. Wiedząc, że tożsamość zestawu żądającego może być przydatna do identyfikowania poprawnej wersji zależności, jeśli dostępna jest więcej niż jedna wersja. Aby uzyskać więcej informacji, zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Dla tego zdarzenia <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> Właściwość zwraca nazwę zestawu przed zastosowaniem zasad.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca zestawy, które zostały załadowane do kontekstu przeznaczonego tylko do odbicia w domenie aplikacji.</summary>
        <returns>Tablica <see cref="T:System.Reflection.Assembly" /> obiektów reprezentujących zestawy ładowane do kontekstu tylko odbicie w domenie aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zestawy, które zostały załadowane do kontekstu tylko odbicie. Aby uzyskać zestawy, które zostały załadowane do wykonania, użyj <xref:System.AppDomain.GetAssemblies%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu ładuje zestaw system. dll do kontekstu wykonywania, a następnie do kontekstu tylko odbicie. Metody <xref:System.AppDomain.GetAssemblies%2A> i<xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> są używane do wyświetlania zestawów ładowanych do poszczególnych kontekstów.  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Podjęto próbę wykonania operacji w niezaładowanym domenie aplikacji.</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę do katalogu podstawowego, w którym program rozpoznawania zestawu powinien sondować dla zestawów prywatnych.</summary>
        <value>Ścieżka w katalogu podstawowym, w której program rozpoznawania zestawu powinien sondować dla zestawów prywatnych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestawy prywatne są wdrażane w tej samej strukturze katalogów co aplikacja. Jeśli ścieżka określona przez <xref:System.AppDomain.RelativeSearchPath%2A> właściwość nie jest w obszarze <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, zostanie zignorowana.  
  
 Ta właściwość zwraca wartość ustawioną przy <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>użyciu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy rozpoznawanie zasobu nie powiedzie się, ponieważ zasób nie jest prawidłowym połączonym lub osadzonym zasobem w zestawie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ResolveEventHandler> Dla tego zdarzenia można spróbować zlokalizować zestaw zawierający zasób i zwrócić go.  
  
> [!IMPORTANT]
>  To zdarzenie nie jest zgłaszane, jeśli rozwiązanie nie powiedzie się, ponieważ nie można odnaleźć pliku dla prawidłowego połączonego zasobu. Jest zgłaszany, jeśli nie można odnaleźć strumienia zasobów manifestu, ale nie zostanie zgłoszony, jeśli nie można odnaleźć klucza zasobu.  
  
 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]Począwszy od<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> , właściwość zawiera zestaw, który zażądał zasobu. Aby uzyskać więcej informacji, zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Aby zarejestrować procedurę obsługi zdarzeń dla tego zdarzenia, musisz mieć wymagane uprawnienia lub <xref:System.Security.SecurityException> zgłaszać.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">Poziom zasad zabezpieczeń.</param>
        <summary>Ustanawia poziom zasad zabezpieczeń dla tej domeny aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę przed załadowaniem zestawu do <xref:System.AppDomain> w celu zapewnienia, że zasady zabezpieczeń mają wpływ.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.AppDomain.SetAppDomainPolicy%2A> metody w celu ustawienia poziomu zasad zabezpieczeń domeny aplikacji.  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domainPolicy" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Poziom zasad zabezpieczeń został już ustawiony.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">W pełni kwalifikowana ścieżka do lokalizacji kopii w tle.</param>
        <summary>Określa ścieżkę katalogu jako lokalizację, w której zestawy są kopiowane w tle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ścieżka pamięci podręcznej jest ignorowana, jeśli <xref:System.AppDomainSetup.ApplicationName%2A> właściwość nie jest ustawiona. <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> Zobacz właściwość.  
  
 Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przypisuje wartość do właściwości domeny aplikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości domeny aplikacji zdefiniowanej przez użytkownika do utworzenia lub zmiany.</param>
        <param name="data">Wartość właściwości.</param>
        <summary>Przypisuje określoną wartość do określonej właściwości domeny aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby wstawić wpis lub zmodyfikować wartość wpisu w wewnętrznej pamięci podręcznej par nazwa-dane, które opisują właściwości tego wystąpienia <xref:System.AppDomain>.  
  
 Pamięć podręczna programu automatycznie zawiera wstępnie zdefiniowane wpisy systemowe, które są wstawiane podczas tworzenia domeny aplikacji. Nie można wstawiać ani modyfikować wpisów systemowych za pomocą tej metody. Wywołanie metody, które próbuje zmodyfikować wpis systemu, nie ma żadnego wpływu; Metoda nie zgłasza wyjątku. Można sprawdzić wartości wpisów systemowych przy użyciu <xref:System.AppDomain.GetData%2A> metody lub równoważne <xref:System.AppDomainSetup> właściwości opisane w <xref:System.AppDomain.GetData%2A>.  
  
 Można wywołać tę metodę, aby ustawić wartość domyślnego interwału limitu czasu dla oceny wzorców wyrażenia regularnego przez podanie "REGEX_DEFAULT_MATCH_TIMEOUT" jako wartości `name` argumentu <xref:System.TimeSpan> i wartości, która reprezentuje limit czasu interwał jako wartość `data` argumentu. Możesz również wstawić lub zmodyfikować własne zdefiniowane przez użytkownika pary nazwa-dane za pomocą tej metody i zbadać ich wartości za pomocą <xref:System.AppDomain.GetData%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> jak za pomocą metody utworzyć nową parę wartości. W przykładzie zostanie użyta <xref:System.AppDomain.GetData%2A> Metoda pobrania wartości i zostanie ona wyświetlona w konsoli programu.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="permission" Type="System.Security.IPermission" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości domeny aplikacji zdefiniowanej przez użytkownika do utworzenia lub zmiany.</param>
        <param name="data">Wartość właściwości.</param>
        <param name="permission">Uprawnienie do żądania obiektu wywołującego podczas pobierania właściwości.</param>
        <summary>Przypisuje określoną wartość do określonej właściwości domeny aplikacji z określonym uprawnieniem do żądania obiektu wywołującego podczas pobierania właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do wstawiania lub modyfikowania własnych wpisów zdefiniowanych przez użytkownika w wewnętrznej pamięci podręcznej par nazwa/dane, które opisują właściwości domeny aplikacji. Podczas wstawiania wpisu można określić żądanie uprawnienia, które ma zostać wymuszone, gdy wpis zostanie pobrany. Ponadto można wywołać tę metodę, aby ustawić wartość domyślnego interwału limitu czasu dla oceny wzorców wyrażeń regularnych przez dostarczenie "REGEX_DEFAULT_MATCH_TIMEOUT" jako wartości `name` argumentu <xref:System.TimeSpan> oraz wartości, która reprezentuje interwał limitu czasu jako wartość `data` argumentu.  
  
 Nie można użyć tej metody do przypisywania żądania zabezpieczeń do ciągu właściwości zdefiniowanej przez system.  
  
 Pamięć podręczna programu automatycznie zawiera wstępnie zdefiniowane wpisy systemowe, które są wstawiane podczas tworzenia domeny aplikacji. Nie można wstawiać ani modyfikować wpisów systemowych za pomocą tej metody. Wywołanie metody, które próbuje zmodyfikować wpis systemu, nie ma żadnego wpływu; Metoda nie zgłasza wyjątku. Wartości wpisów systemowych można sprawdzić za pomocą <xref:System.AppDomain.GetData%2A> metody lub równoważnych <xref:System.AppDomainSetup> właściwości opisanych w sekcji Uwagi dla <xref:System.AppDomain.GetData%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" />Określa zdefiniowany przez system ciąg właściwości i <paramref name="permission" /> nie <see langword="null" />jest.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">W pełni kwalifikowana ścieżka, która jest katalogiem podstawowym podkatalogów, w których są przechowywane zestawy dynamiczne.</param>
        <summary>Określa ścieżkę katalogu jako katalog podstawowy dla podkatalogów, w których są przechowywane i dostępne dynamicznie generowane pliki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia <xref:System.AppDomainSetup.DynamicBase%2A> Właściwość wewnętrznej <xref:System.AppDomainSetup> skojarzonej z tym wystąpieniem.  
  
   
  
## Examples  
 Ta metoda jest obecnie przestarzała i nie należy jej używać w nowych wdrożeniach. Poniższy przykład pokazuje, jak używać nieprzestarzałej alternatywy, <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> właściwości. Aby uzyskać wyjaśnienie tego przykładu, zobacz <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> Właściwość <xref:System.AppDomain.DynamicDirectory%2A> lub właściwość.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Jedna z <see cref="T:System.Security.Principal.PrincipalPolicy" /> wartości, która określa typ obiektu podmiotu zabezpieczeń do dołączenia do wątków.</param>
        <summary>Określa, w jaki sposób obiekty Principal i Identity powinny być dołączone do wątku, jeśli wątek podejmie próbę powiązania z podmiotem zabezpieczeń podczas wykonywania w tej domenie aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej wartości będzie obowiązywać dopiero po ustawieniu jej przed użyciem <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> właściwości. Na <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> przykład jeśli ustawisz dla danego podmiotu zabezpieczeń (na przykład generyczne główne), a następnie <xref:System.AppDomain.SetPrincipalPolicy%2A> użyjesz metody do ustawienia <xref:System.Security.Principal.PrincipalPolicy> do <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, bieżący podmiot zabezpieczeń pozostanie generycznym podmiotem zabezpieczeń.  
  
   
  
## Examples  
 Poniższy przykład ilustruje wpływ na wątki przy użyciu <xref:System.AppDomain.SetPrincipalPolicy%2A> metody do zmiany zasad głównych domeny aplikacji. Przedstawiono w nim również efekt użycia <xref:System.AppDomain.SetThreadPrincipal%2A> metody do zmiany podmiotu zabezpieczeń, który jest dostępny do dołączania do wątków w domenie aplikacji.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby móc manipulować głównym przedmiotem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Włącza kopiowanie w tle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Ta metoda jest obecnie przestarzała i nie należy jej używać w nowych wdrożeniach.  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Lista nazw katalogów, w których każda nazwa jest oddzielona średnikami.</param>
        <summary>Ustanawia określoną ścieżkę katalogu jako lokalizację zestawów do skopiowania w tle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie kopia w tle obejmuje wszystkie zestawy znalezione przy użyciu sondowania. Metoda ogranicza kopiowanie w tle do zestawów w katalogach określonych przez `path`. <xref:System.AppDomain.SetShadowCopyPath%2A>  
  
 <xref:System.AppDomain.SetShadowCopyPath%2A> Metoda nie określa dodatkowych katalogów do przeszukania zestawów. Zestawy, które mają być kopiowane w tle, muszą już znajdować się w ścieżce wyszukiwania, <xref:System.AppDomain.BaseDirectory%2A>na przykład w obszarze. <xref:System.AppDomain.SetShadowCopyPath%2A> Metoda określa, które ścieżki wyszukiwania kwalifikują się do kopiowania w tle.  
  
 Ta metoda ustawia <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> Właściwość wewnętrznej <xref:System.AppDomainSetup> skojarzonej z tym wystąpieniem.  
  
 Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Ta metoda jest obecnie przestarzała i nie należy jej używać w nowych wdrożeniach.  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">Obiekt Principal do dołączenia do wątków.</param>
        <summary>Ustawia domyślny obiekt Principal do dołączenia do wątków, jeśli spróbuje powiązać się z podmiotem zabezpieczeń podczas wykonywania w tej domenie aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ilustruje efekt <xref:System.AppDomain.SetThreadPrincipal%2A> zastosowania metody do zmiany podmiotu zabezpieczeń, który jest dostępny do dołączania do wątków, które są wykonywane w domenie aplikacji. Przedstawiono w nim również wpływ na wątki używające <xref:System.AppDomain.SetPrincipalPolicy%2A> metody do zmiany głównych zasad domeny aplikacji.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="principal" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Podmiot zabezpieczeń wątku został już ustawiony.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby móc manipulować głównym przedmiotem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o konfiguracji domeny aplikacji dla tego wystąpienia.</summary>
        <value>Informacje o inicjalizacji domeny aplikacji.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informację o tym, czy domena aplikacji jest skonfigurowana do kopiowania plików w tle.</summary>
        <value><see langword="true" />Jeśli domena aplikacji jest skonfigurowana do kopiowania plików w tle; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> Zobacz i [zestawy kopiowania w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetIDsOfNames`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetTypeInfo`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetTypeInfoCount`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::Invoke`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje reprezentację w postaci ciągu, która zawiera przyjazną nazwę domeny aplikacji i wszystkie zasady kontekstowe.</summary>
        <returns>Ciąg utworzony przez konkatenację ciągu literału "Name:", przyjazną nazwę domeny aplikacji oraz ciąg reprezentacji zasad kontekstu lub ciąg "nie ma zasad kontekstu".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.AppDomain.ToString%2A> zwracaną metody.  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Domena aplikacji reprezentowana przez bieżącą <see cref="T:System.AppDomain" /> została zwolniona.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy rozpoznanie typu nie powiedzie się.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.TypeResolve> Zdarzenie występuje, gdy środowisko uruchomieniowe języka wspólnego nie może ustalić zestawu, który może utworzyć żądany typ. Taka sytuacja może wystąpić, jeśli typ jest zdefiniowany w zestawie dynamicznym lub typ nie jest zdefiniowany w zestawie dynamicznym, ale środowisko uruchomieniowe nie wie, który zestaw jest zdefiniowany w. Ta ostatnia sytuacja może wystąpić, <xref:System.Type.GetType%2A?displayProperty=nameWithType> gdy jest wywoływana przy użyciu nazwy typu, która nie jest kwalifikowana z nazwą zestawu.  
  
 <xref:System.ResolveEventHandler> Dla tego zdarzenia można spróbować zlokalizować i utworzyć typ.  
  
 Jednak <xref:System.AppDomain.TypeResolve> zdarzenie nie występuje, jeśli środowisko uruchomieniowe wie, że nie można znaleźć typu w niektórych zestawach. Na przykład to zdarzenie nie występuje, jeśli typ nie zostanie znaleziony w zestawie statycznym, ponieważ typy znanego środowiska uruchomieniowego nie mogą być dodawane dynamicznie do zestawów statycznych.  
  
 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]Począwszy od<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> , właściwość zawiera zestaw, który zażądał typu. Aby uzyskać więcej informacji, zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Aby zarejestrować procedurę obsługi zdarzeń dla tego zdarzenia, musisz mieć wymagane uprawnienia lub <xref:System.Security.SecurityException> zgłaszać.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.AppDomain.TypeResolve> zdarzenie.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek nie zostanie przechwycony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie zapewnia powiadomienie o nieprzechwyconych wyjątkach. Dzięki temu aplikacja może rejestrować informacje o wyjątku przed użyciem domyślnej procedury obsługi przez system, a następnie kończy działanie aplikacji. Jeśli jest dostępna wystarczająca ilość informacji o stanie aplikacji, można podjąć inne działania — takie jak zapisywanie danych programu do późniejszego odzyskiwania. Należy zachować ostrożność, ponieważ dane programu mogą ulec uszkodzeniu, gdy wyjątki nie są obsługiwane.  
  
> [!NOTE]
>  W .NET Framework wersje 1,0 i 1,1 Opcje zakończenia i debugowania aplikacji są raportowane użytkownikowi przed podjęciem tego zdarzenia, a nie po.  
  
 To zdarzenie może być obsługiwane w dowolnej domenie aplikacji. Jednak zdarzenie nie jest zawsze zgłaszane w domenie aplikacji, w której wystąpił wyjątek. Wyjątek jest nieobsługiwany tylko wtedy, gdy cały stos wątku został odłączony bez znajdowania odpowiedniego programu obsługi wyjątków, więc pierwsze miejsce, w którym zdarzenie może zostać wywołane, znajduje się w domenie aplikacji, z której pochodzi wątek.  
  
> [!NOTE]
>  W .NET Framework wersje 1,0 i 1,1 to zdarzenie występuje tylko w przypadku domyślnej domeny aplikacji utworzonej przez system podczas uruchamiania aplikacji. Jeśli aplikacja tworzy dodatkowe domeny aplikacji, określenie delegata tego zdarzenia w tych domenach nie ma żadnego wpływu.  
  
 <xref:System.AppDomain.UnhandledException> Jeśli zdarzenie jest obsługiwane w domyślnej domenie aplikacji, zostanie zgłoszone dla dowolnego nieobsłużonego wyjątku w dowolnym wątku, niezależnie od tego, jaką domenę aplikacji uruchomił wątek. Jeśli wątek uruchomiony w domenie aplikacji, która ma program obsługi zdarzeń dla <xref:System.AppDomain.UnhandledException>, zdarzenie jest zgłaszane w domenie aplikacji. Jeśli ta domena aplikacji nie jest domyślną domeną aplikacji i istnieje również procedura obsługi zdarzeń w domenie domyślnej aplikacji, zdarzenie jest zgłaszane w obu domenach aplikacji.  
  
 Załóżmy na przykład, że wątek zaczyna się w domenie aplikacji "AD1", wywołuje metodę w domenie aplikacji "AD2", a następnie wywołuje metodę w domenie aplikacji "AD3", w której zgłasza wyjątek. Pierwszą domeną aplikacji, w której <xref:System.AppDomain.UnhandledException> może zostać zgłoszone zdarzenie, jest "AD1". Jeśli ta domena aplikacji nie jest domyślną domeną aplikacji, zdarzenie może być również zgłaszane w domyślnej domenie aplikacji.  
  
> [!NOTE]
>  Czas wykonywania wątku w środowisku uruchomieniowym języka wspólnego zostanie przerwany, gdy programy obsługi <xref:System.AppDomain.UnhandledException> zdarzeń dla zdarzenia są wykonywane.  
  
 Jeśli program obsługi zdarzeń ma <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atrybut z odpowiednimi flagami, program obsługi zdarzeń jest traktowany jako ograniczony region wykonania.  
  
 Począwszy od <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> , to zdarzenie nie jest wywoływane w przypadku wyjątków, które uszkadzają stan procesu, takich jak przepełnienia stosu lub naruszenia zasad dostępu, chyba że program obsługi zdarzeń ma krytyczne znaczenie dla zabezpieczeń i ma atrybut. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]  
  
 W .NET Framework wersje 1,0 i 1,1, nieobsłużony wyjątek występujący w wątku innym niż główny wątek aplikacji jest przechwytywany przez środowisko uruchomieniowe i w związku z tym nie powoduje przerwania działania aplikacji. W ten sposób można zgłaszać zdarzeniebezprzerywaniadziałaniaaplikacji.<xref:System.AppDomain.UnhandledException> Począwszy od .NET Framework w wersji 2,0, ten wyjątek dla nieobsłużonych wyjątków w wątkach podrzędnych został usunięty, ponieważ skumulowany wpływ takich awarii nie obejmuje obniżenie wydajności, uszkodzenie danych i zawieszanie, z których wszystkie były trudne rozpocząć. Aby uzyskać więcej informacji, w tym listę przypadków, w których środowisko uruchomieniowe nie zostało zakończone, zobacz [wyjątki w zarządzanych wątkach](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
 Aby zarejestrować procedurę obsługi zdarzeń dla tego zdarzenia, musisz mieć wymagane uprawnienia lub <xref:System.Security.SecurityException> zgłaszać.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
## <a name="other-events-for-unhandled-exceptions"></a>Inne zdarzenia dla nieobsłużonych wyjątków  
 W przypadku niektórych modeli aplikacji <xref:System.AppDomain.UnhandledException> zdarzenie może być przechodzące przez inne zdarzenia, jeśli wystąpił nieobsługiwany wyjątek w wątku aplikacji głównej.  
  
 W aplikacjach, które używają Windows Forms, Nieobsłużone wyjątki w wątku aplikacji głównej powodują wystąpienie <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> zdarzenia. Jeśli to zdarzenie jest obsługiwane, zachowanie domyślne polega na tym, że nieobsługiwany wyjątek nie kończy działanie aplikacji, chociaż aplikacja pozostaje w nieznanym stanie. W takim przypadku <xref:System.AppDomain.UnhandledException> zdarzenie nie zostanie zgłoszone. To zachowanie można zmienić przy użyciu pliku konfiguracyjnego aplikacji lub przy użyciu <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> metody zmiany trybu na <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> przed <xref:System.Windows.Forms.Application.ThreadException> podłączaniem programu obsługi zdarzeń. Dotyczy to tylko głównego wątku aplikacji. <xref:System.AppDomain.UnhandledException> Zdarzenie jest zgłaszane w przypadku nieobsłużonych wyjątków zgłoszonych w innych wątkach.  
  
 Począwszy od Microsoft Visual Studio 2005, Visual Basic Framework aplikacji zapewnia inne zdarzenie dla nieobsłużonych wyjątków w wątku aplikacji głównej. <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> Zobacz zdarzenie. To zdarzenie ma obiekt argumentów zdarzeń o takiej samej nazwie, jak obiekt argumentów zdarzeń używany przez <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, ale z innymi właściwościami. W szczególności ten obiekt argumentów zdarzeń ma <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> właściwość, która umożliwia kontynuowanie działania aplikacji, ignorując nieobsłużony wyjątek (i pozostawiając aplikację w nieznanym stanie). W takim przypadku <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> zdarzenie nie zostanie zgłoszone.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.AppDomain.UnhandledException> zdarzenie. Definiuje procedurę obsługi zdarzeń, `MyHandler`która jest wywoływana za każdym razem, gdy w domenie aplikacji domyślnej zostanie zgłoszony nieobsługiwany wyjątek. Następnie zgłasza dwa wyjątki. Pierwszy jest obsługiwany przez blok **try/catch** . Druga jest nieobsługiwana i wywołuje `MyHandle` procedurę przed zakończeniem działania aplikacji.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">Domena aplikacji do zwolnienia.</param>
        <summary>Zwalnia określoną domenę aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W .NET Framework w wersji 2,0 istnieje wątek przeznaczony do zwalniania domen aplikacji. Zwiększa to niezawodność, szczególnie w przypadku, gdy .NET Framework jest hostowana. Podczas wywoływania <xref:System.AppDomain.Unload%2A>wątku domena docelowa jest oznaczona do wyładowania. Dedykowany wątek próbuje zwolnić domenę, a wszystkie wątki w domenie są przerywane. Jeśli wątek nie zostanie przerwany, na przykład ponieważ wykonuje kod niezarządzany lub, ponieważ wykonuje `finally` blok, a następnie po upływie czasu a <xref:System.CannotUnloadAppDomainException> jest zgłaszany w wątku, który pierwotnie został wywołany <xref:System.AppDomain.Unload%2A>. Jeśli wątek, który nie został ostatecznie przerwany, nie zostanie zwolniony z domeny docelowej. W związku z tym w .NET Framework w `domain` wersji 2,0 nie ma gwarancji, ponieważ nie jest możliwe zakończenie wykonywania wątków.  
  
> [!NOTE]
>  W niektórych przypadkach wywoływanie <xref:System.AppDomain.Unload%2A> powoduje natychmiastowe <xref:System.CannotUnloadAppDomainException>, na przykład jeśli jest wywoływana w finalizatorze.  
  
 Wątki w programie `domain` są kończone <xref:System.Threading.Thread.Abort%2A> przy użyciu <xref:System.Threading.ThreadAbortException> metody, która zgłasza w wątku. Mimo że wątek powinien kończyć się bezzwłocznie, może kontynuować wykonywanie w przypadku nieprzewidywalnej ilości czasu w `finally` klauzuli.  
  
## <a name="version-compatibility"></a>Zgodność wersji  
 W .NET Framework w wersji 1,0 i 1,1 Jeśli wątek, który wywołuje <xref:System.AppDomain.Unload%2A> , działa w `domain`programie, jest uruchamiany inny wątek w celu wykonania operacji Unload. Jeśli `domain` nie można zwolnić, zostanie zgłoszony w <xref:System.CannotUnloadAppDomainException> tym wątku, a nie w oryginalnym wątku, który został wywołany <xref:System.AppDomain.Unload%2A>. Jeśli jednak wątek, który wywołuje <xref:System.AppDomain.Unload%2A> , działa poza `domain`, ten wątek odbiera wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zwolnić domenę aplikacji.  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domain" />jest <see langword="null" />.</exception>
        <exception cref="T:System.CannotUnloadAppDomainException"><paramref name="domain" />nie można zwolnić.</exception>
        <exception cref="T:System.Exception">Wystąpił błąd podczas procesu zwalniania.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby dodać program obsługi zdarzeń dla tego zdarzenia. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ea61cb4223b387adbeae8acfa4c08e31102abc3b" /><Meta Name="ms.sourcegitcommit" Value="662f143e6be46d519ff8ab4451d543d91e651478" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/18/2018" /><Meta Name="ms.locfileid" Value="53568775" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje domenę aplikacji, która jest izolowanym środowisku, w którym aplikacje są wykonywane. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domeny aplikacji, które są reprezentowane przez <xref:System.AppDomain> obiektów, pomagają granic izolacji, zwalnianie i zabezpieczeń dla wykonywania kodu zarządzanego.  
  
-   Za pomocą domen aplikacji wykrywać zadania, które może obniżyć procesu. Jeśli stan <xref:System.AppDomain> wykonuje zadanie staje się niestabilny, <xref:System.AppDomain> może być rozładowany bez wywierania wpływu na proces. Jest to ważne w przypadku, gdy proces musi działać przez długi czas bez ponownego uruchamiania. Umożliwia także domen aplikacji do izolowania zadania, które nie powinny współużytkować dane.  
  
-   Jeśli zestaw jest ładowany do domyślnej domeny aplikacji, nie może być zwolniony z pamięci procesu jest uruchomiona. Jednak jeśli otworzysz drugiej domenie aplikacji, załadowanie i wykonanie zestawu, zestaw jest zwolniony, gdy domena tej aplikacji jest zwalniana. Użyj tej techniki, aby zmniejszyć zestaw roboczy procesy długotrwałe, od czasu do czasu korzystających z dużej biblioteki dll.  
  
 > [!NOTE]
 >  Na platformie .NET Core <xref:System.AppDomain> implementacja jest ograniczona zgodnie z projektem i nie zapewnia granic izolacji, zwalnianie lub zabezpieczeń. Dla platformy .NET Core jest dokładnie jeden <xref:System.AppDomain>. Izolacja i wyładowywanie są realizowane za pośrednictwem <xref:System.Runtime.Loader.AssemblyLoadContext>. Granice zabezpieczeń powinny być dostarczone przez granice procesu i technik odpowiednią komunikację zdalną.
 
 Wiele domen aplikacji można uruchomić w ramach jednego procesu; Jednakże nie istnieje jeden do jednego korelacji między domenami aplikacji oraz wątkami. Wiele wątków może należeć do domeny pojedynczej aplikacji, a gdy danego wątku nie ogranicza się do domeny pojedynczej aplikacji, w dowolnym momencie, wątek wykonuje w domenie pojedynczej aplikacji.  
  
 Domeny aplikacji są tworzone przy użyciu <xref:System.AppDomain.CreateDomain%2A> metody. <xref:System.AppDomain> wystąpienia są używane do ładowania i wykonywać zestawy (<xref:System.Reflection.Assembly>). Gdy <xref:System.AppDomain> jest już w użyciu, może zostać zwolniony.  
  
 <xref:System.AppDomain> Klasa implementuje zestaw zdarzeń, które umożliwiają aplikacjom reagować, gdy zestaw jest ładowany, gdy domena aplikacji zostanie zwolniony, lub gdy wystąpił nieobsługiwany wyjątek jest zgłaszany.  
  
 Aby uzyskać więcej informacji na temat korzystania z domeny aplikacji, zobacz [domen aplikacji](~/docs/framework/app-domains/application-domains.md).  
  
 Ta klasa implementuje <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, i <xref:System.Security.IEvidenceFactory> interfejsów.  
  
 Może być zastosowana zdalnie otoką nie powinien nigdy tworzyć <xref:System.AppDomain> obiektu. Ten sposób można opublikować zdalnego odwołanie do tego <xref:System.AppDomain>, takie jak udostępnianie metody <xref:System.AppDomain.CreateInstance%2A> dostępu zdalnego i skutecznie niszczenie zabezpieczenia dostępu kodu, w tym <xref:System.AppDomain>. Złośliwego klientów łączących się zdalny <xref:System.AppDomain> można uzyskać dostępu do dowolnego zasobu <xref:System.AppDomain> sam ma dostęp. Nie należy tworzyć może być zastosowana zdalnie otoki dla dowolnego typu, która rozszerza <xref:System.MarshalByRefObject> i który implementuje metody, które mogłyby zostać użyte przez złośliwego klientów, aby pominąć system zabezpieczeń.  
  
> [!CAUTION]
>  Wartością domyślną dla <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> właściwość `false`. To ustawienie jest niebezpieczne dla usług. Aby zapobiec usługi pobierania częściowo zaufany kod, należy ustawić tę właściwość na `true`.  
  
   
  
## Examples  
 Ten przykład pokazuje, jak utworzyć nową <xref:System.AppDomain>, tworzenia wystąpienia typu w tym nowe <xref:System.AppDomain>i komunikować się z obiektu tego typu. Ponadto, w tym przykładzie pokazano, jak zwolnić <xref:System.AppDomain> powoduje obiektu się bezużyteczne.  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">Instrukcje: Konfigurowanie domeny aplikacji</related>
    <related type="Article" href="https://msdn.microsoft.com/library/ba1fa43e-49f5-47d9-bd7f-3024af16f4ba">Instrukcje: Tworzenie domeny aplikacji</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1432aa2d-bd83-4346-bf3b-a1b7920e2aa9">Instrukcje: Ładowanie zestawów do domeny aplikacji</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f356116d-e415-4f7c-a332-6e6a60227192">Instrukcje: Zwolnienie domeny aplikacji</related>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kontekst aktywacji dla bieżącej domeny aplikacji.</summary>
        <value>Obiekt, który reprezentuje kontekst aktywacji dla bieżącej domeny aplikacji lub <see langword="null" /> Jeśli domena nie kontekstu aktywacji.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa katalogu, który ma zostać dołączona do ścieżki prywatnej.</param>
        <summary>Dołącza określony katalog do ścieżki prywatnej listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie tej właściwości nie jest zalecane, ponieważ może go zmienić ścieżkę sondowania dla zestawów, po one zostały już załadowane. Użyj <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> właściwości zamiast tego.  
  
 Prywatna lub ścieżki względne wyszukiwania, jest ścieżką względną podstawowego katalogu, gdzie mechanizm rozpoznawania zestawów sondy zestawy prywatne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tożsamość aplikacji w domenie aplikacji.</summary>
        <value>Obiekt, który identyfikuje aplikację w domenie aplikacji.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje opisujące uprawnień udzielonych aplikacji oraz tego, czy aplikacja ma poziom zaufania, który umożliwia jego uruchomienie.</summary>
        <value>Obiekt, który hermetyzuje informacje uprawnień i zaufania dla aplikacji w domenie aplikacji.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Zestaw nazwa, wyświetlana w formularzu, dostarczone przez <see cref="P:System.Reflection.Assembly.FullName" /> właściwości.</param>
        <summary>Zwraca nazwę wyświetlaną zestawu, po zastosowaniu zasad.</summary>
        <returns>Nazwa jest wyświetlana w ciągu zawierającego zestaw, po zastosowaniu zasad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ApplyPolicy%2A> Metoda przyjmuje wiadomość zestawu nazwę wyświetlaną i zwraca nazwę wyświetlaną po zastosowaniu zasad. Jest to przydatne, jeśli potrzebujesz do załadowania zestawu za pomocą zasad, ponieważ kontekstu reflection-only nie można stosować zasady.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zestaw jest ładowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AssemblyLoadEventHandler> Delegowanie dla to zdarzenie wskazuje, jaki zestaw został załadowany.  
  
 Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musisz mieć wymagane uprawnienia, lub <xref:System.Security.SecurityException> zgłaszany.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.AssemblyLoad> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy rozpoznawania zestawu nie powiodło się.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest odpowiedzialny za <xref:System.ResolveEventHandler> dla tego zdarzenia do zwrócenia zestawu, który jest określony przez <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> właściwości lub w celu zwrócenia wartości null, jeśli zestaw nie został rozpoznany. Zestaw musi być ładowane do kontekstu wykonywania; Jeśli jest ładowany do kontekstu reflection-only, obciążenia, który spowodował zgłoszenie tego zdarzenia nie powiedzie się.  
  
 Aby uzyskać wytyczne dotyczące używania tego zdarzenia, zobacz [rozwiązywanie Załadowań zestawów](~/docs/framework/app-domains/resolve-assembly-loads.md).  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> właściwość zwraca zestaw, który zażądał ładowanie zestawu, którego nie można rozpoznać. Moduł ładujący może być na przykład nie można załadować zależności zestawu żądania, ponieważ żądanie zestawu i jego zależności nie znajdują się w ścieżce badania. Znając tożsamości żądającego zestawu może być przydatne w celu znajdowania zależności lub w określeniu poprawnej wersji, jeśli jest dostępna więcej niż jedna wersja zależności. Aby uzyskać więcej informacji, zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <xref:System.ResolveEventHandler> zdarzenie jest wywoływane dla wszystkich zestawów, w tym zestawów zasobów. We wcześniejszych wersjach zdarzenie nie został zgłoszony dla zestawów zasobów. Jeśli system operacyjny jest zlokalizowana, program obsługi może wywoływać wielokrotnie: jeden raz dla każdej kultury w łańcuchu rezerwowego.  
  
 Dla tego zdarzenia <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> właściwość zwraca nazwę zestawu, przed zastosowaniem zasad.  
  
> [!IMPORTANT]
>  Jeśli więcej niż jeden program obsługi zdarzeń jest zarejestrowany dla tego zdarzenia, programy obsługi zdarzeń są wywoływane w kolejności, dopóki program obsługi zdarzeń nie zwróci wartość, która nie jest `null`. Programy obsługi zdarzeń kolejnych są ignorowane.
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
        <related type="Article" href="https://msdn.microsoft.com/library/5099e549-f4fd-49fb-a290-549edd456c6a">Rozwiązywanie załadowań zestawów</related>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera katalog podstawowy, używany przez mechanizm rozpoznawania zestawów do sondowania dla zestawów.</summary>
        <value>Katalog podstawowy mechanizm rozpoznawania zestawów używa do sondowania dla zestawów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość odnosi się do <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> właściwości. Można również pobrać, za pomocą <xref:System.AppDomain.GetData%2A> metody z parametrami "APPBASE".  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nową domenę aplikacji, określając katalog podstawowy do użycia podczas wyszukiwania dla zestawów do załadowania do domeny. Następnie w przykładzie <xref:System.AppDomain.BaseDirectory%2A> właściwości, aby uzyskać ścieżkę podstawowego katalogu, do wyświetlenia w konsoli.  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji w samej ścieżce, w tym przypadku ścieżka ma postać "file://" lub \\\UNC\dir lub "c:\\". Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje ścieżki, który określa lokalizację zestawy prywatne do pustego ciągu ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ścieżka prywatnego jest ścieżką względną wobec katalogu podstawowego, wyszukująca środowiska uruchomieniowego języka wspólnego, aby zlokalizować zestawy prywatne.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.AppDomain.ClearPrivatePath%2A> metodę, aby usunąć wszystkie wpisy z listy ścieżek prywatnych do wyszukiwania, gdy są ładowane zestawy.  
  
 Ta metoda jest obecnie przestarzała i nie należy jej używać w nowych wdrożeniach.  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje listę katalogów, zawierającego zestawy kopie w tle do pustego ciągu ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ścieżka kopii w tle jest listę katalogów, gdzie kopiowane zestawów w tle są przechowywane.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> i [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="F:System.String.Empty" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie określonego typu COM.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku zawierającego zestaw, który definiuje żądanego typu.</param>
        <param name="typeName">Nazwa żądanego typu.</param>
        <summary>Tworzy nowe wystąpienie określonego typu COM. Parametry Określ nazwę pliku, który zawiera zestaw zawierający typ i nazwę typu.</summary>
        <returns>Obiekt, który jest otoką nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia tworzenie obiektów zdalnie bez konieczności ładowania typu lokalnie.  
  
 Zwracana wartość należy do odkodowania dostępu do rzeczywistego obiektu.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atrybutu o wartości `true` musi dotyczyć jawnie lub domyślnie typ COM dla tej metody, aby utworzyć wystąpienia tego typu; w przeciwnym razie <xref:System.TypeLoadException> zgłaszany.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Nie można załadować typu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Znaleziono nie publicznego konstruktora bez parametrów.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MemberAccessException"><paramref name="typeName" /> jest klasą abstrakcyjną.  
  
—lub— 
Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyName" /> jest pustym ciągiem ("").</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">Obiekt COM, jest określany jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku zawierającego zestaw, który definiuje żądanego typu.</param>
        <param name="typeName">Nazwa żądanego typu.</param>
        <param name="hashValue">Reprezentuje wartość obliczona wartość skrótu.</param>
        <param name="hashAlgorithm">Reprezentuje algorytm wyznaczania wartości skrótu manifestu zestawu.</param>
        <summary>Tworzy nowe wystąpienie określonego typu COM. Parametry Określ nazwę pliku, który zawiera zestaw zawierający typ i nazwę typu.</summary>
        <returns>Obiekt, który jest otoką nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia tworzenie obiektów zdalnie bez konieczności ładowania typu lokalnie.  
  
 Zwracana wartość należy do odkodowania dostępu do rzeczywistego obiektu.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atrybutu o wartości `true` musi dotyczyć jawnie lub domyślnie typ COM dla tej metody, aby utworzyć wystąpienia tego typu; w przeciwnym razie <xref:System.TypeLoadException> zgłaszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Nie można załadować typu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Znaleziono nie publicznego konstruktora bez parametrów.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MemberAccessException"><paramref name="typeName" /> jest klasą abstrakcyjną.  
  
—lub— 
Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> ciąg pusty ("").</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">Obiekt COM, jest określany jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzenie nowej domeny aplikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny.</param>
        <summary>Tworzy nową domenę aplikacji przy użyciu określonej nazwy.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `friendlyName` Parametr służy do identyfikowania domeny w taki sposób, który jest zrozumiały dla ludzi. Ten ciąg musi być odpowiednie dla wyświetlania w interfejsie użytkownika.  
  
 Używa tego przeciążenia metody <xref:System.AppDomainSetup> informacje z domyślnej domeny aplikacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano ogólnie rzecz biorąc, jak utworzyć domenę przy użyciu jednej z <xref:System.AppDomain.CreateDomain%2A> przeciążenia.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metoda nie jest obsługiwana na platformie .NET Core.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> spowoduje używanie dowodu z bieżącej domeny aplikacji.</param>
        <summary>Tworzy nową domenę aplikacji o podanej nazwie za pomocą dostarczony dowód.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa tego przeciążenia metody <xref:System.AppDomainSetup> informacje z domyślnej domeny aplikacji.  
  
 Jeśli `securityInfo` jest nie podano, jest używany dowód z bieżącej domeny aplikacji.  
  
> [!IMPORTANT]
>  Nie należy używać tego przeciążenia metody do tworzenia domen aplikacji w trybie piaskownicy. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], dowód dostarczany dla `securityInfo` nie wpływa już na zestaw uprawnień w domenie aplikacji. Użyj <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> przeciążenia metody tworzenia domen aplikacji w trybie piaskownicy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano ogólnie rzecz biorąc, jak utworzyć domenę przy użyciu jednej z <xref:System.AppDomain.CreateDomain%2A> przeciążenia.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> spowoduje używanie dowodu z bieżącej domeny aplikacji.</param>
        <param name="info">Obiekt, który zawiera informacje o inicjalizacji domeny aplikacji.</param>
        <summary>Tworzy nową domenę aplikacji przy użyciu określonej nazwy, dowód i informacje o konfiguracji domeny aplikacji.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `info` jest nie podano używa tego przeciążenia metody <xref:System.AppDomainSetup> informacje z domyślnej domeny aplikacji.  
  
 Jeśli `securityInfo` jest nie podano, jest używany dowód z bieżącej domeny aplikacji.  
  
> [!IMPORTANT]
>  Nie należy używać tego przeciążenia metody do tworzenia domen aplikacji w trybie piaskownicy. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], dowód dostarczany dla `securityInfo` nie wpływa już na zestaw uprawnień w domenie aplikacji. Użyj <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> przeciążenia metody tworzenia domen aplikacji w trybie piaskownicy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano ogólnie rzecz biorąc, jak utworzyć domenę przy użyciu jednej z <xref:System.AppDomain.CreateDomain%2A> przeciążenia.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz opis <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> spowoduje używanie dowodu z bieżącej domeny aplikacji.</param>
        <param name="info">Obiekt, który zawiera informacje o inicjalizacji domeny aplikacji.</param>
        <param name="grantSet">Domyślne uprawnienia, oznacza to zestaw przyznane do wszystkich zestawów ładowane do nowej domeny aplikacji, które nie mają określonych przydziałów.</param>
        <param name="fullTrustAssemblies">Tablica silnych nazw reprezentujących zestawy, aby zostały uznane za w pełni zaufany w nowej domenie aplikacji.</param>
        <summary>Tworzy nową domenę aplikacji przy użyciu określonej nazwy, dowód, informacje o konfiguracji domeny aplikacji, domyślny zestaw uprawnień i tablicę całkowicie zaufanych zestawów.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy ustawić <xref:System.AppDomainSetup.ApplicationBase%2A> właściwość <xref:System.AppDomainSetup> obiekt, który możesz podać `info`. W przeciwnym razie jest zgłaszany wyjątek.  
  
 Jeśli `securityInfo` jest nie podano, jest używany dowód z bieżącej domeny aplikacji.  
  
 Informacje przewidziane `grantSet` i `fullTrustAssemblies` służy do tworzenia <xref:System.Security.Policy.ApplicationTrust> obiektu dla nowej domeny aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Domena aplikacji jest <see langword="null" />.  
  
—lub— 
<see cref="P:System.AppDomainSetup.ApplicationBase" /> Właściwość nie jest ustawiona na <see cref="T:System.AppDomainSetup" /> obiekt, który jest dostarczany dla <paramref name="info" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Tworzenia domeny aplikacji i wykonywanie na niej operacji. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> spowoduje używanie dowodu z bieżącej domeny aplikacji.</param>
        <param name="appBasePath">Katalog podstawowy mechanizm rozpoznawania zestawów używa do sondowania dla zestawów. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Ścieżka względna podstawowego katalogu, gdzie mechanizm rozpoznawania zestawów powinny sondować zestawy prywatne. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">Jeśli <see langword="true" />, kopia w tle zestaw jest ładowany do tej domeny aplikacji.</param>
        <summary>Tworzy nową domenę aplikacji o podanej nazwie, przy użyciu dowód, ścieżki podstawowej aplikacji, ścieżki wyszukiwania względne i parametr, który określa, czy zestaw kopii w tle jest ładowany do domeny aplikacji.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `securityInfo` jest nie podano, jest używany dowód z bieżącej domeny aplikacji.  
  
 Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz <xref:System.AppDomain.ShadowCopyFiles%2A> i [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Nie należy używać tego przeciążenia metody do tworzenia domen aplikacji w trybie piaskownicy. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], dowód dostarczany dla `securityInfo` nie wpływa już na zestaw uprawnień w domenie aplikacji. Użyj <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> przeciążenia metody tworzenia domen aplikacji w trybie piaskownicy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano ogólnie rzecz biorąc, jak utworzyć domenę przy użyciu jednej z <xref:System.AppDomain.CreateDomain%2A> przeciążenia.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> spowoduje używanie dowodu z bieżącej domeny aplikacji.</param>
        <param name="appBasePath">Katalog podstawowy mechanizm rozpoznawania zestawów używa do sondowania dla zestawów. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Ścieżka względna podstawowego katalogu, gdzie mechanizm rozpoznawania zestawów powinny sondować zestawy prywatne. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles"><see langword="true" /> Ładowanie zestawu kopii w tle do domeny aplikacji.</param>
        <param name="adInit"><see cref="T:System.AppDomainInitializer" /> Delegata, który reprezentuje metodę wywołania zwrotnego do wywołania, gdy nowy <see cref="T:System.AppDomain" /> obiekt jest zainicjowany.</param>
        <param name="adInitArgs">Tablica argumentów ciągów, które zostaną przekazane do wywołania zwrotnego, reprezentowane przez <paramref name="adInit" />, gdy nowy <see cref="T:System.AppDomain" /> obiekt jest zainicjowany.</param>
        <summary>Tworzy nową domenę aplikacji o podanej nazwie, przy użyciu dowód, ścieżki podstawowej aplikacji, ścieżki wyszukiwania względne i parametr, który określa, czy zestaw kopii w tle jest ładowany do domeny aplikacji. Określa metody wywołania zwrotnego, która jest wywoływana po zainicjowaniu domeny aplikacji i Tablica ciągów argumentów do przebiegu metody wywołania zwrotnego.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody reprezentowanej przez `adInit` jest wykonywany w kontekście nowo utworzona domena aplikacji.  
  
 Jeśli `securityInfo` jest nie podano, jest używany dowód z bieżącej domeny aplikacji.  
  
 Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz <xref:System.AppDomain.ShadowCopyFiles%2A> i [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Nie należy używać tego przeciążenia metody do tworzenia domen aplikacji w trybie piaskownicy. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], dowód dostarczany dla `securityInfo` nie wpływa już na zestaw uprawnień w domenie aplikacji. Użyj <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> przeciążenia metody tworzenia domen aplikacji w trybie piaskownicy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowane w określonym zestawie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym zestawie.</summary>
        <returns>Obiekt, który jest otoką nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje domyślnego konstruktora dla `typeName`.  
  
 Zobacz <xref:System.Reflection.AssemblyName> format `assemblyName`.  
  
 Próba wywołania <xref:System.AppDomain.CreateInstance%2A> docelowo na domeny aplikacji, który nie jest bieżącej domeny aplikacji spowoduje pomyślne obciążenie zestawu w docelowej domenie aplikacji. Ponieważ <xref:System.Reflection.Assembly> nie <xref:System.MarshalByRefObject>, gdy ta metoda próbuje zwrócić <xref:System.Reflection.Assembly> załadowanego zestawu do bieżącej domeny aplikacji, środowisko uruchomieniowe języka wspólnego próbuje załadować zestaw do bieżącej domeny aplikacji i obciążenie może się nie powieść. Jeśli ustawienia ścieżek obu domen aplikacji są różne, zestaw ładowany do bieżącej domeny aplikacji może się różnić od zestawu, który został załadowany po raz pierwszy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym zestawie. Parametr określa tablicę z atrybutami aktywacji.</summary>
        <returns>Obiekt, który jest otoką nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje domyślnego konstruktora dla `typeName`.  
  
 Zobacz <xref:System.Reflection.AssemblyName> format `assemblyName`.  
  
 Próba wywołania <xref:System.AppDomain.CreateInstance%2A> docelowo na domeny aplikacji, który nie jest bieżącej domeny aplikacji spowoduje pomyślne obciążenie zestawu w docelowej domenie aplikacji. Ponieważ <xref:System.Reflection.Assembly> nie <xref:System.MarshalByRefObject>, gdy ta metoda próbuje zwrócić <xref:System.Reflection.Assembly> załadowanego zestawu do bieżącej domeny aplikacji, środowisko uruchomieniowe języka wspólnego próbuje załadować zestaw do bieżącej domeny aplikacji i obciążenie może się nie powieść. Jeśli ustawienia ścieżek obu domen aplikacji są różne, zestaw ładowany do bieżącej domeny aplikacji może się różnić od zestawu, który został załadowany po raz pierwszy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Typy obiektu, który umożliwia wiązanie, wymuszanie argumentów, wywoływania członków i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przy użyciu odbicia. Jeśli <paramref name="binder" /> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli jest preferowany, Konstruktor domyślny <paramref name="args" /> musi być pusta tablica lub null.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="typeName" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym zestawie. Parametry określają integratora, flagi powiązań, argumenty konstruktora, informacje specyficzne dla kultury używaną do interpretacji parametru argumentów i atrybuty opcjonalne aktywacji.</summary>
        <returns>Obiekt, który jest otoką nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Reflection.AssemblyName> format `assemblyName`.  
  
 Próba wywołania <xref:System.AppDomain.CreateInstance%2A> docelowo na domeny aplikacji, który nie jest bieżącej domeny aplikacji spowoduje pomyślne obciążenie zestawu w docelowej domenie aplikacji. Ponieważ <xref:System.Reflection.Assembly> nie <xref:System.MarshalByRefObject>, gdy ta metoda próbuje zwrócić <xref:System.Reflection.Assembly> załadowanego zestawu do bieżącej domeny aplikacji, środowisko uruchomieniowe języka wspólnego próbuje załadować zestaw do bieżącej domeny aplikacji i obciążenie może się nie powieść. Jeśli ustawienia ścieżek obu domen aplikacji są różne, zestaw ładowany do bieżącej domeny aplikacji może się różnić od zestawu, który został załadowany po raz pierwszy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Typy obiektu, który umożliwia wiązanie, wymuszanie argumentów, wywoływania członków i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przy użyciu odbicia. Jeśli <paramref name="binder" /> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli jest preferowany, Konstruktor domyślny <paramref name="args" /> musi być pusta tablica lub null.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="typeName" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do autoryzowania tworzenia parametru <paramref name="typeName" />.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym zestawie. Parametry określają integratora, flagi powiązań, argumenty konstruktora, informacje specyficzne dla kultury, używane do interpretować argumenty aktywacji i atrybuty autoryzacji do utworzenia typu.</summary>
        <returns>Obiekt, który jest otoką nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Reflection.AssemblyName> format `assemblyName`.  
  
 Próba wywołania <xref:System.AppDomain.CreateInstance%2A> docelowo na domeny aplikacji, który nie jest bieżącej domeny aplikacji spowoduje pomyślne obciążenie zestawu w docelowej domenie aplikacji. Ponieważ <xref:System.Reflection.Assembly> nie <xref:System.MarshalByRefObject>, gdy ta metoda próbuje zwrócić <xref:System.Reflection.Assembly> załadowanego zestawu do bieżącej domeny aplikacji, środowisko uruchomieniowe języka wspólnego próbuje załadować zestaw do bieżącej domeny aplikacji i obciążenie może się nie powieść. Jeśli ustawienia ścieżek obu domen aplikacji są różne, zestaw ładowany do bieżącej domeny aplikacji może się różnić od zestawu, który został załadowany po raz pierwszy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
 <paramref name="securityAttributes" /> nie jest <see langword="null" />. Gdy starsza zasada CAS nie jest włączone, <paramref name="securityAttributes" /> powinny być <see langword="null." /></exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie określonego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <summary>Tworzy nowe wystąpienie określonego typu. Parametry określają zestawu, w którym zdefiniowano typ i nazwę typu.</summary>
        <returns>Wystąpienie obiektu określonego przez <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która łączy <xref:System.AppDomain.CreateInstance%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Ta metoda wywołuje domyślnego konstruktora dla `typeName`.  
  
 Zobacz <xref:System.Reflection.AssemblyName> format `assemblyName`. Zobacz <xref:System.Type.FullName%2A?displayProperty=nameWithType> właściwość format `typeName`.  
  
> [!NOTE]
>  Jeśli wprowadzisz wczesnym wiązaniem wywołanie metody `M` obiektu typu `T1` który został zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i że metoda przeprowadza wywołanie wczesnym wiązaniem do metody obiektu typu `T2` w zestawie `C` innych niż Bieżący zestaw lub zestawu zawierającego `T1`, zestawu `C` jest ładowany do bieżącej domeny aplikacji. To ładowanie odbywa się nawet wtedy, gdy wywołanie wczesnym wiązaniem `T1.M()` została wprowadzona w treści <xref:System.Reflection.Emit.DynamicMethod>, lub innego dynamicznie generowanego kodu. Jeśli bieżąca domena jest domeną domyślną, zestaw `C` można zwolnić dopiero po zakończenia procesu. Jeśli bieżąca domena później spróbuje załadować zestaw `C`, obciążenie może się nie powieść.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje najprostszy sposób na wykonanie kodu w innej domenie aplikacji. W przykładzie zdefiniowano klasę o nazwie `Worker` tej, która dziedziczy <xref:System.MarshalByRefObject>. `Worker` Klasa definiuje metodę, która wyświetla nazwę domeny aplikacji, w którym jest wykonywany. Przykład tworzy wystąpienia elementu `Worker` w domyślnej domeny aplikacji i w nowej domenie aplikacji.  
  
> [!NOTE]
>  Zestaw, który zawiera `Worker` muszą być załadowane do obu domen aplikacji, ale jej załadować innych zestawów, które istnieją tylko w domenie nowej aplikacji.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">możliwość odczytu pliku zawierającego manifest zestawu lub jeśli typ jest tworzony z modułu innej niż plik manifestu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu. Parametry określają zestawu, w którym zdefiniowano typ, nazwa typu, a tablica atrybutów aktywacji.</summary>
        <returns>Wystąpienie obiektu określonego przez <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która łączy <xref:System.AppDomain.CreateInstance%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Ta metoda wywołuje domyślnego konstruktora dla `typeName`.  
  
 Zobacz <xref:System.Reflection.AssemblyName> format `assemblyName`. Zobacz <xref:System.Type.FullName%2A?displayProperty=nameWithType> właściwość format `typeName`.  
  
> [!NOTE]
>  Jeśli wprowadzisz wczesnym wiązaniem wywołanie metody `M` obiektu typu `T1` który został zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i że metoda przeprowadza wywołanie wczesnym wiązaniem do metody obiektu typu `T2` w zestawie `C` innych niż Bieżący zestaw lub zestawu zawierającego `T1`, zestawu `C` jest ładowany do bieżącej domeny aplikacji. To ładowanie odbywa się nawet wtedy, gdy wywołanie wczesnym wiązaniem `T1.M()` została wprowadzona w treści <xref:System.Reflection.Emit.DynamicMethod>, lub innego dynamicznie generowanego kodu. Jeśli bieżąca domena jest domeną domyślną, zestaw `C` można zwolnić dopiero po zakończenia procesu. Jeśli bieżąca domena później spróbuje załadować zestaw `C`, obciążenie może się nie powieść.  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Typy obiektu, który umożliwia wiązanie, wymuszanie argumentów, wywoływania członków i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przy użyciu odbicia. Jeśli <paramref name="binder" /> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli jest preferowany, Konstruktor domyślny <paramref name="args" /> musi być pusta tablica lub null.</param>
        <param name="culture">Obiekt specyficzny dla kultury, używane do sterowania wymuszanie typów. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see langword="CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu. który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w określonym zestawie, określania, czy jest ignorowana wielkość liter nazwy typu. atrybuty wiązania i integratorów modeli, które służą do wybierania typu, który ma zostać utworzony; Argumenty konstruktora; Kultura; i atrybuty aktywacji.</summary>
        <returns>Wystąpienie obiektu określonego przez <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która łączy <xref:System.AppDomain.CreateInstance%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Zobacz <xref:System.Reflection.AssemblyName> format `assemblyName`. Zobacz <xref:System.Type.FullName%2A?displayProperty=nameWithType> właściwość format `typeName`.  
  
> [!NOTE]
>  Jeśli wprowadzisz wczesnym wiązaniem wywołanie metody `M` obiektu typu `T1` który został zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i że metoda przeprowadza wywołanie wczesnym wiązaniem do metody obiektu typu `T2` w zestawie `C` innych niż Bieżący zestaw lub zestawu zawierającego `T1`, zestawu `C` jest ładowany do bieżącej domeny aplikacji. To ładowanie odbywa się nawet wtedy, gdy wywołanie wczesnym wiązaniem `T1.M()` została wprowadzona w treści <xref:System.Reflection.Emit.DynamicMethod>, lub innego dynamicznie generowanego kodu. Jeśli bieżąca domena jest domeną domyślną, zestaw `C` można zwolnić dopiero po zakończenia procesu. Jeśli bieżąca domena później spróbuje załadować zestaw `C`, obciążenie może się nie powieść.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie `ignoreCase` parametru.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Typy obiektu, który umożliwia wiązanie, wymuszanie argumentów, wywoływania członków i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przy użyciu odbicia. Jeśli <paramref name="binder" /> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli jest preferowany, Konstruktor domyślny <paramref name="args" /> musi być pusta tablica lub null.</param>
        <param name="culture">Obiekt specyficzny dla kultury, używane do sterowania wymuszanie typów. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see langword="CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do autoryzowania tworzenia parametru <paramref name="typeName" />.</param>
        <summary>Tworzy nowe wystąpienie określonego typu. Parametry Podaj nazwę typu, oraz sposób ich znaleziono i utworzyć.</summary>
        <returns>Wystąpienie obiektu określonego przez <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która łączy <xref:System.AppDomain.CreateInstance%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Zobacz <xref:System.Reflection.AssemblyName> format `assemblyName`. Zobacz <xref:System.Type.FullName%2A?displayProperty=nameWithType> właściwość format `typeName`.  
  
> [!NOTE]
>  Jeśli wprowadzisz wczesnym wiązaniem wywołanie metody `M` obiektu typu `T1` który został zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i że metoda przeprowadza wywołanie wczesnym wiązaniem do metody obiektu typu `T2` w zestawie `C` innych niż Bieżący zestaw lub zestawu zawierającego `T1`, zestawu `C` jest ładowany do bieżącej domeny aplikacji. To ładowanie odbywa się nawet wtedy, gdy wywołanie wczesnym wiązaniem `T1.M()` została wprowadzona w treści <xref:System.Reflection.Emit.DynamicMethod>, lub innego dynamicznie generowanego kodu. Jeśli bieżąca domena jest domeną domyślną, zestaw `C` można zwolnić dopiero po zakończenia procesu. Jeśli bieżąca domena później spróbuje załadować zestaw `C`, obciążenie może się nie powieść.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie `ignoreCase` parametru.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie danego typu zdefiniowane w określonym pliku zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa (łącznie ze ścieżką) pliku zawierającego zestaw, który definiuje żądany typ. Zestaw jest ładowany za pomocą <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> metody.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Obiekt, który jest otoką nowego wystąpienia lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie zostanie znaleziony. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny konstruktor dla `typeName` zostanie wywołana.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 Gdy <xref:System.AppDomain.CreateInstanceFrom%2A> metoda jest używana do utworzenia wystąpienia w domenie aplikacji docelowej innej niż ta, z którego jest nawiązywane połączenie, zestaw jest ładowany do domeny aplikacji docelowej. Jeśli jednak wystąpienie nie zostanie rozwinięte w domenie aplikacji wywołującej, użycie nierozwiniętych instancji w określony sposób może spowodować załadowanie zestawu do domeny aplikacji wywołującej. Na przykład po rozwinięciu danego wystąpienia można zażądać informacji o typie, aby wywołać jego metody z późnym wiązaniem. Podczas ładowania zestawu do domeny aplikacji wywołującej mogą wystąpić wyjątki.  
  
-   Jeśli inna wersja tego samego zestawu została wcześniej załadowana do domeny aplikacji wywołującej lub jeśli załadowana ścieżka domeny aplikacji wywołującej różni się od domeny aplikacji docelowej, wyjątki takie jak <xref:System.MissingMethodException> mogą wystąpić.  
  
-   Jeśli domeny aplikacji wywołującej sprawia, że wywołania z wczesnym wiązaniem na typ wystąpienia <xref:System.InvalidCastException> mogą być generowane, gdy podejmowana jest próba rzutowania wystąpienia.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> przeciążenia metody, aby utworzyć wystąpienie obiektu w domenie aplikacji docelowej i wywołać jej metody.  
  
 W przykładzie zdefiniowano `MarshallableExample` klasy, które mogą być organizowane poza granice domeny aplikacji. Przykład tworzy ścieżki do aktualnie wykonywanej zestawu, tworzy domenę aplikacji docelowej i używa <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> przeciążenia metody, aby załadować zestaw przykład do domeny aplikacji docelowej, a następnie utwórz wystąpienie obiektu `MarshallableExample`.  
  
> [!NOTE]
>  Ścieżka jest bezwzględna w tym przykładzie, ale ścieżka względna również będzie działać, ponieważ <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> metoda jest używana do załadowania zestawu.  
  
 Po rozpakowaniu uchwyt obiektu, w przykładzie pokazano użycie obiektu w domenie aplikacji docelowej na trzy sposoby:  
  
-   Wywoływanie metody z późnym wiązaniem, przy użyciu odbicia. Wymaga to informacje o typie, co powoduje, że zestaw, który ma być załadowany do domeny aplikacji obiektu wywołującego. (W tym przykładzie go jest już załadowany.)  
  
-   Rzutowanie obiektu do interfejsu wiadomo, że zarówno obiekt wywołujący i obiekt wywoływany. Jeśli interfejs jest zdefiniowany w zestawie wywołującego, lub w zestawie trzeci odwołuje się obiekt wywołujący i obiekt wywoływany, o nazwie zestaw nie jest ładowany do domeny aplikacji obiektu wywołującego.  
  
-   Przy użyciu obiektu bezpośrednio po jej typ jest znany do obiektu wywołującego. Zestaw musi być ładowany do domeny aplikacji obiektu wywołującego.  
  
 Innym sposobem, aby uniknąć wczytywania zestawu o nazwie do domeny aplikacji obiektu wywołującego jest do obiektu wywołującego, można dziedziczyć <xref:System.MarshalByRefObject> klasy i w celu zdefiniowania metody, które mogą być uruchamiane w docelowej domenie aplikacji. Tej metody można użyć odbicia do zbadania zestawu docelowego, ponieważ zestaw docelowy już jest ładowany do domeny aplikacji docelowej. Zobacz przykład <xref:System.AppDomain.DynamicDirectory%2A> właściwości.  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Znaleziono nie Konstruktor publiczny bez parametrów.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa (łącznie ze ścieżką) pliku zawierającego zestaw, który definiuje żądany typ. Zestaw jest ładowany za pomocą <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> metody.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Obiekt, który jest otoką nowego wystąpienia lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie zostanie znaleziony. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny konstruktor dla `typeName` zostanie wywołana.  
  
 Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 Gdy <xref:System.AppDomain.CreateInstanceFrom%2A> metoda jest używana do utworzenia wystąpienia w domenie aplikacji docelowej innej niż ta, z którego jest nawiązywane połączenie, zestaw jest ładowany do domeny aplikacji docelowej. Jeśli jednak wystąpienie nie zostanie rozwinięte w domenie aplikacji wywołującej, użycie nierozwiniętych instancji w określony sposób może spowodować załadowanie zestawu do domeny aplikacji wywołującej. Na przykład po rozwinięciu danego wystąpienia można zażądać informacji o typie, aby wywołać jego metody z późnym wiązaniem. Podczas ładowania zestawu do domeny aplikacji wywołującej mogą wystąpić wyjątki.  
  
-   Jeśli inna wersja tego samego zestawu została wcześniej załadowana do domeny aplikacji wywołującej lub jeśli załadowana ścieżka domeny aplikacji wywołującej różni się od domeny aplikacji docelowej, wyjątki takie jak <xref:System.MissingMethodException> mogą wystąpić.  
  
-   Jeśli domeny aplikacji wywołującej sprawia, że wywołania z wczesnym wiązaniem na typ wystąpienia <xref:System.InvalidCastException> mogą być generowane, gdy podejmowana jest próba rzutowania wystąpienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa (łącznie ze ścieżką) pliku zawierającego zestaw, który definiuje żądany typ. Zestaw jest ładowany za pomocą <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> metody.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Typy obiektu, który umożliwia wiązanie, wymuszanie argumentów, wywoływania członków i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przy użyciu odbicia. Jeśli <paramref name="binder" /> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli jest preferowany, Konstruktor domyślny <paramref name="args" /> musi być pusta tablica lub null.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="typeName" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Obiekt, który jest otoką nowego wystąpienia lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie zostanie znaleziony. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 Gdy <xref:System.AppDomain.CreateInstanceFrom%2A> metoda jest używana do utworzenia wystąpienia w domenie aplikacji docelowej innej niż ta, z którego jest nawiązywane połączenie, zestaw jest ładowany do domeny aplikacji docelowej. Jeśli jednak wystąpienie nie zostanie rozwinięte w domenie aplikacji wywołującej, użycie nierozwiniętych instancji w określony sposób może spowodować załadowanie zestawu do domeny aplikacji wywołującej. Na przykład po rozwinięciu danego wystąpienia można zażądać informacji o typie, aby wywołać jego metody z późnym wiązaniem. Podczas ładowania zestawu do domeny aplikacji wywołującej mogą wystąpić wyjątki.  
  
-   Jeśli inna wersja tego samego zestawu została wcześniej załadowana do domeny aplikacji wywołującej lub jeśli załadowana ścieżka domeny aplikacji wywołującej różni się od domeny aplikacji docelowej, wyjątki takie jak <xref:System.MissingMethodException> mogą wystąpić.  
  
-   Jeśli domeny aplikacji wywołującej sprawia, że wywołania z wczesnym wiązaniem na typ wystąpienia <xref:System.InvalidCastException> mogą być generowane, gdy podejmowana jest próba rzutowania wystąpienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa (łącznie ze ścieżką) pliku zawierającego zestaw, który definiuje żądany typ. Zestaw jest ładowany za pomocą <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> metody.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Typy obiektu, który umożliwia wiązanie, wymuszanie argumentów, wywoływania członków i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przy użyciu odbicia. Jeśli <paramref name="binder" /> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli jest preferowany, Konstruktor domyślny <paramref name="args" /> musi być pusta tablica lub null.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="typeName" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do autoryzowania tworzenia parametru <paramref name="typeName" />.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Obiekt, który jest otoką nowego wystąpienia lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie zostanie znaleziony. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 Gdy <xref:System.AppDomain.CreateInstanceFrom%2A> metoda jest używana do utworzenia wystąpienia w domenie aplikacji docelowej innej niż ta, z którego jest nawiązywane połączenie, zestaw jest ładowany do domeny aplikacji docelowej. Jeśli jednak wystąpienie nie zostanie rozwinięte w domenie aplikacji wywołującej, użycie nierozwiniętych instancji w określony sposób może spowodować załadowanie zestawu do domeny aplikacji wywołującej. Na przykład po rozwinięciu danego wystąpienia można zażądać informacji o typie, aby wywołać jego metody z późnym wiązaniem. Podczas ładowania zestawu do domeny aplikacji wywołującej mogą wystąpić wyjątki.  
  
-   Jeśli inna wersja tego samego zestawu została wcześniej załadowana do domeny aplikacji wywołującej lub jeśli załadowana ścieżka domeny aplikacji wywołującej różni się od domeny aplikacji docelowej, wyjątki takie jak <xref:System.MissingMethodException> mogą wystąpić.  
  
-   Jeśli domeny aplikacji wywołującej sprawia, że wywołania z wczesnym wiązaniem na typ wystąpienia <xref:System.InvalidCastException> mogą być generowane, gdy podejmowana jest próba rzutowania wystąpienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
 <paramref name="securityAttributes" /> nie jest <see langword="null" />. Gdy starsza zasada CAS nie jest włączone, <paramref name="securityAttributes" /> powinien być <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie danego typu zdefiniowane w określonym pliku zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku i ścieżka zestawu definiują żądany typ.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Żądany obiekt lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która łączy <xref:System.AppDomain.CreateInstanceFrom%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Ta metoda wywołuje domyślnego konstruktora dla `typeName`.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Znaleziono nie Konstruktor publiczny bez parametrów.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku i ścieżka zestawu definiują żądany typ.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw (zobacz <see cref="P:System.Type.FullName" /> właściwości).</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Żądany obiekt lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która łączy <xref:System.AppDomain.CreateInstanceFrom%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Ta metoda wywołuje domyślnego konstruktora dla `typeName`.  
  
 Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Znaleziono nie Konstruktor publiczny bez parametrów.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku i ścieżka zestawu definiują żądany typ.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Typy obiektu, który umożliwia wiązanie, wymuszanie argumentów, wywoływania członków i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przy użyciu odbicia. Jeśli <paramref name="binder" /> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli jest preferowany, Konstruktor domyślny <paramref name="args" /> musi być pusta tablica lub null.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="typeName" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w pliku określonym zestawie, określania, czy jest ignorowana wielkość liter nazwy typu. atrybuty wiązania i integratorów modeli, które służą do wybierania typu, który ma zostać utworzony; Argumenty konstruktora; Kultura; i atrybuty aktywacji.</summary>
        <returns>Żądany obiekt lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która łączy <xref:System.AppDomain.CreateInstanceFrom%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego, wersja która jest aktualnie załadowana.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku i ścieżka zestawu definiują żądany typ.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, w tym przestrzeń nazw, ale nie zestaw zwrócone przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Typy obiektu, który umożliwia wiązanie, wymuszanie argumentów, wywoływania członków i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przy użyciu odbicia. Jeśli <paramref name="binder" /> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli jest preferowany, Konstruktor domyślny <paramref name="args" /> musi być pusta tablica lub null.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="typeName" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do autoryzowania tworzenia parametru <paramref name="typeName" />.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Żądany obiekt lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodna metoda, która łączy <xref:System.AppDomain.CreateInstanceFrom%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącej domeny aplikacji dla bieżącego <see cref="T:System.Threading.Thread" />.</summary>
        <value>Bieżącej domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy nową domenę aplikacji. <xref:System.AppDomain.CurrentDomain%2A> Właściwość jest używana do uzyskania <xref:System.AppDomain> obiekt, który reprezentuje bieżącej domeny aplikacji. <xref:System.AppDomain.FriendlyName%2A> Właściwość zawiera nazwę bieżącej domeny aplikacji, która jest następnie wyświetlana w wierszu polecenia.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje zestawu dynamicznego w bieżącej domenie aplikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb dostępu dla zestawu dynamicznego.</param>
        <summary>Definiuje zestaw dynamiczny za pomocą określonego trybu nazwy i dostęp.</summary>
        <returns>Zestaw dynamiczny za pomocą określonego trybu nazwy i dostęp.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
> [!NOTE]
>  Podczas programowania kodu, który emituje zestawy dynamiczne, zaleca się użycie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowód i uprawnienia, podaj dowód ma zestawu dynamicznego i uwzględnienie <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru gwarantuje, że kod MSIL jest weryfikowany. Ograniczeniem tej techniki jest to, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używana z kodem, który wymaga pełnego zaufania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> metody i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
<see langword="Name" /> Właściwość <paramref name="name" /> rozpoczyna się od białego lub zawiera ukośnik albo ukośnik odwrotny.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb dostępu dla zestawu dynamicznego.</param>
        <param name="assemblyAttributes">Lista numerowana atrybutów, które mają być stosowane do zestawu, lub <see langword="null" /> Jeśli żadnych atrybutów.</param>
        <summary>Definiuje zestaw dynamiczny z określoną nazwą, tryb dostępu oraz atrybuty niestandardowe.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeciążenia służy do określania atrybutów, które nie będą działać poprawnie, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład atrybuty zabezpieczeń, takich jak <xref:System.Security.SecurityTransparentAttribute> i <xref:System.Security.SecurityCriticalAttribute> nie będą działać poprawnie, jeśli są dodawane po utworzeniu zestawu dynamicznego.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji na temat tego ograniczenia, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
 Tego przeciążenia metody została wprowadzona w systemie [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia zestawu dynamicznego, który ma <xref:System.Security.SecurityTransparentAttribute>. Ten atrybut musi być określona jako element tablicy <xref:System.Reflection.Emit.CustomAttributeBuilder> obiektów.  
  
 Pierwszym krokiem w tworzeniu <xref:System.Reflection.Emit.CustomAttributeBuilder> jest uzyskanie konstruktora dla atrybutu. Konstruktor nie ma parametrów, więc <xref:System.Type.GetConstructor%2A> metoda jest wywoływana z pustą tablicę <xref:System.Type> obiekty do reprezentowania typy parametrów. Drugi etap służy do przekazywania, wynikowy <xref:System.Reflection.ConstructorInfo> obiekt do konstruktora dla <xref:System.Reflection.Emit.CustomAttributeBuilder> klasy, wraz z pustą tablicę typu <xref:System.Object> do reprezentacji argumentów.  
  
 Wartość wynikowa <xref:System.Reflection.Emit.CustomAttributeBuilder> jest następnie przekazywany do <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę jako jedynym elementem w tablicy.  
  
 Przykładowy kod definiuje moduł i wpisz w nowy zestaw dynamiczny, a następnie wyświetla zestawu atrybutów.  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
<see langword="Name" /> Właściwość <paramref name="name" /> rozpoczyna się od białego znaku lub zawiera ukośnik albo ukośnik.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <summary>Definiuje zestawu dynamicznego przy użyciu określonej nazwy, tryb dostępu i dokumenty.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko w pełni Zaufani wywołujący mogą podawać ich `evidence` przy definiowaniu elementu dynamicznego <xref:System.Reflection.Assembly>. Środowisko uruchomieniowe zmapuje <xref:System.Security.Policy.Evidence> za pomocą zasad zabezpieczeń, aby określić udzielone uprawnienia. Częściowo Zaufani wywołujący muszą podawać wartość null `evidence`. Jeśli `evidence` jest `null`, środowisko wykonawcze kopiuje zestawy uprawnień, czyli bieżące udzielić odmowy uprawnień i wywołujący <xref:System.Reflection.Assembly> dynamiczny <xref:System.Reflection.Assembly> definiowanego, a zasady są oznaczane jako rozwiązane.  
  
 Jeśli dynamicznej <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejnych załadowaniach zostaną przyznane uprawnienia na podstawie zasad związanych z lokalizacji, w którym <xref:System.Reflection.Assembly> został zapisany.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
> [!NOTE]
>  Podczas programowania kodu, który emituje zestawy dynamiczne, zaleca się użycie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowód i uprawnienia, podaj dowód ma zestawu dynamicznego i uwzględnienie <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru gwarantuje, że kod MSIL jest weryfikowany. Ograniczeniem tej techniki jest to, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używana z kodem, który wymaga pełnego zaufania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> metody i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Po raz pierwszy, przykładowy kod próbuje utworzyć wystąpienie `MyDynamicType` przez wywołanie metody <xref:System.AppDomain.CreateInstance%2A> metody z nieprawidłową nazwę zestawu i wychwytuje wyjątek wynikowe.  
  
 Przykład kodu dodaje program obsługi zdarzeń dla <xref:System.AppDomain.AssemblyResolve> zdarzeń, a następnie próbuje utworzyć wystąpienie`MyDynamicType`. Podczas wywołania <xref:System.AppDomain.CreateInstance%2A>, <xref:System.AppDomain.AssemblyResolve> zdarzenie jest wywoływane dla nieprawidłowym zestawie. Program obsługi zdarzeń tworzy zestaw dynamiczny, który zawiera typ o nazwie `MyDynamicType`, zapewnia typ konstruktora bez parametrów i zwraca nowy zestaw dynamiczny. Wywołanie <xref:System.AppDomain.CreateInstance%2A> następnie zakończy się pomyślnie, a Konstruktor `MyDynamicType` wyświetla komunikat na konsoli.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
<see langword="Name" /> Właściwość <paramref name="name" /> rozpoczyna się od białego lub zawiera ukośnik albo ukośnik odwrotny.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli <paramref name="dir" /> jest <see langword="null" />, katalog wartością domyślną jest bieżący katalog.</param>
        <summary>Definiuje zestawu dynamicznego przy użyciu określonej nazwy, tryb dostępu i katalog magazynu.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
> [!NOTE]
>  Podczas programowania kodu, który emituje zestawy dynamiczne, zaleca się użycie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowód i uprawnienia, podaj dowód ma zestawu dynamicznego i uwzględnienie <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru gwarantuje, że kod MSIL jest weryfikowany. Ograniczeniem tej techniki jest to, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używana z kodem, który wymaga pełnego zaufania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> metody i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
<see langword="Name" /> Właściwość <paramref name="name" /> rozpoczyna się od białego lub zawiera ukośnik albo ukośnik odwrotny.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb dostępu dla zestawu dynamicznego.</param>
        <param name="assemblyAttributes">Lista numerowana atrybutów, które mają być stosowane do zestawu, lub <see langword="null" /> Jeśli żadnych atrybutów.</param>
        <param name="securityContextSource">Źródło kontekstu zabezpieczeń.</param>
        <summary>Definiuje zestaw dynamiczny z określoną nazwą, tryb dostępu oraz atrybuty niestandardowe, a jego kontekstu zabezpieczeń przy użyciu określonego źródła.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeciążenia służy do określania atrybutów, które nie będą działać poprawnie, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład atrybuty zabezpieczeń, takich jak <xref:System.Security.SecurityTransparentAttribute> i <xref:System.Security.SecurityCriticalAttribute> nie będą działać poprawnie, jeśli są dodawane po utworzeniu zestawu dynamicznego.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji na temat tego ograniczenia, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
<see langword="Name" /> Właściwość <paramref name="name" /> rozpoczyna się od białego znaku lub zawiera ukośnik albo ukośnik.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="securityContextSource" /> nie jest jedną z wartości wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli <paramref name="dir" /> jest <see langword="null" />, katalog wartością domyślną jest bieżący katalog.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <summary>Definiuje zestawu dynamicznego przy użyciu określonej nazwy, tryb dostępu, katalog magazynu i dowodów.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko w pełni Zaufani wywołujący mogą podawać ich `evidence` przy definiowaniu elementu dynamicznego <xref:System.Reflection.Assembly>. Środowisko uruchomieniowe zmapuje <xref:System.Security.Policy.Evidence> za pomocą zasad zabezpieczeń, aby określić udzielone uprawnienia. Częściowo Zaufani wywołujący muszą podawać wartość null `evidence`. Jeśli `evidence` jest `null`, środowisko wykonawcze kopiuje zestawy uprawnień, czyli bieżące udzielić odmowy uprawnień i wywołujący <xref:System.Reflection.Assembly> dynamiczny <xref:System.Reflection.Assembly> definiowanego, a zasady są oznaczane jako rozwiązane.  
  
 Jeśli dynamicznej <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejnych załadowaniach zostaną przyznane uprawnienia na podstawie zasad związanych z lokalizacji, w którym <xref:System.Reflection.Assembly> został zapisany.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
> [!NOTE]
>  Podczas programowania kodu, który emituje zestawy dynamiczne, zaleca się użycie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowód i uprawnienia, podaj dowód ma zestawu dynamicznego i uwzględnienie <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru gwarantuje, że kod MSIL jest weryfikowany. Ograniczeniem tej techniki jest to, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używana z kodem, który wymaga pełnego zaufania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> metody i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
<see langword="Name" /> Właściwość <paramref name="name" /> rozpoczyna się od białego lub zawiera ukośnik albo ukośnik odwrotny.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <summary>Definiuje zestawu dynamicznego przy użyciu określonej nazwy, tryb dostępu i żądań dotyczących uprawnień.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określona dla żądań dotyczących uprawnień `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` nie są używane, chyba że zestawu dynamicznego został zapisany i ponownie załadowany do pamięci. Aby określić żądań dotyczących uprawnień dla zestawu przejściowe, które nie są nigdy zapisywane na dysku, użyj przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowód, jak również jako żądane uprawnienia i dostarczyć <xref:System.Security.Policy.Evidence> obiektu.  
  
> [!NOTE]
>  Podczas programowania kodu, który emituje zestawy dynamiczne, zaleca się użycie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowód i uprawnienia, podaj dowód ma zestawu dynamicznego i uwzględnienie <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru gwarantuje, że kod MSIL jest weryfikowany. Ograniczeniem tej techniki jest to, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używana z kodem, który wymaga pełnego zaufania.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> metody i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
<see langword="Name" /> Właściwość <paramref name="name" /> rozpoczyna się od białego lub zawiera ukośnik albo ukośnik odwrotny.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestawu dynamicznego. Jeśli <paramref name="dir" /> jest <see langword="null" />, używany jest bieżący katalog.</param>
        <param name="isSynchronized"><see langword="true" /> Aby zsynchronizować tworzenia moduły, typy i elementy członkowskie w zestawu dynamicznego; w przeciwnym razie <see langword="false" />.</param>
        <param name="assemblyAttributes">Lista numerowana atrybutów, które mają być stosowane do zestawu, lub <see langword="null" /> Jeśli żadnych atrybutów.</param>
        <summary>Definiuje zestawu dynamicznego przy użyciu określonej nazwy, tryb dostępu, katalog magazynu i opcji synchronizacji.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeciążenia służy do określania atrybutów, które nie będą działać poprawnie, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład atrybuty zabezpieczeń, takich jak <xref:System.Security.SecurityTransparentAttribute> i <xref:System.Security.SecurityCriticalAttribute> nie będą działać poprawnie, jeśli są dodawane po utworzeniu zestawu dynamicznego.  
  
 Jeśli `isSynchronized` jest `true`, z następujących metod wynikowy <xref:System.Reflection.Emit.AssemblyBuilder> zostaną zsynchronizowane: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, i <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Jeśli dwie z tych metod są wywoływane w różnych wątkach, blokuje ukończenie innych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
<see langword="Name" /> Właściwość <paramref name="name" /> rozpoczyna się od białego znaku lub zawiera ukośnik albo ukośnik.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <summary>Definiuje zestawu dynamicznego przy użyciu określonej nazwy, tryb dostępu, dowód i żądań dotyczących uprawnień.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określona dla żądań dotyczących uprawnień `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` są używane tylko wtedy, gdy `evidence` jest również podana, lub jeśli zestaw dynamiczny jest zapisywany i ponownie załadowany do pamięci.  
  
> [!NOTE]
>  Podczas programowania kodu, który emituje zestawy dynamiczne, zaleca się, że zawrzesz <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru gwarantuje, że kod MSIL jest weryfikowany. Ograniczeniem tej techniki jest to, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używana z kodem, który wymaga pełnego zaufania.  
  
 Tylko w pełni Zaufani wywołujący mogą podawać ich `evidence` przy definiowaniu elementu dynamicznego <xref:System.Reflection.Assembly>. Środowisko uruchomieniowe zmapuje <xref:System.Security.Policy.Evidence> za pomocą zasad zabezpieczeń, aby określić udzielone uprawnienia. Częściowo Zaufani wywołujący muszą podawać wartość null `evidence`. Jeśli `evidence` jest `null`, środowisko wykonawcze kopiuje zestawy uprawnień, czyli bieżące udzielić odmowy uprawnień i wywołujący <xref:System.Reflection.Assembly> dynamiczny <xref:System.Reflection.Assembly> definiowanego, a zasady są oznaczane jako rozwiązane.  
  
 Jeśli dynamicznej <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejnych załadowaniach zostaną przyznane uprawnienia na podstawie zasad związanych z lokalizacji, w którym <xref:System.Reflection.Assembly> został zapisany.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> metody i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
<see langword="Name" /> Właściwość <paramref name="name" /> rozpoczyna się od białego lub zawiera ukośnik albo ukośnik odwrotny.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli <paramref name="dir" /> jest <see langword="null" />, katalog wartością domyślną jest bieżący katalog.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <summary>Definiuje zestawu dynamicznego przy użyciu określonej nazwy, tryb dostępu, katalog magazynu i żądań dotyczących uprawnień.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określona dla żądań dotyczących uprawnień `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` nie są używane, chyba że zestawu dynamicznego został zapisany i ponownie załadowany do pamięci. Aby określić żądań dotyczących uprawnień dla zestawu przejściowe, które nie są nigdy zapisywane na dysku, użyj przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowód, jak również jako żądane uprawnienia i dostarczyć <xref:System.Security.Policy.Evidence> obiektu.  
  
> [!NOTE]
>  Podczas programowania kodu, który emituje zestawy dynamiczne, zaleca się użycie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metody, która określa dowód i uprawnienia, podaj dowód ma zestawu dynamicznego i uwzględnienie <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru gwarantuje, że kod MSIL jest weryfikowany. Ograniczeniem tej techniki jest to, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używana z kodem, który wymaga pełnego zaufania.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> metody i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
<see langword="Name" /> Właściwość <paramref name="name" /> rozpoczyna się od białego lub zawiera ukośnik albo ukośnik odwrotny.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli <paramref name="dir" /> jest <see langword="null" />, katalog wartością domyślną jest bieżący katalog.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <summary>Definiuje zestawu dynamicznego przy użyciu określonej nazwy, tryb dostępu, katalog magazynu, dowód i żądań dotyczących uprawnień.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określona dla żądań dotyczących uprawnień `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` są używane tylko wtedy, gdy `evidence` jest również podana, lub jeśli zestaw dynamiczny jest zapisywany i ponownie załadowany do pamięci.  
  
> [!NOTE]
>  Podczas programowania kodu, który emituje zestawy dynamiczne, zaleca się, że zawrzesz <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru gwarantuje, że kod MSIL jest weryfikowany. Ograniczeniem tej techniki jest to, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używana z kodem, który wymaga pełnego zaufania.  
  
 Tylko w pełni Zaufani wywołujący mogą podawać ich `evidence` przy definiowaniu elementu dynamicznego <xref:System.Reflection.Assembly>. Środowisko uruchomieniowe zmapuje <xref:System.Security.Policy.Evidence> za pomocą zasad zabezpieczeń, aby określić udzielone uprawnienia. Częściowo Zaufani wywołujący muszą podawać wartość null `evidence`. Jeśli `evidence` jest `null`, środowisko wykonawcze kopiuje zestawy uprawnień, czyli bieżące udzielić odmowy uprawnień i wywołujący <xref:System.Reflection.Assembly> dynamiczny <xref:System.Reflection.Assembly> definiowanego, a zasady są oznaczane jako rozwiązane.  
  
 Jeśli dynamicznej <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejnych załadowaniach zostaną przyznane uprawnienia na podstawie zasad związanych z lokalizacji, w którym <xref:System.Reflection.Assembly> został zapisany.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> metody i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
<see langword="Name" /> Właściwość <paramref name="name" /> rozpoczyna się od białego lub zawiera ukośnik albo ukośnik odwrotny.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestawu dynamicznego. Jeśli <paramref name="dir" /> jest <see langword="null" />, katalog wartością domyślną jest bieżący katalog.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <param name="isSynchronized"><see langword="true" /> Aby zsynchronizować tworzenia moduły, typy i elementy członkowskie w zestawu dynamicznego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Definiuje zestawu dynamicznego przy użyciu określonej nazwy, tryb dostępu, katalog magazynu dowód, żądań dotyczących uprawnień i opcji synchronizacji.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określona dla żądań dotyczących uprawnień `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` są używane tylko wtedy, gdy `evidence` jest również podana, lub jeśli zestaw dynamiczny jest zapisywany i ponownie załadowany do pamięci.  
  
> [!NOTE]
>  Podczas programowania kodu, który emituje zestawy dynamiczne, zaleca się, że zawrzesz <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru gwarantuje, że kod MSIL jest weryfikowany. Ograniczeniem tej techniki jest to, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używana z kodem, który wymaga pełnego zaufania.  
  
 Tylko w pełni zaufany wywołujący mogą podawać ich dowód, przy definiowaniu elementu dynamicznego <xref:System.Reflection.Assembly>. Środowisko uruchomieniowe zmapuje <xref:System.Security.Policy.Evidence> za pomocą zasad zabezpieczeń, aby określić udzielone uprawnienia. Częściowo Zaufani wywołujący muszą podawać `null` dla `evidence` parametru. Jeśli `evidence` jest `null`, środowisko wykonawcze kopiuje zestawy uprawnień, czyli bieżące udzielić odmowy uprawnień i wywołujący <xref:System.Reflection.Assembly> dynamiczny <xref:System.Reflection.Assembly> definiowanego, a zasady są oznaczane jako rozwiązane.  
  
 Jeśli dynamicznej <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejnych załadowaniach zostaną przyznane uprawnienia na podstawie zasad związanych z lokalizacji, w którym <xref:System.Reflection.Assembly> został zapisany.  
  
 Jeśli `isSynchronized` jest `true`, z następujących metod wynikowy <xref:System.Reflection.Emit.AssemblyBuilder> zostaną zsynchronizowane: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, i <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Jeśli dwie z tych metod są wywoływane w różnych wątkach, zablokuje Zakończenie drugiego.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> metody i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
<see langword="Name" /> Właściwość <paramref name="name" /> rozpoczyna się od białego lub zawiera ukośnik albo ukośnik odwrotny.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestawu dynamicznego. Jeśli <paramref name="dir" /> jest <see langword="null" />, używany jest bieżący katalog.</param>
        <param name="evidence">Dowód dostarczany dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <param name="isSynchronized"><see langword="true" /> Aby zsynchronizować tworzenia moduły, typy i elementy członkowskie w zestawu dynamicznego; w przeciwnym razie <see langword="false" />.</param>
        <param name="assemblyAttributes">Lista numerowana atrybutów, które mają być stosowane do zestawu, lub <see langword="null" /> Jeśli żadnych atrybutów.</param>
        <summary>Definiuje zestaw dynamiczny z określoną nazwą, tryb dostępu, katalog magazynu, dowód, żądań dotyczących uprawnień, opcja synchronizacji oraz atrybuty niestandardowe.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeciążenia służy do określania atrybutów, które nie będą działać poprawnie, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład atrybuty zabezpieczeń, takich jak <xref:System.Security.SecurityTransparentAttribute> i <xref:System.Security.SecurityCriticalAttribute> nie będą działać poprawnie, jeśli są dodawane po utworzeniu zestawu dynamicznego.  
  
 Określona dla żądań dotyczących uprawnień `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` parametry są używane tylko wtedy, gdy `evidence` również podano parametr, lub jeśli zestaw dynamiczny jest zapisywany i ponownie załadowany do pamięci.  
  
> [!NOTE]
>  Podczas tworzenia kodu, który emituje zestawy dynamiczne, zaleca się że zawrzesz <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> znacznik w `refusedPermissions` parametru. Włączenie tej flagi powoduje, że Microsoft intermediate language (MSIL), który zostanie zweryfikowany. Ta technika wykryje niezamierzone Generowanie zweryfikowanie kodu, które w przeciwnym razie jest bardzo trudne do wykrycia. Ograniczeniem tej techniki jest to, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używany z kodem, który wymaga pełnego zaufania.  
  
 Tylko w pełni zaufanych wywołań, można dostarczyć dowodów przy definiowaniu elementu dynamicznego <xref:System.Reflection.Assembly>. Środowisko uruchomieniowe mapuje <xref:System.Security.Policy.Evidence> za pomocą zasad zabezpieczeń, aby określić udzielone uprawnienia. Częściowo Zaufani wywołujący muszą podawać `null` dla `evidence` parametru. Jeśli `evidence` jest `null`, środowisko wykonawcze kopiuje zestawy uprawnień (które jest bieżącym udzielanie odmowy uprawnień i) z zestawu wywołującego do zestawu dynamicznego, który jest definiowany, a zasady są oznaczane jako rozwiązane.  
  
 Jeśli zestaw dynamiczny jest zapisywany na dysku, kolejnych załadowaniach zostaną przyznane uprawnienia na podstawie zasad, które są skojarzone z lokalizacji, w którym zapisano zestawu dynamicznego.  
  
 Jeśli `isSynchronized` jest `true`, z następujących metod wynikowy <xref:System.Reflection.Emit.AssemblyBuilder> zostaną zsynchronizowane: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, i <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Jeśli dwie z tych metod są wywoływane w różnych wątkach, blokuje ukończenie innych.  
  
 Tego przeciążenia metody została wprowadzona w systemie [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
<see langword="Name" /> Właściwość <paramref name="name" /> rozpoczyna się od białego znaku lub zawiera ukośnik albo ukośnik.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">Delegat, który określa metodę do wywołania.</param>
        <summary>Wykonuje kod w innej domenie aplikacji, która jest identyfikowane za pomocą określonego delegata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` można określić marshal przez wartość, <xref:System.MarshalByRefObject>, lub <xref:System.ContextBoundObject>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, przy użyciu statycznego <xref:System.AppDomain.DoCallBack%2A> metody.  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 Poniższy przykład demonstruje użycie <xref:System.AppDomain.DoCallBack%2A> metoda przez wartość.  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 Poniższy przykład demonstruje użycie <xref:System.AppDomain.DoCallBack%2A> metoda przez odwołanie.  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBackDelegate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Menedżera domeny, dostarczone przez hosta podczas inicjowania domeny aplikacji.</summary>
        <value>Obiekt, który reprezentuje Menedżer domeny udostępniane przez hosta, gdy domena aplikacji zostało zainicjowane, lub <see langword="null" /> Jeśli brak Menedżera domeny została przekazana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezarządzany host środowiska uruchomieniowego języka wspólnego (CLR) może zapewnić Menedżer domeny. Menedżer domeny może uczestniczyć w Inicjowanie nowej domeny aplikacji i podać innych menedżerów, taką jak <xref:System.Security.HostSecurityManager>, który uczestniczyć w operacji domeny aplikacji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="T:System.AppDomain" /> ma zostać zwolniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler> Delegowania dla tego zdarzenia, które można wykonać żadnych działań zakończenie przed domena aplikacji jest zwalniana.  
  
 Każda domena aplikacji, które musi wykonać przetwarzanie, gdy jest zwolniony, należy zarejestrować program obsługi zdarzeń dla tego zdarzenia. Program obsługi zdarzeń udostępnionego nie należy używać, ponieważ <xref:System.EventHandler> delegata nie określa domeny, która jest zwalniany.  
  
> [!NOTE]
>  To zdarzenie nigdy nie jest zgłaszany w domyślnej domeny aplikacji.  
  
 Nie należy wprowadzać założeń dotyczących zdarzenie jest wywoływane na wątek. Zdarzenie może zostać wywołane w innym wątku niż ta, która wywołała <xref:System.AppDomain.Unload%2A> metody.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera katalog używany przez mechanizm rozpoznawania zestawów do sondowania dla zestawów utworzony dynamicznie.</summary>
        <value>Katalog, który używa programu rozpoznawania nazw zestawów, aby sondować dynamicznie utworzyć zestawy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ustawić katalogu dynamicznym, przypisz ścieżkę katalogu podstawowego do <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> właściwość <xref:System.AppDomainSetup> obiekt, który będzie używany do utworzenia nowej domeny aplikacji. Ścieżka katalogu podstawowego przypisania do właściwości jest modyfikowany przez dodanie podkatalog o nazwie proste jest wartość skrótu ciągu można przypisać do <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> właściwości, więc jest formatu podstawowego katalogu *oryginalnej ścieżce* \\ *skrótu*. Dynamiczne katalog jest podkatalogiem katalogu podstawowego. Nazwy proste jest wartością <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> właściwości, dzięki czemu jego format jest *oryginalnej ścieżce*\\*skrótu*\\*Nazwa aplikacji*.  
  
   
  
## Examples  
 Poniższy przykład tworzy domenę aplikacji z katalogu dla zestawów dynamicznych, emituje zestawu dynamicznego i zapisuje go w katalogu dynamicznym ładuje zestaw do nowej domeny aplikacji i używa go.  
  
 W przykładzie jest tworzony <xref:System.AppDomainSetup> i ustawia jego <xref:System.AppDomainSetup.ApplicationName%2A> właściwość "Przykład" i jego <xref:System.AppDomainSetup.DynamicBase%2A> właściwość "C:\DynamicAssemblyDir". Przykład następnie wyświetla <xref:System.AppDomainSetup.DynamicBase%2A> właściwości, aby pokazać, że skrótu nazwę aplikacji ma zostały dołączane jako podkatalogu ścieżki, który pierwotnie został przypisany.  
  
> [!NOTE]
>  Katalog podstawowy, w tym przykładzie jest przeznaczona do przekraczających badania ścieżkę dla przykładowej aplikacji. Pamiętaj skompilować przykład w innej lokalizacji. Usuń katalog podstawowy i jego podkatalogach każdym uruchomieniu tego przykładu.  
  
 Przykład tworzy nową domenę aplikacji, za pomocą <xref:System.AppDomainSetup> obiektu. W przykładzie użyto <xref:System.AppDomain.DynamicDirectory%2A> właściwość służąca do pobierania nazwy katalogu, dzięki czemu może utworzyć katalogu. (Przykład może równie łatwo można utworzyć katalogu wcześniej przez złączenie oryginalnej ścieżce, skrótu nazwę aplikacji i nazwy aplikacji.)  
  
 W przykładzie przedstawiono `GenerateDynamicAssembly` metodę, która generuje zestaw o nazwie `DynamicHelloWorld.dll` i zapisuje go w katalogu dynamicznym nowej domeny aplikacji. Zestaw dynamiczny zawiera jeden typ `HelloWorld`, który ma metodę statyczną (`Shared` w języku Visual Basic) o nazwie `HelloFromAD`. Wywołanie tej metody zawiera nazwę domeny aplikacji.  
  
 `Example` Klasa pochodzi od <xref:System.MarshalByRefObject>, dlatego na przykład można utworzyć wystąpienia klasy w nowej domeny aplikacji i wywołanie jego `Test` metody. `Test` Metoda ładuje zestaw dynamiczny poprzez jego nazwę wyświetlaną i wywołuje statyczną `HelloFromAD` metody.  
  
 Możesz pokazać, że dynamiczne katalog jest przeszukiwany po normalne ścieżkach sondowania przez napisanie kodu dla zestawu o nazwie `DynamicHelloWorld.dll` i kompilowanie go w tym samym katalogu co w tym przykładzie. Zestaw musi mieć klasę o nazwie `HelloWorld` ze statyczną metodę o nazwie `HelloFromAD`. Ta metoda musi mieć taką samą funkcjonalność jak w przykładzie; po prostu umożliwia wyświetlanie ciągu w konsoli. Zestaw musi mieć również <xref:System.Reflection.AssemblyVersionAttribute> atrybut, który ustawia jego wersję do numeru 1.0.0.0. Po uruchomieniu tego przykładu, zestawu, który jest skompilowany w bieżącym katalogu znajduje się przed dynamiczne katalog jest przeszukiwany.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Security.Policy.Evidence" /> skojarzone z tej domeny aplikacji.</summary>
        <value>Dowód, skojarzone z tej domeny aplikacji.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje zestaw znajdujących się w określonym pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <summary>Wykonuje zestaw znajdujących się w określonym pliku.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Można również wykonywać zestawy za pomocą <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody, która ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody.  
  
 Aby utworzyć <xref:System.AppDomain> załadowanie i wykonanie, użyj <xref:System.AppDomain.CreateDomain%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, przy użyciu jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary>Wykonuje znajdujących się w określonym pliku zestawu przy użyciu określonego dowodów.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 <xref:System.AppDomain.ExecuteAssembly%2A> Metoda nie powoduje utworzenia nowego procesu ani domeny aplikacji, a nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Można również wykonywać zestawy za pomocą <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody, która ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, przy użyciu jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="args">Argumenty punktu wejścia w zestawie.</param>
        <summary>Wykonuje zawarte w określonym pliku zestawu przy użyciu określonych argumentów.</summary>
        <returns>Wartość, która jest zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Można również wykonywać zestawy za pomocą <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody, która ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, przy użyciu jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="assemblySecurity">Dowód dostarczony dla zestawu.</param>
        <param name="args">Argumenty punktu wejścia w zestawie.</param>
        <summary>Wykonuje zawarte w określonym pliku zestawu przy użyciu określonego dowodów i argumentów.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Można również wykonywać zestawy za pomocą <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody, która ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, przy użyciu jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="assemblySecurity" /> nie jest <see langword="null" />. Gdy starsza zasada CAS nie jest włączone, <paramref name="assemblySecurity" /> powinien być <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="args">Argumenty punktu wejścia w zestawie.</param>
        <param name="hashValue">Reprezentuje wartość obliczona wartość skrótu.</param>
        <param name="hashAlgorithm">Reprezentuje algorytm wyznaczania wartości skrótu manifestu zestawu.</param>
        <summary>Wykonuje zawarte w określonym pliku zestawu przy użyciu określonych argumentów, wartość skrótu i algorytm wyznaczania wartości skrótu.</summary>
        <returns>Wartość, która jest zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Można również wykonywać zestawy za pomocą <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody, która ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, przy użyciu jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="assemblySecurity">Dowód dostarczony dla zestawu.</param>
        <param name="args">Argumenty punktu wejścia w zestawie.</param>
        <param name="hashValue">Reprezentuje wartość obliczona wartość skrótu.</param>
        <param name="hashAlgorithm">Reprezentuje algorytm wyznaczania wartości skrótu manifestu zestawu.</param>
        <summary>Wykonuje zawarte w określonym pliku zestawu przy użyciu określonego dowód, argumenty, wartość skrótu i algorytm wyznaczania wartości skrótu.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Można również wykonywać zestawy za pomocą <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody, która ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody.  
  
   
  
## Examples  
 Thefollowing przykładzie pokazano użycie jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="assemblySecurity" /> nie jest <see langword="null" />. Gdy starsza zasada CAS nie jest włączone, <paramref name="assemblySecurity" /> powinien być <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonywanie zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Wykonuje zestaw, biorąc pod uwagę jego nazwę wyświetlaną.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A> metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie według lokalizacji pliku. W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A> ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody, a nie za pomocą <xref:System.Reflection.Assembly.LoadFile%2A> metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Aby utworzyć <xref:System.AppDomain> załadowanie i wykonanie, użyj <xref:System.AppDomain.CreateDomain%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zestaw określony przez <paramref name="assemblyName" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw określony przez <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw określony przez <paramref name="assemblyName" /> został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><see cref="T:System.Reflection.AssemblyName" /> Obiekt reprezentujący nazwę zestawu.</param>
        <param name="args">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Wykonuje zestaw, biorąc pod uwagę <see cref="T:System.Reflection.AssemblyName" />, przy użyciu określonych argumentów.</summary>
        <returns>Wartość, która jest zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A> metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie według lokalizacji pliku. W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A> ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody, a nie za pomocą <xref:System.Reflection.Assembly.LoadFile%2A> metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Zestaw określony przez <paramref name="assemblyName" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw określony przez <paramref name="assemblyName" /> został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw określony przez <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary>Wykonuje podane jego nazwę wyświetlaną zestawu przy użyciu określonego dowodów.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A> metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie według lokalizacji pliku. W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A> ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody, a nie za pomocą <xref:System.Reflection.Assembly.LoadFile%2A> metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda nie powoduje utworzenia nowego procesu ani domeny aplikacji, a nie wykonuje metody punktu wejścia w nowym wątku.  
  
> [!NOTE]
>  Kiedy używasz <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody z <xref:System.Security.Policy.Evidence> parametru dowody są scalane. Dowody dostarczone jako argument do <xref:System.AppDomain.ExecuteAssemblyByName%2A> metoda wypierają dowody dostarczone przez moduł ładujący.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zestaw określony przez <paramref name="assemblyName" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw określony przez <paramref name="assemblyName" /> został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw określony przez <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="args">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Wykonuje podane jego nazwę wyświetlaną zestawu przy użyciu określonych argumentów.</summary>
        <returns>Wartość, która jest zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A> metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie według lokalizacji pliku. W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A> ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody, a nie za pomocą <xref:System.Reflection.Assembly.LoadFile%2A> metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zestaw określony przez <paramref name="assemblyName" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw określony przez <paramref name="assemblyName" /> został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw określony przez <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><see cref="T:System.Reflection.AssemblyName" /> Obiekt reprezentujący nazwę zestawu.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <param name="args">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Wykonuje zestaw, biorąc pod uwagę <see cref="T:System.Reflection.AssemblyName" />, przy użyciu określonego dowodów i argumentów.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A> metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie według lokalizacji pliku. W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A> ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody, a nie za pomocą <xref:System.Reflection.Assembly.LoadFile%2A> metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
> [!NOTE]
>  Kiedy używasz <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody z <xref:System.Security.Policy.Evidence> parametru dowody są scalane. Dowody dostarczone jako argument do <xref:System.AppDomain.ExecuteAssemblyByName%2A> metoda wypierają dowody dostarczone przez moduł ładujący.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Zestaw określony przez <paramref name="assemblyName" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw określony przez <paramref name="assemblyName" /> został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw określony przez <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="assemblySecurity" /> nie jest <see langword="null" />. Gdy starsza zasada CAS nie jest włączone, <paramref name="assemblySecurity" /> powinien być <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <param name="args">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Wykonuje podane jego nazwę wyświetlaną zestawu przy użyciu określonego dowodów i argumentów.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A> metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie według lokalizacji pliku. W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A> ładuje zestawy przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody, a nie za pomocą <xref:System.Reflection.Assembly.LoadFile%2A> metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
> [!NOTE]
>  Kiedy używasz <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody z <xref:System.Security.Policy.Evidence> parametru dowody są scalane. Dowody dostarczone jako argument do <xref:System.AppDomain.ExecuteAssemblyByName%2A> metoda wypierają dowody dostarczone przez moduł ładujący.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zestaw określony przez <paramref name="assemblyName" /> nie zostanie znaleziony.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw określony przez <paramref name="assemblyName" /> został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw określony przez <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="assemblySecurity" /> nie jest <see langword="null" />. Gdy starsza zasada CAS nie jest włączone, <paramref name="assemblySecurity" /> powinien być <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek jest zgłaszany w kodzie zarządzanym, zanim środowisko uruchomieniowe wyszukuje stos wywołań dla obsługi wyjątków w domenie aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest tylko powiadomienia. Obsługa tego zdarzenia obsłużyć wyjątek lub nie mieć wpływ na kolejne obsługi wyjątków w dowolny sposób. Po zwiększeniu zdarzenia i procedury obsługi zdarzeń wywołanych, środowisko uruchomieniowe języka wspólnego (CLR) rozpoczyna się wyszukiwanie program obsługi wyjątku. <xref:System.AppDomain.FirstChanceException> udostępnia domeny aplikacji z pierwszej szansy zbadać wszelkie zarządzanym wyjątku.  
  
 Zdarzenia mogą być obsługiwane dla domeny aplikacji. Jeśli wątek przechodzi przez wiele domen aplikacji podczas wykonywania wywołania, zdarzenie jest wywoływane w każdej domenie aplikacji, który został zarejestrowany program obsługi zdarzeń, przed rozpoczęciem środowiska CLR, wyszukując pasującej klauzuli obsługi wyjątków w tej domenie aplikacji. Po obsłużeniu zdarzenia wyszukiwania zostanie przeprowadzona dla pasującej klauzuli obsługi wyjątków w tej domenie aplikacji. Jeśli nie zostanie znaleziony, zdarzenie jest wywoływane w następnej domeny aplikacji.  
  
 Musi obsługiwać wszystkie wyjątki, które występują w przypadku obsługi <xref:System.AppDomain.FirstChanceException> zdarzeń. W przeciwnym razie <xref:System.AppDomain.FirstChanceException> jest podniesione cyklicznie. Może to spowodować przepełnienie stosu i kończenie działania aplikacji. Firma Microsoft zaleca wdrożenia programów obsługi zdarzeń dla tego zdarzenia jako ograniczone regiony wykonania (CERs), aby uniknąć wpływu na maszynę wirtualną, gdy zgłoszenie wyjątku jest wyjątków związanych z infrastrukturą, takie jak braku pamięci lub stack overflow Trwa przetwarzanie.  
  
 To zdarzenie nie jest inicjowane dla wyjątków, które wskazują uszkodzenie stan procesu, takie jak naruszenia zasad dostępu, chyba że program obsługi zdarzeń jest krytyczne dla bezpieczeństwa, a ma <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> atrybutu.  
  
 Środowisko uruchomieniowe języka wspólnego wstrzymuje przerwań wątku podczas tego zdarzenia powiadomień jest obsługiwane.  
  
   
  
## Examples  
 Poniższy przykład tworzy serię domen aplikacji o nazwie `AD0` za pośrednictwem `AD3`, za pomocą `Worker` obiektu w każdej domenie aplikacji. Każdy `Worker` obiekt odwołuje się do `Worker` obiektu w następnej domeny aplikacji, z wyjątkiem `Worker` w to ostatnia domena aplikacji. <xref:System.AppDomain.FirstChanceException> Zdarzenie jest obsługiwane we wszystkich domenach aplikacji, z wyjątkiem `AD1`.  
  
> [!NOTE]
>  Oprócz tego przykładu, który pokazuje powiadomień o wyjątkach pierwszej szansy w wielu domenach aplikacji, można znaleźć prostych zastosowań w [jak: Odbieranie powiadomień o wyjątkach pierwszej szansy](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).  
  
 Podczas tworzenia domen aplikacji domyślnej domeny aplikacji wywołuje `TestException` metody dla pierwszej domeny aplikacji. Każdy `Worker` obiektu wywołania `TestException` metodę dla następnej domeny aplikacji, aż do ostatniego `Worker` zgłasza wyjątek, który jest obsługiwany lub nieobsługiwany. W efekcie bieżącego wątku przechodzi przez wszystkie domeny aplikacji i `TestException` jest dodawany do stosu w każdej domenie aplikacji.  
  
 Podczas ostatniego `Worker` obiektu obsługuje dany wyjątek <xref:System.AppDomain.FirstChanceException> zdarzenie jest wywoływane tylko w przypadku będzie to ostatnia domena aplikacji. Domeny aplikacji nigdy nie uzyskać szansę, aby obsłużyć wyjątek, aby zdarzenie nie zostanie wywołane.  
  
 Podczas ostatniego `Worker` obiekt nie obsługuje wyjątek, <xref:System.AppDomain.FirstChanceException> zdarzenie jest zgłaszane w każdej domenie aplikacji, która ma program obsługi zdarzeń. Po zakończeniu każdej obsługi zdarzenia stosu w dalszym ciągu Odwiń do momentu wyjątek zostaje przechwycony przez domyślnej domeny aplikacji.  
  
> [!NOTE]
>  Aby zobaczyć, jak wyświetlanie stosu wraz ze wzrostem, ponieważ zdarzenie jest wywoływane bliżej i bliżej domyślnej domeny aplikacji, należy zmienić `e.Exception.Message` do `e.Exception` w `FirstChanceHandler` procedury obsługi zdarzeń. Należy zauważyć, że w przypadku `TestException` poza granice domeny aplikacji, nazywa się pojawia się dwukrotnie: raz dla serwera proxy i jeden raz dla wycinka.  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
        <related type="Article" href="https://msdn.microsoft.com/library/66f002b8-a97d-4a6e-a503-2cec01689113">Instrukcje: Odbieranie powiadomień o wyjątkach pierwszej szansy</related>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przyjazną nazwę tej domeny aplikacji.</summary>
        <value>Przyjazna nazwa tej domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przyjazna nazwa domyślnej domeny aplikacji jest nazwa pliku wykonywalnego procesu. Na przykład, jeśli plik wykonywalny używane do uruchamiania procesu jest `"c:\MyAppDirectory\MyAssembly.exe"`, przyjazna nazwa domyślnej domeny aplikacji jest `"MyAssembly.exe"`.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.AppDomain.FriendlyName%2A> właściwości do pobrania przyjazną nazwę bieżącej domeny aplikacji. Dla domyślnej domeny aplikacji przyjazna nazwa jest nazwą pliku wykonywalnego aplikacji. Przykładowy kod przedstawia również dodatkowe informacje na temat domeny aplikacji.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera zestawy, które zostały załadowane do kontekstu wykonania tej domeny aplikacji.</summary>
        <returns>Tablica zestawów w tej domenie aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.AppDomain.GetAssemblies%2A> metodę, aby uzyskać listę wszystkich zestawów, które zostały załadowane do domeny aplikacji. Zestawy są następnie wyświetlane w konsoli.  
  
 Aby uruchomić ten przykład kodu, należy utworzyć zestaw o nazwie `CustomLibrary.dll`, lub zmień nazwę zestawu, który jest przekazywany do <xref:System.AppDomain.GetAssemblies%2A> metody.  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera identyfikator bieżącego wątku.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem identyfikator bieżącego wątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> właściwość, która jest stabilna, nawet po programu .NET Framework jest obsługiwany przez środowisko, które obsługuje włókien (wątki uproszczonego).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywołać tę metodę. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości domeny wstępnie zdefiniowanych aplikacji lub nazwą właściwości domeny aplikacji zdefiniowano.</param>
        <summary>Pobiera wartość przechowywaną w bieżącej domenie aplikacji dla określonej nazwy.</summary>
        <returns>Wartość <paramref name="name" /> właściwości lub <see langword="null" /> Jeśli właściwość nie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do pobierania wartości wpisu w wewnętrznej pamięci podręcznej par nazwa danych, które opisują właściwości tego wystąpienia <xref:System.AppDomain>. Należy pamiętać, że porównanie `name` o nazwie pary klucz wartość jest uwzględniana wielkość liter.  
  
 Pamięć podręczna automatycznie zawiera wpisy wstępnie zdefiniowanego, które są wstawiane po utworzeniu domeny aplikacji. Możesz sprawdzić ich wartościami <xref:System.AppDomain.GetData%2A> metody lub równoważny <xref:System.AppDomainSetup> właściwości.  
  
 Można wstawić lub zmodyfikować własne pary nazwa danych zdefiniowane przez użytkownika za pomocą <xref:System.AppDomain.SetData%2A> metody i sprawdzić ich wartościami <xref:System.AppDomain.GetData%2A> metody.  
  
 W poniższej tabeli opisano `name` każdego wstępnie zdefiniowane wpisu systemu i odpowiadającymi mu dostawcami <xref:System.AppDomainSetup> właściwości.  
  
|Wartość atrybutu "name"|Właściwość|  
|---------------------|--------------|  
|"APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|(nie właściwość)<br /><br /> "APP_LAUNCH_URL" odpowiada adresowi URL, o których pierwotnie żądanej przez użytkownika, zanim wszelkie przekierowania. Jest ona dostępna tylko wtedy, gdy aplikacja została uruchomiona przy użyciu przeglądarki, takich jak program Internet Explorer. Nie wszystkie przeglądarki, podaj tę wartość.|  
|"APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|(nie właściwość)|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|"FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|"LICENSE_FILE" lub ciąg specyficzne dla aplikacji|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|"LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|"LOCATION_URI"|(nie właściwość)|  
|"PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> "REGEX_DEFAULT_MATCH_TIMEOUT" nie jest wpisem systemu i jego wartość może zostać ustawiona przez wywołanie metody <xref:System.AppDomain.SetData%2A> metody.|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 Poniższy przykład tworzy nową domenę aplikacji, ustawia wartość dostarczane przez system dla domeny i dodaje parę wartości nowej domeny. W przykładzie następnie pokazano sposób użycia <xref:System.AppDomain.GetData%2A> metodę, aby pobrać dane z tych par wartości i wyświetlać je w konsoli.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji w samej, jeśli właściwość ma zastosowanie do ścieżki ścieżce. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typ bieżącego wystąpienia.</summary>
        <returns>Typ bieżącego wystąpienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą, która jednoznacznie identyfikuje domeny aplikacji w ramach procesu.</summary>
        <value>Liczba całkowita, która identyfikuje domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy drugą domenę aplikacji i wyświetla informacje o domyślnej domeny i nowej domeny.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia <see cref="T:System.AppDomain" /> przez cały okres istnienia, uniemożliwiając tworzonych przez dzierżawy.</summary>
        <returns>Zawsze <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Przełącznik zgodności do testowania.</param>
        <summary>Pobiera wartość logiczną dopuszcza wartości null wskazuje, czy ustawiono żadnych przełączników zgodności, a jeśli tak, czy przełącznik zgodności określona jest wartość.</summary>
        <returns>Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), gdy są ustawione żadne przełączniki zgodności; w przeciwnym razie wartość typu Boolean wskazująca czy zgodności przełącznika, który jest określony przez <paramref name="value" /> jest ustawiona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy przełącznik zgodności określonego został ustawiony dla bieżącej domeny aplikacji. Przełączników zgodności zazwyczaj przywrócić zachowanie (takie jak sposób ciągi są sortowane), został zmieniony między wersjami programu .NET Framework.  Są one ustalane przez wywołanie <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> metoda przed utworzeniem domeny aplikacji.  
  
 Poniższa tabela zawiera przykłady przełączników zgodności, które można ustawić, aby przywrócić zachowanie wcześniejszych wersji programu .NET Framework.  
  
|Przełącznik|Znaczenie|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Code access security (CAS) dla [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] jest włączona w tej domenie aplikacji. Zobacz [ &lt;NetFx40_LegacySecurityPolicy&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Ustawienia domyślne sortowania ciągów [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] są włączone w tej domenie aplikacji. Jej sukces wymaga sort00001000.dll do zainstalowania. Zobacz [ &lt;CompatSortNLSVersion&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Ustawienia domyślne sortowania ciągów [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]a standard Unicode 5.0 są włączone w tej domenie aplikacji. Jej sukces wymaga sort00060101.dll do zainstalowania.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> Formatowanie zachowanie [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] jest włączona w tej domenie aplikacji.  Zobacz [ &lt;TimeSpan_LegacyFormatMode&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) sekcji "Przywracanie starszej wersji TimeSpan formatowanie" i <xref:System.TimeSpan> tematu.|  
|"UseRandomizedStringHashAlgorithm"|Środowisko uruchomieniowe oblicza kody skrótów dla ciągów na podstawie domeny aplikacji zamiast pojedynczego algorytmu mieszania, który produkuje spójny kod mieszany w różnych domenach aplikacji. Zobacz [ &lt;userandomizedstringhashalgorithm —&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy domena aplikacji jest domyślnej domeny aplikacji dla procesu.</summary>
        <returns><see langword="true" /> Jeśli bieżący <see cref="T:System.AppDomain" /> obiekt reprezentuje domyślnej domeny aplikacji dla procesu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy proces zarządzany ma domyślnej domeny aplikacji. Wykonywanie programu rozpoczyna się w domenie domyślnej.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy drugą domenę aplikacji i wyświetla informacje o domyślnej domeny i nowej domeny.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy ta domena aplikacji jest zwolnienie i obiektami, które zawiera są zatwierdzony przez środowisko uruchomieniowe języka wspólnego.</summary>
        <returns><see langword="true" /> Jeśli ta domena aplikacji jest zwolnienie i środowisko uruchomieniowe języka wspólnego rozpoczęto wywoływania finalizatory; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda finalizacji obiektu zapewnia możliwość wykonywać dowolne operacje niezbędne czyszczenia, zanim obiekt będzie bezużyteczne. Po zakończeniu obiekt jest dostępny, ale w nieprawidłowym stanie i w związku z tym bezużyteczny. Po pewnym czasie wyrzucania elementów bezużytecznych kończy i odzyskuje obiektu.  
  
 Metoda finalizacji obiektu jest wywoływana w jednym z następujących sytuacji: podczas wyrzucania elementów bezużytecznych, gdy środowisko uruchomieniowe języka wspólnego jest zamykany lub w przypadku, gdy domena aplikacji, która zawiera obiekt jest zwalniana. <xref:System.AppDomain.IsFinalizingForUnload%2A> Metoda zwraca `true` tylko w ostatnim przypadku; nie zwraca `true` Jeśli finalizacji wyniki z procedur wyrzucania elementów bezużytecznych lub zamykaniu środowiska CLR.  
  
> [!NOTE]
>  Aby określić, czy finalizacji wynika z zamykaniu środowiska CLR, użyj <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> właściwości. Zwraca `true` w przypadku finalizacji jest zakończona z powodu Trwa zwalnianie domeny aplikacji lub do zamykania środowiska CLR.  
  
 Podczas wykonywania w metodzie finalizacji jest zakończona podczas zwalniania domeny, możesz chcieć uzyskać dostęp inny obiekt, który odwołuje się do niej pole statyczne i ma metodę finalizacji jest zakończona. Jednak nie można niezawodnie tak zrobisz, ponieważ dostęp do obiektu może już mieć sfinalizowany.  
  
> [!NOTE]
>  Wyjątkiem od tej reguły jest <xref:System.Console> klasy, która zawiera pola statyczne, które odwołują się obiekty strumienia, ale jest zaimplementowana specjalnie, dzięki czemu zawsze można zapisywać na konsoli systemu nawet podczas zamykania systemu lub zwalnianie domeny.  
  
 Ta metoda w metodzie finalizacji obiektu do określenia, czy zwalniania domeny aplikacji, która zawiera obiekt. Jeśli tak jest rzeczywiście nie niezawodny dostęp do dowolnego obiektu, który ma metodę finalizacji i odwołuje się do niej pole statyczne.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy zestawy, które są ładowane do bieżącej domeny aplikacji wykonywanie z pełnym zaufaniem.</summary>
        <value><see langword="true" /> Jeśli zestawy, które są ładowane do bieżącej domeny aplikacji są wykonywane z pełnym zaufaniem; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zawsze zwraca `true` dla domyślnej domeny aplikacji o aplikację działającą na pulpicie. Zwraca `false` dla domeny aplikacji w trybie piaskownicy, który został utworzony przy użyciu <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> przeciążenia metody, chyba że uprawnienia, które są przypisywane do domeny aplikacji są równoważne z pełnym zaufaniem.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.IsFullyTrusted%2A> właściwości i <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości z domenami całkowicie zaufanym i częściowo zaufanych aplikacji. W pełni zaufanej domeny aplikacji jest domyślnej domeny aplikacji dla aplikacji. Domeny aplikacji częściowo zaufanej jest tworzona przy użyciu <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> przeciążenie metody.  
  
 W przykładzie użyto `Worker` klasę pochodzącą od <xref:System.MarshalByRefObject>, dzięki czemu mogą być organizowane poza granice domeny aplikacji. W przykładzie jest tworzony `Worker` obiektu w domyślnej domeny aplikacji. Następnie wywołuje `TestIsFullyTrusted` metodę w celu wyświetlenia wartości właściwości dla domeny aplikacji i dwa zestawy, które są ładowane do domeny aplikacji: mscorlib, który jest częścią programu .NET Framework i zestaw przykładu. Domeny aplikacji jest w pełni zaufany, dzięki czemu oba zestawy są w pełni zaufane.  
  
 W przykładzie jest tworzony inny `Worker` obiektu w domenie aplikacji w trybie piaskownicy i ponownie wywołuje `TestIsFullyTrusted` metody. Mscorlib zawsze jest zaufany, nawet w przypadku domeny częściowo zaufanych aplikacji, ale zestaw przykład jest częściowo zaufany.  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżącej domeny aplikacji ma zestaw uprawnień przydzielanych wszystkich zestawów, które są ładowane do domeny aplikacji.</summary>
        <value><see langword="true" /> Jeśli bieżąca domena aplikacji ma jednorodnego zestaw uprawnień; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `true` dla domen aplikacji w trybie piaskownicy, które zostały utworzone przy użyciu <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> przeciążenie metody. Domen aplikacji w trybie piaskownicy ma jednorodnego zestawu uprawnień; oznacza to, że ten sam zestaw uprawnień zostanie ustanowione wszystkich częściowo zaufanych zestawów, które są ładowane do domeny aplikacji. Domeny aplikacji w trybie piaskownicy ma opcjonalnie listy zestawów o silnych nazwach, które są wykluczone z tego uprawnienia, ustaw, a zamiast tego uruchomić z pełnym zaufaniem.  
  
 W pełni zaufany kod może użyć <xref:System.AppDomain.PermissionSet%2A> własność, aby określić zestaw uprawnień jednolitą domenę aplikacji w trybie piaskownicy.  
  
 Właściwość ta zwraca również wartość `true` dla domyślnej domeny aplikacji, aplikacji pulpitu, ponieważ tej domeny aplikacji przyznaje wszystkich zestawów pełnego zaufania.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> do tej domeny aplikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica typu <see langword="byte" /> czyli COFF obrazów zawierającym emitowany zestaw.</param>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> przy użyciu pliku obiektu wspólnego format (COFF) na podstawie obrazu zawierającego emitowany <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], poziom zaufania zestawu, który jest ładowany za pomocą tej metody jest taka sama jak poziom zaufania domeny aplikacji.  
  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest przewidziane jako udogodnienie współdziałania obiektów wywołujących, które nie mogą wywołać statyczną <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody. Ładowanie zestawów do innych domen aplikacji, użyj metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje, które są wspólne dla wszystkich przeciążeń z tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie podczas ładowania zestawu raw.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Obiekt, który opisuje zestawu do załadowania.</param>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> biorąc pod uwagę jej <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest przewidziane jako udogodnienie współdziałania obiektów wywołujących, które nie mogą wywołać statyczną <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody. Ładowanie zestawów do innych domen aplikacji, użyj metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Jeśli wersja żądany zestaw jest już załadowany, ta metoda zwraca załadowany zestaw, nawet jeśli wymagana jest inna wersja.  
  
 Dostarczanie częściową nazwę zestawu dla `assemblyRef` nie jest zalecane. (Część nazwy są pomijane przez co najmniej kultury, wersji i token klucza publicznego. Dla przeciążeń, które przyjmują ciąg, a nie <xref:System.Reflection.AssemblyName> obiektu, "MyAssembly, Version = 1.0.0.0" jest przykładem część nazwy i "MyAssembly, Version = 1.0.0.0, kultura = neutral, PublicKeyToken = 18ab3442da84b47" znajduje się przykład Pełna nazwa.) Używając części nazwisk ma negatywny wpływ na wydajność. Ponadto częściową nazwę zestawu można załadować zestawu z globalnej pamięci podręcznej tylko wtedy, gdy dokładną kopię zestawu w katalogu podstawowego aplikacji (<xref:System.AppDomain.BaseDirectory%2A> lub <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).  
  
 Jeśli bieżący <xref:System.AppDomain> obiekt reprezentuje domenę aplikacji `A`i <xref:System.AppDomain.Load%2A> metoda jest wywoływana z domeny aplikacji `B`, zestaw jest ładowany do obu domen aplikacji. Na przykład, poniższy kod ładowania `MyAssembly` do nowej domeny aplikacji `ChildDomain` również do domeny aplikacji, w którym wykonuje kodu:  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 Zestaw jest ładowany w obu domenach, ponieważ <xref:System.Reflection.Assembly> nie pochodzi od <xref:System.MarshalByRefObject>i w związku z tym wartość zwracana przez <xref:System.AppDomain.Load%2A> metody nie mogą być przekazywane. Zamiast tego środowiska uruchomieniowego języka wspólnego próbuje załadować zestaw do domeny aplikacji wywołującej. Zestawy, które są ładowane do obu domen aplikacji mogą się różnić, jeśli ustawienia ścieżek obu domen aplikacji są różne.  
  
> [!NOTE]
>  Jeśli oba <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> właściwości i <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> właściwości są ustawione, pierwsza próba załadowania zestawu używa nazwy wyświetlanej (łącznie z wersji, kultury i tak dalej, zwrócone przez <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> właściwości). Jeśli plik nie zostanie znaleziony, <xref:System.Reflection.AssemblyName.CodeBase%2A> właściwość jest używana do wyszukiwania dla zestawu. Jeśli zestaw znajduje się za pomocą <xref:System.Reflection.AssemblyName.CodeBase%2A>, nazwa wyświetlana jest dopasowywana do zestawu. Jeśli dopasowanie nie powiedzie się, <xref:System.IO.FileLoadException> zgłaszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyRef" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> biorąc pod uwagę jego nazwę wyświetlaną.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest przewidziane jako udogodnienie współdziałania obiektów wywołujących, które nie mogą wywołać statyczną <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody. Ładowanie zestawów do innych domen aplikacji, użyj metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje, które są wspólne dla wszystkich przeciążeń z tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> jest <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyString" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica typu <see langword="byte" /> czyli COFF obrazów zawierającym emitowany zestaw.</param>
        <param name="rawSymbolStore">Tablica typu <see langword="byte" /> zawierające bajty raw, reprezentujący symbole dla zestawu.</param>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> przy użyciu pliku obiektu wspólnego format (COFF) na podstawie obrazu zawierającego emitowany <see cref="T:System.Reflection.Assembly" />. Bajtów raw, reprezentujący symbole dla <see cref="T:System.Reflection.Assembly" /> również są ładowane.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], poziom zaufania zestawu, który jest ładowany za pomocą tej metody jest taka sama jak poziom zaufania domeny aplikacji.  
  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest przewidziane jako udogodnienie współdziałania obiektów wywołujących, które nie mogą wywołać statyczną <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody. Ładowanie zestawów do innych domen aplikacji, użyj metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje, które są wspólne dla wszystkich przeciążeń z tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie podczas ładowania zestawu raw.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Obiekt, który opisuje zestawu do załadowania.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> biorąc pod uwagę jej <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest przewidziane jako udogodnienie współdziałania obiektów wywołujących, które nie mogą wywołać statyczną <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody. Ładowanie zestawów do innych domen aplikacji, użyj metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje, które są wspólne dla wszystkich przeciążeń z tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" /> jest <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyRef" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania ścieżkę, która nie znajduje się w formularzu "file://" lub "\\\UNC\dir\\" lub "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> biorąc pod uwagę jego nazwę wyświetlaną.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest przewidziane jako udogodnienie współdziałania obiektów wywołujących, które nie mogą wywołać statyczną <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody. Ładowanie zestawów do innych domen aplikacji, użyj metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje, które są wspólne dla wszystkich przeciążeń z tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> jest <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyString" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania ścieżkę, która nie znajduje się w formularzu "file://" lub "\\\UNC\dir\\" lub "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica typu <see langword="byte" /> czyli COFF obrazów zawierającym emitowany zestaw.</param>
        <param name="rawSymbolStore">Tablica typu <see langword="byte" /> zawierające bajty raw, reprezentujący symbole dla zestawu.</param>
        <param name="securityEvidence">Dowód ładowania zestawu.</param>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> przy użyciu pliku obiektu wspólnego format (COFF) na podstawie obrazu zawierającego emitowany <see cref="T:System.Reflection.Assembly" />. Bajtów raw, reprezentujący symbole dla <see cref="T:System.Reflection.Assembly" /> również są ładowane.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], poziom zaufania zestawu, który jest ładowany za pomocą tej metody jest taka sama jak poziom zaufania domeny aplikacji.  
  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest przewidziane jako udogodnienie współdziałania obiektów wywołujących, które nie mogą wywołać statyczną <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody. Ładowanie zestawów do innych domen aplikacji, użyj metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje, które są wspólne dla wszystkich przeciążeń z tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie podczas ładowania zestawu raw.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="securityEvidence" /> nie jest <see langword="null" />. Gdy starsza zasada CAS nie jest włączone, <paramref name="securityEvidence" /> powinien być <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania ścieżkę, która nie znajduje się w formularzu "file://" lub "\\\UNC\dir\\" lub "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy procesor CPU i pamięci monitorowania domeny aplikacji jest włączone dla bieżącego procesu. Gdy monitorowanie jest włączone dla procesu, nie można wyłączyć.</summary>
        <value><see langword="true" /> Jeśli jest włączone monitorowanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To `static` właściwości (`Shared` właściwość w języku Visual Basic) steruje procesora CPU i pamięci monitorowania wszystkich domen aplikacji w procesie.  
  
 Jeśli spróbujesz ustawić tę właściwość na `false`, <xref:System.ArgumentException> wyjątek jest zgłaszany, nawet jeśli bieżąca wartość właściwości jest `false`.  
  
 Gdy jest włączone monitorowanie, możesz użyć <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, i <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> wystąpienia właściwości do monitorowania użycia procesora CPU i pamięci poszczególnych aplikacji domen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący proces Próba przypisania wartości <see langword="false" /> do tej właściwości.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Monitorowanie zasobów domen aplikacji</related>
        <related type="Article" href="https://msdn.microsoft.com/library/02119ab6-1e91-448e-97ad-e7b2e5c4bbbd">&lt;appdomainresourcemonitoring —&gt; — Element</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę bajtów, które przetrwały ostatniego zebrania i które są znane, aby odwoływać się do bieżącej domeny aplikacji.</summary>
        <value>Liczba bajtów poprawny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statystyki są aktualizowane przy użyciu każdego wyrzucania elementów bezużytecznych. Jednak mają gwarancję, że muszą być dokładne dopiero po pełnej, blokowanie pamięci; oznacza to, że występuje kolekcję zawierającą wszystkie generacje i który zatrzymuje aplikację podczas zbierania. Na przykład <xref:System.GC.Collect?displayProperty=nameWithType> przeciążenie metody wykonywania pełnego, blokowanie pamięci. (Kolekcji współbieżnych przebiega w tle i nie są blokowane w aplikacji).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> właściwość jest ustawiona na <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Monitorowanie zasobów domen aplikacji</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą liczbę bajtów, które przetrwały od ostatniego zebrania dla wszystkich domen aplikacji w procesie.</summary>
        <value>Całkowita liczba bajtów przy życiu dla procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po pobraniu pełne, blokowanie ten numer reprezentuje liczbę bajtów obecnie nałożona na żywo w zarządzanych stosów. Należy się blisko numer zgłoszony przez <xref:System.GC.GetTotalMemory%2A> metody. Po pobraniu tymczasowych ten numer reprezentuje liczbę bajtów obecnie nałożona na żywo w generacje efemeryczne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> właściwość jest ustawiona na <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Monitorowanie zasobów domen aplikacji</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowity rozmiar w bajtach, wszystkie alokacje pamięci, które zostały wprowadzone przez domenę aplikacji, ponieważ został utworzony, bez odjęcie ilości pamięci, które zostały zebrane.</summary>
        <value>Całkowity rozmiar wszystkich alokacji pamięci.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> właściwość jest ustawiona na <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Monitorowanie zasobów domen aplikacji</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitego czasu procesora użytą przez wszystkie wątki podczas wykonywania w bieżącej domenie aplikacji, od momentu uruchomienia procesu.</summary>
        <value>Łączny czas procesora dla bieżącej domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Łączny czas, który jest zgłaszany domeny aplikacji obejmuje czas każdy wątek w procesie wykonywania w tej domenie aplikacji.  
  
 Wątek, który wywołuje kod niezarządzany nadal jest skojarzona z domeny aplikacji i czasu procesora poświęconego na wykonywanie kodu niezarządzanego jest raportowane dla domeny aplikacji, w którym wykonano wywołanie.  
  
 Jeśli wątek jest zablokowany lub uśpienia, nie używa czasu procesora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> właściwość jest ustawiona na <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Monitorowanie zasobów domen aplikacji</related>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestaw uprawnień w domenie aplikacji w trybie piaskownicy.</summary>
        <value>Zestaw uprawnień w domenie aplikacji w trybie piaskownicy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domeny aplikacji w trybie piaskownicy, które zostały utworzone przy użyciu <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> przeciążenia metody ma jednorodnego zestawu uprawnień; oznacza to, że ten sam zestaw uprawnień zostanie ustanowione wszystkich częściowo zaufanych zestawów, które są ładowane do domeny aplikacji. Domeny aplikacji w trybie piaskownicy ma opcjonalnie listy zestawów o silnych nazwach, które są wykluczone z tego uprawnienia, ustaw, a zamiast tego uruchomić z pełnym zaufaniem.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy kończy proces nadrzędny domyślnej domeny aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler> Dla tego zdarzenia można wykonać zakończenia działań, takich jak zamykanie plików, zwalniając magazynu i tak dalej przed zakończeniem procesu.  
  
 Począwszy od programu .NET Framework w wersji 2.0, to zdarzenie jest wywoływane w każdej domenie aplikacji, który rejestruje program obsługi zdarzeń.  
  
> [!NOTE]
>  Łączny czas wykonywania wszystkich <xref:System.AppDomain.ProcessExit> procedury obsługi zdarzeń jest ograniczona, tak, jak całkowity czas wykonywania wszystkich finalizatory jest ograniczony przy zamykaniu procesu. Wartość domyślna to 2 sekundy. Niezarządzany host może zmienić czas wykonywania przez wywołanie metody [iclrpolicymanager::setTimeout —](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) metody z [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) wartość wyliczenia.  
  
 W .NET Framework w wersji 1.0 i 1.1 to zdarzenie jest wywoływane tylko w domyślnej domeny aplikacji i tylko wtedy, gdy program obsługi zdarzeń jest zarejestrowany w domyślnej domeny aplikacji.  
  
 Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musisz mieć wymagane uprawnienia, lub <xref:System.Security.SecurityException> zgłaszany.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy rozpoznawania zestawu nie powiodło się w kontekstu reflection-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku kontekstu reflection-only zależności nie są rozpoznawane automatycznie. Musi być wstępnie załadowane lub zwrócone przez procedurę obsługi dla tego zdarzenia. To zdarzenie jest wywoływane, gdy zestaw ma zależność, która nie jest już załadowana do kontekstu reflection-only. Brak zależności jest określona przez <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> właściwości. <xref:System.ResolveEventHandler> Dla tego zdarzenia musi zwrócić zestaw, który spełnia zależności. Zestaw, który jest zwracany muszą być załadowane do kontekstu reflection-only.  
  
> [!IMPORTANT]
>  To zdarzenie jest wywoływane tylko w przypadku brakujących zależności zestawów, które są ładowane do kontekstu reflection-only (na przykład za pomocą <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> metody). Nie jest inicjowane, jeśli nie można odnaleźć zestawu, który jest ładowany.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> właściwość zwraca zestaw, który zażądał ładowanie zestawu, którego nie można rozpoznać. Znając tożsamości żądającego zestawu może być przydatna podczas identyfikacji poprawna wersja zależności, jeśli więcej niż jedna wersja jest dostępna. Aby uzyskać więcej informacji, zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Dla tego zdarzenia <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> właściwość zwraca nazwę zestawu, przed zastosowaniem zasad.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca zestawy, które zostały załadowane do kontekstu reflection-only domeny aplikacji.</summary>
        <returns>Tablica <see cref="T:System.Reflection.Assembly" /> obiekty reprezentujące zestawy ładowane do kontekstu reflection-only domeny aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zestawy, które zostały załadowane do kontekstu reflection-only. Aby uzyskać zestawów, które zostały załadowane do wykonania, użyj <xref:System.AppDomain.GetAssemblies%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu ładuje zestaw System.dll w kontekście wykonywania, a następnie do kontekstu reflection-only. <xref:System.AppDomain.GetAssemblies%2A> i <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> metody są używane do wyświetlania zestawy ładowane w każdym kontekście.  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Nastąpi próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę w ramach podstawowego katalogu, gdzie mechanizm rozpoznawania zestawów powinny sondowania dla zestawy prywatne.</summary>
        <value>Ścieżka w ramach podstawowego katalogu, gdzie mechanizm rozpoznawania zestawów powinny sondować zestawy prywatne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestawy prywatne są wdrażane w tej samej struktury katalogów aplikacji. Jeśli ścieżka określona przez <xref:System.AppDomain.RelativeSearchPath%2A> właściwość nie jest w obszarze <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, jest on ignorowany.  
  
 Ta właściwość zwraca wartość można ustawić przy użyciu <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy rozwiązanie zasobu nie powiedzie się, ponieważ zasób nie jest prawidłowy zasób osadzony lub połączony w zestawie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ResolveEventHandler> Dla tego zdarzenia może podejmować próby zlokalizowania zestawu zawierającego zasobu i przywrócić go.  
  
> [!IMPORTANT]
>  To zdarzenie nie jest inicjowane, jeśli rozpoznawanie zakończy się niepowodzeniem, ponieważ plik nie znajduje się nieprawidłowa zasobu połączonego. Jest zgłaszany, jeśli nie można znaleźć strumienia zasobu manifestu, ale nie jest inicjowane, jeśli nie można odnaleźć klucza pojedynczy zasób.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> właściwość zawiera zestaw, który żądanego zasobu. Aby uzyskać więcej informacji, zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musisz mieć wymagane uprawnienia, lub <xref:System.Security.SecurityException> zgłaszany.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">Poziom zasad zabezpieczeń.</param>
        <summary>Określa poziom zasad zabezpieczeń dla tej domeny aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę należy wywołać przed zestaw jest ładowany do <xref:System.AppDomain> w kolejności dla zasad zabezpieczeń, aby mieć wpływ.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.AppDomain.SetAppDomainPolicy%2A> metodę, aby ustawić poziom zasad zabezpieczeń domeny aplikacji.  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domainPolicy" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Poziom zasad zabezpieczeń został już ustawiony.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">W pełni kwalifikowana ścieżka do lokalizacji kopii w tle.</param>
        <summary>Określa ścieżkę katalogu określonego jako lokalizacja, w których zestawy są kopiowane w tle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ścieżka pamięci podręcznej jest ignorowana, jeśli <xref:System.AppDomainSetup.ApplicationName%2A> nie ustawiono właściwości. Zobacz <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> właściwości.  
  
 Aby uzyskać więcej informacji dotyczących kopiowania w tle Zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przypisuje wartość do właściwości domeny aplikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości domeny zdefiniowane przez użytkownika aplikacji do tworzenia lub zmiany.</param>
        <param name="data">Wartość właściwości.</param>
        <summary>Przypisuje wartość określonej właściwości domeny określonej aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby wstawić wpis lub zmodyfikuj wartość wpisu w wewnętrznej pamięci podręcznej par nazwa danych, które opisują właściwości tego wystąpienia <xref:System.AppDomain>.  
  
 Pamięć podręczna automatycznie zawiera wpisy wstępnie zdefiniowanego, które są wstawiane po utworzeniu domeny aplikacji. Nie można wstawić lub zmodyfikować wpisy systemu przy użyciu tej metody. Wywołanie metody, które spróbują zmodyfikować wpisu systemu nie przynosi efektu; Metoda nie zgłasza wyjątku. Można sprawdzić wartości wpisów systemu za pomocą <xref:System.AppDomain.GetData%2A> metody lub równoważny <xref:System.AppDomainSetup> właściwości opisanych w <xref:System.AppDomain.GetData%2A>.  
  
 Chcesz wywołać tę metodę, aby ustawić wartość domyślny interwał limitu czasu oceny wzorce wyrażeń regularnych przez dostaw "REGEX_DEFAULT_MATCH_TIMEOUT", jako wartość `name` argumentu i <xref:System.TimeSpan> wartość, która reprezentuje limit czasu Interwał jako wartość `data` argumentu. Można także wstawić lub zmodyfikować własne pary nazwa danych zdefiniowane przez użytkownika za pomocą tej metody i sprawdzić ich wartościami <xref:System.AppDomain.GetData%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> metodę, aby utworzyć nową parę wartości. Następnie w przykładzie <xref:System.AppDomain.GetData%2A> metodę, aby pobrać wartości i wyświetla go w konsoli.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości domeny zdefiniowane przez użytkownika aplikacji do tworzenia lub zmiany.</param>
        <param name="data">Wartość właściwości.</param>
        <param name="permission">Uprawnienie do żądanie obiektu wywołującego, gdy właściwość zostanie pobrana.</param>
        <summary>Przypisuje wartość określonej właściwości domeny określonej aplikacji przy użyciu określonego uprawnienia, aby żądanie obiektu wywołującego, gdy właściwość zostanie pobrana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia wstawienia lub zmodyfikowania własne zdefiniowane przez użytkownika wpisów w wewnętrznej pamięci podręcznej par nazwa/danych, które opisują właściwości domeny aplikacji. Podczas wstawiania wpis można określić żądanie uprawnień, gdy wpis jest pobierany. Ponadto chcesz wywołać tę metodę, aby ustawić wartość domyślny interwał limitu czasu oceny wzorce wyrażeń regularnych przez dostaw "REGEX_DEFAULT_MATCH_TIMEOUT" jako wartości `name` argumentu i <xref:System.TimeSpan> wartość, która reprezentuje interwał limitu czasu jako wartość `data` argumentu.  
  
 Nie można użyć tej metody można przypisać żądania zabezpieczeń do ciągu właściwości zdefiniowanych przez system.  
  
 Pamięć podręczna automatycznie zawiera wpisy wstępnie zdefiniowanego, które są wstawiane po utworzeniu domeny aplikacji. Nie można wstawić lub zmodyfikować wpisy systemu przy użyciu tej metody. Wywołanie metody, które spróbują zmodyfikować wpisu systemu nie przynosi efektu; Metoda nie zgłasza wyjątku. Można sprawdzić wartości wpisów systemu za pomocą <xref:System.AppDomain.GetData%2A> metody lub równoważny <xref:System.AppDomainSetup> właściwości opisane w sekcji uwag do <xref:System.AppDomain.GetData%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" /> Określa ciąg właściwości zdefiniowane przez system i <paramref name="permission" /> nie <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">W pełni kwalifikowana ścieżka to katalog podstawowy dla podkatalogi, w której przechowywane są dynamicznych zestawów.</param>
        <summary>Określa ścieżkę katalogu określonego jako katalog podstawowy dla podkatalogi, gdzie przechowywane dynamicznie generowanych plików i dostępne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia <xref:System.AppDomainSetup.DynamicBase%2A> właściwości wewnętrznego <xref:System.AppDomainSetup> skojarzony z tym wystąpieniem.  
  
   
  
## Examples  
 Ta metoda jest obecnie przestarzała i nie należy jej używać w nowych wdrożeniach. Poniższy przykład pokazuje, jak używać Nieprzestarzała alternatywa <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> właściwości. Aby dowiedzieć się, w tym przykładzie, zobacz <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> właściwości lub <xref:System.AppDomain.DynamicDirectory%2A> właściwości.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Jedną z <see cref="T:System.Security.Principal.PrincipalPolicy" /> wartości, które określa typ obiektu podmiotu zabezpieczeń, aby dołączyć do wątków.</param>
        <summary>Określa, jak obiekty jednostki i tożsamość musi być podłączona do wątku Jeśli wątek próbuje powiązać z podmiotem zabezpieczeń podczas wykonywania w tej domenie aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej wartości będą tylko skuteczne, jeśli zostanie ustawiona przed użyciem <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> właściwości. Na przykład jeśli ustawisz <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> do danego podmiotu zabezpieczeń (na przykład ogólny podmiot zabezpieczeń), a następnie użycie <xref:System.AppDomain.SetPrincipalPolicy%2A> metodę, aby ustawić <xref:System.Security.Principal.PrincipalPolicy> do <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, bieżący podmiot zabezpieczeń pozostanie ogólne jednostki.  
  
   
  
## Examples  
 Poniższy przykład pokazuje wpływ na wątki przy użyciu <xref:System.AppDomain.SetPrincipalPolicy%2A> metodę, aby zmienić zasady dotyczące nazwy głównej domeny aplikacji. Zawiera również za pomocą <xref:System.AppDomain.SetThreadPrincipal%2A> metodę, aby zmienić jednostkę, który jest dostępny dla dołączania do wątków w domenie aplikacji.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby móc manipulować głównym przedmiotem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Włącza funkcję kopiowania w tle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji dotyczących kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Ta metoda jest obecnie przestarzała i nie należy jej używać w nowych wdrożeniach.  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Lista nazw katalogów, których nazwy są oddzielone średnikami.</param>
        <summary>Określa ścieżkę katalogu określonego jako lokalizację zestawów do kopie w tle woluminów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie kopia w tle obejmuje wszystkie zestawy, można ich odnaleźć poprzez badania. <xref:System.AppDomain.SetShadowCopyPath%2A> Metoda ogranicza kopii w tle do zestawów w katalogi określone przez `path`.  
  
 <xref:System.AppDomain.SetShadowCopyPath%2A> Metody nie określa dodatkowe katalogi, które mają być wyszukiwane zestawów. Zestawy być kopiowane w tle musi już znajdować się w ścieżce wyszukiwania, na przykład w obszarze <xref:System.AppDomain.BaseDirectory%2A>. <xref:System.AppDomain.SetShadowCopyPath%2A> Metody określa ścieżki wyszukiwania, które kwalifikują się w tle-skopiowania.  
  
 Ta metoda ustawia <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> właściwości wewnętrznego <xref:System.AppDomainSetup> skojarzony z tym wystąpieniem.  
  
 Aby uzyskać więcej informacji dotyczących kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Ta metoda jest obecnie przestarzała i nie należy jej używać w nowych wdrożeniach.  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">Obiekt podmiotu zabezpieczeń, można dołączyć do wątków.</param>
        <summary>Ustawia domyślny obiekt podmiotu zabezpieczeń do podłączenia do wątków, przy próbie powiązać z podmiotem zabezpieczeń podczas wykonywania w tej domenie aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia efekt użycia <xref:System.AppDomain.SetThreadPrincipal%2A> metodę, aby zmienić jednostkę, która jest dostępne do dołączenia do wątków, które są wykonywane w domenie aplikacji. Zawiera również wpływ na wątki przy użyciu <xref:System.AppDomain.SetPrincipalPolicy%2A> metodę, aby zmienić zasady dotyczące nazwy głównej domeny aplikacji.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="principal" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Główny wątek został już ustawiony.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby móc manipulować głównym przedmiotem. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o konfiguracji domeny aplikacji dla tego wystąpienia.</summary>
        <value>Informacje o inicjalizacji domeny aplikacji.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wskazanie, czy domena aplikacji jest skonfigurowany do plików kopii w tle.</summary>
        <value><see langword="true" /> Jeśli domena aplikacji jest skonfigurowany do plików kopii w tle; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> i [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera reprezentację ciągu znaków, zawierającą przyjazna nazwa domeny aplikacji i wszystkie zasady kontekstu.</summary>
        <returns>Ciąg powstały przez złączenie literału "Nazwa:", przyjazną nazwę domeny aplikacji i ciągów reprezentujących zasady kontekstu albo ciąg "nie ma żadnych kontekstu zasad."</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wyświetla wartość zwracaną przez <xref:System.AppDomain.ToString%2A> metody.  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Domeny aplikacji, reprezentowane przez bieżącą <see cref="T:System.AppDomain" /> został zwolniony.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy rozwiązanie typu zakończy się niepowodzeniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.TypeResolve> Zdarzenie występuje, gdy środowisko uruchomieniowe języka wspólnego nie potrafi określić zestaw, który można utworzyć żądanego typu. Może to wystąpić, jeśli typ jest zdefiniowany w zestawie dynamicznym lub typ nie jest zdefiniowany w zestawie dynamicznym, ale środowisko wykonawcze nie wie zestawu, którego typ jest zdefiniowany w. Ostatnie sytuacja może wystąpić, gdy <xref:System.Type.GetType%2A?displayProperty=nameWithType> jest wywoływana z nazwę typu, który nie jest kwalifikowana nazwą zestawu.  
  
 <xref:System.ResolveEventHandler> Dla tego zdarzenia może podejmować próby zlokalizowania i utworzenia typu.  
  
 Jednak <xref:System.AppDomain.TypeResolve> zdarzenie nie występuje, jeśli środowisko wykonawcze wie, nie jest możliwe, można odnaleźć typu w określonych zestawach. To zdarzenie nie występuje na przykład, jeśli typ nie zostanie znaleziony w zestawie danych statycznych, ponieważ środowisko uruchomieniowe wie typów nie mogą być dynamicznie dodawane do zestawy statyczne.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> właściwość zawiera zestaw, który żądanego typu. Aby uzyskać więcej informacji, zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musisz mieć wymagane uprawnienia, lub <xref:System.Security.SecurityException> zgłaszany.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.TypeResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy nie przechwycono wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie zawiera powiadomienia o nieprzechwyconych wyjątków. Umożliwia aplikacji do rejestrowania informacji o wyjątku, zanim system domyślny program obsługi zgłasza wyjątek użytkownikowi i kończy działanie aplikacji. Jeśli wystarczających informacji na temat stanu aplikacji jest dostępna, inne działania mogą być podejmowane — takie jak zapisywanie danych program nowsze odzyskiwania. Jest zachowanie ostrożności, ponieważ mogą ulec uszkodzeniu danych programu, gdy wyjątki nie są obsługiwane.  
  
> [!NOTE]
>  W wersjach programu .NET Framework 1.0 i 1.1 zakończenia aplikacji i opcje debugowania są zgłaszane dla użytkownika przed to zdarzenie jest wywoływane, a nie po.  
  
 To zdarzenie można obsługiwać w każdej domenie aplikacji. Zdarzenie nie jest jednak zawsze inicjowane w domenie aplikacji, w którym wystąpił wyjątek. Wyjątek jest nieobsługiwany, tylko wtedy, gdy całego stosu dla wątku został rozwinięty bez znajdowanie obsługi wyjątków mających zastosowanie, dzięki czemu pierwsze miejsce, które mogą być zdarzenia znajduje się w domenie aplikacji, skąd pochodzi wątku.  
  
> [!NOTE]
>  W .NET Framework w wersji 1.0 i 1.1 to zdarzenie występuje tylko w przypadku domyślnej domeny aplikacji, który jest tworzony przez system po uruchomieniu aplikacji. Jeśli aplikacja tworzy domen dodatkowych aplikacji, określając delegata dla tego zdarzenia w tych domenach aplikacji nie ma znaczenia.  
  
 Jeśli <xref:System.AppDomain.UnhandledException> zdarzenie jest obsługiwane w domyślnej domeny aplikacji, jest zgłaszany, istnieje dla dowolnego nieobsługiwany wyjątek w żadnym z wątków, niezależnie od tego, jakie domeny aplikacji wątków, uruchomiony w. Jeśli wątek jest uruchomiony w domenie aplikacji, która ma program obsługi zdarzeń dla <xref:System.AppDomain.UnhandledException>, zdarzenie jest zgłaszane w tej domenie aplikacji. Jeśli tej domeny aplikacji nie jest częścią domyślnej domeny aplikacji, a także jest program obsługi zdarzeń w domyślnej domeny aplikacji, to zdarzenie jest wywoływane w obu domen aplikacji.  
  
 Na przykład załóżmy, że wątek uruchamia się w domenie aplikacji "AD1" wywołuje metodę w domenie aplikacji "AD2" i stamtąd wywołuje metodę w domenie aplikacji "AD3", gdzie go zgłasza wyjątek. Pierwszy domeną aplikacji, w której <xref:System.AppDomain.UnhandledException> zdarzenie może zostać wywołane jest "AD1". Jeśli ta domena aplikacji nie jest domyślnej domeny aplikacji, można również można zdarzenia w domyślnej domeny aplikacji.  
  
> [!NOTE]
>  Środowisko uruchomieniowe języka wspólnego wstrzymuje przerwań wątku podczas obsługi zdarzeń dla <xref:System.AppDomain.UnhandledException> zdarzeń są wykonywane.  
  
 Jeśli program obsługi zdarzeń <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atrybut flag odpowiednie, program obsługi zdarzeń jest traktowany jako region ograniczonego wykonania.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], to zdarzenie nie jest inicjowane dla wyjątków, które doprowadzić do uszkodzenia procesu, takie jak przepełnienie stosu lub dostępu naruszenia, chyba, że program obsługi zdarzeń zabezpieczenia krytyczny i ma <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> atrybutu.  
  
 W wersjach programu .NET Framework 1.0 i 1.1 nieobsłużony wyjątek, który występuje w wątku niż wątku głównego aplikacji zostanie przechwycony przez środowisko uruchomieniowe i w związku z tym nie powoduje zamknięcie aplikacji. Dlatego jest możliwe <xref:System.AppDomain.UnhandledException> zdarzenia bez przerywania aplikacji. Począwszy od programu .NET Framework w wersji 2.0, to backstop dla nieobsłużonych wyjątków w wątkach podrzędny został usunięty, ponieważ skumulowany efekt takie błędy dyskretnej uwzględnione spadek wydajności, uszkodzone dane i zawieszanie, które były trudne do debugowanie. Aby uzyskać więcej informacji, łącznie z listą przypadki, w których środowisko uruchomieniowe nie kończy się, zobacz [wyjątki w zarządzanych wątkach](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
 Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musisz mieć wymagane uprawnienia, lub <xref:System.Security.SecurityException> zgłaszany.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
## <a name="other-events-for-unhandled-exceptions"></a>Inne zdarzenia dla nieobsłużonych wyjątków  
 W przypadku niektórych modeli aplikacji <xref:System.AppDomain.UnhandledException> zdarzeń może być wywłaszczony przez inne zdarzenia, jeśli wystąpi nieobsługiwany wyjątek w wątku głównego aplikacji.  
  
 W aplikacji, które używają Windows Forms, nieobsłużonych wyjątków z aplikacji głównej przyczyny wątku <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> zdarzenia. Jeśli to zdarzenie jest obsługiwane, zachowanie domyślne jest nieobsługiwany wyjątek kończy aplikację, mimo że aplikacja pozostanie w nieznanym stanie. W takim przypadku <xref:System.AppDomain.UnhandledException> zdarzenie jest zgłaszane w nie. To zachowanie można zmienić za pomocą pliku konfiguracji aplikacji lub za pomocą <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> metodę, aby zmienić tryb <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> przed <xref:System.Windows.Forms.Application.ThreadException> program obsługi zdarzeń jest podłączany. Dotyczy to tylko wątku głównego aplikacji. <xref:System.AppDomain.UnhandledException> Zdarzenie jest wywoływane dla nieobsługiwanych wyjątków zgłoszonych w innych wątków.  
  
 Począwszy od programu Microsoft Visual Studio 2005 framework aplikacji Visual Basic oferuje inne zdarzenie do nieobsługiwanych wyjątków w wątku głównego aplikacji. Zobacz <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> zdarzeń. To zdarzenie ma obiekt argumenty zdarzenia o takiej samej nazwie jako obiektu argumenty zdarzenia, które są używane przez <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, ale z różnymi właściwościami. W szczególności tego obiektu w argumenty zdarzeń ma <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> właściwość, która umożliwia aplikacji kontynuować uruchamianie nieobsługiwany wyjątek jest ignorowany (i opuszczania aplikacji w nieznanym stanie). W takim przypadku <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> zdarzenie jest zgłaszane w nie.  
  
   
  
## Examples  
 Pokazuje followingexample <xref:System.AppDomain.UnhandledException> zdarzeń. Definiuje procedurę obsługi zdarzeń, `MyHandler`, która jest wywoływana zawsze wtedy, gdy wystąpił nieobsługiwany wyjątek jest zgłaszany w domyślnej domeny aplikacji. Następnie wyniku weryfikacji zgłasza wyjątek dwoma wyjątkami. Pierwszy jest obsługiwany przez **bloku try/catch** bloku. Drugi nie jest obsługiwana i wywołuje `MyHandle` procedury, zanim aplikacja zakończy.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">Domena aplikacji, aby zwolnić.</param>
        <summary>Zwalnia domeny określonej aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W .NET Framework w wersji 2.0 ma wątku dedykowanego zwalnianie domen aplikacji. Zwiększa niezawodność, szczególnie w przypadku programu .NET Framework jest obsługiwany. Kiedy wątek wywołuje <xref:System.AppDomain.Unload%2A>, domeny docelowej jest oznaczony do zwalniania. Dedykowany wątek próbuje zwolnić domeny, a wszystkie wątki w domenie zostaną przerwane. Jeśli wątek nie przerwać, na przykład ponieważ wykonywania kodu niezarządzanego lub jest on uruchamiany `finally` bloku, a następnie po upływie określonego czasu <xref:System.CannotUnloadAppDomainException> jest zgłaszany w wątku, który pierwotnie <xref:System.AppDomain.Unload%2A>. Wątek, który nie można przerwać końcu zakończeniu domeny docelowej nie jest zwalniany. W efekcie w .NET Framework w wersji 2.0 `domain` nie musi zwolnić, ponieważ nie może nie być możliwe zakończyć wykonywanie wątków.  
  
> [!NOTE]
>  W niektórych przypadkach podczas wywoływania <xref:System.AppDomain.Unload%2A> powoduje natychmiastowe <xref:System.CannotUnloadAppDomainException>, na przykład jeśli jest to finalizator.  
  
 Wątki w `domain` kończą przy użyciu <xref:System.Threading.Thread.Abort%2A> metody, która zgłasza <xref:System.Threading.ThreadAbortException> w wątku. Mimo że wątku należy niezwłocznie zakończyć, może kontynuować wykonywania dla nieprzewidywalne ilość czasu w `finally` klauzuli.  
  
## <a name="version-compatibility"></a>Zgodność wersji  
 W .NET Framework w wersji 1.0 i 1.1, jeśli wątek, który wywołuje <xref:System.AppDomain.Unload%2A> działa w `domain`, inny wątek jest uruchomiona, można wykonać operacji zwolnienia. Jeśli `domain` nie może zostać zwolniony, <xref:System.CannotUnloadAppDomainException> jest generowany w tym wątku, a nie w oryginalnym wątku, który wywołał <xref:System.AppDomain.Unload%2A>. Jednak jeśli wątek wywołująca <xref:System.AppDomain.Unload%2A> działa poza `domain`, że wątek odbiera wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób zwolnienie domeny aplikacji.  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domain" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.CannotUnloadAppDomainException"><paramref name="domain" /> nie może zostać usunięty.</exception>
        <exception cref="T:System.Exception">Wystąpił błąd podczas procesu zwolnienia.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby dodać program obsługi zdarzeń dla tego zdarzenia. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
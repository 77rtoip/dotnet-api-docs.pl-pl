<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fd7cab7e2a95d15e00ca1bd7a52479f9dcce723a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36434969" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje domenę aplikacji, która jest izolowanym środowisku, gdy wykonanie aplikacji. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domeny aplikacji, które są reprezentowane przez <xref:System.AppDomain> obiektów, pomagają granic izolacji, zwalnianie i zabezpieczeń wykonywania kodu zarządzanego.  
  
-   Domeny aplikacji umożliwia izolowanie zadań, które mogą spowodować przerwanie procesu. Jeśli stan <xref:System.AppDomain> wykonuje zadanie staje się niestabilny, <xref:System.AppDomain> może być zwolniony bez wpływu na proces. Jest to ważne w przypadku, gdy proces musi zostać uruchomiony dłuższe okresy bez ponownego uruchamiania. Domeny aplikacji służy również do izolowania zadania, które nie powinny udostępniać dane.  
  
-   Jeśli zestaw jest ładowany do domyślnej domeny aplikacji, nie może być usunięte z pamięci procesu jest uruchomiona. Jednak po otwarciu druga domena aplikacji do ładowania i wykonywania zestawu zestaw jest zwolniony podczas tej domeny aplikacji zostanie zwolniona. Ten sposób można zminimalizować zestaw roboczy procesy długotrwałe, czasami używające duże biblioteki dll.  
  
 Wielu domen aplikacji można uruchomić w ramach jednego procesu; jednak nie istnieje sygnałowych domeny aplikacji i wątków. Kilka wątków może należeć do domeny pojedynczej aplikacji, a podczas danego wątku nie jest ograniczona do domeny pojedynczej aplikacji, w dowolnym momencie, wątek wykonuje się w domenie pojedynczej aplikacji.  
  
 Domeny aplikacji są tworzone przy użyciu <xref:System.AppDomain.CreateDomain%2A> metody. <xref:System.AppDomain> wystąpienia są używane do ładowania i wykonywania zestawów (<xref:System.Reflection.Assembly>). Gdy <xref:System.AppDomain> jest już w użyciu, może zostać zwolniony.  
  
 <xref:System.AppDomain> Klasa implementuje zestaw zdarzeń, które umożliwiają aplikacjom odpowiadać, gdy zestaw jest ładowany podczas domeny aplikacji zostanie zwolniony, lub gdy jest nieobsługiwany wyjątek.  
  
 Aby uzyskać więcej informacji na temat używania domeny aplikacji, zobacz [domen aplikacji](~/docs/framework/app-domains/application-domains.md).  
  
 Ta klasa implementuje <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, i <xref:System.Security.IEvidenceFactory> interfejsów.  
  
 Nigdy nie należy tworzyć otoka może być zastosowana zdalnie dla <xref:System.AppDomain> obiektu. Dzięki temu można opublikować zdalnego odwołanie do tego <xref:System.AppDomain>, takie jak udostępnianie metody <xref:System.AppDomain.CreateInstance%2A> dostępu zdalnego i efektywnie niszczenie zabezpieczenia dostępu kodu, w tym <xref:System.AppDomain>. Złośliwe klientów łączących się zdalny <xref:System.AppDomain> można uzyskać dostępu do dowolnego zasobu <xref:System.AppDomain> z kolei ma dostęp do. Nie należy tworzyć może być zastosowana zdalnie otoki dla dowolnego typu, rozszerzający <xref:System.MarshalByRefObject> i implementującej metody, które mogłyby zostać użyte przez złośliwe klientów do obejścia zabezpieczeń systemu.  
  
> [!CAUTION]
>  Wartość domyślna dla <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> jest właściwość `false`. To ustawienie jest niebezpieczne dla usług. Aby zapobiec usług pobierania częściowo zaufanego kodu, ustaw tę właściwość na `true`.  
  
   
  
## Examples  
 W tym przykładzie pokazano, jak utworzyć nową <xref:System.AppDomain>, tworzenia nowego wystąpienia typu w tym <xref:System.AppDomain>i komunikować się z tego typu obiektu. Ponadto, w tym przykładzie pokazano, jak można zwolnić <xref:System.AppDomain> powoduje obiektu ma być bezużytecznych.  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kontekst aktywacji dla bieżącej domeny aplikacji.</summary>
        <value>Obiekt, który reprezentuje kontekst aktywacji dla bieżącej domeny aplikacji lub <see langword="null" /> Jeśli domena nie kontekstu aktywacji.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa katalogu do dołączenia ścieżkę prywatną.</param>
        <summary>Dołącza określony katalog do ścieżki prywatnej listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie tej właściwości nie jest zalecane, ponieważ może go zmienić ścieżki próbkowania dla zestawów, po ma został już załadowany. Użyj <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> właściwości zamiast tego.  
  
 Ścieżki prywatnej lub ścieżka względna wyszukiwania jest ścieżka względna katalogu podstawowego, której mechanizm rozpoznawania zestawów sondy dla zestawy prywatne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tożsamość aplikacji w domenie aplikacji.</summary>
        <value>Obiekt, który identyfikuje aplikację w domenie aplikacji.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje opisujące uprawnienia przyznane aplikacji i określa, czy aplikacja ma poziom zaufania, który umożliwia jego uruchomienie.</summary>
        <value>Obiekt hermetyzujący informacje o uprawnienia i zaufania dla aplikacji w domenie aplikacji.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Zestaw do nazwy wyświetlanej, w formularzu pochodzącymi <see cref="P:System.Reflection.Assembly.FullName" /> właściwości.</param>
        <summary>Zwraca nazwy wyświetlanej zestawu po zastosowaniu zasady.</summary>
        <returns>Ciąg zawierający zestaw wyświetlana nazwa, po zastosowaniu zasady.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ApplyPolicy%2A> Metoda ma podjąć zestawu nazwę wyświetlaną i zwraca nazwę wyświetlaną po zastosowaniu zasad. Jest to przydatne, jeśli zachodzi konieczność załadowania zestawu za pomocą zasad, ponieważ kontekstu reflection-only nie można stosować zasady.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zestaw jest ładowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AssemblyLoadEventHandler> Delegowanie dla to zdarzenie wskazuje, jaki zestaw został załadowany.  
  
 Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musi mieć wymagane uprawnienia lub <xref:System.Security.SecurityException> jest generowany.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.AssemblyLoad> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy rozpoznawania zestawu nie powiodło się.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest on odpowiedzialny za <xref:System.ResolveEventHandler> dla tego zdarzenia do zwrócenia zestawu określoną przez <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> właściwości, lub aby zwrócić wartość null, jeśli zestaw nie został rozpoznany. Zestaw muszą być załadowane do kontekstu wykonywania; Jeśli jest on ładowany do kontekstu reflection-only, obciążenia, który spowodował się tego zdarzenia nie powiedzie się.  
  
 Aby uzyskać wskazówki, użyj tego zdarzenia, zobacz [rozwiązywanie Załadowań zestawów](~/docs/framework/app-domains/resolve-assembly-loads.md).  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> właściwość zwraca żądane ładowanie zestawu, którego nie można rozpoznać zestawu. Moduł ładujący może być na przykład nie można załadować zależności zestawu żądania, ponieważ zestaw żądania i jego zależności nie znajdują się w ścieżce sondowania. Znajomość tożsamości zestawu żądania mogą być przydatne, lokalizowanie zależności lub do identyfikowania poprawną wersję, jeśli dostępny jest więcej niż jedną wersję zależności. Aby uzyskać więcej informacji, zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <xref:System.ResolveEventHandler> zdarzenie jest wywoływane dla wszystkich zestawów, w tym zestawy zasobów. W starszych wersjach zdarzenie nie zostało zgłoszone dla zestawy zasobów. Jeśli system operacyjny jest zlokalizowana, program obsługi może być wywołana wiele razy: raz dla każdej kultury w łańcuchu powrotu.  
  
 Dla tego zdarzenia <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> właściwość zwraca nazwę zestawu, przed zastosowaniem zasad.  
  
> [!IMPORTANT]
>  Jeśli więcej niż jeden program obsługi zdarzeń jest zarejestrowany dla tego zdarzenia, handlersarecalled zdarzeń w kolejności, dopóki program obsługi zdarzeń zwraca wartość, która nie jest `null`. Programy obsługi zdarzeń kolejne są ignorowane.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera katalog podstawowy, używaną do sondowania dla zestawów mechanizm rozpoznawania zestawów.</summary>
        <value>Katalog podstawowy mechanizm rozpoznawania zestawów używa do sondowania dla zestawów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość odpowiada <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> właściwości. Można również pobrać, przy użyciu <xref:System.AppDomain.GetData%2A> metody z ciągiem "APPBASE".  
  
   
  
## Examples  
 Poniższy przykładowy kod tworzy nową domenę aplikacji, określając podstawowego katalogu używana podczas wyszukiwania zestawów do załadowania do domeny. W przykładzie następnie użyto <xref:System.AppDomain.BaseDirectory%2A> właściwości uzyskanie ścieżkę katalogu podstawowego do wyświetlenia w konsoli.  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji w sama ścieżka, w tym przypadku ścieżka jest w formie "file://" lub \\\UNC\dir lub "c:\\". Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje ścieżki, który określa lokalizację zestawy prywatne do ciągu pustego ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prywatne ścieżka jest ścieżką względną wobec katalogu podstawowego, wyszukująca zlokalizować zestawy prywatne środowisko uruchomieniowe języka wspólnego.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.AppDomain.ClearPrivatePath%2A> metodę, aby usunąć wszystkie pozycje z listy prywatnej ścieżki wyszukiwania, gdy zestawy zostały załadowane.  
  
 Ta metoda jest obecnie przestarzała i nie należy jej używać w nowych wdrożeniach.  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje listę katalogów zawierających zestawów w tle kopiowane do ciągu pustego ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ścieżka kopii tle jest lista katalogów, do którego skopiowane zestawów w tle są przechowywane.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> i [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie określonego typu COM.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku zawierającego zestawu, który definiuje żądanego typu.</param>
        <param name="typeName">Nazwa żądanego typu.</param>
        <summary>Tworzy nowe wystąpienie określonego typu COM. Parametry, określ nazwę pliku, który zawiera zestaw zawierający ten typ i nazwa typu.</summary>
        <returns>Obiekt będący otoki dla nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody do tworzenia obiektów zdalnie, nie można załadować typu lokalnie.  
  
 Musi być zwracana wartość do odkodowania dostępu do rzeczywistego obiektu.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atrybutu o wartości `true` należy zastosować jawnie lub domyślnie na typ COM dla tej metody można utworzyć wystąpienia tego typu; w przeciwnym razie <xref:System.TypeLoadException> jest generowany.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Nie można załadować typu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Znaleziono nie publicznego konstruktora bez parametrów.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> jest klasą abstrakcyjną.  - lub - tego elementu członkowskiego został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> to ciąg pusty ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">Obiekt COM, który jest on określany jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku zawierającego zestawu, który definiuje żądanego typu.</param>
        <param name="typeName">Nazwa żądanego typu.</param>
        <param name="hashValue">Reprezentuje wartość obliczona wartość skrótu.</param>
        <param name="hashAlgorithm">Reprezentuje siła algorytmu wyznaczania wartości skrótu używanego przez manifest zestawu.</param>
        <summary>Tworzy nowe wystąpienie określonego typu COM. Parametry, określ nazwę pliku, który zawiera zestaw zawierający ten typ i nazwa typu.</summary>
        <returns>Obiekt będący otoki dla nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody do tworzenia obiektów zdalnie, nie można załadować typu lokalnie.  
  
 Musi być zwracana wartość do odkodowania dostępu do rzeczywistego obiektu.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atrybutu o wartości `true` należy zastosować jawnie lub domyślnie na typ COM dla tej metody można utworzyć wystąpienia tego typu; w przeciwnym razie <xref:System.TypeLoadException> jest generowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Nie można załadować typu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Znaleziono nie publicznego konstruktora bez parametrów.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> jest klasą abstrakcyjną.  - lub - tego elementu członkowskiego został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> jest pustym ciągiem ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">Obiekt COM, który jest on określany jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzenie nowej domeny aplikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny.</param>
        <summary>Tworzy nową domenę aplikacji o określonej nazwie.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `friendlyName` Parametr służy do identyfikowania domeny w sposób zrozumiały dla człowieka. Ten ciąg powinny być dostosowane do wyświetlania na interfejsy użytkownika.  
  
 Używa tego przeciążenia metody <xref:System.AppDomainSetup> informacji z domyślnej domeny aplikacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, ogólnie rzecz biorąc, sposób tworzenia domeny przy użyciu jednej z <xref:System.AppDomain.CreateDomain%2A> przeciążenia.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> do użycia dowody bieżącej domeny aplikacji.</param>
        <summary>Tworzy nową domenę aplikacji o podanej nazwie przy użyciu dostarczonego dowód.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa tego przeciążenia metody <xref:System.AppDomainSetup> informacji z domyślnej domeny aplikacji.  
  
 Jeśli `securityInfo` jest nie zostanie podany, jest używany dowód z bieżącej domeny aplikacji.  
  
> [!IMPORTANT]
>  Nie należy używać tego przeciążenia metody do tworzenia domen aplikacji w trybie piaskownicy. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], dowody, które jest dostarczone dla `securityInfo` nie wpływa na zestaw grant domeny aplikacji. Użyj <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> przeciążenie metody do tworzenia domeny aplikacji w trybie piaskownicy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, ogólnie rzecz biorąc, sposób tworzenia domeny przy użyciu jednej z <xref:System.AppDomain.CreateDomain%2A> przeciążenia.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> do użycia dowody bieżącej domeny aplikacji.</param>
        <param name="info">Obiekt zawierający informacje o inicjowania domeny aplikacji.</param>
        <summary>Tworzy nową domenę aplikacji przy użyciu określonej nazwy, dowód i informacje o konfiguracji domeny aplikacji.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `info` jest nie zostaną podane, używa tego przeciążenia metody <xref:System.AppDomainSetup> informacji z domyślnej domeny aplikacji.  
  
 Jeśli `securityInfo` jest nie zostanie podany, jest używany dowód z bieżącej domeny aplikacji.  
  
> [!IMPORTANT]
>  Nie należy używać tego przeciążenia metody do tworzenia domen aplikacji w trybie piaskownicy. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], dowody, które jest dostarczone dla `securityInfo` nie wpływa na zestaw grant domeny aplikacji. Użyj <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> przeciążenie metody do tworzenia domeny aplikacji w trybie piaskownicy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, ogólnie rzecz biorąc, sposób tworzenia domeny przy użyciu jednej z <xref:System.AppDomain.CreateDomain%2A> przeciążenia.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz opis <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> do użycia dowody bieżącej domeny aplikacji.</param>
        <param name="info">Obiekt zawierający informacje o inicjowania domeny aplikacji.</param>
        <param name="grantSet">Uprawnienia domyślne, czyli ustawić przyznanych do wszystkich zestawów załadowanych do nowej domeny aplikacji, które nie mają określonego przyznaje.</param>
        <param name="fullTrustAssemblies">Tablica silnych nazw reprezentujący zestawy uznany w pełni zaufany w nowej domenie aplikacji.</param>
        <summary>Tworzy nową domenę aplikacji przy użyciu określonej nazwy, dowód, informacje o konfiguracji domeny aplikacji, domyślny zestaw uprawnień i tablicy całkowicie zaufanych zestawów.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy ustawić <xref:System.AppDomainSetup.ApplicationBase%2A> właściwość <xref:System.AppDomainSetup> obiekt, który można podać `info`. W przeciwnym razie jest zgłaszany wyjątek.  
  
 Jeśli `securityInfo` jest nie zostanie podany, jest używany dowód z bieżącej domeny aplikacji.  
  
 Informacje przewidziane `grantSet` i `fullTrustAssemblies` służy do tworzenia <xref:System.Security.Policy.ApplicationTrust> obiektu dla nowej domeny aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Domena aplikacji jest <see langword="null" />.  - lub - <see cref="P:System.AppDomainSetup.ApplicationBase" /> właściwość nie jest ustawiona na <see cref="T:System.AppDomainSetup" /> dostarczonej dla obiekt <paramref name="info" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Tworzenia domeny aplikacji i wykonywanie na niej operacji. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> do użycia dowody bieżącej domeny aplikacji.</param>
        <param name="appBasePath">Katalog podstawowy mechanizm rozpoznawania zestawów używa do sondowania dla zestawów. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Ścieżka względna katalogu podstawowego, której mechanizm rozpoznawania zestawów powinny sondować zestawy prywatne. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">Jeśli <see langword="true" />, zestawu kopii w tle jest ładowany do tej domeny aplikacji.</param>
        <summary>Tworzy nową domenę aplikacji o podanej nazwie, przy użyciu dowód, podstawowa ścieżka aplikacji, ścieżka względna wyszukiwania i parametr, który określa, czy zestaw kopii w tle ma być załadowane do tej domeny aplikacji.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `securityInfo` jest nie zostanie podany, jest używany dowód z bieżącej domeny aplikacji.  
  
 Aby uzyskać więcej informacji na temat Kopiowanie w tle, zobacz <xref:System.AppDomain.ShadowCopyFiles%2A> i [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Nie należy używać tego przeciążenia metody do tworzenia domen aplikacji w trybie piaskownicy. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], dowody, które jest dostarczone dla `securityInfo` nie wpływa na zestaw grant domeny aplikacji. Użyj <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> przeciążenie metody do tworzenia domeny aplikacji w trybie piaskownicy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, ogólnie rzecz biorąc, sposób tworzenia domeny przy użyciu jednej z <xref:System.AppDomain.CreateDomain%2A> przeciążenia.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Przyjazna nazwa domeny. Ta przyjazna nazwa może być wyświetlana w interfejsie użytkownika do identyfikowania domeny. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Dowód, który potwierdza tożsamość kodu uruchomionego w domenie aplikacji. Przekaż <see langword="null" /> do użycia dowody bieżącej domeny aplikacji.</param>
        <param name="appBasePath">Katalog podstawowy mechanizm rozpoznawania zestawów używa do sondowania dla zestawów. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Ścieżka względna katalogu podstawowego, której mechanizm rozpoznawania zestawów powinny sondować zestawy prywatne. Aby uzyskać więcej informacji, zobacz <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">
          <see langword="true" /> Aby załadować zestawu kopii w tle do domeny aplikacji.</param>
        <param name="adInit">
          <see cref="T:System.AppDomainInitializer" /> Delegata, który reprezentuje metodę wywołania zwrotnego do wywołania, gdy nowy <see cref="T:System.AppDomain" /> obiekt został zainicjowany.</param>
        <param name="adInitArgs">Tablica argumenty typu string do przekazania do wywołania zwrotnego reprezentowany przez <c>adInit</c>, gdy nowy <see cref="T:System.AppDomain" /> obiekt został zainicjowany.</param>
        <summary>Tworzy nową domenę aplikacji o podanej nazwie, przy użyciu dowód, podstawowa ścieżka aplikacji, ścieżka względna wyszukiwania i parametr, który określa, czy zestaw kopii w tle ma być załadowane do tej domeny aplikacji. Określa metody wywołania zwrotnego, które jest wywoływane, gdy domena aplikacji została zainicjowana i tablicę argumentów ciągów do przekazania metody wywołania zwrotnego.</summary>
        <returns>Nowo utworzona domena aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metodę reprezentowaną przez `adInit` jest wykonywany w kontekście domeny nowo utworzonej aplikacji.  
  
 Jeśli `securityInfo` jest nie zostanie podany, jest używany dowód z bieżącej domeny aplikacji.  
  
 Aby uzyskać więcej informacji na temat Kopiowanie w tle, zobacz <xref:System.AppDomain.ShadowCopyFiles%2A> i [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Nie należy używać tego przeciążenia metody do tworzenia domen aplikacji w trybie piaskownicy. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], dowody, które jest dostarczone dla `securityInfo` nie wpływa na zestaw grant domeny aplikacji. Użyj <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> przeciążenie metody do tworzenia domeny aplikacji w trybie piaskownicy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowane w określonym zestawie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym zestawie.</summary>
        <returns>Obiekt będący otoki dla nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje konstruktor domyślny `typeName`.  
  
 Zobacz <xref:System.Reflection.AssemblyName> dla formatu `assemblyName`.  
  
 Próba wywołania <xref:System.AppDomain.CreateInstance%2A> w celu pomyślnego ładowania zestawu w docelowej domenie aplikacji spowoduje domeny aplikacji, która nie jest bieżącej domeny aplikacji. Ponieważ <xref:System.Reflection.Assembly> nie jest <xref:System.MarshalByRefObject>, gdy ta metoda próbuje zwrócić <xref:System.Reflection.Assembly> załadować zestawu do bieżącej domeny aplikacji, środowisko uruchomieniowe języka wspólnego próbuje załadować zestawu do bieżącej domeny aplikacji i obciążenie może zakończyć się niepowodzeniem. Jeśli ustawienia ścieżek obu domen aplikacji są różne, zestaw ładowany do bieżącej domeny aplikacji może się różnić od zestawu, który został załadowany po raz pierwszy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablicę, która zawiera jedną <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym zestawie. Parametr określa tablicę z atrybutami aktywacji.</summary>
        <returns>Obiekt będący otoki dla nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje konstruktor domyślny `typeName`.  
  
 Zobacz <xref:System.Reflection.AssemblyName> dla formatu `assemblyName`.  
  
 Próba wywołania <xref:System.AppDomain.CreateInstance%2A> w celu pomyślnego ładowania zestawu w docelowej domenie aplikacji spowoduje domeny aplikacji, która nie jest bieżącej domeny aplikacji. Ponieważ <xref:System.Reflection.Assembly> nie jest <xref:System.MarshalByRefObject>, gdy ta metoda próbuje zwrócić <xref:System.Reflection.Assembly> załadować zestawu do bieżącej domeny aplikacji, środowisko uruchomieniowe języka wspólnego próbuje załadować zestawu do bieżącej domeny aplikacji i obciążenie może zakończyć się niepowodzeniem. Jeśli ustawienia ścieżek obu domen aplikacji są różne, zestaw ładowany do bieżącej domeny aplikacji może się różnić od zestawu, który został załadowany po raz pierwszy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów za pomocą odbicia. Jeśli <c>integratora</c> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli domyślny konstruktor jest preferowana, <c>argumentów</c> musi być pustą tablicą ani mieć wartości null.</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typeName</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablicę, która zawiera jedną <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym zestawie. Parametry określają integratora, flag powiązań, argumenty konstruktora, sposób interpretowania argumentów i atrybuty activation opcjonalne informacje specyficzne dla kultury.</summary>
        <returns>Obiekt będący otoki dla nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Reflection.AssemblyName> dla formatu `assemblyName`.  
  
 Próba wywołania <xref:System.AppDomain.CreateInstance%2A> w celu pomyślnego ładowania zestawu w docelowej domenie aplikacji spowoduje domeny aplikacji, która nie jest bieżącej domeny aplikacji. Ponieważ <xref:System.Reflection.Assembly> nie jest <xref:System.MarshalByRefObject>, gdy ta metoda próbuje zwrócić <xref:System.Reflection.Assembly> załadować zestawu do bieżącej domeny aplikacji, środowisko uruchomieniowe języka wspólnego próbuje załadować zestawu do bieżącej domeny aplikacji i obciążenie może zakończyć się niepowodzeniem. Jeśli ustawienia ścieżek obu domen aplikacji są różne, zestaw ładowany do bieżącej domeny aplikacji może się różnić od zestawu, który został załadowany po raz pierwszy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów za pomocą odbicia. Jeśli <c>integratora</c> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli domyślny konstruktor jest preferowana, <c>argumentów</c> musi być pustą tablicą ani mieć wartości null.</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typeName</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablicę, która zawiera jedną <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do tworzenia autoryzacji <c>typeName</c>.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym zestawie. Parametry określają integratora, flag powiązań, argumenty konstruktora, informacje specyficzne dla kultury sposób interpretowania argumenty aktywacji i atrybuty autoryzacji do utworzenia typu.</summary>
        <returns>Obiekt będący otoki dla nowego wystąpienia określonego przez <paramref name="typeName" />. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Reflection.AssemblyName> dla formatu `assemblyName`.  
  
 Próba wywołania <xref:System.AppDomain.CreateInstance%2A> w celu pomyślnego ładowania zestawu w docelowej domenie aplikacji spowoduje domeny aplikacji, która nie jest bieżącej domeny aplikacji. Ponieważ <xref:System.Reflection.Assembly> nie jest <xref:System.MarshalByRefObject>, gdy ta metoda próbuje zwrócić <xref:System.Reflection.Assembly> załadować zestawu do bieżącej domeny aplikacji, środowisko uruchomieniowe języka wspólnego próbuje załadować zestawu do bieżącej domeny aplikacji i obciążenie może zakończyć się niepowodzeniem. Jeśli ustawienia ścieżek obu domen aplikacji są różne, zestaw ładowany do bieżącej domeny aplikacji może się różnić od zestawu, który został załadowany po raz pierwszy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.  - lub - <paramref name="securityAttributes" /> nie jest <see langword="null" />. Gdy starszą zasadę nie jest włączone, <paramref name="securityAttributes" /> powinna być <see langword="null." /></exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie określonego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <summary>Tworzy nowe wystąpienie określonego typu. Parametry określają zestawu, w którym zdefiniowano typ i nazwę typu.</summary>
        <returns>Wystąpienie obiektu określonego przez <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstance%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Ta metoda wywołuje konstruktor domyślny `typeName`.  
  
 Zobacz <xref:System.Reflection.AssemblyName> dla formatu `assemblyName`. Zobacz <xref:System.Type.FullName%2A?displayProperty=nameWithType> właściwość format `typeName`.  
  
> [!NOTE]
>  Jeśli wprowadzisz wywołania z wczesnym wiązaniem do metody `M` obiektu typu `T1` zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i metoda zgłasza wywołania z wczesnym wiązaniem metod typu obiektu `T2` w zestawie `C` innych niż Bieżący zestaw lub zestawu zawierającego `T1`, zestawu `C` jest ładowany do bieżącej domeny aplikacji. Ładowanie tego występuje nawet wtedy, gdy wywołanie z wczesnym wiązaniem `T1.M()` została wprowadzona w treści <xref:System.Reflection.Emit.DynamicMethod>, lub w innym dynamicznie generowanym kodzie. Jeśli bieżąca domena jest domeną domyślną, zestawu `C` nie może być zwolnione, do czasu zakończenia procesu. Jeśli bieżąca domena później próbuje załadować zestawu `C`, obciążenie może zakończyć się niepowodzeniem.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje Najprostszym sposobem, aby wykonać kod w innej domenie aplikacji. W przykładzie zdefiniowano klasę o nazwie `Worker` dziedziczący po <xref:System.MarshalByRefObject>. `Worker` Klasa definiuje metodę, która zawiera nazwę domeny aplikacji, w którym jest wykonywany. W przykładzie jest tworzony wystąpienia `Worker` w domyślnej domeny aplikacji i w nowej domenie aplikacji.  
  
> [!NOTE]
>  Zestaw zawierający `Worker` muszą być załadowane do obu domen aplikacji, ale można go załadować innych zestawów, które istnieją tylko w nowej domenie aplikacji.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">dla możliwości odczytu pliku manifestu zestawu zawierającego lub w przypadku tworzenia typu z modułu niż plik manifestu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablicę, która zawiera jedną <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu. Parametry określają zestawu, w którym zdefiniowano typ, nazwa typu, a tablica atrybutów aktywacji.</summary>
        <returns>Wystąpienie obiektu określonego przez <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstance%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Ta metoda wywołuje konstruktor domyślny `typeName`.  
  
 Zobacz <xref:System.Reflection.AssemblyName> dla formatu `assemblyName`. Zobacz <xref:System.Type.FullName%2A?displayProperty=nameWithType> właściwość format `typeName`.  
  
> [!NOTE]
>  Jeśli wprowadzisz wywołania z wczesnym wiązaniem do metody `M` obiektu typu `T1` zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i metoda zgłasza wywołania z wczesnym wiązaniem metod typu obiektu `T2` w zestawie `C` innych niż Bieżący zestaw lub zestawu zawierającego `T1`, zestawu `C` jest ładowany do bieżącej domeny aplikacji. Ładowanie tego występuje nawet wtedy, gdy wywołanie z wczesnym wiązaniem `T1.M()` została wprowadzona w treści <xref:System.Reflection.Emit.DynamicMethod>, lub w innym dynamicznie generowanym kodzie. Jeśli bieżąca domena jest domeną domyślną, zestawu `C` nie może być zwolnione, do czasu zakończenia procesu. Jeśli bieżąca domena później próbuje załadować zestawu `C`, obciążenie może zakończyć się niepowodzeniem.  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów za pomocą odbicia. Jeśli <c>integratora</c> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli domyślny konstruktor jest preferowana, <c>argumentów</c> musi być pustą tablicą ani mieć wartości null.</param>
        <param name="culture">Używane do sterowania koercja typu obiektu specyficzne dla kultury. Jeśli <c>kultury</c> jest <see langword="null" />, <see langword="CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablicę, która zawiera jedną <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu. który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowane w określonym zestawie, określania, czy jest ignorowana w przypadku nazwy typu. atrybuty wiązania i integratorów, które służą do wybierania typu, który ma zostać utworzony; Argumenty konstruktora; Kultura; i atrybuty aktywacji.</summary>
        <returns>Wystąpienie obiektu określonego przez <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstance%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Zobacz <xref:System.Reflection.AssemblyName> dla formatu `assemblyName`. Zobacz <xref:System.Type.FullName%2A?displayProperty=nameWithType> właściwość format `typeName`.  
  
> [!NOTE]
>  Jeśli wprowadzisz wywołania z wczesnym wiązaniem do metody `M` obiektu typu `T1` zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i metoda zgłasza wywołania z wczesnym wiązaniem metod typu obiektu `T2` w zestawie `C` innych niż Bieżący zestaw lub zestawu zawierającego `T1`, zestawu `C` jest ładowany do bieżącej domeny aplikacji. Ładowanie tego występuje nawet wtedy, gdy wywołanie z wczesnym wiązaniem `T1.M()` została wprowadzona w treści <xref:System.Reflection.Emit.DynamicMethod>, lub w innym dynamicznie generowanym kodzie. Jeśli bieżąca domena jest domeną domyślną, zestawu `C` nie może być zwolnione, do czasu zakończenia procesu. Jeśli bieżąca domena później próbuje załadować zestawu `C`, obciążenie może zakończyć się niepowodzeniem.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie `ignoreCase` parametru.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów za pomocą odbicia. Jeśli <c>integratora</c> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli domyślny konstruktor jest preferowana, <c>argumentów</c> musi być pustą tablicą ani mieć wartości null.</param>
        <param name="culture">Używane do sterowania koercja typu obiektu specyficzne dla kultury. Jeśli <c>kultury</c> jest <see langword="null" />, <see langword="CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablicę, która zawiera jedną <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do tworzenia autoryzacji <c>typeName</c>.</param>
        <summary>Tworzy nowe wystąpienie określonego typu. Parametry, określ nazwę typu i jak jest znaleziono i utworzyć.</summary>
        <returns>Wystąpienie obiektu określonego przez <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstance%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Zobacz <xref:System.Reflection.AssemblyName> dla formatu `assemblyName`. Zobacz <xref:System.Type.FullName%2A?displayProperty=nameWithType> właściwość format `typeName`.  
  
> [!NOTE]
>  Jeśli wprowadzisz wywołania z wczesnym wiązaniem do metody `M` obiektu typu `T1` zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i metoda zgłasza wywołania z wczesnym wiązaniem metod typu obiektu `T2` w zestawie `C` innych niż Bieżący zestaw lub zestawu zawierającego `T1`, zestawu `C` jest ładowany do bieżącej domeny aplikacji. Ładowanie tego występuje nawet wtedy, gdy wywołanie z wczesnym wiązaniem `T1.M()` została wprowadzona w treści <xref:System.Reflection.Emit.DynamicMethod>, lub w innym dynamicznie generowanym kodzie. Jeśli bieżąca domena jest domeną domyślną, zestawu `C` nie może być zwolnione, do czasu zakończenia procesu. Jeśli bieżąca domena później próbuje załadować zestawu `C`, obciążenie może zakończyć się niepowodzeniem.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie `ignoreCase` parametru.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie danego typu zdefiniowane w określonym pliku zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa (łącznie ze ścieżką) pliku zawierającego zestaw, który definiuje żądany typ. Zestaw jest ładowany przy użyciu <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> metody.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Obiekt będący otoki dla nowego wystąpienia lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie znaleziono. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny konstruktor `typeName` jest wywoływana.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 Gdy <xref:System.AppDomain.CreateInstanceFrom%2A> metoda jest używana do utworzenia wystąpienia w domenie aplikacji docelowej, inne niż domena aplikacji, w którym jest nawiązane połączenie, zestaw jest ładowany w docelowej domenie aplikacji. Jeśli jednak wystąpienie nie zostanie rozwinięte w domenie aplikacji wywołującej, użycie nierozwiniętych instancji w określony sposób może spowodować załadowanie zestawu do domeny aplikacji wywołującej. Na przykład po rozwinięciu danego wystąpienia można zażądać informacji o typie, aby wywołać jego metody z późnym wiązaniem. Podczas ładowania zestawu do domeny aplikacji wywołującej mogą wystąpić wyjątki.  
  
-   Jeśli inna wersja tego samego zestawu zostało wcześniej załadowane do wywoływania domeny aplikacji lub jeśli takie jak ścieżka obciążenia wywoływania domeny aplikacji to innym niż docelowa domena aplikacji, wyjątki <xref:System.MissingMethodException> może wystąpić.  
  
-   Jeśli wywołanie domeny aplikacji sprawia, że wywołania z wczesnym wiązaniem na typ wystąpienia <xref:System.InvalidCastException> może zostać wygenerowany, gdy podejmowana jest próba można rzutować wystąpienia.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> przeciążenie metody do tworzenia wystąpienia obiektu w domenie aplikacji docelowej i wywołania metody.  
  
 W przykładzie zdefiniowano `MarshallableExample` klasy, które mogą być przekazywane między granicami domeny aplikacji. Przykład kompilacje ścieżka do aktualnie realizowanej zestawu tworzy docelowa domena aplikacji, a używa <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> przeciążenie metody można załadować zestawu przykład do domeny docelowej aplikacji i Utwórz wystąpienie `MarshallableExample`.  
  
> [!NOTE]
>  Ścieżka jest bezwzględna w tym przykładzie, ale ścieżka względna również będzie działać, ponieważ <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> metoda jest używana do ładowania zestawu.  
  
 Po odkodowywania uchwyt obiektu, w przykładzie pokazano trzy sposoby użycia obiektu w domenie aplikacji docelowej:  
  
-   Wywoływanie metody z późnym wiązaniem, za pomocą odbicia. Wymaga to informacje o typie, co powoduje, że zestaw do którego zostanie załadowana domeny aplikacji obiektu wywołującego. (W tym przykładzie jest on już załadowany.)  
  
-   Rzutowanie obiektu do interfejsu znane do wywołującego i wywoływany. Jeśli interfejs jest zdefiniowany w zestawie wywoływania lub w zestawie trzeci odwołuje się obiekt wywołujący jak również wywoływany, zestawu o nazwie nie jest załadowany do domeny aplikacji obiektu wywołującego.  
  
-   Przy użyciu obiektu bezpośrednio po jego typ jest znany do obiektu wywołującego. Zestaw muszą być załadowane do domeny aplikacji obiektu wywołującego.  
  
 Innym sposobem uniknięcia ładowania zestawu o nazwie do domeny aplikacji obiektu wywołującego jest dla obiekt wywołujący, aby dziedziczyć <xref:System.MarshalByRefObject> klasy i w celu zdefiniowania metody, które mogą być uruchamiane w docelowej domenie aplikacji. Tej metody można użyć odbicia do zbadania zestawu docelowego, ponieważ zestaw docelowy jest już załadowany do domeny aplikacji docelowej. Zobacz przykład <xref:System.AppDomain.DynamicDirectory%2A> właściwości.  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.  - lub - <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Znaleziono nie publicznego konstruktora bez parametrów.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa (łącznie ze ścieżką) pliku zawierającego zestaw, który definiuje żądany typ. Zestaw jest ładowany przy użyciu <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> metody.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablicę, która zawiera jedną <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Obiekt będący otoki dla nowego wystąpienia lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie znaleziono. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny konstruktor `typeName` jest wywoływana.  
  
 Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 Gdy <xref:System.AppDomain.CreateInstanceFrom%2A> metoda jest używana do utworzenia wystąpienia w domenie aplikacji docelowej, inne niż domena aplikacji, w którym jest nawiązane połączenie, zestaw jest ładowany w docelowej domenie aplikacji. Jeśli jednak wystąpienie nie zostanie rozwinięte w domenie aplikacji wywołującej, użycie nierozwiniętych instancji w określony sposób może spowodować załadowanie zestawu do domeny aplikacji wywołującej. Na przykład po rozwinięciu danego wystąpienia można zażądać informacji o typie, aby wywołać jego metody z późnym wiązaniem. Podczas ładowania zestawu do domeny aplikacji wywołującej mogą wystąpić wyjątki.  
  
-   Jeśli inna wersja tego samego zestawu zostało wcześniej załadowane do wywoływania domeny aplikacji lub jeśli takie jak ścieżka obciążenia wywoływania domeny aplikacji to innym niż docelowa domena aplikacji, wyjątki <xref:System.MissingMethodException> może wystąpić.  
  
-   Jeśli wywołanie domeny aplikacji sprawia, że wywołania z wczesnym wiązaniem na typ wystąpienia <xref:System.InvalidCastException> może zostać wygenerowany, gdy podejmowana jest próba można rzutować wystąpienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa (łącznie ze ścieżką) pliku zawierającego zestaw, który definiuje żądany typ. Zestaw jest ładowany przy użyciu <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> metody.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przez odbicie. Jeśli <c>integratora</c> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli domyślny konstruktor jest preferowana, <c>argumentów</c> musi być pustą tablicą ani mieć wartości null.</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typeName</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablicę, która zawiera jedną <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Obiekt będący otoki dla nowego wystąpienia lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie znaleziono. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 Gdy <xref:System.AppDomain.CreateInstanceFrom%2A> metoda jest używana do utworzenia wystąpienia w domenie aplikacji docelowej, inne niż domena aplikacji, w którym jest nawiązane połączenie, zestaw jest ładowany w docelowej domenie aplikacji. Jeśli jednak wystąpienie nie zostanie rozwinięte w domenie aplikacji wywołującej, użycie nierozwiniętych instancji w określony sposób może spowodować załadowanie zestawu do domeny aplikacji wywołującej. Na przykład po rozwinięciu danego wystąpienia można zażądać informacji o typie, aby wywołać jego metody z późnym wiązaniem. Podczas ładowania zestawu do domeny aplikacji wywołującej mogą wystąpić wyjątki.  
  
-   Jeśli inna wersja tego samego zestawu zostało wcześniej załadowane do wywoływania domeny aplikacji lub jeśli takie jak ścieżka obciążenia wywoływania domeny aplikacji to innym niż docelowa domena aplikacji, wyjątki <xref:System.MissingMethodException> może wystąpić.  
  
-   Jeśli wywołanie domeny aplikacji sprawia, że wywołania z wczesnym wiązaniem na typ wystąpienia <xref:System.InvalidCastException> może zostać wygenerowany, gdy podejmowana jest próba można rzutować wystąpienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.  - lub - <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa (łącznie ze ścieżką) pliku zawierającego zestaw, który definiuje żądany typ. Zestaw jest ładowany przy użyciu <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> metody.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przez odbicie. Jeśli <c>integratora</c> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli domyślny konstruktor jest preferowana, <c>argumentów</c> musi być pustą tablicą ani mieć wartości null.</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typeName</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablicę, która zawiera jedną <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do tworzenia autoryzacji <c>typeName</c>.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Obiekt będący otoki dla nowego wystąpienia lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie znaleziono. Zwracana wartość musi być bez otoki, aby miała dostęp do rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 Gdy <xref:System.AppDomain.CreateInstanceFrom%2A> metoda jest używana do utworzenia wystąpienia w domenie aplikacji docelowej, inne niż domena aplikacji, w którym jest nawiązane połączenie, zestaw jest ładowany w docelowej domenie aplikacji. Jeśli jednak wystąpienie nie zostanie rozwinięte w domenie aplikacji wywołującej, użycie nierozwiniętych instancji w określony sposób może spowodować załadowanie zestawu do domeny aplikacji wywołującej. Na przykład po rozwinięciu danego wystąpienia można zażądać informacji o typie, aby wywołać jego metody z późnym wiązaniem. Podczas ładowania zestawu do domeny aplikacji wywołującej mogą wystąpić wyjątki.  
  
-   Jeśli inna wersja tego samego zestawu zostało wcześniej załadowane do wywoływania domeny aplikacji lub jeśli takie jak ścieżka obciążenia wywoływania domeny aplikacji to innym niż docelowa domena aplikacji, wyjątki <xref:System.MissingMethodException> może wystąpić.  
  
-   Jeśli wywołanie domeny aplikacji sprawia, że wywołania z wczesnym wiązaniem na typ wystąpienia <xref:System.InvalidCastException> może zostać wygenerowany, gdy podejmowana jest próba można rzutować wystąpienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.  - lub - <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.  - lub - <paramref name="securityAttributes" /> nie jest <see langword="null" />. Gdy starszą zasadę nie jest włączone, <paramref name="securityAttributes" /> powinien być <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NullReferenceException">To wystąpienie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie danego typu zdefiniowane w określonym pliku zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku i ścieżka zestawu definiują żądany typ.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Żądany obiekt lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie znaleziono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstanceFrom%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Ta metoda wywołuje konstruktor domyślny `typeName`.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> jest <see langword="null" />.  - lub - <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Znaleziono nie publicznego konstruktora bez parametrów.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku i ścieżka zestawu definiują żądany typ.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestawu (zobacz <see cref="P:System.Type.FullName" /> właściwości).</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablicę, która zawiera jedną <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Żądany obiekt lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie znaleziono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstanceFrom%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Ta metoda wywołuje konstruktor domyślny `typeName`.  
  
 Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> jest <see langword="null" />.  - lub - <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Znaleziono nie publicznego konstruktora bez parametrów.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku i ścieżka zestawu definiują żądany typ.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przez odbicie. Jeśli <c>integratora</c> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli domyślny konstruktor jest preferowana, <c>argumentów</c> musi być pustą tablicą ani mieć wartości null.</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typeName</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablicę, która zawiera jedną <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowane w pliku określonego zestawu określenie, czy jest ignorowana w przypadku nazwy typu. atrybuty wiązania i integratorów, które służą do wybierania typu, który ma zostać utworzony; Argumenty konstruktora; Kultura; i atrybuty aktywacji.</summary>
        <returns>Żądany obiekt lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie znaleziono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstanceFrom%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> jest <see langword="null" />.  - lub - <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji środowiska CLR wersji, która jest obecnie załadowane.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku i ścieżka zestawu definiują żądany typ.</param>
        <param name="typeName">W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez <see cref="P:System.Type.FullName" /> właściwości.</param>
        <param name="ignoreCase">Wartość logiczna określająca, czy w wyszukiwaniu ma być uwzględniana wielkość liter czy nie.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przez odbicie. Jeśli <c>integratora</c> jest wartość null, jest używany domyślny integrator.</param>
        <param name="args">Argumenty, które mają zostać przekazane do konstruktora. Ta tablica argumentów musi pod względem liczby, kolejności i typów parametrów odpowiadać konstruktorowi, który ma zostać wywołany. Jeśli domyślny konstruktor jest preferowana, <c>argumentów</c> musi być pustą tablicą ani mieć wartości null.</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typeName</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablicę, która zawiera jedną <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do tworzenia autoryzacji <c>typeName</c>.</param>
        <summary>Tworzy nowe wystąpienie określonego typu zdefiniowanego w podanym pliku zestawu.</summary>
        <returns>Żądany obiekt lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie znaleziono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstanceFrom%2A> i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> jest <see langword="null" />.  - lub - <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma wystarczających uprawnień do wywołania tego konstruktora.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Odczytywanie pliku zawierającego manifest zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącej domeny aplikacji dla bieżącego <see cref="T:System.Threading.Thread" />.</summary>
        <value>Bieżącej domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod tworzy nową domenę aplikacji. <xref:System.AppDomain.CurrentDomain%2A> Właściwość jest używana do uzyskania <xref:System.AppDomain> obiekt, który reprezentuje bieżącej domeny aplikacji. <xref:System.AppDomain.FriendlyName%2A> Właściwość zawiera nazwę bieżącej domeny aplikacji, który następnie jest wyświetlany w wierszu polecenia.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje zestaw dynamiczny w bieżącej domenie aplikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb dostępu dla zestawów dynamicznych.</param>
        <summary>Definiuje dynamicznego zestawu z określonym trybem nazwy i dostępu.</summary>
        <returns>Dynamiczne zestawu z określonym trybem nazwy i dostępu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
> [!NOTE]
>  Podczas tworzenia kodu, który emituje zestawów dynamicznych, zaleca się używanie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę, która określa dowód i uprawnienia, podaj dowód ma zestawie dynamicznym ma i zawierać <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany. Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> — metoda i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  - lub - <see langword="Name" /> właściwość <paramref name="name" /> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb dostępu dla zestawów dynamicznych.</param>
        <param name="assemblyAttributes">Wyliczalny listę atrybutów, które ma zostać zastosowany do zestawu, lub <see langword="null" /> Jeśli istnieją żadne atrybuty.</param>
        <summary>Definiuje dynamicznego zestawu o określonej nazwie, tryb dostępu oraz atrybuty niestandardowe.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeciążenia służy do określania atrybutów, które nie będą działać poprawnie, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład zabezpieczeń atrybuty, takie jak <xref:System.Security.SecurityTransparentAttribute> i <xref:System.Security.SecurityCriticalAttribute> nie działają prawidłowo, jeśli są one dodawane po utworzeniu zestawu dynamicznego.  
  
 Tej metody należy użyć tylko w celu zdefiniowania zestawu dynamicznego w bieżącej domeny aplikacji. Aby uzyskać więcej informacji na temat tego ograniczenia, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
 To przeciążenie metody została wprowadzona w systemie [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia dynamicznego zestawu, który ma <xref:System.Security.SecurityTransparentAttribute>. Ten atrybut musi być określony jako element tablicy <xref:System.Reflection.Emit.CustomAttributeBuilder> obiektów.  
  
 Pierwszym krokiem tworzenia <xref:System.Reflection.Emit.CustomAttributeBuilder> jest uzyskanie konstruktora dla atrybutu. Konstruktor nie ma parametrów, więc <xref:System.Type.GetConstructor%2A> metoda jest wywoływana z pustą tablicę <xref:System.Type> obiekty do reprezentowania typy parametrów. Drugim krokiem jest przekazanie powstałe w ten sposób <xref:System.Reflection.ConstructorInfo> obiekt do konstruktora dla <xref:System.Reflection.Emit.CustomAttributeBuilder> klasy wraz z pustą tablicę typu <xref:System.Object> do reprezentacji argumentów.  
  
 Powstałe w ten sposób <xref:System.Reflection.Emit.CustomAttributeBuilder> są następnie przekazywane do <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę jako jedynym elementem tablicy.  
  
 Przykładowy kod definiuje modułu oraz typ w nowego zestawu dynamicznego, a następnie wyświetla zestawu atrybutów.  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  - lub - <see langword="Name" /> właściwość <paramref name="name" /> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <summary>Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu i dokumenty.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko w pełni zaufane obiekty wywołujące można podać ich `evidence` podczas definiowania dynamicznym <xref:System.Reflection.Assembly>. Środowisko uruchomieniowe przypisze <xref:System.Security.Policy.Evidence> za pomocą zasad zabezpieczeń, aby określić uprawnienia nadanego. Częściowo zaufane obiekty wywołujące należy podać wartość null `evidence`. Jeśli `evidence` jest `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżącego udzielania i odmawiania zestawów z obiektu wywołującego <xref:System.Reflection.Assembly> do dynamicznej <xref:System.Reflection.Assembly> definiowanego i oznacza zasad jako rozwiązane.  
  
 Jeśli dynamiczny <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejne obciążeń otrzyma przyznaje na podstawie zasad związane z lokalizacją gdzie <xref:System.Reflection.Assembly> został zapisany.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
> [!NOTE]
>  Podczas tworzenia kodu, który emituje zestawów dynamicznych, zaleca się używanie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę, która określa dowód i uprawnienia, podaj dowód ma zestawie dynamicznym ma i zawierać <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany. Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> — metoda i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Najpierw próbuje utworzyć wystąpienie przykładowy kod `MyDynamicType` przez wywołanie metody <xref:System.AppDomain.CreateInstance%2A> metodę o nazwie nieprawidłowy zestaw i przechwytuje wynikowy wyjątek.  
  
 Przykładowy kod dodaje program obsługi zdarzeń dla <xref:System.AppDomain.AssemblyResolve> zdarzeń, a następnie próbuje utworzyć wystąpienie`MyDynamicType`. Podczas wywołania <xref:System.AppDomain.CreateInstance%2A>, <xref:System.AppDomain.AssemblyResolve> zdarzenie jest wywoływane dla zestawu nieprawidłowy. Program obsługi zdarzeń tworzy dynamiczne zestawu, który zawiera typ o nazwie `MyDynamicType`daje typu konstruktora bez parametrów i zwraca nowego zestawu dynamicznego. Wywołanie <xref:System.AppDomain.CreateInstance%2A> następnie zakończy działanie pomyślnie, a Konstruktor `MyDynamicType` na konsoli zostanie wyświetlony komunikat.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  - lub - <see langword="Name" /> właściwość <paramref name="name" /> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli <c>dir</c> jest <see langword="null" />, domyślne ustawienia katalogu do bieżącego katalogu.</param>
        <summary>Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu i katalog magazynu.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
> [!NOTE]
>  Podczas tworzenia kodu, który emituje zestawów dynamicznych, zaleca się używanie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę, która określa dowód i uprawnienia, podaj dowód ma zestawie dynamicznym ma i zawierać <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany. Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> — metoda i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  - lub - <see langword="Name" /> właściwość <paramref name="name" /> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb dostępu dla zestawów dynamicznych.</param>
        <param name="assemblyAttributes">Wyliczalny listę atrybutów, które ma zostać zastosowany do zestawu, lub <see langword="null" /> Jeśli istnieją żadne atrybuty.</param>
        <param name="securityContextSource">Źródło kontekstu zabezpieczeń.</param>
        <summary>Definiuje dynamicznego zestawu o określonej nazwie, tryb dostępu oraz atrybuty niestandardowe, a jego kontekstu zabezpieczeń przy użyciu określonego źródła.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeciążenia służy do określania atrybutów, które nie będą działać poprawnie, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład zabezpieczeń atrybuty, takie jak <xref:System.Security.SecurityTransparentAttribute> i <xref:System.Security.SecurityCriticalAttribute> nie działają prawidłowo, jeśli są one dodawane po utworzeniu zestawu dynamicznego.  
  
 Tej metody należy użyć tylko w celu zdefiniowania zestawu dynamicznego w bieżącej domeny aplikacji. Aby uzyskać więcej informacji na temat tego ograniczenia, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  - lub - <see langword="Name" /> właściwość <paramref name="name" /> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="securityContextSource" /> nie jest jedną z wartości wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli <c>dir</c> jest <see langword="null" />, domyślne ustawienia katalogu do bieżącego katalogu.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <summary>Definiuje przy użyciu określonej nazwy, tryb dostępu, katalog magazynu i dowód zestawie dynamicznym.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko w pełni zaufane obiekty wywołujące można podać ich `evidence` podczas definiowania dynamicznym <xref:System.Reflection.Assembly>. Środowisko uruchomieniowe przypisze <xref:System.Security.Policy.Evidence> za pomocą zasad zabezpieczeń, aby określić uprawnienia nadanego. Częściowo zaufane obiekty wywołujące należy podać wartość null `evidence`. Jeśli `evidence` jest `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżącego udzielania i odmawiania zestawów z obiektu wywołującego <xref:System.Reflection.Assembly> do dynamicznej <xref:System.Reflection.Assembly> definiowanego i oznacza zasad jako rozwiązane.  
  
 Jeśli dynamiczny <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejne obciążeń otrzyma przyznaje na podstawie zasad związane z lokalizacją gdzie <xref:System.Reflection.Assembly> został zapisany.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
> [!NOTE]
>  Podczas tworzenia kodu, który emituje zestawów dynamicznych, zaleca się używanie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę, która określa dowód i uprawnienia, podaj dowód ma zestawie dynamicznym ma i zawierać <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany. Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> — metoda i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  - lub - <see langword="Name" /> właściwość <paramref name="name" /> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <summary>Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu i żądania uprawnień.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądania uprawnień określony dla `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` nie są używane, chyba że dynamicznego zestawu został zapisany i ponownie załadowana do pamięci. Aby określić żądanych uprawnień dla zestawu przejściowego, który nie jest zapisywany na dysku, użyj przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę, która określa jako również jako żądane uprawnienia i podaj dowód <xref:System.Security.Policy.Evidence> obiektu.  
  
> [!NOTE]
>  Podczas tworzenia kodu, który emituje zestawów dynamicznych, zaleca się używanie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę, która określa dowód i uprawnienia, podaj dowód ma zestawie dynamicznym ma i zawierać <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany. Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> — metoda i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  - lub - <see langword="Name" /> właściwość <paramref name="name" /> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany w zestawie dynamicznym. Jeśli <c>dir</c> jest <see langword="null" />, bieżący katalog jest używany.</param>
        <param name="isSynchronized">
          <see langword="true" /> Aby zsynchronizować tworzenia modułów, typy i elementy członkowskie w zestawie dynamicznym; w przeciwnym razie <see langword="false" />.</param>
        <param name="assemblyAttributes">Wyliczalny listę atrybutów, które ma zostać zastosowany do zestawu, lub <see langword="null" /> Jeśli istnieją żadne atrybuty.</param>
        <summary>Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu, katalog magazynu i opcji synchronizacji.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeciążenia służy do określania atrybutów, które nie będą działać poprawnie, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład zabezpieczeń atrybuty, takie jak <xref:System.Security.SecurityTransparentAttribute> i <xref:System.Security.SecurityCriticalAttribute> nie działają prawidłowo, jeśli są one dodawane po utworzeniu zestawu dynamicznego.  
  
 Jeśli `isSynchronized` jest `true`, z następujących metod powstałe w ten sposób <xref:System.Reflection.Emit.AssemblyBuilder> zostaną zsynchronizowane: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, i <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Jeśli dwa z tych metod są nazywane w różnych wątkach, blokuje ukończenie innych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  - lub - <see langword="Name" /> właściwość <paramref name="name" /> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <summary>Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu, dowód i żądania uprawnień.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądania uprawnień określony dla `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` są używane tylko wtedy, gdy `evidence` jest także dostarczany, lub jeśli w zestawie dynamicznym jest zapisany i ponownie załadowana do pamięci.  
  
> [!NOTE]
>  Podczas tworzenia kodu, który emituje zestawów dynamicznych zalecane jest, że obejmuje <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany. Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.  
  
 Tylko w pełni zaufane obiekty wywołujące można podać ich `evidence` podczas definiowania dynamicznym <xref:System.Reflection.Assembly>. Środowisko uruchomieniowe przypisze <xref:System.Security.Policy.Evidence> za pomocą zasad zabezpieczeń, aby określić uprawnienia nadanego. Częściowo zaufane obiekty wywołujące należy podać wartość null `evidence`. Jeśli `evidence` jest `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżącego udzielania i odmawiania zestawów z obiektu wywołującego <xref:System.Reflection.Assembly> do dynamicznej <xref:System.Reflection.Assembly> definiowanego i oznacza zasad jako rozwiązane.  
  
 Jeśli dynamiczny <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejne obciążeń otrzyma przyznaje na podstawie zasad związane z lokalizacją gdzie <xref:System.Reflection.Assembly> został zapisany.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> — metoda i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  - lub - <see langword="Name" /> właściwość <paramref name="name" /> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli <c>dir</c> jest <see langword="null" />, domyślne ustawienia katalogu do bieżącego katalogu.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <summary>Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu, katalog magazynu i żądania uprawnień.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądania uprawnień określony dla `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` nie są używane, chyba że dynamicznego zestawu został zapisany i ponownie załadowana do pamięci. Aby określić żądanych uprawnień dla zestawu przejściowego, który nie jest zapisywany na dysku, użyj przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę, która określa jako również jako żądane uprawnienia i podaj dowód <xref:System.Security.Policy.Evidence> obiektu.  
  
> [!NOTE]
>  Podczas tworzenia kodu, który emituje zestawów dynamicznych, zaleca się używanie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A> metodę, która określa dowód i uprawnienia, podaj dowód ma zestawie dynamicznym ma i zawierać <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany. Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> — metoda i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  - lub - <see langword="Name" /> właściwość <paramref name="name" /> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli <c>dir</c> jest <see langword="null" />, domyślne ustawienia katalogu do bieżącego katalogu.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <summary>Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu, katalog magazynu, dowód i żądania uprawnień.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądania uprawnień określony dla `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` są używane tylko wtedy, gdy `evidence` jest także dostarczany, lub jeśli w zestawie dynamicznym jest zapisany i ponownie załadowana do pamięci.  
  
> [!NOTE]
>  Podczas tworzenia kodu, który emituje zestawów dynamicznych zalecane jest, że obejmuje <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany. Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.  
  
 Tylko w pełni zaufane obiekty wywołujące można podać ich `evidence` podczas definiowania dynamicznym <xref:System.Reflection.Assembly>. Środowisko uruchomieniowe przypisze <xref:System.Security.Policy.Evidence> za pomocą zasad zabezpieczeń, aby określić uprawnienia nadanego. Częściowo zaufane obiekty wywołujące należy podać wartość null `evidence`. Jeśli `evidence` jest `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżącego udzielania i odmawiania zestawów z obiektu wywołującego <xref:System.Reflection.Assembly> do dynamicznej <xref:System.Reflection.Assembly> definiowanego i oznacza zasad jako rozwiązane.  
  
 Jeśli dynamiczny <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejne obciążeń otrzyma przyznaje na podstawie zasad związane z lokalizacją gdzie <xref:System.Reflection.Assembly> został zapisany.  
  
 Ta metoda powinna służyć wyłącznie do definiowania zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> — metoda i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  - lub - <see langword="Name" /> właściwość <paramref name="name" /> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany w zestawie dynamicznym. Jeśli <c>dir</c> jest <see langword="null" />, domyślne ustawienia katalogu do bieżącego katalogu.</param>
        <param name="evidence">Dowód dostarczony dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <param name="isSynchronized">
          <see langword="true" /> Aby zsynchronizować tworzenia modułów, typy i elementy członkowskie w zestawie dynamicznym; w przeciwnym razie <see langword="false" />.</param>
        <summary>Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu, katalog magazynu dowód, żądania uprawnień i opcji synchronizacji.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądania uprawnień określony dla `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` są używane tylko wtedy, gdy `evidence` jest także dostarczany, lub jeśli w zestawie dynamicznym jest zapisany i ponownie załadowana do pamięci.  
  
> [!NOTE]
>  Podczas tworzenia kodu, który emituje zestawów dynamicznych zalecane jest, że obejmuje <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> w `refusedPermissions`. W tym <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany. Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.  
  
 Tylko w pełni zaufane obiekty wywołujące mogą udowodnić ich podczas definiowania dynamicznym <xref:System.Reflection.Assembly>. Środowisko uruchomieniowe przypisze <xref:System.Security.Policy.Evidence> za pomocą zasad zabezpieczeń, aby określić uprawnienia nadanego. Częściowo zaufane obiekty wywołujące należy podać `null` dla `evidence` parametru. Jeśli `evidence` jest `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżącego udzielania i odmawiania zestawów z obiektu wywołującego <xref:System.Reflection.Assembly> do dynamicznej <xref:System.Reflection.Assembly> definiowanego i oznacza zasad jako rozwiązane.  
  
 Jeśli dynamiczny <xref:System.Reflection.Assembly> jest zapisywany na dysku, kolejne obciążeń otrzyma przyznaje na podstawie zasad związane z lokalizacją gdzie <xref:System.Reflection.Assembly> został zapisany.  
  
 Jeśli `isSynchronized` jest `true`, z następujących metod powstałe w ten sposób <xref:System.Reflection.Emit.AssemblyBuilder> zostaną zsynchronizowane: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, i <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Jeśli dwa z tych metod są nazywane w różnych wątkach, zablokuje innych zakończenia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.DefineDynamicAssembly%2A> — metoda i <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  - lub - <see langword="Name" /> właściwość <paramref name="name" /> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Unikatowa tożsamość zestawu dynamicznego.</param>
        <param name="access">Tryb, w którym będzie dostępny zestaw dynamiczny.</param>
        <param name="dir">Nazwa katalogu, w którym zostanie zapisany w zestawie dynamicznym. Jeśli <c>dir</c> jest <see langword="null" />, bieżący katalog jest używany.</param>
        <param name="evidence">Dowód, że dostarczonej dla zestawu dynamicznego. Dowód w niezmienionej formie jest używany jako ostateczny zestaw stosowanych zasad rozpoznawania dowodów.</param>
        <param name="requiredPermissions">Żądanie wymaganych uprawnień.</param>
        <param name="optionalPermissions">Opcjonalne żądanie uprawnienia.</param>
        <param name="refusedPermissions">Żądanie odrzuconych uprawnień.</param>
        <param name="isSynchronized">
          <see langword="true" /> Aby zsynchronizować tworzenia modułów, typy i elementy członkowskie w zestawie dynamicznym; w przeciwnym razie <see langword="false" />.</param>
        <param name="assemblyAttributes">Wyliczalny listę atrybutów, które ma zostać zastosowany do zestawu, lub <see langword="null" /> Jeśli istnieją żadne atrybuty.</param>
        <summary>Definiuje dynamicznego zestawu z określoną nazwą, tryb dostępu, katalog magazynu, dowód, żądania uprawnień, opcja synchronizacji i atrybuty niestandardowe.</summary>
        <returns>Zestaw dynamiczny z określoną nazwą i funkcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeciążenia służy do określania atrybutów, które nie będą działać poprawnie, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład zabezpieczeń atrybuty, takie jak <xref:System.Security.SecurityTransparentAttribute> i <xref:System.Security.SecurityCriticalAttribute> nie działają prawidłowo, jeśli są one dodawane po utworzeniu zestawu dynamicznego.  
  
 Żądania uprawnień określony dla `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` tylko wtedy, gdy są używane parametry `evidence` również podano parametr, lub jeśli w zestawie dynamicznym jest zapisany i ponownie załadowana do pamięci.  
  
> [!NOTE]
>  Podczas opracowywania kod, który emituje zestawów dynamicznych, firma Microsoft zaleca możesz uwzględnić <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> oflagowane w `refusedPermissions` parametru. Włączenie tej flagi zapewnia, że zostaną zweryfikowane język pośredni (MSIL) firmy Microsoft. Ta technika wykryje niezamierzone Generowanie zweryfikowanie kodu, które w przeciwnym razie jest bardzo trudne do wykrycia. Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException> zostanie wygenerowany, gdy jest używany z kodem, który wymaga pełnego zaufania.  
  
 Tylko w pełni zaufane obiekty wywołujące mogą udowodnić podczas definiowania dynamicznym <xref:System.Reflection.Assembly>. Środowisko uruchomieniowe mapuje <xref:System.Security.Policy.Evidence> za pomocą zasad zabezpieczeń, aby określić uprawnienia nadanego. Częściowo zaufane obiekty wywołujące należy podać `null` dla `evidence` parametru. Jeśli `evidence` jest `null`, środowisko uruchomieniowe kopiuje zestawów uprawnienia (które jest bieżącym grant i odmowy zestawy) z zestawu obiektu wywołującego do dynamicznego zestawu, który jest definiowany i oznacza zasady jako rozwiązane.  
  
 Jeśli w zestawie dynamicznym jest zapisywany na dysku, kolejne obciążenie otrzyma przyznaje na podstawie zasad, które są skojarzone z lokalizacji, w którym zapisano w zestawie dynamicznym.  
  
 Jeśli `isSynchronized` jest `true`, z następujących metod powstałe w ten sposób <xref:System.Reflection.Emit.AssemblyBuilder> zostaną zsynchronizowane: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, i <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Jeśli dwa z tych metod są nazywane w różnych wątkach, blokuje ukończenie innych.  
  
 To przeciążenie metody została wprowadzona w systemie [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="Name" /> Właściwość <paramref name="name" /> jest <see langword="null" />.  - lub - <see langword="Name" /> właściwość <paramref name="name" /> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">Delegat, który określa metodę do wywołania.</param>
        <summary>Wykonuje kod w innej domenie aplikacji, identyfikowany przez określonego delegata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` można określić marshal za wartość, <xref:System.MarshalByRefObject>, lub <xref:System.ContextBoundObject>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, przy użyciu statycznego <xref:System.AppDomain.DoCallBack%2A> metody.  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 W poniższym przykładzie pokazano, przy użyciu <xref:System.AppDomain.DoCallBack%2A> metody przez wartość.  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 W poniższym przykładzie pokazano, przy użyciu <xref:System.AppDomain.DoCallBack%2A> metody przez odwołanie.  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBackDelegate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Menedżera domeny dostarczony przez hosta podczas inicjowania domeny aplikacji.</summary>
        <value>Obiekt reprezentujący menedżera domen dostarczone przez hosta podczas inicjowania domeny aplikacji lub <see langword="null" /> Jeśli brak Menedżera domeny nie został podany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezarządzane hosta środowisko uruchomieniowe języka wspólnego (CLR) może zapewnić Menedżer domeny. Menedżer domeny mogą uczestniczyć w Inicjowanie nowej domeny aplikacji i podaj inne menedżerów, takich jak <xref:System.Security.HostSecurityManager>, który uczestniczyć w operacji domeny aplikacji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="T:System.AppDomain" /> ma zostać zwolniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler> Delegowanie dla to zdarzenie można wykonać żadnych działań zakończenia, zanim zostanie usunięty z pamięci domeny aplikacji.  
  
 Każda domena aplikacji potrzebnych do wykonania przetwarzania, gdy jest zwolniony należy zarejestrować program obsługi zdarzeń dla tego zdarzenia. Program obsługi zdarzeń udostępnionego nie powinna być używana, ponieważ <xref:System.EventHandler> delegata nie będzie rozpoznawał domeny, która jest zwalniany.  
  
> [!NOTE]
>  To zdarzenie jest wywoływane nigdy w domyślnej domeny aplikacji.  
  
 Nie należy wprowadzać założeń, o które zdarzenie jest wywoływane w wątku. Może być zdarzenia w innym wątku niż ten, który wywołuje <xref:System.AppDomain.Unload%2A> metody.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera katalogu, którego używa mechanizmu rozpoznawania zestawu do sondowania dla zestawów utworzony dynamicznie.</summary>
        <value>Katalog używany przez mechanizm rozpoznawania zestawów do sondowania dla zestawów utworzony dynamicznie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ustawić katalogu dynamicznych, przypisz ścieżkę katalogu podstawowego do <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> właściwość <xref:System.AppDomainSetup> obiekt, który będzie używany do utworzenia nowej domeny aplikacji. Ścieżka katalogu podstawowego można przypisać do właściwości jest modyfikowany przez dodanie którego prostą nazwą jest wartością skrótu parametrów przypisywane do podkatalogu <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> właściwości, więc jest format podstawowego katalogu *oryginalnej ścieżce* \\ *skrótu*. Dynamiczne katalog jest podkatalogiem katalogu podstawowego. Jego prostą nazwą jest wartością <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> właściwości, więc jego format jest *oryginalnej ścieżce*\\*skrótu*\\*Nazwa aplikacji*.  
  
   
  
## Examples  
 Poniższy przykład tworzy domenę aplikacji z katalogu dla zestawów dynamicznych, emituje zestawu dynamicznego i zapisuje go w katalogu dynamiczne ładuje zestaw do nowej domeny aplikacji i używa jej.  
  
 W przykładzie jest tworzony <xref:System.AppDomainSetup> obiekt i ustawia jej <xref:System.AppDomainSetup.ApplicationName%2A> dla właściwości "Example" i jego <xref:System.AppDomainSetup.DynamicBase%2A> dla właściwości "C:\DynamicAssemblyDir". W przykładzie następnie przedstawiono <xref:System.AppDomainSetup.DynamicBase%2A> właściwości, aby pokazać, że skrótu nazwy aplikacji zostały dołączone jako podkatalogu ścieżki, która pierwotnie była przypisana.  
  
> [!NOTE]
>  Podstawowego katalogu, w tym przykładzie jest przeznaczony na zewnątrz ścieżki próbkowania dla przykładowej aplikacji. Należy się upewnić, że w przykładzie w innej lokalizacji. Usuń podstawowego katalogu i jego podkatalogach zawsze należy uruchomić przykład.  
  
 W przykładzie jest tworzona nowa domena aplikacji przy użyciu <xref:System.AppDomainSetup> obiektu. W przykładzie użyto <xref:System.AppDomain.DynamicDirectory%2A> właściwość, aby pobrać nazwę katalogu, więc można utworzyć katalogu. (Przykład równie łatwo utworzyć katalog wcześniej łączenie Oryginalna ścieżka, wartość skrótu nazwę aplikacji i nazwę aplikacji.)  
  
 W przykładzie przedstawiono `GenerateDynamicAssembly` metodę, która emituje zestawu o nazwie `DynamicHelloWorld.dll` i zapisuje go w katalogu dynamicznym nowej domeny aplikacji. Zestaw dynamiczny zawiera jeden typ `HelloWorld`, która ma statycznej metody (`Shared` metody w języku Visual Basic) o nazwie `HelloFromAD`. Wywołanie tej metody Wyświetla nazwę domeny aplikacji.  
  
 `Example` Pochodną klasy <xref:System.MarshalByRefObject>, więc przykładzie można utworzyć wystąpienia klasy w nowej domenie aplikacji i wywołanie jego `Test` metody. `Test` Metody ładuje według jego nazwy wyświetlanej zestawu dynamicznego i wywołuje statycznych `HelloFromAD` metody.  
  
 Można wyświetlić, że dynamiczne katalogu przeszukuje po zwykłych sondowania ścieżek pisanie kodu dla zestawu o nazwie `DynamicHelloWorld.dll` i kompilowanie go w tym samym katalogu co w tym przykładzie. Zestaw musi mieć klasę o nazwie `HelloWorld` za pomocą metody statycznej o nazwie `HelloFromAD`. Ta metoda muszą mieć te same funkcje co w przykładzie; po prostu umożliwia wyświetlanie ciąg do konsoli. Zestaw musi mieć również <xref:System.Reflection.AssemblyVersionAttribute> atrybut, który ustawia swoją wersję 1.0.0.0. Po uruchomieniu przykładzie zestawu, w którym skompilowany w bieżącym katalogu znajduje się przed dynamiczne katalogu jest przeszukiwany.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Security.Policy.Evidence" /> skojarzone z tą domeną aplikacji.</summary>
        <value>Dowody skojarzone z tą domeną aplikacji.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje zawarte w określonym pliku zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <summary>Wykonuje zawarte w określonym pliku zestawu.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Można również wykonywać zestawów przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodę, która ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody.  
  
 Aby utworzyć <xref:System.AppDomain> do ładowania i wykonywania, użyj <xref:System.AppDomain.CreateDomain%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, używając jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary>Wykonuje zawarte w określonym pliku zestawu przy użyciu określonego dowód.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 <xref:System.AppDomain.ExecuteAssembly%2A> Metoda nie powoduje utworzenia nowego procesu lub domeny aplikacji i nie wykonuj metoda punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Można również wykonywać zestawów przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodę, która ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, używając jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="args">Argumenty punktu wejścia w zestawie.</param>
        <summary>Wykonuje zawarte w określonym pliku zestawu przy użyciu określonych argumentów.</summary>
        <returns>Wartość, która jest zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Można również wykonywać zestawów przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodę, która ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, używając jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="assemblySecurity">Podany dowody dla zestawu.</param>
        <param name="args">Argumenty punktu wejścia w zestawie.</param>
        <summary>Wykonuje zawarte w określonym pliku zestawu przy użyciu określonego dowodów i argumentów.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Można również wykonywać zestawów przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodę, która ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, używając jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> nie jest <see langword="null" />. Gdy starszą zasadę nie jest włączone, <paramref name="assemblySecurity" /> powinien być <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="args">Argumenty punktu wejścia w zestawie.</param>
        <param name="hashValue">Reprezentuje wartość obliczona wartość skrótu.</param>
        <param name="hashAlgorithm">Reprezentuje siła algorytmu wyznaczania wartości skrótu używanego przez manifest zestawu.</param>
        <summary>Wykonuje zawarte w określonym pliku zestawu przy użyciu określonych argumentów, wartość skrótu i algorytmu wyznaczania wartości skrótu.</summary>
        <returns>Wartość, która jest zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Można również wykonywać zestawów przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodę, która ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, używając jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw do wykonania.</param>
        <param name="assemblySecurity">Podany dowody dla zestawu.</param>
        <param name="args">Argumenty punktu wejścia w zestawie.</param>
        <param name="hashValue">Reprezentuje wartość obliczona wartość skrótu.</param>
        <param name="hashAlgorithm">Reprezentuje siła algorytmu wyznaczania wartości skrótu używanego przez manifest zestawu.</param>
        <summary>Wykonuje zawarte w określonym pliku zestawu przy użyciu określonego dowód, argumenty, wartość skrótu i algorytmu wyznaczania wartości skrótu.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Ta metoda ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A> metody. Można również wykonywać zestawów przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodę, która ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody.  
  
   
  
## Examples  
 Thefollowing w przykładzie pokazano, używając jednego z przeciążeń <xref:System.AppDomain.ExecuteAssembly%2A> w dwóch różnych domenach.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> nie jest <see langword="null" />. Gdy starszą zasadę nie jest włączone, <paramref name="assemblySecurity" /> powinien być <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Wykonuje podane nazwy wyświetlanej zestawu.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A> metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie na podstawie lokalizacji pliku. W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A> ładuje zestawy za pomocą <xref:System.Reflection.Assembly.Load%2A> metody, a nie z <xref:System.Reflection.Assembly.LoadFile%2A> metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 Aby utworzyć <xref:System.AppDomain> do ładowania i wykonywania, użyj <xref:System.AppDomain.CreateDomain%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Określony przez zestaw <paramref name="assemblyName" /> nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">Określony przez zestaw <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Określony przez zestaw <paramref name="assemblyName" /> został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <see cref="T:System.Reflection.AssemblyName" /> Obiekt reprezentujący nazwę zestawu.</param>
        <param name="args">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Wykonuje zestaw podane <see cref="T:System.Reflection.AssemblyName" />, przy użyciu określonych argumentów.</summary>
        <returns>Wartość, która jest zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A> metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie na podstawie lokalizacji pliku. W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A> ładuje zestawy za pomocą <xref:System.Reflection.Assembly.Load%2A> metody, a nie z <xref:System.Reflection.Assembly.LoadFile%2A> metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Określony przez zestaw <paramref name="assemblyName" /> nie znaleziono.</exception>
        <exception cref="T:System.IO.FileLoadException">Określony przez zestaw <paramref name="assemblyName" /> został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Określony przez zestaw <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary>Wykonuje zestawu podanej nazwy wyświetlanej za pomocą określonego dowód.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A> metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie na podstawie lokalizacji pliku. W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A> ładuje zestawy za pomocą <xref:System.Reflection.Assembly.Load%2A> metody, a nie z <xref:System.Reflection.Assembly.LoadFile%2A> metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda nie powoduje utworzenia nowego procesu lub domeny aplikacji i nie wykonuj metoda punktu wejścia w nowym wątku.  
  
> [!NOTE]
>  Jeśli używasz <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody z <xref:System.Security.Policy.Evidence> parametru części dowód są łączone ze sobą. Elementy dowody dostarczone jako argument <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody zastępują elementy dowody dostarczone przez moduł ładujący.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Określony przez zestaw <paramref name="assemblyName" /> nie znaleziono.</exception>
        <exception cref="T:System.IO.FileLoadException">Określony przez zestaw <paramref name="assemblyName" /> został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Określony przez zestaw <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="args">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Wykonuje podane nazwy wyświetlanej zestawu przy użyciu określonych argumentów.</summary>
        <returns>Wartość, która jest zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A> metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie na podstawie lokalizacji pliku. W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A> ładuje zestawy za pomocą <xref:System.Reflection.Assembly.Load%2A> metody, a nie z <xref:System.Reflection.Assembly.LoadFile%2A> metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Określony przez zestaw <paramref name="assemblyName" /> nie znaleziono.</exception>
        <exception cref="T:System.IO.FileLoadException">Określony przez zestaw <paramref name="assemblyName" /> został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Określony przez zestaw <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <see cref="T:System.Reflection.AssemblyName" /> Obiekt reprezentujący nazwę zestawu.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <param name="args">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Wykonuje zestaw podane <see cref="T:System.Reflection.AssemblyName" />, przy użyciu określonego dowodów i argumentów.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A> metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie na podstawie lokalizacji pliku. W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A> ładuje zestawy za pomocą <xref:System.Reflection.Assembly.Load%2A> metody, a nie z <xref:System.Reflection.Assembly.LoadFile%2A> metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
> [!NOTE]
>  Jeśli używasz <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody z <xref:System.Security.Policy.Evidence> parametru części dowód są łączone ze sobą. Elementy dowody dostarczone jako argument <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody zastępują elementy dowody dostarczone przez moduł ładujący.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Określony przez zestaw <paramref name="assemblyName" /> nie znaleziono.</exception>
        <exception cref="T:System.IO.FileLoadException">Określony przez zestaw <paramref name="assemblyName" /> został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Określony przez zestaw <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> nie jest <see langword="null" />. Gdy starszą zasadę nie jest włączone, <paramref name="assemblySecurity" /> powinien być <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <param name="args">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Wykonuje podane nazwy wyświetlanej zestawu przy użyciu określonego dowodów i argumentów.</summary>
        <returns>Wartość zwracana przez punkt wejścia w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A> metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName> , a nie na podstawie lokalizacji pliku. W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A> ładuje zestawy za pomocą <xref:System.Reflection.Assembly.Load%2A> metody, a nie z <xref:System.Reflection.Assembly.LoadFile%2A> metody.  
  
 Zestaw rozpoczyna wykonywanie w punkcie wejścia określonym w nagłówku .NET Framework.  
  
 Ta metoda nie tworzy nowego procesu ani domeny aplikacji oraz nie wykonuje metody punktu wejścia w nowym wątku.  
  
> [!NOTE]
>  Jeśli używasz <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody z <xref:System.Security.Policy.Evidence> parametru części dowód są łączone ze sobą. Elementy dowody dostarczone jako argument <xref:System.AppDomain.ExecuteAssemblyByName%2A> metody zastępują elementy dowody dostarczone przez moduł ładujący.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Określony przez zestaw <paramref name="assemblyName" /> nie znaleziono.</exception>
        <exception cref="T:System.IO.FileLoadException">Określony przez zestaw <paramref name="assemblyName" /> został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Określony przez zestaw <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> nie jest <see langword="null" />. Gdy starszą zasadę nie jest włączone, <paramref name="assemblySecurity" /> powinien być <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Określony zestaw nie ma punktu wejścia.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu, do informacji w samej ścieżce i w celu przekierowywania nazwy wyświetlanej do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Aby uzyskać dostęp do witryny sieci Web, gdy nazwa wyświetlana jest przekierowywana do adresu URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uruchamiać aplikację konsoli. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy jest zwracany wyjątek w kodzie zarządzanym przed środowiska uruchomieniowego wyszukuje stos wywołań dla obsługi wyjątków w domenie aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest tylko powiadomienie. Obsługa tego zdarzenia obsłużyć wyjątek lub nie mają wpływ na kolejne obsługi wyjątków w dowolny sposób. Po zdarzeniu został zgłoszony i procedury obsługi zdarzeń został wywołany, środowisko uruchomieniowe języka wspólnego (CLR) rozpoczyna się do wyszukiwania program obsługi wyjątku. <xref:System.AppDomain.FirstChanceException> udostępnia domeny aplikacji z pierwszej szansy zbadanie zarządzanych wyjątku.  
  
 Zdarzenia mogą być obsługiwane w każdej domenie aplikacji. Jeśli wątek przechodzi przez wielu domen aplikacji podczas wykonywania wywołania, zdarzenie jest wywoływane w każdej domenie aplikacji, który został zarejestrowany program obsługi zdarzeń, przed rozpoczęciem CLR wyszukiwanie zgodnych obsługi wyjątków w tej domenie aplikacji. Po zdarzeniu został obsłużony, wyszukiwanie jest przeprowadzane dla zgodnych obsługi wyjątków w tej domenie aplikacji. W przypadku nieodnalezienia, zdarzenie jest wywoływane w następnej domeny aplikacji.  
  
 Wszystkie wyjątki, które występują w przypadku obsługi musi obsługiwać <xref:System.AppDomain.FirstChanceException> zdarzeń. W przeciwnym razie <xref:System.AppDomain.FirstChanceException> jest zgłoszono rekursywnie. Może to spowodować przepełnienie stosu i kończenie działania aplikacji. Zaleca się wdrożenie obsługi zdarzeń dla tego zdarzenia jako ograniczone regiony wykonania (CERs), aby uniknąć związanych z infrastrukturą wyjątki, takie jak braku pamięci lub stos przepełnienie wpływających na maszynę wirtualną, gdy zgłoszenie wyjątku Trwa przetwarzanie.  
  
 To zdarzenie nie jest wywoływane dla wyjątków, które wskazują uszkodzenie stan procesu, np. naruszenia zasad dostępu, jeśli program obsługi zdarzeń jest krytyczny dla zabezpieczeń i ma <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> atrybutu.  
  
 Środowisko uruchomieniowe języka wspólnego wstrzymuje przerwań wątku podczas obsługi zdarzenia z powiadomieniem.  
  
   
  
## Examples  
 Poniższy przykład tworzy serię domen aplikacji o nazwie `AD0` za pośrednictwem `AD3`, z `Worker` obiektów w każdej domenie aplikacji. Każdy `Worker` obiekt odwołuje się do `Worker` obiektu w następnej domeny aplikacji, z wyjątkiem `Worker` w ostatnim domeny aplikacji. <xref:System.AppDomain.FirstChanceException> Zdarzenie jest obsługiwane we wszystkich domenach aplikacji z wyjątkiem `AD1`.  
  
> [!NOTE]
>  Oprócz przykładzie pokazano powiadomienia o wyjątkach pierwszej szansy w wielu domenach aplikacji, można znaleźć przypadki użycia proste w [porady: odbieranie powiadomień wyjątek pierwszej szansy](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).  
  
 Podczas tworzenia domeny aplikacji domyślnej domeny aplikacji wywołuje `TestException` metody dla pierwszej domeny aplikacji. Każdy `Worker` obiektu wywołania `TestException` metody dalej domeny aplikacji do ostatniego `Worker` zgłasza wyjątek, który jest obsługiwany lub nieobsługiwany. W związku z tym bieżący wątek przechodzi przez wszystkie domeny aplikacji i `TestException` zostanie dodany do stosu w każdej domenie aplikacji.  
  
 Podczas ostatniego `Worker` obiektu obsługuje wyjątek, <xref:System.AppDomain.FirstChanceException> zdarzenie jest wywoływane tylko w ostatnim domeny aplikacji. Domeny aplikacji nigdy nie uzyskać możliwość obsługi wyjątku, aby zdarzenie nie jest wywoływane.  
  
 Podczas ostatniego `Worker` obiekt nie obsługuje wyjątek, <xref:System.AppDomain.FirstChanceException> zdarzenie jest zgłaszane w każdej domenie aplikacji, która ma obsługi zdarzeń. Po zakończeniu każdej obsługi zdarzeń stosu w dalszym ciągu unwind dopóki wyjątek zostanie przechwycony przez domyślnej domeny aplikacji.  
  
> [!NOTE]
>  Aby zobaczyć sposób wyświetlania stosu zwiększa się w miarę zdarzenie jest wywoływane bliżej i bliżej domyślnej domeny aplikacji, należy zmienić `e.Exception.Message` do `e.Exception` w `FirstChanceHandler` procedury obsługi zdarzeń. Zwróć uwagę, że w przypadku `TestException` jest wywoływana przez granice domeny aplikacji, zostanie wyświetlone dwa razy: raz dla serwera proxy i raz dla elementu zastępczego.  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przyjazną nazwę tej domeny aplikacji.</summary>
        <value>Przyjazna nazwa tej domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przyjazna nazwa domyślnej domeny aplikacji jest nazwą pliku wykonywalnego procesu. Na przykład, jeśli plik wykonywalny używane do uruchamiania procesu jest `"c:\MyAppDirectory\MyAssembly.exe"`, przyjazną nazwę domyślnej domeny aplikacji jest `"MyAssembly.exe"`.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.AppDomain.FriendlyName%2A> właściwości do pobrania przyjazną nazwę bieżącej domeny aplikacji. Dla domyślnej domeny aplikacji przyjazna nazwa jest nazwą pliku wykonywalnego aplikacji. Przykładowy kod przedstawia również dodatkowe informacje dotyczące domeny aplikacji.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera zestawy, które zostały załadowane do kontekstu wykonywania tej domeny aplikacji.</summary>
        <returns>Tablica zestawów w tej domenie aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.AppDomain.GetAssemblies%2A> metodę, aby uzyskać listę wszystkich zestawów, które zostały załadowane do tej domeny aplikacji. Zestawy są następnie wyświetlane w konsoli.  
  
 Aby uruchomić ten przykład kodu, musisz utworzyć zestaw o nazwie `CustomLibrary.dll`, lub zmień nazwę zestawu, który jest przekazywany do <xref:System.AppDomain.GetAssemblies%2A> metody.  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera bieżący identyfikator wątku.</summary>
        <returns>32-bitowe liczby całkowite ze znakiem to identyfikator bieżącego wątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> właściwość, która jest stabilna nawet wtedy, gdy programu .NET Framework jest obsługiwana w środowisku obsługującym włókien (wątki lekkie).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywołać tę metodę. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości domeny aplikacji wstępnie zdefiniowanych lub nazwa właściwości domeny aplikacji zdefiniowano.</param>
        <summary>Pobiera wartość przechowywana w bieżącej domenie aplikacji dla podanej nazwy.</summary>
        <returns>Wartość <paramref name="name" /> właściwości, lub <see langword="null" /> Jeśli właściwość nie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do pobierania wartości do wpisu w wewnętrznej pamięci podręcznej par nazwa danych, które opisują właściwości tego wystąpienia <xref:System.AppDomain>. Należy pamiętać, że porównanie `name` o nazwie pary klucz wartość jest rozróżniana wielkość liter.  
  
 Pamięć podręczna zawiera automatycznie wpisy wstępnie zdefiniowanych systemu, które są wstawiane podczas tworzenia domeny aplikacji. Możesz sprawdzić ich wartości z <xref:System.AppDomain.GetData%2A> metody lub jego odpowiednik <xref:System.AppDomainSetup> właściwości.  
  
 Możesz wstawić lub zmodyfikować własne par nazwa danych zdefiniowanych przez użytkownika z <xref:System.AppDomain.SetData%2A> — metoda i sprawdzić ich wartości z <xref:System.AppDomain.GetData%2A> metody.  
  
 W poniższej tabeli opisano `name` każdego wstępnie zdefiniowane wpisu systemu i odpowiednie <xref:System.AppDomainSetup> właściwości.  
  
|Wartość "name"|Właściwość|  
|---------------------|--------------|  
|"APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|(nie właściwości)<br /><br /> "APP_LAUNCH_URL" odpowiada adresowi URL pierwotnie żądanej przez użytkownika, przed przekierowania. Jest dostępna tylko wtedy, gdy aplikacja została uruchomiona przy użyciu przeglądarki, takich jak program Internet Explorer. Nie wszystkie przeglądarki zawierają tę wartość.|  
|"APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|(nie właściwości)|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|"FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|"LICENSE_FILE" lub ciąg specyficzne dla aplikacji|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|"LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|"LOCATION_URI"|(nie właściwości)|  
|"PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> "REGEX_DEFAULT_MATCH_TIMEOUT" nie jest wpisem systemu i jego wartość można ustawić przez wywołanie metody <xref:System.AppDomain.SetData%2A> metody.|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 Poniższy przykład tworzy nową domenę aplikacji, ustawia wartość dostarczane przez system dla domeny i dodaje nową parę wartość dla domeny. W przykładzie następnie pokazano sposób użycia <xref:System.AppDomain.GetData%2A> metody w celu pobrania danych z tych par wartości i wyświetlane w konsoli.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji w ścieżce siebie, jeśli właściwość ma zastosowanie do ścieżki. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typ bieżącego wystąpienia.</summary>
        <returns>Typ bieżącego wystąpienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą, który unikatowo identyfikuje domeny aplikacji w ramach procesu.</summary>
        <value>Liczba całkowita, która identyfikuje domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy drugi domeny aplikacji i wyświetla informacje o domyślnej domeny i nowej domeny.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia <see cref="T:System.AppDomain" /> przez cały okres istnienia, zapobiegając tworzona dzierżawy.</summary>
        <returns>Zawsze <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Przełącz zgodności, aby przetestować.</param>
        <summary>Pobiera wartości NULL wartość logiczna, która wskazuje, czy ustawiono żadnych przełączników zgodności i jeśli tak, czy ustawiono zgodności określonego przełącznika.</summary>
        <returns>Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic) Jeśli zostały zdefiniowane żadne przełączniki zgodności; w przeciwnym razie wartość logiczna wskazująca czy zgodność przełącznik jest określona przez <paramref name="value" /> jest ustawiona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy została ustawiona przełącznik zgodności określonego dla bieżącej domeny aplikacji. Przełączniki zgodności zwykle przywrócić zachowanie (takie jak ciągi sposób sortowania) który został zmieniony między wersjami programu .NET Framework.  Są one ustawione przez wywołanie metody <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> metody przed utworzeniem domeny aplikacji.  
  
 Poniższa tabela zawiera przykłady przełączniki zgodności, które można ustawić, aby przywrócić zachowanie wcześniejszych wersji programu .NET Framework.  
  
|Przełącznik|Znaczenie|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Kod zabezpieczeń dostępu (CAS) [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] jest włączona w tej domenie aplikacji. Zobacz [ &lt;NetFx40_LegacySecurityPolicy&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Ciąg sortowania wartości domyślne dla [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] są włączone w tej domenie aplikacji. Jego powodzenia wymaga sort00001000.dll do zainstalowania. Zobacz [ &lt;compatsortnlsversion —&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Ciąg sortowania wartości domyślne dla [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]i Unicode 5.0 są włączone w tej domenie aplikacji. Jego powodzenia wymaga sort00060101.dll do zainstalowania.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> Formatowanie zachowanie [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] jest włączona w tej domenie aplikacji.  Zobacz [ &lt;timespan_legacyformatmode —&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) sekcji "Przywracanie starszych TimeSpan formatowanie" i <xref:System.TimeSpan> tematu.|  
|"UseRandomizedStringHashAlgorithm"|Środowisko uruchomieniowe oblicza skrótu dla ciągów na poszczególnych domen aplikacji zamiast przy użyciu pojedynczego algorytmu wyznaczania wartości skrótu, który tworzy spójne skrótu w domenach aplikacji. Zobacz [ &lt;userandomizedstringhashalgorithm —&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy domena aplikacji jest domeną domyślną aplikację dla procesu.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.AppDomain" /> obiekt reprezentuje domyślnej domeny aplikacji dla procesu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy proces zarządzanych ma domyślnej domeny aplikacji. Rozpoczyna wykonywanie w domenie domyślnej.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy drugi domeny aplikacji i wyświetla informacje o domyślnej domeny i nowej domeny.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy ta domena aplikacji jest zwolnienie i obiektami, które zawiera są zatwierdzony przez środowisko uruchomieniowe języka wspólnego.</summary>
        <returns>
          <see langword="true" /> Czy ta domena aplikacji jest zwalnianie i środowisko uruchomieniowe języka wspólnego rozpoczęło się wywoływania finalizatory; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda finalizacji obiektu zapewnia możliwość wykonania wszystkich operacji cleanup konieczne przed bezużytecznych jest obiekt. Po zakończeniu obiekt jest dostępny, ale w nieprawidłowym stanie i w związku z tym korzystanie z niej. Po pewnym czasie wyrzucanie elementów bezużytecznych kończy i zwraca obiekt.  
  
 Wywoływana jest metoda finalizacji obiektu w jednym z następujących sytuacji: podczas wyrzucania elementów bezużytecznych, gdy trwa zamykanie środowiska CLR lub gdy domena aplikacji, która zawiera obiekt jest usunięty z pamięci. <xref:System.AppDomain.IsFinalizingForUnload%2A> Metoda zwraca `true` tylko w przypadku ostatniego; nie zwraca `true` Jeśli finalizacji wyniki z rutynowych wyrzucanie elementów bezużytecznych lub zamykania środowiska CLR.  
  
> [!NOTE]
>  Aby określić, czy finalizacji z powodu wyłączenia CLR, użyj <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> właściwości. Zwraca `true` w przypadku finalizacji z powodu Zwalnianie domeny aplikacji lub do zamykania środowiska CLR.  
  
 Podczas wykonywania w metodę finalizacji podczas wyładowywania domeny, można uzyskać dostępu do innego obiektu, który odwołuje się do niego pola statycznego i ma metodę finalizacji. Jednak nie można niezawodnie tym ponieważ dostęp do obiektu mogą już mieć sfinalizowany.  
  
> [!NOTE]
>  Wyjątkiem od tej reguły jest <xref:System.Console> klasy, która zawiera pól statycznych, które odwołują się obiekty strumienia, ale jest zaimplementowana specjalnie, aby zawsze można pisać do konsoli systemu, nawet podczas zamykania domeny zwalnianie lub systemu.  
  
 Użyj tej metody w metodzie finalizacji obiektu, aby ustalić, czy domena aplikacji, która zawiera obiekt wyładowywania. Jeśli tak jest, nie można niezawodnie dostęp każdy obiekt, który ma metodę finalizacji i odwołuje się do niego pola statycznego.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy zestawy, które są ładowane do bieżącej domeny aplikacji wykonywanie z pełnym zaufaniem.</summary>
        <value>
          <see langword="true" /> Jeśli zostanie wykonane przy pełnym zaufaniu; zestawy, które są ładowane do bieżącej domeny aplikacji w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zawsze zwraca `true` dla domyślnej domeny aplikacji aplikację, która działa na pulpicie. Zwraca `false` dla domeny aplikacji w trybie piaskownicy, który został utworzony przy użyciu <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> — metoda przeciążenia, chyba że uprawnienia, które są przypisywane do domeny aplikacji są równoważne pełnego zaufania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.IsFullyTrusted%2A> właściwości i <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości z domenami aplikacji pełni zaufanych i częściowo zaufany. Domena aplikacji w pełni zaufany jest domyślnej domeny aplikacji dla aplikacji. Domeny aplikacji częściowo zaufanej jest tworzona przy użyciu <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> przeciążenie metody.  
  
 W przykładzie użyto `Worker` klasą pochodzącą z <xref:System.MarshalByRefObject>, dlatego mogą być przekazywane między granicami domeny aplikacji. W przykładzie jest tworzony `Worker` obiektu w domyślnej domeny aplikacji. Następnie wywołuje `TestIsFullyTrusted` metodę w celu wyświetlenia wartości właściwości dla domeny aplikacji i dwóch zestawów, które są ładowane do domeny aplikacji: mscorlib, która jest częścią programu .NET Framework i zestawu przykład. Domena aplikacji jest w pełni zaufany, i oba zestawy są w pełni zaufany.  
  
 W przykładzie jest tworzony innego `Worker` obiektu w domenie aplikacji piaskownicy i ponownie wywołania `TestIsFullyTrusted` metody. Mscorlib zawsze jest zaufany, nawet w przypadku aplikacji częściowo zaufanej domeny, ale przykład zestaw jest częściowo zaufany.  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżącej domeny aplikacji zawiera zestaw uprawnień, który został udzielony do wszystkich zestawów załadowanych do domeny aplikacji.</summary>
        <value>
          <see langword="true" /> Jeśli bieżąca domena aplikacji ma jednorodnego zestawu uprawnień; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `true` dla domen aplikacji w trybie piaskownicy, które zostały utworzone przy użyciu <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> przeciążenie metody. Domeny aplikacji w trybie piaskownicy ma jednorodnego zestawu uprawnień; oznacza to, że ten sam zestaw uprawnień jest przyznawane wszystkie częściowo zaufane zestawy, które są ładowane do domeny aplikacji. Domeny aplikacji w trybie piaskownicy opcjonalnie zawiera listę zestawów o silnych nazwach, które są wykluczone z tego uprawnienia ustawiona, a zamiast tego Uruchom przy pełnym zaufaniu.  
  
 Całkowicie zaufane, można użyć kodu <xref:System.AppDomain.PermissionSet%2A> właściwości do określania zestawu jednorodnego grant domeny aplikacji w trybie piaskownicy.  
  
 Ta właściwość zwraca również wartość `true` dla domyślnej domeny aplikacji klasycznych aplikacji, ponieważ w tej domenie aplikacji przyznaje status całkowitego zaufania do wszystkich zestawów.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> w tej domenie aplikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica typu <see langword="byte" /> czyli COFF obrazu zawierający emitowany zestawu.</param>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> z typowych pliku obiektu formatu (COFF) na podstawie zawierający wyemitowanego obrazu <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], poziom zaufania zestawu, który jest ładowany za pomocą tej metody jest taki sam jak poziom zaufania domeny aplikacji.  
  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest przewidziane jako udogodnienie wywołań współdziałania, którzy nie można wywołać statycznych <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody. Ładowanie zestawów do innych domen aplikacji, użyj metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje, które są wspólne dla wszystkich przeciążenie tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie podczas ładowania zestawu raw.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Obiekt zestawu do załadowania.</param>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> podane jego <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest przewidziane jako udogodnienie wywołań współdziałania, którzy nie można wywołać statycznych <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody. Ładowanie zestawów do innych domen aplikacji, użyj metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Jeśli wersja żądany zestaw został już załadowany, ta metoda zwraca załadowanego zestawu, nawet jeśli wymagana jest inna wersja.  
  
 Podanie nazwy zestawu z częściowa dla `assemblyRef` nie jest zalecane. (Część nazwy pomija co najmniej jeden kultury, wersji lub token klucza publicznego. Dla przeciążeń, które przyjmują ciąg zamiast <xref:System.Reflection.AssemblyName> obiektu, "MyAssembly, wersja = 1.0.0.0" przykładem część nazwy i "MyAssembly, wersja 1.0.0.0, Culture = neutral, PublicKeyToken = = 18ab3442da84b47" jest pełna nazwa.) Korzystanie z częściowa nazw ma negatywny wpływ na wydajność. Ponadto nazwy zestawu z częściowa można załadować zestawu z globalnej pamięci podręcznej zestawów tylko wtedy, gdy dokładną kopię zestawu w katalogu podstawowego aplikacji (<xref:System.AppDomain.BaseDirectory%2A> lub <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).  
  
 Jeśli bieżący <xref:System.AppDomain> obiekt reprezentuje domeny aplikacji `A`i <xref:System.AppDomain.Load%2A> metoda jest wywoływana z domeny aplikacji `B`, zestaw jest ładowany do obu domen aplikacji. Na przykład poniższy kod obciążeń `MyAssembly` do nowej domeny aplikacji `ChildDomain` , a także do domeny aplikacji, gdy kod jest wykonywany:  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 Zestaw został załadowany do obie domeny, ponieważ <xref:System.Reflection.Assembly> nie pochodzi od <xref:System.MarshalByRefObject>i dlatego wartość zwracana <xref:System.AppDomain.Load%2A> metody nie mogą być przekazywane. Zamiast tego środowisko uruchomieniowe języka wspólnego próbuje załadować zestawu do wywoływania domeny aplikacji. Zestawy, które są ładowane do domeny dwóch aplikacji mogą się różnić, jeśli ustawienia ścieżki dla domeny dwóch aplikacji są różne.  
  
> [!NOTE]
>  Jeśli oba <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> właściwości i <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> właściwości są ustawione, pierwsza próba załadowania zestawu, użyta zostanie nazwa wyświetlana (łącznie z wersji, kultury i tak dalej zwrócony przez <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> właściwości). Jeśli plik nie zostanie znaleziony, <xref:System.Reflection.AssemblyName.CodeBase%2A> właściwość jest używana do wyszukiwania zestawu. Jeśli zestaw znajduje się za pomocą <xref:System.Reflection.AssemblyName.CodeBase%2A>, nazwa wyświetlana jest dopasowywana do zestawu. W przypadku niepowodzenia dopasowania <xref:System.IO.FileLoadException> jest generowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyRef" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> podanej nazwy wyświetlanej.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest przewidziane jako udogodnienie wywołań współdziałania, którzy nie można wywołać statycznych <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody. Ładowanie zestawów do innych domen aplikacji, użyj metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje, które są wspólne dla wszystkich przeciążenie tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> jest <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyString" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Dostęp do lokalizacji zestawu, jeżeli zestaw nie jest lokalny.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica typu <see langword="byte" /> czyli COFF obrazu zawierający emitowany zestawu.</param>
        <param name="rawSymbolStore">Tablica typu <see langword="byte" /> zawierające nieprzetworzone bajtów reprezentujący symboli dla zestawu.</param>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> z typowych pliku obiektu formatu (COFF) na podstawie zawierający wyemitowanego obrazu <see cref="T:System.Reflection.Assembly" />. Nieprzetworzona bajtów reprezentujący symboli dla <see cref="T:System.Reflection.Assembly" /> również zostały załadowane.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], poziom zaufania zestawu, który jest ładowany za pomocą tej metody jest taki sam jak poziom zaufania domeny aplikacji.  
  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest przewidziane jako udogodnienie wywołań współdziałania, którzy nie można wywołać statycznych <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody. Ładowanie zestawów do innych domen aplikacji, użyj metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje, które są wspólne dla wszystkich przeciążenie tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie podczas ładowania zestawu raw.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Obiekt zestawu do załadowania.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> podane jego <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest przewidziane jako udogodnienie wywołań współdziałania, którzy nie można wywołać statycznych <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody. Ładowanie zestawów do innych domen aplikacji, użyj metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje, które są wspólne dla wszystkich przeciążenie tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> jest <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyRef" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Odczytywanie ścieżki, która nie jest w formie "file://" lub "\\\UNC\dir\\" lub "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Wyświetlana nazwa zestawu. Zobacz <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> podanej nazwy wyświetlanej.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest przewidziane jako udogodnienie wywołań współdziałania, którzy nie można wywołać statycznych <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody. Ładowanie zestawów do innych domen aplikacji, użyj metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje, które są wspólne dla wszystkich przeciążenie tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> jest <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyString" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Odczytywanie ścieżki, która nie jest w formie "file://" lub "\\\UNC\dir\\" lub "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica typu <see langword="byte" /> czyli COFF obrazu zawierający emitowany zestawu.</param>
        <param name="rawSymbolStore">Tablica typu <see langword="byte" /> zawierające nieprzetworzone bajtów reprezentujący symboli dla zestawu.</param>
        <param name="securityEvidence">Dowód ładowania zestawu.</param>
        <summary>Ładunki <see cref="T:System.Reflection.Assembly" /> z typowych pliku obiektu formatu (COFF) na podstawie zawierający wyemitowanego obrazu <see cref="T:System.Reflection.Assembly" />. Nieprzetworzona bajtów reprezentujący symboli dla <see cref="T:System.Reflection.Assembly" /> również zostały załadowane.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], poziom zaufania zestawu, który jest ładowany za pomocą tej metody jest taki sam jak poziom zaufania domeny aplikacji.  
  
 Ta metoda powinna służyć tylko do załadowania zestawu w bieżącej domenie aplikacji. Ta metoda jest przewidziane jako udogodnienie wywołań współdziałania, którzy nie można wywołać statycznych <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody. Ładowanie zestawów do innych domen aplikacji, użyj metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Aby uzyskać informacje, które są wspólne dla wszystkich przeciążenie tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie podczas ładowania zestawu raw.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> nie jest <see langword="null" />. Gdy starszą zasadę nie jest włączone, <paramref name="securityEvidence" /> powinien być <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Odczytywanie ścieżki, która nie jest w formie "file://" lub "\\\UNC\dir\\" lub "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy procesora CPU i pamięci monitorowania domeny aplikacji jest włączone dla bieżącego procesu. Gdy monitorowanie jest włączone dla procesu, nie można wyłączyć.</summary>
        <value>
          <see langword="true" /> Jeśli jest włączone monitorowanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To `static` właściwości (`Shared` właściwość w języku Visual Basic) steruje procesora CPU i pamięci monitorowania wszystkich domen aplikacji w procesie.  
  
 Jeśli spróbujesz ustawić tę właściwość na `false`, <xref:System.ArgumentException> wyjątek jest zgłaszany, nawet jeśli bieżąca wartość właściwości jest `false`.  
  
 Gdy jest włączone monitorowanie, możesz użyć <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, i <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> wystąpienia właściwości do monitorowania użycia procesora CPU i pamięci domen aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący proces Próbowano przypisać wartość <see langword="false" /> do tej właściwości.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę bajtów, który udało się przetrwać ostatniego zebrania i które są znane odwoływać się do bieżącej domeny aplikacji.</summary>
        <value>Liczba bajtów zachowane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statystyki są aktualizowane przy każdym wyrzucanie elementów bezużytecznych. Jednak gwarancji one być dokładne tylko po pełnej, blokowanie kolekcji; występuje, oznacza to, kolekcję zawierającą wszystkie generacje i zatrzymuje się podczas pobierania aplikacji. Na przykład <xref:System.GC.Collect?displayProperty=nameWithType> przeciążenie metody wykonuje pełne, blokowanie kolekcji. (Kolekcji współbieżnych przebiega w tle i nie są blokowane w aplikacji).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> właściwość jest ustawiona na <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą liczbę bajtów, które udało przetrwać od ostatniego zebrania dla wszystkich domen aplikacji w procesie.</summary>
        <value>Całkowita liczba bajtów sprawny dla procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po pobraniu pełne, blokowania to liczba reprezentuje liczbę bajtów aktualnie przechowywany na żywo w zarządzanych stosów. Powinien być bliski liczba zgłoszonych przez <xref:System.GC.GetTotalMemory%2A> metody. Po pobraniu tymczasowych ta liczba reprezentuje liczbę bajtów posiadanych na żywo w generacje tymczasowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> właściwość jest ustawiona na <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowity rozmiar w bajtach, wszystkie alokacji pamięci, które zostały wprowadzone przez domenę aplikacji od czasu utworzenia, bez odjęcie ilości pamięci, które zostały zebrane.</summary>
        <value>Całkowity rozmiar wszystkich alokacji pamięci.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> właściwość jest ustawiona na <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitego czasu procesora użytą przez wszystkie wątki podczas wykonywania w bieżącej domenie aplikacji, od momentu uruchomienia procesu.</summary>
        <value>Łączny czas procesora dla bieżącej domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Całkowity czas, który jest zgłaszany, dla domeny aplikacji obejmuje czas każdy wątek w procesie wykonywania w tej domenie aplikacji.  
  
 Wątek, który odwołuje się do kodu niezarządzanego jest nadal skojarzone z domeny aplikacji, a czas procesora poświęcony na wykonywanie kodu niezarządzanego jest raportowane dla domeny aplikacji, w którym wykonano wywołanie.  
  
 Gdy wątek jest zablokowany lub uśpiony, go nie zużywa czas procesora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> właściwość jest ustawiona na <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestaw uprawnień w domenie aplikacji piaskownicy.</summary>
        <value>Zestaw uprawnień w domenie aplikacji piaskownicy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domeny aplikacji w trybie piaskownicy, które zostały utworzone przy użyciu <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> przeciążenie metody ma jednorodnego zestawu uprawnień; oznacza to, uzyskuje ten sam zestaw uprawnień do wszystkich zestawów częściowo zaufany, które są ładowane do domeny aplikacji. Domeny aplikacji w trybie piaskownicy opcjonalnie zawiera listę zestawów o silnych nazwach, które są wykluczone z tego uprawnienia ustawiona, a zamiast tego Uruchom przy pełnym zaufaniu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy kończy proces nadrzędny domyślnej domeny aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler> Dla to zdarzenie można wykonać zakończenia działania, takie jak zamykanie plików, zwalniając magazynu i tak dalej przed zakończeniem procesu.  
  
 Począwszy od programu .NET Framework w wersji 2.0, to zdarzenie jest zgłaszane w każdej domenie aplikacji, która rejestruje program obsługi zdarzeń.  
  
> [!NOTE]
>  Łączny czas wykonywania wszystkich <xref:System.AppDomain.ProcessExit> procedury obsługi zdarzeń jest ograniczona, tak samo, jak całkowity czas wykonywania wszystkich finalizatory jest ograniczona w Zamykanie procesu. Wartość domyślna to dwie sekundy. Niezarządzane hosta można zmienić czasu wykonania przez wywołanie metody [ICLRPolicyManager::SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) metody z [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) wartości wyliczenia.  
  
 W wersji systemu .NET Framework 1.0 i 1.1 to zdarzenie jest wywoływane tylko w domyślnej domeny aplikacji i tylko wtedy, gdy program obsługi zdarzeń jest zarejestrowany w domyślnej domeny aplikacji.  
  
 Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musi mieć wymagane uprawnienia lub <xref:System.Security.SecurityException> jest generowany.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy rozpoznawania zestawu nie powiodło się w kontekstu reflection-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kontekście tylko odbicie zależności nie są rozpoznawane automatycznie. Muszą być wstępnie ładowane lub zwrócone przez procedurę obsługi dla tego zdarzenia. To zdarzenie jest wywoływane, gdy ma zależność, która nie jest już załadowana do kontekstu reflection-only. Brakująca zależność jest określona przez <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> właściwości. <xref:System.ResolveEventHandler> Dla tego zdarzenia musi zwracać zestawu, który spełnia zależności. Zestaw, który jest zwracany muszą być załadowane do kontekstu reflection-only.  
  
> [!IMPORTANT]
>  To zdarzenie jest wywoływane tylko w przypadku brakujące zależności zestawu, który jest ładowany do kontekstu reflection-only (na przykład za pomocą <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> metody). Nie jest wywoływane, jeśli nie można znaleźć zestawu, które są ładowane.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> właściwość zwraca żądane ładowanie zestawu, którego nie można rozpoznać zestawu. Znajomość tożsamości żądającego zestawu może być przydatne do określenia poprawnej wersji zależności, jeśli jest dostępna więcej niż jedna wersja. Aby uzyskać więcej informacji, zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Dla tego zdarzenia <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> właściwość zwraca nazwę zestawu, przed zastosowaniem zasad.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca zestawy, które zostały załadowane do kontekstu reflection-only domeny aplikacji.</summary>
        <returns>Tablica <see cref="T:System.Reflection.Assembly" /> obiektów, które reprezentują zestawy ładowane do kontekstu reflection-only domeny aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zestawy, które zostały załadowane do kontekstu reflection-only. Aby uzyskać zestawy, które zostały załadowane do wykonania, należy użyć <xref:System.AppDomain.GetAssemblies%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu ładuje zestaw System.dll do kontekstu wykonywania, a następnie do kontekstu reflection-only. <xref:System.AppDomain.GetAssemblies%2A> i <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> metody są używane do wyświetlania zestawów załadowanych do każdego kontekstu.  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">W domenie aplikacji zwolniony nastąpi próba wykonania operacji.</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę katalogu podstawowego gdzie powinien sondowania mechanizm rozpoznawania zestawów dla zestawy prywatne.</summary>
        <value>Ścieżka katalogu podstawowego gdzie mechanizm rozpoznawania zestawów powinny sondować zestawy prywatne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestawy prywatne są wdrażane w tej samej struktury katalogów, co aplikacja. Jeśli ścieżka określona przez <xref:System.AppDomain.RelativeSearchPath%2A> właściwość nie jest w obszarze <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, zostanie zignorowany.  
  
 Ta właściwość zwraca wartość ustawiona przy użyciu <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy rozwiązanie zasobu nie powiedzie się, ponieważ zasób nie jest prawidłowy zasób połączony lub osadzony w zestawie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ResolveEventHandler> Dla tego zdarzenia może próbować zlokalizować zestawu zawierającego zasobu i zwraca go.  
  
> [!IMPORTANT]
>  To zdarzenie nie jest wywoływane, jeśli rozpoznawania nie powiedzie się, ponieważ nie można odnaleźć pliku dla prawidłowego połączonego zasobu. Jest on uruchamiany, jeśli nie można znaleźć strumienia zasobu manifestu, ale nie jest wywoływane, jeśli nie można odnaleźć klucza pojedynczego zasobu.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> właściwość zawiera zestaw żądanego zasobu. Aby uzyskać więcej informacji, zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musi mieć wymagane uprawnienia lub <xref:System.Security.SecurityException> jest generowany.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">Poziomu zasad zabezpieczeń.</param>
        <summary>Ustanawia poziomu zasad zabezpieczeń dla tej domeny aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przed zestaw jest ładowany do <xref:System.AppDomain> w kolejności obowiązują zasady zabezpieczeń.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.AppDomain.SetAppDomainPolicy%2A> metodę, aby ustawić poziom zasad zabezpieczeń domeny aplikacji.  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domainPolicy" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Poziom zabezpieczeń zasad została już ustawiona.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do lokalizacji kopiowania w tle.</param>
        <summary>Określa ścieżkę katalogu określonego jako lokalizacji, w którym zestawy są kopie w tle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ścieżkę pamięci podręcznej jest ignorowana, jeśli <xref:System.AppDomainSetup.ApplicationName%2A> nie ustawiono właściwości. Zobacz <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> właściwości.  
  
 Aby uzyskać więcej informacji na temat Kopiowanie w tle Zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przypisuje wartość do właściwości domeny aplikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości domeny użytkownika aplikacji do tworzenia lub zmiany.</param>
        <param name="data">Wartość właściwości.</param>
        <summary>Przypisuje określona wartość właściwości określonej aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby wstawić wpis lub zmodyfikuj wartość wpisu w wewnętrznej pamięci podręcznej par nazwa danych, które opisują właściwości tego wystąpienia <xref:System.AppDomain>.  
  
 Pamięć podręczna zawiera automatycznie wpisy wstępnie zdefiniowanych systemu, które są wstawiane podczas tworzenia domeny aplikacji. Nie można wstawić lub zmodyfikować wpisy systemu za pomocą tej metody. Wywołanie metody, która próbuje zmodyfikować wpis systemu nie obowiązuje; Metoda nie zgłasza wyjątek. Możesz sprawdzić wartości system wpisów z <xref:System.AppDomain.GetData%2A> metody lub jego odpowiednik <xref:System.AppDomainSetup> właściwości opisane w <xref:System.AppDomain.GetData%2A>.  
  
 Można wywołać tej metody można ustawić wartości domyślny limit czasu dla obliczenia wyrażenia regularnego wzorce przez dostaw "REGEX_DEFAULT_MATCH_TIMEOUT" jako wartości `name` argumentu i <xref:System.TimeSpan> wartość, która reprezentuje limit czasu Interwał jako wartość `data` argumentu. Możesz również wstawić lub zmodyfikować własne par nazwa danych zdefiniowanych przez użytkownika za pomocą tej metody i sprawdzać ich wartości z <xref:System.AppDomain.GetData%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> metodę w celu utworzenia nowej pary wartości. W przykładzie następnie użyto <xref:System.AppDomain.GetData%2A> metody do pobierania wartości i wyświetla je w konsoli.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości domeny użytkownika aplikacji do tworzenia lub zmiany.</param>
        <param name="data">Wartość właściwości.</param>
        <param name="permission">Uprawnienie do żądanie obiektu wywołującego, gdy właściwość zostanie pobrana.</param>
        <summary>Przypisuje określona dla właściwości domeny określonej aplikacji z określonego uprawnienia, aby żądanie obiektu wywołującego, gdy właściwość zostanie pobrana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody można wstawić ani modyfikować własnych wpisów zdefiniowane przez użytkownika w wewnętrznej pamięci podręcznej par nazwa/danych, które opisują właściwości domeny aplikacji. Po wstawieniu wpis, można określić żądanie uprawnień, aby wymusić po pobraniu wpis. Ponadto można wywołać tej metody można ustawić wartości domyślny limit czasu dla obliczenia wyrażenia regularnego wzorce przez dostaw "REGEX_DEFAULT_MATCH_TIMEOUT" jako wartości `name` argumentu i <xref:System.TimeSpan> wartość, która reprezentuje interwał limitu czasu jako wartość `data` argumentu.  
  
 Nie można użyć tej metody można przypisać żądania zabezpieczeń do ciągu właściwości zdefiniowane przez system.  
  
 Pamięć podręczna zawiera automatycznie wpisy wstępnie zdefiniowanych systemu, które są wstawiane podczas tworzenia domeny aplikacji. Nie można wstawić lub zmodyfikować wpisy systemu za pomocą tej metody. Wywołanie metody, która próbuje zmodyfikować wpis systemu nie obowiązuje; Metoda nie zgłasza wyjątek. Możesz sprawdzić wartości system wpisów z <xref:System.AppDomain.GetData%2A> metody lub jego odpowiednik <xref:System.AppDomainSetup> właściwości opisane w sekcji uwag dla <xref:System.AppDomain.GetData%2A> — metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> Określa ciąg właściwości zdefiniowane przez system i <paramref name="permission" /> nie jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Pełni kwalifikowana ścieżka jest katalogiem podstawowej podkatalogi przechowywania zestawów dynamicznych.</param>
        <summary>Określa ścieżkę katalogu określonego jako podstawowego katalogu do podkatalogów, gdzie przechowywane dynamicznie generowanym plików i dostępne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia <xref:System.AppDomainSetup.DynamicBase%2A> właściwości wewnętrznego <xref:System.AppDomainSetup> skojarzony z tym wystąpieniem.  
  
   
  
## Examples  
 Ta metoda jest obecnie przestarzała i nie należy jej używać w nowych wdrożeniach. Poniższy przykład przedstawia użycie Aktualna alternatywa <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> właściwości. Aby uzyskać informacje w tym przykładzie, zobacz <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> właściwości lub <xref:System.AppDomain.DynamicDirectory%2A> właściwości.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Jeden z <see cref="T:System.Security.Principal.PrincipalPolicy" /> wartości, które określają typ obiektu głównej można dołączyć do wątków.</param>
        <summary>Określa, jak obiekty Principal role i tożsamość musi być podłączona do wątku wątek próba powiązania do podmiotu zabezpieczeń podczas wykonywania w tej domenie aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie wartości tylko zostaną zastosowane, jeśli zostanie ustawiona przed użyciem <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> właściwości. Na przykład jeśli ustawisz <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> do danego podmiotu zabezpieczeń (na przykład ogólny podmiot zabezpieczeń), a następnie użycie <xref:System.AppDomain.SetPrincipalPolicy%2A> metodę, aby ustawić <xref:System.Security.Principal.PrincipalPolicy> do <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, bieżący podmiot zabezpieczeń pozostanie ogólnego podmiot zabezpieczeń.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wpływ na wątki przy użyciu <xref:System.AppDomain.SetPrincipalPolicy%2A> metodą zmiany zasad dotyczących nazwy głównej domeny aplikacji. Przedstawiono również efekt użycia <xref:System.AppDomain.SetThreadPrincipal%2A> metodę, aby zmienić podmiot zabezpieczeń, który jest dostępne do dołączenia do wątków w domenie aplikacji.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby móc manipulować głównym przedmiotem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Włącza kopiowanie w tle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Ta metoda jest obecnie przestarzała i nie należy jej używać w nowych wdrożeniach.  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Lista nazw katalogów, których nazwy oddzielone średnikami.</param>
        <summary>Określa ścieżkę katalogu określonego jako lokalizacji zestawów się kopie w tle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie kopia w tle obejmuje wszystkie zestawy znaleziono przez sondowanie. <xref:System.AppDomain.SetShadowCopyPath%2A> Metoda ogranicza kopii w tle do zestawów w określonym przez `path`.  
  
 <xref:System.AppDomain.SetShadowCopyPath%2A> — Metoda nie określa dodatkowe katalogi wyszukiwania zestawów. Zestawy należy skopiować w tle musi już znajdować się w ścieżce wyszukiwania, na przykład w obszarze <xref:System.AppDomain.BaseDirectory%2A>. <xref:System.AppDomain.SetShadowCopyPath%2A> — Metoda określa, które ścieżki wyszukiwania można tle-skopiować.  
  
 Ta metoda ustawia <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> właściwości wewnętrznego <xref:System.AppDomainSetup> skojarzony z tym wystąpieniem.  
  
 Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Ta metoda jest obecnie przestarzała i nie należy jej używać w nowych wdrożeniach.  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">Obiekt główny, aby dołączyć do wątków.</param>
        <summary>Ustawia domyślnego obiektu głównego jest dołączony do wątków, jeśli ich próba powiązania do podmiotu zabezpieczeń podczas wykonywania w tej domenie aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono efekt użycia <xref:System.AppDomain.SetThreadPrincipal%2A> metodę, aby zmienić podmiot zabezpieczeń, który jest dostępne do dołączenia do wątków, które są wykonywane w domenie aplikacji. Przedstawiono również wpływa na wątki przy użyciu <xref:System.AppDomain.SetPrincipalPolicy%2A> metodą zmiany zasad dotyczących nazwy głównej domeny aplikacji.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Główny wątek został już ustawiony.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby móc manipulować głównym przedmiotem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o konfiguracji domeny aplikacji dla tego wystąpienia.</summary>
        <value>Informacje o inicjowania domeny aplikacji.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wskazuje, czy domena aplikacji jest skonfigurowana do plików kopii w tle.</summary>
        <value>
          <see langword="true" /> Jeśli domena aplikacji jest skonfigurowana do pliki kopii w tle; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> i [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Próba wykonania operacji w niezaładowanej domenie aplikacji.</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje reprezentacji w postaci ciągu zawiera przyjazną nazwę domeny aplikacji i wszelkich zasad kontekstu.</summary>
        <returns>Ciąg utworzony łączenie literału "Nazwa:", przyjazną nazwę domeny aplikacji i reprezentacji ciągu zasad kontekstu albo ciąg "nie ma żadnych kontekstu zasad."</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość zwracaną <xref:System.AppDomain.ToString%2A> metody.  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Domeny aplikacji reprezentowany przez bieżący <see cref="T:System.AppDomain" /> został usunięty z pamięci.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy rozwiązanie typu kończy się niepowodzeniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.TypeResolve> Zdarzenie wystąpi, gdy środowisko uruchomieniowe języka wspólnego nie mógł określić zestaw, który można utworzyć żądanego typu. Może to wystąpić, jeśli typ jest zdefiniowany w zestawie dynamicznym, lub typ nie jest zdefiniowany w zestawie dynamicznym, ale środowisko uruchomieniowe nie ma zestawu, którego typ jest zdefiniowany w. Ostatnie sytuacja może wystąpić, gdy <xref:System.Type.GetType%2A?displayProperty=nameWithType> jest wywoływana z nazwę typu, który nie jest kwalifikowana nazwą zestawu.  
  
 <xref:System.ResolveEventHandler> Dla tego zdarzenia może próbować zlokalizować i utworzenia typu.  
  
 Jednak <xref:System.AppDomain.TypeResolve> zdarzenie nie występuje w przypadku środowiska uruchomieniowego wie, nie można znaleźć typu w niektórych zestawach. To zdarzenie nie występuje na przykład, jeśli typ nie zostanie znaleziony w zestawie statycznych, ponieważ środowisko uruchomieniowe wie, że typów nie można dynamicznie dodawać do zestawy statyczne.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> właściwość zawiera zestaw żądanego typu. Aby uzyskać więcej informacji, zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musi mieć wymagane uprawnienia lub <xref:System.Security.SecurityException> jest generowany.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.AppDomain.TypeResolve> zdarzeń.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy nie zostanie przechwycony wyjątek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie zawiera powiadomień nieprzechwyconych wyjątków. Umożliwia aplikacji do rejestrowania informacji o wyjątku, przed domyślny program obsługi systemu zgłasza wyjątek dla użytkownika i zakończenie aplikacji. Jeśli dostępne są wystarczające dane o stanie aplikacji, innych działań — takie jak zapisywanie danych program nowsze odzyskiwania. Zalecane jest ostrożność, ponieważ mogą ulec uszkodzeniu danych programu, gdy wyjątki nie są obsługiwane.  
  
> [!NOTE]
>  W wersji systemu .NET Framework 1.0 i 1.1 zakończenie aplikacji oraz opcji debugowania są zgłaszane dla użytkownika przed to zdarzenie jest zgłaszane, a nie po.  
  
 To zdarzenie można obsługiwać w dowolnej domenie aplikacji. Zdarzenie nie jest jednak niekoniecznie wywoływane w domenie aplikacji, w którym wystąpił wyjątek. Wyjątek jest obsługiwany tylko wtedy, gdy cały stos wątku został oddzielić bez znajdowanie program obsługi wyjątku dotyczy, więc pierwszego miejsca, które mogą być zdarzenia znajduje się w domenie aplikacji, którego pochodzi wątku.  
  
> [!NOTE]
>  W wersji systemu .NET Framework 1.0 i 1.1 to zdarzenie występuje tylko w przypadku domyślnej domeny aplikacji jest tworzony przez system po uruchomieniu aplikacji. Jeśli aplikacja tworzy domeny dodatkowych aplikacji, określając delegowanego dla tego zdarzenia w tych domenach aplikacji nie ma znaczenia.  
  
 Jeśli <xref:System.AppDomain.UnhandledException> zdarzenie jest obsługiwane w domyślnej domeny aplikacji, zostanie zaokrąglona istnieje dla żadnego nieobsłużony wyjątek w którymkolwiek wątku, niezależnie od tego, jakie domeny aplikacji uruchomiona wątku. Jeśli wątek jest uruchomiony w domenie aplikacji, która ma program obsługi zdarzeń dla <xref:System.AppDomain.UnhandledException>, zdarzenie jest zgłaszane w tej domenie aplikacji. Jeśli ta domena aplikacji nie jest domyślnej domeny aplikacji, a także jest program obsługi zdarzeń w domyślnej domeny aplikacji, zdarzenie jest wywoływane w obu domenach aplikacji.  
  
 Na przykład załóżmy, że wątek jest uruchamiany w domeny aplikacji "AD1" wywołuje metodę w domenie aplikacji "AD2" i stamtąd wywołuje metodę w domenie aplikacji "AD3", gdzie zgłasza wyjątek. Pierwsza domena aplikacji, w którym <xref:System.AppDomain.UnhandledException> zdarzenie może być wywoływane jest "AD1". Jeśli ta domena aplikacji nie jest domyślnej domeny aplikacji, można również być zdarzenia w domyślnej domeny aplikacji.  
  
> [!NOTE]
>  Środowisko uruchomieniowe języka wspólnego wstrzymuje przerwań wątku podczas obsługi zdarzeń <xref:System.AppDomain.UnhandledException> zdarzenia są wykonywane.  
  
 Jeśli program obsługi zdarzeń ma <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atrybutu flag odpowiednie, program obsługi zdarzeń jest traktowany jako region ograniczonego wykonania.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], to zdarzenie nie jest zgłaszane wyjątki, które doprowadzić do uszkodzenia procesu, takie jak przepełnienie stosu lub uzyskać dostępu do naruszenia, chyba że obsługi zdarzeń jest krytyczny dla zabezpieczeń i ma <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> atrybutu.  
  
 W wersji systemu .NET Framework 1.0 i 1.1 nieobsługiwany wyjątek w wątku innego niż wątku głównego aplikacji zostanie przechwycony przez środowisko uruchomieniowe i w związku z tym nie powoduje zamknięcie aplikacji. W związku z tym istnieje możliwość <xref:System.AppDomain.UnhandledException> się bez przerywania aplikacji zdarzenia. W programie .NET Framework w wersji 2.0, to backstop dla nieobsługiwanych wyjątków w wątkach podrzędny został usunięty, ponieważ skrócenie takie błędy dyskretnej uwzględnione spadek wydajności, uszkodzone dane i zawieszaniu, które były trudne do debugowania. Aby uzyskać więcej informacji, łącznie z listą przypadków, w których środowisko uruchomieniowe nie kończy się, zobacz [wyjątki w zarządzanych wątkach](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
 Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musi mieć wymagane uprawnienia lub <xref:System.Security.SecurityException> jest generowany.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
## <a name="other-events-for-unhandled-exceptions"></a>Inne zdarzenia dla nieobsłużonych wyjątków  
 Dla pewnych aplikacji modele <xref:System.AppDomain.UnhandledException> zdarzeń może być wywłaszczony przez inne zdarzenia, jeśli wystąpi nieobsługiwany wyjątek w wątku głównego aplikacji.  
  
 W aplikacjach korzystających z technologii Windows Forms nieobsługiwanych wyjątków w aplikacji głównej przyczyny wątku <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> się zdarzenia. Jeśli to zdarzenie jest obsługiwane, domyślne zachowanie jest nieobsługiwany wyjątek nie zakończy aplikacji, mimo że aplikacja pozostaje w nieznanym stanie. W takim przypadku <xref:System.AppDomain.UnhandledException> nie zdarzenia. To zachowanie można zmienić przy użyciu pliku konfiguracji aplikacji lub za pomocą <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> metodę, aby zmienić trybu <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> przed <xref:System.Windows.Forms.Application.ThreadException> program obsługi zdarzeń jest podłączony. Dotyczy to tylko wątku głównego aplikacji. <xref:System.AppDomain.UnhandledException> Zdarzenie jest zgłaszane w przypadku nieobsługiwanych wyjątków zgłoszonych w innych wątków.  
  
 Struktura aplikacji Visual Basic w programie Microsoft Visual Studio 2005, zapewnia inne zdarzenie nieobsługiwanych wyjątków w wątku głównego aplikacji. Zobacz <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> zdarzeń. To zdarzenie ma obiekt argumentów zdarzenia z taką samą nazwę jak obiekt argumenty zdarzenia używane przez <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, ale o innej właściwości. W szczególności ten obiekt argumenty zdarzeń ma <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> właściwość, która umożliwia to aplikacji kontynuować uruchamianie, ignorowanie nieobsługiwany wyjątek (i pozostawienie aplikacji w nieznanym stanie). W takim przypadku <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> nie zdarzenia.  
  
   
  
## Examples  
 Pokazuje followingexample <xref:System.AppDomain.UnhandledException> zdarzeń. Definiuje program obsługi zdarzeń `MyHandler`, które jest wywoływane zawsze, gdy wystąpił nieobsługiwany wyjątek jest zgłaszany w domyślnej domeny aplikacji. Zgłasza dwa wyjątki. Pierwszy jest obsługiwany przez **bloku try/catch** bloku. Drugim jest nieobsługiwany i wywołuje `MyHandle` procedury przed kończy aplikacji.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">Aby zwolnić domeny aplikacji.</param>
        <summary>Zwalnia domeny określonej aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework w wersji 2.0 jest wątku dedykowane do zwalniania domen aplikacji. Zwiększa niezawodność, szczególnie w przypadku programu .NET Framework jest obsługiwana. Gdy wywołuje wątku <xref:System.AppDomain.Unload%2A>, do domeny docelowej jest oznaczony do zwalnianie. Dedykowanym wątku próbuje zwolnić domeny, a wszystkie wątki w domenie są przerywane. Jeśli wątek nie przerwać, na przykład ponieważ jej wykonywania kodu niezarządzanego lub jej wykonywania `finally` bloku, po upływie pewnego czasu <xref:System.CannotUnloadAppDomainException> jest zgłaszany w wątku, który pierwotnie używana <xref:System.AppDomain.Unload%2A>. Kończy się wątku, który nie można przerwać po pewnym czasie, do domeny docelowej nie jest usunięty z pamięci. W związku z tym w programie .NET Framework w wersji 2.0 `domain` nie jest gwarantowana można zwolnić, ponieważ może nie być możliwe zakończyć wykonywanie wątków.  
  
> [!NOTE]
>  W niektórych przypadkach wywoływania <xref:System.AppDomain.Unload%2A> powoduje natychmiastowe <xref:System.CannotUnloadAppDomainException>, na przykład jeśli jest to finalizator.  
  
 Wątki `domain` kończą się przy użyciu <xref:System.Threading.Thread.Abort%2A> metodę, która zgłasza <xref:System.Threading.ThreadAbortException> w wątku. Mimo że wątek należy zakończyć natychmiast, może kontynuować wykonywania dla nieprzewidywalne ilość czasu w `finally` klauzuli.  
  
## <a name="version-compatibility"></a>Zgodność wersji  
 W programie .NET Framework w wersji 1.0, 1.1, jeśli wątek, który wywołuje <xref:System.AppDomain.Unload%2A> działa w `domain`, inny wątek jest uruchomiony do wykonania tej operacji unload. Jeśli `domain` nie może być zwolnione, <xref:System.CannotUnloadAppDomainException> jest zgłaszany w tym wątku nie znajduje się w oryginalnym wątku, który wywołuje <xref:System.AppDomain.Unload%2A>. Jednak jeśli wątku wywołującym <xref:System.AppDomain.Unload%2A> działa poza `domain`, że wątek otrzyma wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak można wyładować domeny aplikacji.  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">
          <paramref name="domain" /> nie może zostać usunięty.</exception>
        <exception cref="T:System.Exception">Wystąpił błąd podczas zwalniania.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby dodać obsługę zdarzeń dla tego zdarzenia. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
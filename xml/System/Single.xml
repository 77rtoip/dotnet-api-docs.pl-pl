<Type Name="Single" FullName="System.Single">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c504b83f8e3b4b878fe3c1622de0177456654580" /><Meta Name="ms.sourcegitcommit" Value="24f564114ee2fa9c63dbac1b25b82826cc4e320f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/25/2019" /><Meta Name="ms.locfileid" Value="68488531" /></Metadata><TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IConvertible, IEquatable(Of Single), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje liczbę zmiennoprzecinkową o pojedynczej precyzji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości reprezentuje numer 32-bitowy o pojedynczej precyzji z wartościami w zakresie od ujemną 3.402823 E38 do pozytywne 3.402823 E38, a także dodatnią lub ujemną zero, <xref:System.Single.PositiveInfinity>, <xref:System.Single.NegativeInfinity>i nie liczbę (<xref:System.Single.NaN>). <xref:System.Single> Jest to przeznaczone do reprezentowania wartości, które są niezwykle duże (takie jak odległości między planety lub galaxies) lub skrajnie bardzo małe (takie jak masa cząsteczkowa substancji w kilogramach) i często są nieprecyzyjne (takie jak odległość od ziemi do innego systemu słonecznego ). <xref:System.Single> Typ jest zgodny ze standardem IEC 60559:1989 (IEEE 754) dla binarnej arytmetycznej liczby zmiennoprzecinkowej.  
  
 Ten temat zawiera następujące sekcje:  
  
-   [Reprezentacja liczb zmiennoprzecinkowych i precyzja](#Precision)  
  
-   [Testowanie pod kątem równości](#Equality)  
  
-   [Wartości zmiennoprzecinkowe i wyjątki](#Exceptions)  
  
-   [Konwersja typu i pojedyncza struktura](#Conversion)  
  
-   [Funkcje zmiennoprzecinkowe](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType>dostarcza metody do porównywania wystąpień tego typu, aby przekonwertować wartość wystąpienia na jego reprezentację w postaci ciągu oraz przekonwertować ciąg reprezentujący liczbę na wystąpienie tego typu. Aby uzyskać informacje na temat sposobu, w jaki Kody specyfikacji formatu kontrolują reprezentację typów wartości, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md), [ciągi standardowego formatu liczb](~/docs/standard/base-types/standard-numeric-format-strings.md)i [Niestandardowe ciągi formatujące liczby](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Reprezentacja liczb zmiennoprzecinkowych i precyzja  
 Typ <xref:System.Single> danych przechowuje wartości zmiennoprzecinkowe o pojedynczej precyzji w formacie binarnym 32-bitowym, jak pokazano w poniższej tabeli:  
  
|Części|Bity|  
|----------|----------|  
|Mantysę lub mantysy|0-22|  
|Zapis|23-30|  
|Sign (0 = pozytywna, 1 = ujemna)|31|  
  
 Podobnie jak ułamki dziesiętne nie mogą precyzyjnie reprezentować niektórych wartości ułamkowych (takich <xref:System.Math.PI?displayProperty=nameWithType>jak 1/3 lub), ułamki binarne nie mogą reprezentować niektórych wartości ułamkowych. Na przykład 2/10, który jest reprezentowany dokładnie przez .2 jako ułamek dziesiętny, jest reprezentowany przez. 0011111001001100 jako ułamek binarny ze wzorcem "1100" powtarzanym do nieskończoności. W takim przypadku wartość zmiennoprzecinkowa zapewnia nieprecyzyjną reprezentację liczby reprezentowanej przez nią. Wykonywanie dodatkowych operacji matematycznych w pierwotnej wartości zmiennoprzecinkowej często zwiększa jego brak dokładności. Na przykład, jeśli porównano wyniki mnożenia .3 o 10 i dodanie .3 do. 3 9 razy, zobaczysz, że dodanie powoduje mniej dokładne wyniki, ponieważ obejmuje osiem większej liczby operacji niż mnożenie. Należy zauważyć, że te różnice są widoczne tylko wtedy, gdy <xref:System.Single> są wyświetlane dwie wartości przy użyciu [standardowego ciągu formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md)"R", który w razie potrzeby wyświetla wszystkie 9 cyfr <xref:System.Single> dokładności obsługiwane przez typ.  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 Ponieważ niektóre liczby nie mogą być reprezentowane dokładnie jako wartości binarne ułamkowe, liczby zmiennoprzecinkowe mogą jedynie przybliżyć rzeczywiste liczby.  
  
 Wszystkie liczby zmiennoprzecinkowe mają ograniczoną liczbę cyfr znaczących, które również określają, jak dokładnie wartość zmiennoprzecinkowa przybliża liczbę rzeczywistą. <xref:System.Single> Wartość może mieć maksymalnie 7 cyfr dziesiętnych, mimo że maksymalnie 9 cyfr jest przechowywanych wewnętrznie. Oznacza to, że niektóre operacje zmiennoprzecinkowe mogą nie mieć dokładności, aby zmienić wartość zmiennoprzecinkową. Poniższy przykład definiuje dużą wartość zmiennoprzecinkową o <xref:System.Single.Epsilon?displayProperty=nameWithType> pojedynczej precyzji, a następnie dodaje do niej produkt i jeden quadrillion. Jednak produkt jest zbyt mały, aby zmodyfikować oryginalną wartość zmiennoprzecinkową. Jego najmniej znacząca cyfra to stutysięcznych, a najbardziej znacząca cyfra w produkcie wynosi 10<sup>-30</sup>.  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 Ograniczona precyzja liczby zmiennoprzecinkowej ma kilka konsekwencji:  
  
-   Dwie liczby zmiennoprzecinkowe, które są wyświetlane jako równe określonej precyzji, mogą nie być porównane, ponieważ ich najmniej znaczące cyfry są różne. W poniższym przykładzie seria numerów jest dodawana razem, a ich łączna suma jest porównywana z ich oczekiwaną sumą. Chociaż dwie wartości są takie same, wywołanie `Equals` metody wskazuje, że nie są.  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     Jeśli <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> zmienisz elementy formatu w instrukcji z `{0}` i `{1}` na `{0:R}` i, `{1:R}` aby wyświetlić wszystkie znaczące cyfry dwóch <xref:System.Single> wartości, jest jasne, że dwie wartości nie są równe, ponieważ utratę dokładności podczas operacji dodawania. W takim przypadku problem można rozwiązać, wywołując <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> metodę, aby <xref:System.Single> zaokrąglić wartości do odpowiedniej dokładności przed przeprowadzeniem porównania.  
  
-   Operacja matematyczna lub porównawcza korzystająca z liczby zmiennoprzecinkowej może nie dać tego samego wyniku, jeśli użyto liczby dziesiętnej, ponieważ liczba zmiennoprzecinkowa binarna może nie być równa liczbie dziesiętnej. W poprzednim przykładzie zilustrowano to poprzez wyświetlenie wyniku mnożenia .3 przez 10 i dodanie .3 do. 3 9 razy.  
  
     Gdy dokładność w operacjach liczbowych z wartościami ułamkowymi jest ważna, <xref:System.Decimal> Użyj typu zamiast <xref:System.Single> typu. Gdy dokładność w operacjach liczbowych o wartościach całkowitych poza <xref:System.Int64> zakresem lub <xref:System.UInt64> <xref:System.Numerics.BigInteger> jest istotna, należy użyć typu.  
  
-   Wartość nie może być przezaokrąglana, jeśli jest używana liczba zmiennoprzecinkowa. Wartość jest określana na potrzeby rundy, jeśli operacja konwertuje oryginalną liczbę zmiennoprzecinkową na inny formularz, operacja odwrotna przekształca przekonwertowany formularz z powrotem na liczbę zmiennoprzecinkową, a końcowa liczba zmiennoprzecinkowa jest równa pierwotnemu liczba zmiennoprzecinkowa. Runda może się nie powieść, ponieważ co najmniej jedna znacząca cyfra zostanie utracona lub zmieniona w konwersji. W poniższym przykładzie trzy <xref:System.Single> wartości są konwertowane na ciągi i zapisywane w pliku. Gdy dane wyjściowe są wyświetlane, choć wartości są identyczne, przywrócone wartości nie są równe oryginalnym wartościom.  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     W takim przypadku wartości można pomyślnie zaokrąglić, używając [standardowego ciągu formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) "G9", aby zachować pełną precyzję <xref:System.Single> wartości, jak pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single>wartości mają mniejszą precyzję <xref:System.Double> niż wartości. Wartość, która jest konwertowana na pozornie równoważne <xref:System.Double> , <xref:System.Double> często nie jest równa wartości ze względu na różnice dokładności. <xref:System.Single> W poniższym przykładzie wynik identycznych operacji dzielenia jest przypisywany do <xref:System.Double> wartości <xref:System.Single> i wartości. Gdy wartość jest rzutowana <xref:System.Double>na, porównanie dwóch wartości pokazuje, że są one nierówne. <xref:System.Single>  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Aby uniknąć tego problemu, należy użyć <xref:System.Double> typu danych zamiast <xref:System.Single> <xref:System.Math.Round%2A> typu danych lub użyć metody, aby obie wartości miały taką samą precyzję.  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Testowanie pod kątem równości  
 Aby można je było traktować jako <xref:System.Single> równe, dwie wartości muszą reprezentować identyczne wartości. Jednak ze względu na różnice między wartościami lub ze względu na utratę dokładności przez jedną lub obie wartości, wartości zmiennoprzecinkowe, które powinny być identyczne, często są nierówne ze względu na różnice w ich najmniej znaczących cyfrach. W rezultacie wywołania <xref:System.Single.Equals%2A> metody, aby określić, czy dwie wartości są równe lub wywołania <xref:System.Single.CompareTo%2A> metody w celu określenia relacji między dwiema <xref:System.Single> wartościami, często dają nieoczekiwane wyniki. Jest to oczywiste w poniższym przykładzie, gdzie dwie pozornie równe <xref:System.Single> wartości są nierówne, ponieważ pierwsza wartość ma 7 cyfr dokładności, natomiast druga wartość ma 9.  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 Obliczone wartości, które są zgodne z różnymi ścieżkami kodu i które są manipulowane na różne sposoby, są często nierówne. W poniższym przykładzie jedna <xref:System.Single> wartość jest kwadratowa, a następnie zostanie obliczony pierwiastek kwadratowy, aby przywrócić oryginalną wartość. Sekunda <xref:System.Single> jest mnożona przez 3,51 i kwadratowa przed pierwiastek kwadratowy wyniku podzieloną przez 3,51, aby przywrócić oryginalną wartość. Chociaż dwie wartości wyglądają tak samo, wywołanie <xref:System.Single.Equals%28System.Single%29> metody wskazuje, że nie są równe. Użycie ciągu formatu standardowego "G9" w celu zwrócenia ciągu wynikowego, który wyświetla wszystkie znaczące cyfry każdej <xref:System.Single> wartości, pokazuje, że druga wartość jest .0000000000001 mniejsza od pierwszej.  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 W przypadkach, gdy utrata dokładności będzie prawdopodobnie miała wpływ na wynik porównania, można użyć następujących technik zamiast wywoływania <xref:System.Single.Equals%2A> metody lub: <xref:System.Single.CompareTo%2A>  
  
-   Wywołaj <xref:System.Math.Round%2A?displayProperty=nameWithType> metodę, aby upewnić się, że obie wartości mają taką samą precyzję. Poniższy przykład modyfikuje poprzedni przykład, aby użyć tego podejścia, tak aby dwie wartości ułamkowe były równoważne.  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     Należy zauważyć, że problem z dokładnością nadal stosuje się do zaokrąglania wartości punktu środkowego. Aby uzyskać więcej informacji, zobacz <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType> metodę.  
  
-   Przetestuj, aby uzyskać przybliżoną równość zamiast równości. Ta technika wymaga zdefiniowania wartości bezwzględnej, która może być różna, ale nadal jest równa, lub określić względną liczbę, o którą mniejsza wartość może być rozbieżna od większej wartości.  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType>jest czasami używany jako miara bezwzględna odległości między dwiema <xref:System.Single> wartościami przy testowaniu pod kątem równości.  Jednak mierzy najmniejszą możliwą wartość, którą można dodać do lub odjąć od <xref:System.Single> , której wartość jest równa zero. <xref:System.Single.Epsilon?displayProperty=nameWithType> Dla większości wartości dodatnich <xref:System.Single> i ujemnych <xref:System.Single.Epsilon?displayProperty=nameWithType> wartość jest zbyt mała do wykrycia. Z tego względu, z wyjątkiem wartości, które są równe zero, nie zalecamy użycia w testach pod kątem równości.  
  
     Poniższy przykład używa tego ostatniego podejścia do zdefiniowania `IsApproximatelyEqual` metody, która testuje względną różnicę między dwiema wartościami. Różni się również wynik wywołań `IsApproximatelyEqual` metody <xref:System.Single.Equals%28System.Single%29> i metody.  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Wartości zmiennoprzecinkowe i wyjątki  
 Operacje z wartościami zmiennoprzecinkowymi nie generują wyjątków, w przeciwieństwie do operacji z typami całkowitymi, które generują wyjątki w przypadkach niedozwolonych operacji, takich jak dzielenie przez zero lub przepełnienie.  Zamiast tego w takich sytuacjach wynik operacji zmiennoprzecinkowej wynosi zero, nieskończoność dodatnia, nieskończoność ujemna lub nie jest liczbą (NaN):  
  
-   Jeśli wynik operacji zmiennoprzecinkowej jest za mały dla formatu docelowego, wynik wynosi zero. Może się tak zdarzyć, gdy dwie bardzo małe liczby zmiennoprzecinkowe są mnożone, jak pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   Jeśli wartość wyniku operacji zmiennoprzecinkowej przekroczy zakres formatu docelowego, wynik operacji jest <xref:System.Single.PositiveInfinity> lub <xref:System.Single.NegativeInfinity>, zgodnie z potrzebami, w odniesieniu do znaku wyniku. Wynikiem operacji przepełnienia <xref:System.Single.MaxValue?displayProperty=nameWithType> jest <xref:System.Single.PositiveInfinity>, a wynikiem <xref:System.Single.MinValue?displayProperty=nameWithType> operacji przepełnienia jest <xref:System.Single.NegativeInfinity>, jak pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity>wyniki od dzielenia przez zero z dodatnią dzielną i <xref:System.Single.NegativeInfinity> wyniki dzielenia przez zero z ujemną dzielną.  
  
-   Jeśli operacja zmiennoprzecinkowa jest nieprawidłowa, wynik operacji to <xref:System.Single.NaN>. Na przykład <xref:System.Single.NaN> wyniki z następujących operacji:  
  
    -   Dzielenie przez zero z dzielną równą zero. Zwróć uwagę, że inne przypadki dzielenia przez zero powodują jedno <xref:System.Single.PositiveInfinity> lub <xref:System.Single.NegativeInfinity>.  
  
    -   Wszystkie operacje zmiennoprzecinkowe z nieprawidłowymi danymi wejściowymi. Na przykład próba znalezienia pierwiasteku kwadratowego zwraca <xref:System.Single.NaN>wartość ujemną.  
  
    -   Każda operacja z argumentem, którego wartość <xref:System.Single.NaN?displayProperty=nameWithType>to.  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>Konwersje typów i pojedyncza struktura  
 <xref:System.Single> Struktura nie definiuje żadnych jawnych lub niejawnych operatorów konwersji; zamiast tego konwersje są implementowane przez kompilator.  
  
 Poniższa tabela zawiera listę możliwych konwersji wartości innych pierwotnych typów liczbowych na <xref:System.Single> wartość, a także wskazuje, czy konwersja jest poszerzana czy zawężana oraz czy wyniki <xref:System.Single> mogą mieć mniejszą precyzję niż Oryginalna wartość.  
  
|Konwersja z|Rozszerzanie/zwężanie|Możliwa utrata dokładności|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|Nie|  
|<xref:System.Decimal>|Widening<br /><br /> Należy pamiętać C# , że wymaga operatora rzutowania.|Tak. <xref:System.Decimal>obsługuje 29 cyfr dziesiętnych dokładności; <xref:System.Single> obsługuje 9.|  
|<xref:System.Double>|Zawężająca wartości spoza zakresu są konwertowane na <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> lub. <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|Tak. <xref:System.Double>obsługuje 17 cyfr dziesiętnych dokładności; <xref:System.Single> obsługuje 9.|  
|<xref:System.Int16>|Widening|Nie|  
|<xref:System.Int32>|Widening|Tak. <xref:System.Int32>obsługuje 10 cyfr dziesiętnych precyzji; <xref:System.Single> obsługuje 9.|  
|<xref:System.Int64>|Widening|Tak. <xref:System.Int64>obsługuje 19 cyfr dziesiętnych precyzji; <xref:System.Single> obsługuje 9.|  
|<xref:System.SByte>|Widening|Nie|  
|<xref:System.UInt16>|Widening|Nie|  
|<xref:System.UInt32>|Widening|Tak. <xref:System.UInt32>obsługuje 10 cyfr dziesiętnych precyzji; <xref:System.Single> obsługuje 9.|  
|<xref:System.UInt64>|Widening|Tak. <xref:System.Int64>obsługuje 20 cyfr dziesiętnych dokładności; <xref:System.Single> obsługuje 9.|  
  
 Poniższy przykład konwertuje minimalną lub maksymalną wartość innych pierwotnych typów liczbowych na <xref:System.Single> wartość.  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 <xref:System.Double> Dodatkowo wartości ,,i<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>przekonwertować do, ,<xref:System.Single.PositiveInfinity?displayProperty=nameWithType>i,odpowiednio. <xref:System.Single.NaN?displayProperty=nameWithType> <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> <xref:System.Double.NaN?displayProperty=nameWithType> <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>  
  
 Należy zauważyć, że konwersja wartości niektórych typów liczbowych na <xref:System.Single> wartość może wiązać się z utratą precyzji. Jak pokazano na przykładzie <xref:System.Decimal>, podczas konwersji, <xref:System.Double>, <xref:System.Int32> <xref:System.UInt32> <xref:System.Int64>,, i <xref:System.UInt64> wartości na <xref:System.Single> wartości, jest możliwa utrata dokładności.  
  
 Konwersja <xref:System.Single> wartości na wartość a <xref:System.Double> jest konwersją rozszerzającą. Konwersja może spowodować utratę precyzji, jeśli <xref:System.Double> typ nie ma dokładnej reprezentacji <xref:System.Single> wartości.  
  
 Konwersja <xref:System.Single> wartości na wartość dowolnego pierwotnego typu danych liczbowych innego niż a <xref:System.Double> jest konwersją zawężania i wymaga operatora CAST (in C#) lub metody konwersji (w Visual Basic). Wartości, które znajdują się poza zakresem docelowego typu danych, które są definiowane przez typ `MinValue` docelowy i `MaxValue` właściwości, zachowują się jak pokazano w poniższej tabeli.  
  
|Typ docelowy|Wynik|  
|-----------------|------------|  
|Dowolny typ całkowity|<xref:System.OverflowException> Wyjątek, jeśli konwersja występuje w kontekście zaewidencjonowanych.<br /><br /> Jeśli konwersja występuje w kontekście niesprawdzonym (wartość domyślna w C#), operacja konwersji zakończy się powodzeniem, ale wartość jest przepełniania.|  
|<xref:System.Decimal>|<xref:System.OverflowException> Wyjątek,|  
  
 Ponadto <xref:System.Single.NaN?displayProperty=nameWithType> ,,i<xref:System.Single.NegativeInfinity?displayProperty=nameWithType> throw<xref:System.OverflowException> dla konwersji do liczb całkowitych w zaznaczonym kontekście, ale te wartości są przepełnione w przypadku przekonwertowania na liczby całkowite w niesprawdzonym kontekście. <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> W przypadku konwersji <xref:System.Decimal>do, zawsze <xref:System.OverflowException>generują. W przypadku konwersji <xref:System.Double>na, są one <xref:System.Double.NaN?displayProperty=nameWithType>konwertowane <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>na, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, i, odpowiednio.  
  
 Należy zauważyć, że utrata dokładności może wynikać z konwersji <xref:System.Single> wartości na inny typ liczbowy. W przypadku konwertowania wartości niecałkowitych <xref:System.Single> , jak dane wyjściowe z przykładu pokazują, składnik Ułamkowy zostanie utracony, <xref:System.Single> gdy wartość zostanie zaokrąglona (w Visual Basic) lub obcięta (jako C#). W przypadku konwersji <xref:System.Decimal> na wartości <xref:System.Single> , wartość może nie mieć dokładnej reprezentacji w docelowym typie danych.  
  
 Poniższy przykład konwertuje <xref:System.Single> kilka wartości na kilka innych typów liczbowych. Konwersje są wykonywane w kontekście zaewidencjonowanych w Visual Basic (wartość domyślna) i w C# (z powodu słowa kluczowego [Checked](~/docs/csharp/language-reference/keywords/checked.md) ). Dane wyjściowe z przykładu przedstawiają wynik konwersji zarówno w niesprawdzonym kontekście. Można wykonać konwersje w niesprawdzonym kontekście w Visual Basic przez skompilowanie z `/removeintchecks+` przełącznikiem kompilatora i w C# wyniku dodawania komentarza do `checked` instrukcji.  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 Aby uzyskać więcej informacji na temat konwersji typów liczbowych, zobacz [Konwersja typu w tabelach .NET Framework](~/docs/standard/base-types/type-conversion.md) i [konwersji typów](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Funkcje zmiennoprzecinkowe  
 <xref:System.Single> Struktura i powiązane typy zapewniają metody do wykonywania następujących kategorii operacji:  
  
-   **Porównanie wartości**. Możesz wywołać <xref:System.Single.Equals%2A> metodę, aby określić, czy dwie <xref:System.Single> wartości <xref:System.Single.CompareTo%2A> są równe, lub metodę, aby określić relację między dwiema wartościami.  
  
     <xref:System.Single> Struktura obsługuje również kompletny zestaw operatorów porównania. Na przykład można testować pod kątem równości lub nierówności lub określić, czy jedna wartość jest większa lub równa innej wartości. Jeśli jeden z operandów jest typu <xref:System.Double> <xref:System.Single> , wartość jest konwertowana na a <xref:System.Double> przed przeprowadzeniem porównania. Jeśli jeden z operandów jest typem całkowitym, jest konwertowany na a <xref:System.Single> przed przeprowadzeniem porównania. Chociaż te rozszerzenia rozszerzają konwersje, mogą one spowodować utratę precyzji.  
  
    > [!WARNING]
    >  Ze względu na różnice w precyzji, dwie <xref:System.Single> wartości, które powinny być równe, mogą być nierówne, co ma wpływ na wynik porównania. Zobacz sekcję [testowanie pod kątem równości](#Equality) , aby uzyskać więcej informacji na <xref:System.Single> temat porównywania dwóch wartości.  
  
     Możesz również wywołać <xref:System.Single.IsNaN%2A>metody,, <xref:System.Single.IsInfinity%2A> <xref:System.Single.IsPositiveInfinity%2A>, i <xref:System.Single.IsNegativeInfinity%2A> , aby przetestować dla tych specjalnych wartości.  
  
-   **Operacje matematyczne**. Typowe operacje arytmetyczne, takie jak dodawanie, odejmowanie, mnożenie i dzielenie są implementowane przez kompilatory języka i instrukcje wspólnego języka pośredniego (CIL), <xref:System.Single> a nie za pomocą metod. Jeśli drugi operand w operacji <xref:System.Double>matematycznej jest <xref:System.Single> , jest konwertowany na a <xref:System.Double> przed wykonaniem operacji, a wynik operacji jest również <xref:System.Double> wartością. Jeśli inny operand jest typem całkowitym, jest konwertowany na a <xref:System.Single> przed wykonaniem operacji, a wynik operacji jest <xref:System.Single> również wartością.  
  
     Można wykonywać inne operacje matematyczne, wywołując `static` metody`Shared` (w <xref:System.Math?displayProperty=nameWithType> Visual Basic) w klasie. Należą do nich dodatkowe metody, które są powszechnie używane do <xref:System.Math.Abs%2A?displayProperty=nameWithType>arytmetycznych ( <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>takich jak, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, i) <xref:System.Math.Cos%2A?displayProperty=nameWithType> , <xref:System.Math.Sin%2A?displayProperty=nameWithType>geometrii (takie jak i) oraz <xref:System.Math.Log%2A?displayProperty=nameWithType>calculus (na przykład).  We wszystkich przypadkach <xref:System.Single> wartość jest konwertowana <xref:System.Double>na.  
  
     Można również manipulować pojedynczymi bitami w <xref:System.Single> wartości. <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType> Metoda zwraca swój wzór bitowy w tablicy bajtów.  Przekazując tę tablicę bajtową do <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> metody, można również <xref:System.Single> zachować wzorzec bitu wartości w 32-bitowej liczbie całkowitej.  
  
-   **Zaokrąglenie**. Zaokrąglanie jest często stosowane jako technika zmniejszenia wpływu różnic między wartościami spowodowanymi problemami z reprezentacją zmiennoprzecinkową i dokładnością. Możesz zaokrąglić <xref:System.Single> wartość, <xref:System.Math.Round%2A?displayProperty=nameWithType> wywołując metodę. Należy jednak pamiętać, że <xref:System.Single> wartość jest konwertowana na a <xref:System.Double> przed wywołaniem metody, a Konwersja może pociągnąć za niego utratę precyzji.  
  
-   **Formatowanie**. Można przekonwertować <xref:System.Single> wartość na reprezentację ciągu, <xref:System.Single.ToString%2A> wywołując metodę lub korzystając z funkcji [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) . Aby uzyskać informacje na temat sposobu, w jaki ciągi formatu kontrolują reprezentację wartości zmiennoprzecinkowych, zobacz [Standardowe ciągi formatu liczb](~/docs/standard/base-types/standard-numeric-format-strings.md) i niestandardowe [ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md) .  
  
-   **Analizowanie ciągów**. Można przekonwertować ciąg reprezentujący wartość zmiennoprzecinkową na <xref:System.Single> wartość przez <xref:System.Single.Parse%2A> wywołanie metody lub <xref:System.Single.TryParse%2A> . Jeśli operacja analizy zakończy się niepowodzeniem, <xref:System.Single.Parse%2A> Metoda zgłasza wyjątek, <xref:System.Single.TryParse%2A> podczas gdy metoda `false`zwraca.  
  
-   **Konwersja typu**. Struktura zapewnia jawną implementację <xref:System.IConvertible> interfejsu, która obsługuje konwersję między dowolnymi dwoma standardowymi typami danych .NET Framework. <xref:System.Single> Kompilatory języka obsługują również niejawną konwersję wartości dla wszystkich innych standardowych typów liczbowych, z wyjątkiem <xref:System.Double> konwersji <xref:System.Single> do wartości. Konwersja wartości dowolnego standardowego typu liczbowego innego niż a <xref:System.Double> na a <xref:System.Single> jest konwersją rozszerzającą i nie wymaga użycia operatora rzutowania ani metody konwersji.  
  
     Jednak konwersja wartości 32-bitowych i 64-bitowych liczb całkowitych może wiązać się z utratą precyzji. W poniższej tabeli przedstawiono różnice w dokładności dla 32-bitowych, 64-bitowych i <xref:System.Double> typów:  
  
    |Typ|Maksymalna precyzja (w cyfrach dziesiętnych)|Wewnętrzna precyzja (w cyfrach dziesiętnych)|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> i <xref:System.UInt32>|10|10|  
    |<xref:System.Int64> i <xref:System.UInt64>|19|19|  
    |<xref:System.Single>|7|9|  
  
     Problem z dokładnością najczęściej wpływa <xref:System.Single> na wartości, które są konwertowane na <xref:System.Double> wartości. W poniższym przykładzie dwie wartości generowane przez identyczne operacje dzielenia są nierówne, ponieważ jedna z wartości jest wartością zmiennoprzecinkową o pojedynczej precyzji, która jest konwertowana na <xref:System.Double>.  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie tego typu są bezpieczne wątkowo. Elementy członkowskie, które na pierwszy rzut oka modyfikują stan wystąpienia, w rzeczywistości zwracają nowe wystąpienie zainicjowane z nową wartością. Podobnie jak w przypadku innych typów odczytywanie i zapisywanie w udostępnionej zmiennej, która zawiera wystąpienie tego typu, musi być chronione przez blokadę w celu zagwarantowania bezpieczeństwa wątków.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Double" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje to wystąpienie z określonym obiektem lub innym <see cref="T:System.Single" /> wystąpieniem i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza niż, równa lub większa niż wartość określonego obiektu lub innego <see cref="T:System.Single" /> wystąpienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania lub <see langword="null" />.</param>
        <summary>Porównuje to wystąpienie do określonego obiektu i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza niż, równa lub większa niż wartość określonego obiektu.</summary>
        <returns>Liczba ze znakiem wskazująca wartości względne tego wystąpienia <paramref name="value" />i.  
  
 <list type="table"><listheader><term> Wartość zwracana 
 </term><description> Opis 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> To wystąpienie jest mniejsze niż <paramref name="value" />.  
  
—lub— 
To wystąpienie nie jest liczbą (<see cref="F:System.Single.NaN" />) i <paramref name="value" /> jest liczbą.  
  
 </description></item><item><term> Zero 
 </term><description> To wystąpienie jest równe <paramref name="value" />.  
  
—lub— 
To wystąpienie i wartość nie mogą być liczbami (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" />lub <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description> To wystąpienie jest większe niż <paramref name="value" />.  
  
—lub— 
To wystąpienie jest liczbą i <paramref name="value" /> nie jest liczbą (<see cref="F:System.Single.NaN" />).  
  
—lub— 
 <paramref name="value" />jest <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr musi być `null` lub wystąpieniem <xref:System.Single>; w przeciwnym razie jest zgłaszany wyjątek. `value` Każde wystąpienie <xref:System.Single>, niezależnie od jego wartości, jest traktowane jako większe niż `null`.  
  
 Wartości muszą być identyczne, aby były uważane za równe. Szczególnie gdy wartości zmiennoprzecinkowe są zależne od wielu operacji matematycznych, często są dla nich tracone precyzje i ich wartości są niemal identyczne, z wyjątkiem ich najmniej znaczących cyfr. Z tego powodu wartość <xref:System.Single.CompareTo%2A> zwracana metody może wydawać się zaskakujące w czasie. Na przykład mnożenie według określonej wartości, po której następuje dzielenie przez tę samą wartość, powinno generować oryginalną wartość, ale w poniższym przykładzie obliczona wartość jest większa niż oryginalna wartość. Wyświetlanie wszystkich znaczących cyfr dwóch wartości przy użyciu [standardowego ciągu formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) "R" wskazuje, że obliczona wartość różni się od oryginalnej wartości w najmniej znaczących cyfrach. Aby uzyskać informacje na temat obsługi takich porównań, zobacz sekcję <xref:System.Single.Equals%28System.Single%29> uwagi metody.  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 Ta metoda jest implementowana do obsługi <xref:System.IComparable> interfejsu. Należy zauważyć, że mimo <xref:System.Single.NaN> że nie jest uważany za równy innemu <xref:System.Single.NaN> ( <xref:System.IComparable> nawet jeden), interfejs wymaga, aby `A.CompareTo(A)` zwracał zero.  
  
## <a name="precision-in-comparisons"></a>Precyzja w porównaniach  
 Dokładność liczb zmiennoprzecinkowych poza udokumentowaną dokładnością jest określona dla implementacji oraz wersji systemu .NET Framework. W związku z tym porównanie dwóch określonych liczb może ulec zmianie między wersji systemu .NET Framework, ponieważ precyzja przedstawienia numeracji wewnętrznej może ulec zmianie.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Single.CompareTo%2A> metodę.  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" />nie <see cref="T:System.Single" />jest.</exception>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(float value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : single -&gt; int&#xA;override this.CompareTo : single -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Liczba zmiennoprzecinkowa pojedynczej precyzji do porównania.</param>
        <summary>Porównuje to wystąpienie z określoną liczbą zmiennoprzecinkową o pojedynczej precyzji i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza niż, równa lub większa niż wartość określonej liczby zmiennoprzecinkowej pojedynczej precyzji.</summary>
        <returns>Liczba ze znakiem wskazująca wartości względne tego wystąpienia <paramref name="value" />i.  
  
 <list type="table"><listheader><term> Wartość zwracana 
 </term><description> Opis 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> To wystąpienie jest mniejsze niż <paramref name="value" />.  
  
—lub— 
To wystąpienie nie jest liczbą (<see cref="F:System.Single.NaN" />) i <paramref name="value" /> jest liczbą.  
  
 </description></item><item><term> Zero 
 </term><description> To wystąpienie jest równe <paramref name="value" />.  
  
—lub— 
Oba te wystąpienia i <paramref name="value" /> nie są liczbami (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" />lub <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description> To wystąpienie jest większe niż <paramref name="value" />.  
  
—lub— 
To wystąpienie jest liczbą i <paramref name="value" /> nie jest liczbą (<see cref="F:System.Single.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości muszą być identyczne, aby były uważane za równe. Wartości zmiennoprzecinkowe są często używane do utraty dokładności i są niemal identyczne, z wyjątkiem ich najmniej znaczących cyfr, zwłaszcza gdy wartości są zależne od wielu operacji matematycznych. Z tego powodu wartość <xref:System.Single.CompareTo%2A> zwracana metody w godzinach może wydawać się zaskakujące. Na przykład mnożenie według dowolnej wartości, a po niej dzielenie przez tę samą wartość, powinno generować pierwotną wartość. Jednak w poniższym przykładzie obliczona wartość jest większa niż oryginalna wartość. Wyświetlanie wszystkich znaczących cyfr dwóch wartości przy użyciu [standardowego ciągu formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) "R" wskazuje, że obliczona wartość różni się od oryginalnej wartości w najmniej znaczących cyfrach. Aby uzyskać informacje na temat obsługi takich porównań, zobacz sekcję <xref:System.Single.Equals%28System.Single%29> uwagi metody.  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 Ta metoda implementuje <xref:System.IComparable%601?displayProperty=nameWithType> interfejs i wykonuje nieco lepszą niż metoda, <xref:System.Single.CompareTo%2A?displayProperty=nameWithType> ponieważ nie musi konwertować `value` parametru do obiektu.  
  
 Należy zauważyć, że chociaż obiekt, którego wartość <xref:System.Single.NaN> nie jest uważany za równy innemu obiektowi, <xref:System.Single.NaN> którego wartość jest ( <xref:System.IComparable%601> nawet sama), interfejs `A.CompareTo(A)` wymaga, aby zwracał zero.  
  
## <a name="widening-conversions"></a>Poszerzenie konwersji  
 W zależności od języka programowania może być możliwe kod <xref:System.Single.CompareTo%2A> metody, w której typ parametru ma mniejszą liczbę bitów (jest węższy) niż typ wystąpienia. To jest możliwe, ponieważ w niektórych językach programowania jest wykonywana niejawna konwersja poszerzająca, która powoduje reprezentowanie parametru jako typu z taką samą liczbą bitów jak liczba bitów wystąpienia.  
  
 Załóżmy na przykład, że typ wystąpienia to <xref:System.Single> i typ parametru to. <xref:System.Int32> Kompilator firmy C# Microsoft generuje instrukcje do reprezentowania wartości parametru jako <xref:System.Single> obiektu <xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType> , a następnie generuje metodę, która porównuje wartości wystąpienia i poszerzonną reprezentację parametru.  
  
 Sprawdź dokumentację języka programowania, aby określić, czy jego kompilator wykonuje niejawne poszerzenia konwersji dla typów liczbowych. Aby uzyskać więcej informacji, zobacz temat [tabele konwersji typów](~/docs/standard/base-types/conversion-tables.md) .  
  
## <a name="precision-in-comparisons"></a>Precyzja w porównaniach  
 Dokładność liczb zmiennoprzecinkowych poza udokumentowaną dokładnością jest określona dla implementacji oraz wersji systemu .NET Framework. W związku z tym porównanie dwóch określonych liczb może ulec zmianie między wersji systemu .NET Framework, ponieważ precyzja przedstawienia numeracji wewnętrznej może ulec zmianie.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje ogólne i nieogólne wersje <xref:System.Single.CompareTo%2A> metody dla kilku typów wartości i elementów referencyjnych.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Single  = 1.401298E-45" />
      <MemberSignature Language="C++ CLI" Value="public: float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : single" Usage="System.single.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>Reprezentuje najmniejszą wartość <see cref="T:System.Single" /> dodatnią, która jest większa od zera. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Single.Epsilon> właściwości odzwierciedla najmniejszy dodatnią <xref:System.Single> wartość, która jest istotna w operacjach liczbowych lub porównaniach, <xref:System.Single> gdy wartość wystąpienia jest równa zero. Na przykład poniższy kod pokazuje, że zero i <xref:System.Single.Epsilon> są uważane za wartości nierówne, natomiast zero i połowa <xref:System.Single.Epsilon> wartości są uważane za równe.  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 Dokładniej, format zmiennoprzecinkowy o pojedynczej precyzji składa się z znaku, 23-bitowego mantysy lub mantysę i 8-bitowego wykładnika. Jak pokazano na poniższym przykładzie, zero ma wykładnik-126 i mantysy 0. <xref:System.Single.Epsilon>ma wykładnik wartości-126 i mantysy 1. Oznacza to, <xref:System.Single.Epsilon?displayProperty=nameWithType> że jest to najmniejsza wartość dodatnia <xref:System.Single> , która jest większa od zera i reprezentuje najmniejszą możliwą wartość oraz najmniejszy <xref:System.Single> możliwy przyrost dla elementu, którego wykładnik to-126.  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 Jednakże właściwość nie jest ogólną miarą precyzji <xref:System.Single> typu <xref:System.Single> ; dotyczy tylko wystąpień o wartości zero. <xref:System.Single.Epsilon>  
  
> [!NOTE]
>  Wartość <xref:System.Single.Epsilon> właściwości nie jest równoznaczna z liczbą komputerów Epsilon, która reprezentuje górną granicę względnego błędu z powodu zaokrąglenia w arytmetycznej liczbie zmiennoprzecinkowej.  
  
 Wartość tej stałej to 1,4 e-45.  
  
 Dwie prawdopodobnie równoważne liczby zmiennoprzecinkowe mogą nie być porównywane z powodu różnic w ich najmniej znaczących cyfrach. Na przykład C# wyrażenie `(float)1/3 == (float)0.33333`nie jest porównywane, ponieważ operacja dzielenia po lewej stronie ma maksymalną precyzję, podczas gdy stała po prawej stronie jest precyzyjna tylko do określonych cyfr. W przypadku utworzenia niestandardowego algorytmu, który określa, czy dwie liczby zmiennoprzecinkowe mogą być uważane za równe, należy użyć wartości większej niż <xref:System.Single.Epsilon> stała, aby określić akceptowalny bezwzględny margines różnicy dla dwóch wartości, które mają być traktowane jako równe. (Zazwyczaj ten margines różnicy jest wiele razy większy niż <xref:System.Single.Epsilon>).  
  
## <a name="platform-notes"></a>Uwagi dotyczące platformy  
 W systemach ARM wartość <xref:System.Single.Epsilon> stałej jest zbyt mała, aby mogła zostać wykryta, więc jest równa zero. Zamiast tego można zdefiniować alternatywną wartość Epsilon równą 1.175494351 E-38.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwa wystąpienia <see cref="T:System.Single" /> reprezentują tę samą wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns><see langword="true" />Jeśli <paramref name="obj" /> jest <see langword="false" />wystąpieniem i jest równa wartości tego wystąpienia; w przeciwnym razie,. <see cref="T:System.Single" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.Equals%2A> Metoda powinna być stosowana z zachowaniem ostrożności, ponieważ dwie równoważne wartości mogą być nierówne z powodu różnej dokładności dwóch wartości. Poniższy przykład zgłasza, że <xref:System.Single> wartość. 3333 <xref:System.Single> i zwrócone przez podział 1 przez 3 są różne.  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 Zamiast porównywania pod kątem równości, jedna zalecana technika obejmuje zdefiniowanie akceptowalnego marginesu różnicy między dwiema wartościami (na przykład .01% jednej z wartości). Jeśli wartość bezwzględna różnicy między dwoma wartościami jest mniejsza niż lub równa marginesowi, różnica jest prawdopodobnie spowodowana różnicami i dlatego wartości mogą być równe. W poniższym przykładzie zastosowano tę technikę do porównania. 33333 i 1/3, <xref:System.Single> dwie wartości, które nie zostały odnalezione przez poprzedni przykład kodu.  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 W takim przypadku wartości są równe.  
  
> [!NOTE]
>  Ponieważ <xref:System.Single.Epsilon> definiuje minimalne wyrażenie wartości dodatniej, której zakres jest bliski zero, margines różnicy musi być większy niż <xref:System.Single.Epsilon>. Zwykle jest to wiele razy większe niż <xref:System.Single.Epsilon>.  
  
 Dokładność liczb zmiennoprzecinkowych poza udokumentowaną dokładnością jest określona dla implementacji oraz wersji systemu .NET Framework. W związku z tym porównanie dwóch określonych liczb może ulec zmianie między wersji systemu .NET Framework, ponieważ precyzja przedstawienia numeracji wewnętrznej może ulec zmianie.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Single.Equals%2A> metodę.  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Rozwiązanie do przeciążenia kompilatora może uwzględniać pozorną różnicę w zachowaniu dwóch <see cref="M:System.Single.Equals(System.Object)" /> przeciążeń metod. Jeśli niejawna konwersja między <paramref name="obj" /> <see cref="T:System.Single" /> argumentem a jest zdefiniowana, a argument nie <see cref="T:System.Object" />jest typem jako, kompilatory <see cref="M:System.Single.Equals(System.Single)" /> mogą wykonać niejawną konwersję i wywołać metodę. W <see cref="M:System.Single.Equals(System.Object)" /> przeciwnym razie wywołuje metodę, która zawsze zwraca <see langword="false" /> wartość, jeśli <paramref name="obj" /> <see cref="T:System.Single" /> jej argument nie jest wartością. Poniższy przykład ilustruje różnice w zachowaniu między dwoma przeciążeniami metod. W przypadku wszystkich pierwotnych typów liczbowych, z <see cref="T:System.Double" /> wyjątkiem w Visual Basic i <see cref="T:System.Decimal" /> z wyjątkiem <see cref="T:System.Double" /> i C#w, pierwsze porównanie zwraca <see langword="true" /> , ponieważ kompilator automatycznie wykonuje konwersję rozszerzającą i wywołuje <see cref="M:System.Single.Equals(System.Single)" /> metodę, a drugie powraca <see langword="false" /> , <see cref="M:System.Single.Equals(System.Object)" /> ponieważ kompilator wywołuje metodę.  
  
[!code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [!code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(float obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : single -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie i określony <see cref="T:System.Single" /> obiekt reprezentują tę samą wartość.</summary>
        <returns><see langword="true" />Jeśli <paramref name="obj" /> jest równe temu wystąpieniu; w przeciwnym razie <see langword="false" />,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje <xref:System.IEquatable%601?displayProperty=nameWithType> interfejs i wykonuje nieco lepsze niż <xref:System.Single.Equals%2A> , ponieważ nie musi skonwertować `obj` parametru do obiektu.  
  
## <a name="widening-conversions"></a>Poszerzenie konwersji  
 W zależności od języka programowania może być możliwe kod <xref:System.Single.Equals%2A> metody, w której typ parametru ma mniejszą liczbę bitów (jest węższy) niż typ wystąpienia. To jest możliwe, ponieważ w niektórych językach programowania jest wykonywana niejawna konwersja poszerzająca, która powoduje reprezentowanie parametru jako typu z taką samą liczbą bitów jak liczba bitów wystąpienia.  
  
 Załóżmy na przykład, że typ wystąpienia to <xref:System.Single> i typ parametru to. <xref:System.Int32> Kompilator firmy C# Microsoft generuje instrukcje do reprezentowania wartości parametru jako <xref:System.Single> obiektu, <xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType> a następnie generuje metodę, która porównuje wartości wystąpienia i poszerzonną reprezentację parametru.  
  
 Sprawdź dokumentację języka programowania, aby określić, czy jego kompilator wykonuje niejawne poszerzenia konwersji dla typów liczbowych. Aby uzyskać więcej informacji, zobacz temat [tabele konwersji typów](~/docs/standard/base-types/conversion-tables.md) .  
  
## <a name="precision-in-comparisons"></a>Precyzja w porównaniach  
 <xref:System.Single.Equals%2A> Metoda powinna być stosowana z zachowaniem ostrożności, ponieważ dwie równoważne wartości mogą być nierówne, ponieważ różnią się dokładnością dwóch wartości. Poniższy przykład zgłasza, że <xref:System.Single> wartość. 3333 <xref:System.Single> i zwrócone przez podział 1 przez 3 są różne.  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 Jedną techniką porównywania, która pozwala uniknąć problemów związanych z porównaniem równości, jest zdefiniowanie akceptowalnego marginesu różnicy między dwiema wartościami (na przykład .01% jednej z wartości). Jeśli wartość bezwzględna różnicy między dwoma wartościami jest mniejsza lub równa marginesowi, różnica może być wynikiem różnic dokładności i dlatego wartości mogą być równe. W poniższym przykładzie zastosowano tę technikę do porównania. 33333 i 1/3, które są <xref:System.Single> dwiema wartościami, których poprzedni przykład kodu nie jest równy.  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 W takim przypadku wartości są równe.  
  
> [!NOTE]
>  Ponieważ <xref:System.Single.Epsilon> definiuje minimalne wyrażenie wartości dodatniej, której zakres jest bliski zero, margines różnicy musi być większy niż <xref:System.Single.Epsilon>. Zwykle jest to wiele razy większe niż <xref:System.Single.Epsilon>. Z tego powodu zaleca się, aby nie używać <xref:System.Double.Epsilon> podczas porównywania <xref:System.Double> wartości równości.  
  
 Druga technika, która pozwala uniknąć problemów związanych z porównaniem pod kątem równości, polega na porównaniu różnicy między dwoma liczbami zmiennoprzecinkowymi z nieprawidłową wartością. Jeśli różnica jest mniejsza lub równa tej wartości bezwzględnej, liczby są równe. Jeśli jest większa, liczby nie są równe. Jednym ze sposobów, aby to zrobić, można arbitralnie wybrać wartość bezwzględną. Jest to jednak problematyczne, ponieważ akceptowalny margines różnic zależy od wielkości <xref:System.Single> wartości. Drugi sposób wykorzystuje funkcję projektowania formatu zmiennoprzecinkowego: Różnica między składnikami mantysy w reprezentacjach liczb całkowitych dwóch wartości zmiennoprzecinkowych wskazuje liczbę możliwych wartości zmiennoprzecinkowych oddzielających dwie wartości. Na przykład różnica między 0,0 i <xref:System.Single.Epsilon> wynosi 1, ponieważ <xref:System.Single.Epsilon> jest najmniejszą reprezentacją wartości podczas pracy z, <xref:System.Single> której wartość jest równa zero. W poniższym przykładzie zastosowano tę technikę do porównania. 33333 i 1/3, czyli dwie <xref:System.Double> wartości, których poprzedni przykład kodu <xref:System.Single.Equals%28System.Single%29> z metodą nie jest równy. Należy zauważyć, że w przykładzie <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> używane <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> są metody i do konwersji wartości zmiennoprzecinkowej o pojedynczej precyzji na reprezentację liczb całkowitych.  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 Dokładność liczb zmiennoprzecinkowych poza udokumentowaną dokładnością jest określona dla implementacji oraz wersji systemu .NET Framework. W związku z tym porównanie dwóch liczb może generować różne wyniki w zależności od wersji .NET Framework, ponieważ precyzja wewnętrznej reprezentacji cyfr może ulec zmianie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Rozwiązanie do przeciążenia kompilatora może uwzględniać pozorną różnicę w zachowaniu dwóch <see cref="M:System.Single.Equals(System.Object)" /> przeciążeń metod. Jeśli niejawna konwersja między <paramref name="obj" /> <see cref="T:System.Single" /> argumentem a jest zdefiniowana, a argument nie <see cref="T:System.Object" />jest typem jako, kompilatory <see cref="M:System.Single.Equals(System.Single)" /> mogą wykonać niejawną konwersję i wywołać metodę. W <see cref="M:System.Single.Equals(System.Object)" /> przeciwnym razie wywołuje metodę, która zawsze zwraca <see langword="false" /> wartość, jeśli <paramref name="obj" /> <see cref="T:System.Single" /> jej argument nie jest wartością. Poniższy przykład ilustruje różnice w zachowaniu między dwoma przeciążeniami metod. W przypadku wszystkich pierwotnych typów liczbowych, z <see cref="T:System.Double" /> wyjątkiem w Visual Basic i <see cref="T:System.Decimal" /> z wyjątkiem <see cref="T:System.Double" /> i C#w, pierwsze porównanie zwraca <see langword="true" /> , ponieważ kompilator automatycznie wykonuje konwersję rozszerzającą i wywołuje <see cref="M:System.Single.Equals(System.Single)" /> metodę, a drugie powraca <see langword="false" /> , <see cref="M:System.Single.Equals(System.Object)" /> ponieważ kompilator wywołuje metodę.  
  
[!code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [!code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.Equals(System.Object)" />
        <altmember cref="Overload:System.Single.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="single.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="single.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość typu <see cref="T:System.Single" />. <see cref="T:System.TypeCode" /></summary>
        <returns>Stała <see cref="F:System.TypeCode.Single" />Wyliczenie.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsFinite(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(float f);" />
      <MemberSignature Language="F#" Value="static member IsFinite : single -&gt; bool" Usage="System.single.IsFinite f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="f">Liczba zmiennoprzecinkowa pojedynczej precyzji.</param>
        <summary>Określa, czy określona wartość jest skończona (zero, subnormal lub Normal).</summary>
        <returns><see langword="true" />Jeśli określona wartość jest skończona (zero, subnormal lub Normal); w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : single -&gt; bool" Usage="System.single.IsInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Liczba zmiennoprzecinkowa pojedynczej precyzji.</param>
        <summary>Zwraca wartość wskazującą, czy określona liczba daje w wyniku ujemną czy dodatnią.</summary>
        <returns><see langword="true" />Jeśli <paramref name="f" /> jest wynikiem obliczenia <see cref="F:System.Single.PositiveInfinity" /> lub <see cref="F:System.Single.NegativeInfinity" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacje zmiennoprzecinkowe zwracają <xref:System.Single.PositiveInfinity> lub <xref:System.Single.NegativeInfinity> sygnalizujący warunek przepełnienia.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Single.IsInfinity%2A> metodę.  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(float f);" />
      <MemberSignature Language="F#" Value="static member IsNaN : single -&gt; bool" Usage="System.single.IsNaN f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Liczba zmiennoprzecinkowa pojedynczej precyzji.</param>
        <summary>Zwraca wartość wskazującą, czy określona wartość nie jest liczbą (<see cref="F:System.Single.NaN" />).</summary>
        <returns><see langword="true" />Jeśli <paramref name="f" /> wartość jest równa liczbie (<see cref="F:System.Single.NaN" />); w przeciwnym <see langword="false" />razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacje zmiennoprzecinkowe zwracają <xref:System.Single.NaN> do sygnału, że wynik operacji jest niezdefiniowany. Na przykład dzielenie 0,0 przez 0,0 skutkuje wynikiem <xref:System.Single.NaN>.  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A>zwraca `false` czy<xref:System.Single> wartość jest <xref:System.Single.PositiveInfinity> albo<xref:System.Single.NegativeInfinity>. Aby przetestować te wartości, użyj <xref:System.Single.IsInfinity%2A>metod, <xref:System.Single.IsPositiveInfinity%2A>i <xref:System.Single.IsNegativeInfinity%2A> .  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Single.IsNaN%2A> metodę.  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegative(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegative : single -&gt; bool" Usage="System.single.IsNegative f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="f">Liczba zmiennoprzecinkowa pojedynczej precyzji.</param>
        <summary>Określa, czy określona wartość jest ujemna.</summary>
        <returns><see langword="true" />Jeśli wartość jest <see langword="false" /> ujemna, w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : single -&gt; bool" Usage="System.single.IsNegativeInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Liczba zmiennoprzecinkowa pojedynczej precyzji.</param>
        <summary>Zwraca wartość wskazującą, czy określona liczba ma być ujemna nieskończoność.</summary>
        <returns><see langword="true" />w <paramref name="f" /> przypadku wartości zwraca <see cref="F:System.Single.NegativeInfinity" />wartość; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacje zmiennoprzecinkowe zwracają <xref:System.Single.NegativeInfinity> do sygnału warunek przepełnienia.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Single.IsNegativeInfinity%2A> metodę.  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsNormal : single -&gt; bool" Usage="System.single.IsNormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="f">Liczba zmiennoprzecinkowa pojedynczej precyzji.</param>
        <summary>Określa, czy określona wartość jest normalna.</summary>
        <returns><see langword="true" />Jeśli <paramref name="f" /> jest normalny; <see langword="false" /> w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : single -&gt; bool" Usage="System.single.IsPositiveInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Liczba zmiennoprzecinkowa pojedynczej precyzji.</param>
        <summary>Zwraca wartość wskazującą czy określona liczba daje w wyniku dodatnią nieskończoność.</summary>
        <returns><see langword="true" />w <paramref name="f" /> przypadku wartości zwraca <see cref="F:System.Single.PositiveInfinity" />wartość; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacje zmiennoprzecinkowe zwracają <xref:System.Single.PositiveInfinity> do sygnału warunek przepełnienia.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Single.IsPositiveInfinity%2A> metodę.  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsSubnormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : single -&gt; bool" Usage="System.single.IsSubnormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="f">Liczba zmiennoprzecinkowa pojedynczej precyzji.</param>
        <summary>Określa, czy określona wartość jest w trybie normalnym.</summary>
        <returns><see langword="true" />Jeśli <paramref name="f" /> jest normalny; <see langword="false" /> w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Single  = 3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : single" Usage="System.single.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.402823E+38</MemberValue>
      <Docs>
        <summary>Reprezentuje największą możliwą wartość <see cref="T:System.Single" />. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej to dodatnia 3.40282347 E + 38.  
  
 Wynik operacji, która przekracza wartość <xref:System.Single.MaxValue?displayProperty=nameWithType> równą. <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> W poniższym przykładzie <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> wynikiem są operacje dodawania, mnożenia i potęgowania, gdy wynik przekroczy <xref:System.Single.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Single.MaxValue> stałą.  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Single  = -3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MinValue = -3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : single" Usage="System.single.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.402823E+38</MemberValue>
      <Docs>
        <summary>Reprezentuje najmniejszą możliwą wartość <see cref="T:System.Single" />. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej to ujemna 3.402823 E38.  
  
 Wynik operacji, która jest mniejsza niż <xref:System.Single.MinValue?displayProperty=nameWithType>. <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> W poniższym przykładzie wynikiem są <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> operacje odejmowania i mnożenia, gdy wynik jest mniejszy niż. <xref:System.Single.MinValue?displayProperty=nameWithType>  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Single.MinValue> stałą.  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Single  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: float NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : single" Usage="System.single.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Reprezentuje nieprawidłową liczbę (<see langword="NaN" />). To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda lub operator zwraca <xref:System.Single.NaN> , gdy wynik operacji jest niezdefiniowany. Na przykład wynik dzielenia zera przez zero to <xref:System.Single.NaN>, jak pokazano w poniższym przykładzie. (Ale należy zauważyć, że dzielenie liczby niezerowej przez zero zwraca albo <xref:System.Single.PositiveInfinity> lub <xref:System.Single.NegativeInfinity>, w zależności od znaku dzielnika).  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 Ponadto wywołanie metody z <xref:System.Single.NaN> wartością lub operacją <xref:System.Single.NaN> w zwracanej <xref:System.Single.NaN>wartości, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 Użyj metody <xref:System.Single.IsNaN%2A> , aby określić, czy wartość nie jest liczbą. <xref:System.Single> Ogólnie rzecz biorąc operatory nie mogą być używane do <xref:System.Single.NaN?displayProperty=nameWithType> porównywania <xref:System.Single> z innymi wartościami, chociaż metody porównania ( <xref:System.Single.Equals%2A> takie <xref:System.Single.CompareTo%2A>jak i) mogą. Poniższy przykład ilustruje różnice w zachowaniu między <xref:System.Single> operatorami i metodami porównania.  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Single.NaN> stałą.  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNaN(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Single  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : single" Usage="System.single.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Reprezentuje nieskończoność ujemną. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest wynikiem dzielenia ujemnej liczby przez zero.  
  
 Ta stała jest zwracana, gdy wynik operacji jest mniejszy niż <xref:System.Single.MinValue>.  
  
 Użyj <xref:System.Single.IsNegativeInfinity%2A> , aby określić, czy wartość ma być ujemna nieskończoność.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Single.NegativeInfinity> stałą.  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : single * single -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwie określone <see cref="T:System.Single" /> wartości są równe.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> i <paramref name="right" /> sąrówne;<see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operator równości dla <xref:System.Single> wartości. <xref:System.Single.op_Equality%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : single * single -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określona <see cref="T:System.Single" /> wartość jest większa niż inna określona <see cref="T:System.Single" /> wartość.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora większego od dla <xref:System.Single> wartości. <xref:System.Single.op_GreaterThan%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : single * single -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określona <see cref="T:System.Single" /> wartość jest większa lub równa innej określonej <see cref="T:System.Single" /> wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większe lub <paramref name="right" />równe; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora wyższego niż lub równego dla <xref:System.Single> wartości. <xref:System.Single.op_GreaterThanOrEqual%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : single * single -&gt; bool" Usage="System.single.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwie określone <see cref="T:System.Single" /> wartości nie są równe.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> i <paramref name="right" /> niesąrówne;<see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operator nierówności dla <xref:System.Single> wartości. <xref:System.Single.op_Inequality%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : single * single -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określona <see cref="T:System.Single" /> wartość jest mniejsza od innej określonej <see cref="T:System.Single" /> wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora mniejszościowego dla <xref:System.Single> wartości. <xref:System.Single.op_LessThan%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : single * single -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określona <see cref="T:System.Single" /> wartość jest mniejsza lub równa innej określonej <see cref="T:System.Single" /> wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsze lub <paramref name="right" />równe; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora mniejszego niż lub równego dla <xref:System.Single> wartości. <xref:System.Single.op_LessThanOrEqual%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje ciąg reprezentujący liczbę na odpowiadającą mu liczbę zmiennoprzecinkową pojedynczej precyzji.</summary>
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; single" Usage="System.single.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę na odpowiadającą mu liczbę zmiennoprzecinkową pojedynczej precyzji.</summary>
        <returns>Liczba zmiennoprzecinkowa o pojedynczej precyzji odpowiadająca wartości liczbowej lub symbolowi określonej <paramref name="s" />w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr może zawierać bieżącą <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>kulturę, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>lub ciąg w postaci: `s`  
  
 [*WS*] [*Sign*] [*cyfry całkowite*[*,*]] *cyfry całkowite* [*.* [*cyfry ułamkowe*]] [e [*Sign*]*cyfry wykładnicze*] [*WS*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Seria białych znaków.|  
|*sign*|Symbol znaku minus lub symbol znaku dodatniego. Prawidłowe znaki znakowe są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> właściwości <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> i bieżącej kultury. Można użyć tylko znaku wiodącego.|  
|*integral-digits*|Ciąg cyfr od 0 do 9, które określają jej część całkowitą. Uruchomienia *cyfr całkowitych* mogą być partycjonowane przez symbol separatora grupy. Na przykład w niektórych kulturach przecinek (,) oddziela grupy wartości tysięcznych. Element ** z cyframi całkowitymi może być nieobecny, jeśli ciąg zawiera element *Ułamkowo-cyfr* .|  
|*,*|Symbol separatora tysięcy specyficzny dla kultury.|  
|*.*|Symbol dziesiętny specyficzny dla kultury.|  
|*cyfry ułamkowe*|Ciąg cyfr od 0 do 9, które określają część ułamkową liczby.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym).|  
|*cyfry wykładnicze*|Ciąg cyfr od 0 do 9, które określają wykładnik potęgi.|  
  
 Parametr jest interpretowany przy użyciu kombinacji <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> flag i <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>. `s` Oznacza to, że biały znak i separatory tysięczne są dozwolone, ale symbole walut nie. Aby jawnie zdefiniować elementy (takie jak symbole waluty, separatory tysięcy i białe znaki), które mogą być obecne w `s`, <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> Użyj przeciążenia metody.  
  
 Parametr jest analizowany przy użyciu informacji o formatowaniu <xref:System.Globalization.NumberFormatInfo> w obiekcie, który jest zainicjowany dla bieżącej kultury systemowej. `s` Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Aby przeanalizować ciąg przy użyciu informacji o formatowaniu określonej kultury, użyj <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> metody lub. <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>  
  
 Zwykle w przypadku przekazania <xref:System.Single.Parse%2A> metody do ciągu, który jest tworzony przez <xref:System.Single.ToString%2A> wywołanie metody, zwracana jest oryginalna <xref:System.Single> wartość. Jednak ze względu na utratę precyzji wartości mogą być różne.  
  
 Jeśli w `s` parametrze podczas operacji analizy napotkany jest separator, a odpowiednia waluta lub liczba dziesiętna i separatory grupy są takie same, operacja analizy zakłada, że separator jest separatorem dziesiętnym, a nie grupą rozdzielając. Aby uzyskać więcej informacji na temat separatorów <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>zobacz <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>,, <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>, i.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Single.Parse%28System.String%29> metodę, aby skonwertować tablicę ciągów na równoważne <xref:System.Single> wartości.  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" />nie reprezentuje liczby w prawidłowym formacie.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" />reprezentuje liczbę mniejszą <see cref="F:System.Single.MinValue" /> lub <see cref="F:System.Single.MaxValue" />równą.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizowanie ciągów liczbowych w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; single" Usage="System.single.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia wskazująca elementy stylu, które mogą być obecne w <paramref name="s" />. Typowa wartość do określenia jest <see cref="F:System.Globalization.NumberStyles.Float" /> połączona <see cref="F:System.Globalization.NumberStyles.AllowThousands" />z.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę w określonym stylu do jej równoważnej liczbie zmiennoprzecinkowej o pojedynczej precyzji.</summary>
        <returns>Liczba zmiennoprzecinkowa o pojedynczej precyzji, która jest równoważna z wartością numeryczną lub symbolem określonym w <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr definiuje elementy stylu (takie jak odstępy, separatory tysięcy i symbole waluty), które są dozwolone `s` w parametrze dla operacji analizy. `style` Musi to być kombinacja flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. Następujące <xref:System.Globalization.NumberStyles> elementy członkowskie nie są obsługiwane:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Parametr może zawierać bieżącą <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>kulturę, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>. `s` W zależności od wartości `style`, może również mieć postać:  
  
 [*WS*] [*$*] [*Sign*] [*cyfry całkowite*[*,*]]*cyfry całkowite*[*.* [*cyfry ułamkowe*]] [E [*Sign*]*cyfry wykładnicze*] [*WS*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
 *ws*  
 Ciąg znaków spacji. Biały znak może pojawić się na początku `s` , `style` jeśli zawiera <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę i może <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> pojawić się na końcu elementu `s` if `style` zawiera flagę.  
  
 $  
 Symbol waluty specyficzny dla kultury. Jego pozycja w ciągu jest definiowana przez <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> właściwości i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> bieżącej kultury. Symbol waluty bieżącej kultury może pojawić się w `s` , `style` <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> jeśli zawiera flagę.  
  
 *sign*  
 Symbol znaku minus (-) lub znaku dodatniego (+). Znak `s` może występować na początku, jeśli `style` zawiera <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę `s` i może <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> być wyświetlany na końcu, jeśli `style` zawiera flagę. Nawiasów można używać w `s` celu wskazania wartości ujemnej, <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Jeśli `style` zawiera flagę.  
  
 *integral-digits*  
 Ciąg cyfr od 0 do 9, które określają jej część całkowitą. Element ** z cyframi całkowitymi może być nieobecny, jeśli ciąg zawiera element *Ułamkowo-cyfr* .  
  
 ,  
 Separator grupy specyficzny dla kultury. Symbol separatora grupy bieżącej kultury może pojawić się `s` w `style` przypadku, <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> gdy zawiera flagę  
  
 .  
 Symbol dziesiętny specyficzny dla kultury. Symbol dziesiętny bieżącej kultury może pojawić się w `s` , `style` <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> jeśli zawiera flagę.  
  
 *cyfry ułamkowe*  
 Ciąg cyfr od 0 do 9, które określają część ułamkową liczby. Cyfry ułamkowe mogą występować w `s` przypadku `style` , <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> gdy zawierają flagę.  
  
 E  
 Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym). Parametr może reprezentować liczbę w notacji wykładniczej, <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Jeśli `style` zawiera flagę. `value`  
  
 *cyfry wykładnicze*  
 Ciąg cyfr od 0 do 9, które określają wykładnik potęgi.  
  
> [!NOTE]
> Wszelkie kończące się znaki NUL (U + 0000 `s` ) w programie są ignorowane przez operację analizowania, niezależnie od wartości `style` argumentu.

 Ciąg z tylko cyframi (który odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stylowi) zawsze jest analizowany pomyślnie. Pozostałe <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> elementy członkowskie formantu, które mogą być obecne, ale nie muszą być obecne w ciągu wejściowym. Poniższa tabela wskazuje, w <xref:System.Globalization.NumberStyles> jaki sposób poszczególne flagi wpływają na elementy, które `s`mogą być obecne w.  
  
|Wartość wyliczenia NumberStyles|Elementy dozwolone jako `s` uzupełnienie cyfr|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Tylko elementy *całkowitej* .|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Elementy dziesiętne (*.*) i *cyfry ułamkowe* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Znak „e” lub znak „E”, co oznacza zapis wykładniczy. Ta flaga sama obsługuje wartości w postaci *cyfr*E*cyfr*; dodatkowe flagi są konieczne do pomyślnego przeanalizowania ciągów z takimi elementami jak znaki dodatnie lub ujemne oraz symbole separatora dziesiętnego.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Element *WS* na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Element *WS* na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Element *Sign* na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Element *Sign* na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Element *Sign* w postaci nawiasów otaczających wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Element separatora tysięcznego (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Element określający walutę ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie elementy. `s` Jednak nie może reprezentować liczby szesnastkowej ani liczby w notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Float>|Element *WS* na początku lub na końcu `s`, ** `s`znak na początku i symbol separatora dziesiętnego (.). `s` Parametr może również używać notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|Elementy `ws` ,`sign`, separator tysięcy (,) i separator dziesiętny (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie elementy. `s` Jednak nie może reprezentować liczby szesnastkowej.|  
  
 Oto kilka przykładów `s` "100", "-123 456 789", "123.45 e + 6", "+ 500", "5E2", "3,1416", "600", "-. 123" i "-Infinite".  
  
 Parametr jest analizowany przy użyciu informacji o formatowaniu <xref:System.Globalization.NumberFormatInfo> w obiekcie, który jest zainicjowany dla bieżącej kultury systemowej. `s` Aby określić kulturę, której informacje o formatowaniu są używane dla operacji analizowania, <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Wywołaj Przeciążenie.  
  
 Zwykle w przypadku przekazania <xref:System.Single.Parse%2A> metody do ciągu, który jest tworzony przez <xref:System.Single.ToString%2A> wywołanie metody, zwracana jest oryginalna <xref:System.Single> wartość. Jednak ze względu na utratę precyzji wartości mogą być różne.  
  
 Jeśli w `s` parametrze podczas operacji analizy napotkany jest separator, a odpowiednia waluta lub liczba dziesiętna i separatory grupy są takie same, operacja analizy zakłada, że separator jest separatorem dziesiętnym, a nie grupą rozdzielając. Aby uzyskać więcej informacji na temat separatorów <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>zobacz <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>,, <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>, i.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> metodę, aby przeanalizować <xref:System.Single> reprezentację ciągu wartości. W przykładzie przedstawiono użycie informacji o formatowaniu dla kultury en-US.  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" />nie jest liczbą w prawidłowym formacie.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" />reprezentuje liczbę, która jest mniejsza <see cref="F:System.Single.MinValue" /> lub <see cref="F:System.Single.MaxValue" />równa.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" />nie <see cref="T:System.Globalization.NumberStyles" /> jest wartością.  
  
—lub— 
 <paramref name="style" /><see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> zawiera wartość.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizowanie ciągów liczbowych w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; single" Usage="System.single.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="provider">Obiekt, który dostarcza informacje <paramref name="s" />o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę w określonym formacie specyficznym dla kultury do jego równoważnej liczbie zmiennoprzecinkowej o pojedynczej precyzji.</summary>
        <returns>Liczba zmiennoprzecinkowa o pojedynczej precyzji odpowiadająca wartości liczbowej lub symbolowi określonej <paramref name="s" />w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest zwykle używane do konwertowania tekstu, który można sformatować na różne sposoby <xref:System.Single> . Może na przykład służyć do skonwertowania tekstu wprowadzanego przez użytkownika w polu tekstowym HTML na wartość liczbową.  
  
 Parametr jest interpretowany przy użyciu kombinacji <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> flag i <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>. `s` <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> `provider`Parametr może zawierać ,<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, lub<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> dla kultury określonej przez lub może zawierać ciąg w postaci: `s`  
  
 [*WS*] [*Sign*] *cyfry całkowite* [*.* [*cyfry ułamkowe*]] [E [*Sign*]*cyfry wykładnicze*] [*WS*]  
  
 Elementy opcjonalne są obramowane nawiasami kwadratowymi ([ i ]). Elementy, które zawierają „cyfry”, składają się z serii cyfr od 0 do 9.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Ciąg znaków spacji.|  
|*sign*|Symbol znaku minus (-) lub znaku dodatniego (+).|  
|*integral-digits*|Ciąg cyfr od 0 do 9, które określają jej część całkowitą. Uruchomienia *cyfr całkowitych* mogą być partycjonowane przez symbol separatora grupy. Na przykład w niektórych kulturach przecinek (,) oddziela grupy wartości tysięcznych. Element ** z cyframi całkowitymi może być nieobecny, jeśli ciąg zawiera element *Ułamkowo-cyfr* .|  
|.|Symbol dziesiętny specyficzny dla kultury.|  
|*cyfry ułamkowe*|Ciąg cyfr od 0 do 9, które określają część ułamkową liczby.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym).|  
|*cyfry wykładnicze*|Ciąg cyfr od 0 do 9, które określają wykładnik potęgi.|  
  
 Aby uzyskać więcej informacji na temat formatów liczbowych, zobacz temat [Typy formatowania](~/docs/standard/base-types/formatting-types.md) .  
  
 Parametr jest <xref:System.IFormatProvider.GetFormat%2A> implementacją, której metoda zwraca obiekt,którydostarczainformacjeoformatowaniuspecyficznedlakultury.<xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider> `provider` <xref:System.Type> `provider` <xref:System.IFormatProvider.GetFormat%2A> Gdy metoda jest wywoływana, wywołuje metodę parametru<xref:System.Globalization.NumberFormatInfo> i przekazuje ją do obiektu, który reprezentuje typ. <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> Metoda następnie zwraca obiekt, który zawiera informacje `s` o formacie parametru. <xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider.GetFormat%2A> Istnieją trzy sposoby, aby użyć `provider` parametru w celu dostarczenia niestandardowych informacji o formatowaniu do operacji analizy:  
  
-   Można przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu liczb dla tej kultury.  
  
-   Można przekazać rzeczywisty <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje o formatowaniu liczb. (Jego implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> po prostu zwraca samą siebie).  
  
-   Można przekazać obiekt niestandardowy, który implementuje <xref:System.IFormatProvider>. Metoda tworzy wystąpienia i <xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu. <xref:System.IFormatProvider.GetFormat%2A>  
  
 Jeśli `provider` jest `null` lub<xref:System.Globalization.NumberFormatInfo> nie można uzyskać informacji o formatowaniu dla bieżącej kultury systemu.  
  
 Jeśli w `s` parametrze podczas operacji analizy napotkany jest separator, a odpowiednia waluta lub liczba dziesiętna i separatory grupy są takie same, operacja analizy zakłada, że separator jest separatorem dziesiętnym, a nie grupą rozdzielając. Aby uzyskać więcej informacji na temat separatorów <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>zobacz <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>,, <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>, i.  
  
 Oto kilka przykładów `s` "100", "-123 456 789", "123.45 e + 6", "+ 500", "5E2", "3,1416", "600", "-. 123" i "-Infinite".  
  
   
  
## Examples  
 W poniższym przykładzie występuje program obsługi zdarzeń kliknięcia przycisku w formularzu sieci Web. Używa tablicy zwracanej przez <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> właściwość w celu określenia ustawień regionalnych użytkownika. Następnie tworzy wystąpienie <xref:System.Globalization.CultureInfo> obiektu, który odpowiada tym ustawieniom regionalnym. Obiekt, który należy do tego <xref:System.Globalization.CultureInfo> obiektu, <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> jest następnie przenoszona do metody <xref:System.Single> w celu przekonwertowania danych wejściowych użytkownika na wartość. <xref:System.Globalization.NumberFormatInfo>  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" />nie reprezentuje liczby w prawidłowym formacie.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" />reprezentuje liczbę mniejszą <see cref="F:System.Single.MinValue" /> lub <see cref="F:System.Single.MaxValue" />równą.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizowanie ciągów liczbowych w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Single" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia wskazująca elementy stylu, które mogą być obecne w <paramref name="s" />. Typowa wartość do określenia jest <see cref="F:System.Globalization.NumberStyles.Float" /> połączona <see cref="F:System.Globalization.NumberStyles.AllowThousands" />z.</param>
        <param name="provider">Obiekt, który dostarcza informacje <paramref name="s" />o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę w określonym stylu i formacie specyficznym dla kultury do jego równoważnej liczbie zmiennoprzecinkowej o pojedynczej precyzji.</summary>
        <returns>Liczba zmiennoprzecinkowa o pojedynczej precyzji odpowiadająca wartości liczbowej lub symbolowi określonej <paramref name="s" />w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr definiuje elementy stylu (takie jak odstępy, separatory tysięcy i symbole waluty), które są dozwolone `s` w parametrze dla operacji analizy. `style` Musi to być kombinacja flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. Następujące <xref:System.Globalization.NumberStyles> elementy członkowskie nie są obsługiwane:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> `provider`Parametr może zawierać ,<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, lub<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> dla kultury określonej przez. `s` W zależności od wartości `style`, może również mieć postać:  
  
 [*WS*] [*$*] [*Sign*] [*cyfry całkowite*],*cyfry całkowite*[. [ *cyfry ułamkowe*]] [E [*Sign*]*cyfry wykładnicze*] [*WS*]  
  
 Elementy w nawiasach kwadratowych ([i]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Ciąg znaków spacji. Biały znak może pojawić się na początku `s` , `style` jeśli zawiera <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę i może <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> pojawić się na końcu elementu `s` if `style` zawiera flagę.|  
|$|Symbol waluty specyficzny dla kultury. Jego pozycja w ciągu jest definiowana przez <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> właściwości i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> bieżącej kultury. Symbol waluty bieżącej kultury może pojawić się w `s` , `style` <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*sign*|Symbol znaku minus (-) lub znaku dodatniego (+). Znak `s` może występować na początku, jeśli `style` zawiera <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę `s` i może <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> być wyświetlany na końcu, jeśli `style` zawiera flagę. Nawiasów można używać w `s` celu wskazania wartości ujemnej, <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Jeśli `style` zawiera flagę.|  
|*integral-digits*|Ciąg cyfr od 0 do 9, które określają jej część całkowitą. Element ** z cyframi całkowitymi może być nieobecny, jeśli ciąg zawiera element *Ułamkowo-cyfr* .|  
|,|Separator grupy specyficzny dla kultury. Symbol separatora grupy bieżącej kultury może pojawić się `s` w `style` przypadku, <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> gdy zawiera flagę|  
|.|Symbol dziesiętny specyficzny dla kultury. Symbol dziesiętny bieżącej kultury może pojawić się w `s` , `style` <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*cyfry ułamkowe*|Ciąg cyfr od 0 do 9, które określają część ułamkową liczby. Cyfry ułamkowe mogą występować w `s` przypadku `style` , <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> gdy zawierają flagę.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym). Parametr może reprezentować liczbę w notacji wykładniczej, <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Jeśli `style` zawiera flagę. `s`|  
|*cyfry wykładnicze*|Ciąg cyfr od 0 do 9, które określają wykładnik potęgi.|  
  
> [!NOTE]
> Wszelkie kończące się znaki NUL (U + 0000 `s` ) w programie są ignorowane przez operację analizowania, niezależnie od wartości `style` argumentu.

 Ciąg z tylko cyframi (który odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stylowi) zawsze jest analizowany pomyślnie. Pozostałe <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> elementy członkowskie formantu, które mogą być obecne, ale nie muszą być obecne w ciągu wejściowym. Poniższa tabela wskazuje, w <xref:System.Globalization.NumberStyles> jaki sposób poszczególne flagi wpływają na elementy, które `s`mogą być obecne w.  
  
|Wartość wyliczenia NumberStyles|Elementy dozwolone jako `s` uzupełnienie cyfr|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Tylko elementy *całkowitej* .|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Elementy dziesiętne (*.*) i *cyfry ułamkowe* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Znak „e” lub znak „E”, co oznacza zapis wykładniczy. Ta flaga sama obsługuje wartości w postaci *cyfr*E*cyfr*; dodatkowe flagi są konieczne do pomyślnego przeanalizowania ciągów z takimi elementami jak znaki dodatnie lub ujemne oraz symbole separatora dziesiętnego.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Element *WS* na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Element *WS* na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Element *Sign* na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Element *Sign* na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Element *Sign* w postaci nawiasów otaczających wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Element separatora tysięcznego (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Element określający walutę ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie elementy. `s` Jednak nie może reprezentować liczby szesnastkowej ani liczby w notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Float>|Element *WS* na początku lub na końcu `s`, ** `s`znak na początku i symbol separatora dziesiętnego (.). `s` Parametr może również używać notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|Elementy `ws` ,`sign`, separator tysięcy (,) i separator dziesiętny (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie elementy. `s` Jednak nie może reprezentować liczby szesnastkowej.|  
  
 `provider` Parametr<xref:System.IFormatProvider> jest implementacją. Jego <xref:System.IFormatProvider.GetFormat%2A> Metoda `value`zwraca obiekt, który zawiera informacje specyficzne dla kultury o formacie. <xref:System.Globalization.NumberFormatInfo> `provider` Zwykle może to być jeden z następujących:  
  
-   <xref:System.Globalization.CultureInfo> Obiekt, który reprezentuje kulturę, która zawiera informacje o formatowaniu liczb. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu liczb.  
  
-   <xref:System.Globalization.NumberFormatInfo> Obiekt, który zawiera informacje o formatowaniu. (Jego implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> po prostu zwraca samą siebie).  
  
-   Obiekt niestandardowy, który implementuje <xref:System.IFormatProvider> i <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> używa metody <xref:System.Globalization.NumberFormatInfo> do tworzenia wystąpienia i zwracania obiektu, który dostarcza informacje o formatowaniu.  
  
 Jeśli `provider` jest `null` ,<xref:System.Globalization.NumberFormatInfo> używany jest obiekt dla bieżącej kultury.  
  
 Jeśli w `s` parametrze podczas operacji analizy napotkany jest separator, a odpowiednia waluta lub liczba dziesiętna i separatory grupy są takie same, operacja analizy zakłada, że separator jest separatorem dziesiętnym, a nie grupą rozdzielając. Aby uzyskać więcej informacji na temat separatorów <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>zobacz <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>,, <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>, i.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metody do analizowania ciągu <xref:System.Single> reprezentacji wartości. Każdy ciąg w tablicy jest analizowany przy użyciu Konwencji formatowania en-US, NL-NL i niestandardowa kultura. Niestandardowa kultura definiuje swój symbol separatora grupy jako znak podkreślenia ("_") i jego rozmiar grupy jako dwa.  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" />nie reprezentuje wartości liczbowej.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" />nie <see cref="T:System.Globalization.NumberStyles" /> jest wartością.  
  
—lub— 
 <paramref name="style" /><see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> jest wartością.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" />reprezentuje liczbę, która jest mniejsza <see cref="F:System.Single.MinValue" /> lub <see cref="F:System.Single.MaxValue" />równa.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizowanie ciągów liczbowych w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Single  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : single" Usage="System.single.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Reprezentuje nieskończoność dodatnią. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest wynikiem dzielenia liczby dodatniej przez zero.  
  
 Ta stała jest zwracana, gdy wynik operacji jest większy niż <xref:System.Single.MaxValue>.  
  
 Użyj <xref:System.Single.IsPositiveInfinity%2A> , aby określić, czy wartość jest równa nieskończoności dodatniej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Single.PositiveInfinity> stałą.  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />Zobacz.</summary>
        <returns><see langword="true" />Jeśli wartość bieżącego wystąpienia nie jest równa zero; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Single> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Single> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia tej metody <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Ta konwersja nie jest obsługiwana. Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia tej metody <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Ta konwersja nie jest obsługiwana. Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Single> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.Double" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Single> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Single> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Single> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Single> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Single> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Single> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Typ, do którego ma zostać przekonwertowana ta <see cref="T:System.Single" /> wartość.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formacie zwracanej wartości.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Single> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie `static` metody (`Shared` w Visual Basic). <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Single> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Single> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Single> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="single.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu.</summary>
        <returns>Ciąg reprezentujący wartość tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString> Metoda formatujewartośćwformaciedomyślnym("G"lubogólnym<xref:System.Single> ) bieżącej kultury. Jeśli chcesz określić inny format lub kulturę, użyj innych przeciążeń <xref:System.Single.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Domyślny format ("G")|Określona kultura|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Określony format|Domyślna kultura (bieżąca)|<xref:System.Single.ToString%28System.String%29>|  
|Określony format|Określona kultura|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Wartością zwracaną może być <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>lub ciąg w postaci:  
  
 [znak]cyfry-całkowite[.[cyfry-ułamkowe]][e[znak]cyfry-wykładnicze]  
  
 Elementy opcjonalne są obramowane nawiasami kwadratowymi ([ i ]). Elementy, które zawierają „cyfry”, składają się z serii cyfr od 0 do 9. W poniższej tabeli wymieniono każdy element:  
  
|Element|Opis|  
|-------------|-----------------|  
|*sign*|Znak ujemny lub symbol znaku dodatniego.|  
|*integral-digits*|Ciąg cyfr określający część całkowitą liczby. Cyfry całkowite mogą być nieobecne w przypadku cyfr ułamkowych.|  
|'.'|Symbol dziesiętny specyficzny dla kultury.|  
|*cyfry ułamkowe*|Ciąg cyfr określający część ułamkową liczby.|  
|adres|Mała litera „e”, wskazująca zapis wykładniczy (naukowy).|  
|*cyfry wykładnicze*|Ciąg cyfr określające wykładnik potęgi.|  
  
 Oto kilka przykładów zwracanej wartości: „100”, „-123,456,789”, „123.45e + 6”, „500”, „3.1416”, „600”, „-0.123” i „-nieskończoność”.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów liczb niestandardowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano metodę <xref:System.Single.ToString%2A?displayProperty=nameWithType> domyślną, aby wyświetlić reprezentację ciągu dla <xref:System.Single> wielu wartości.  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 Poniższy przykład kodu ilustruje użycie <xref:System.Single.Parse%28System.String%29> metody wraz <xref:System.Single.ToString> z metodą.  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="single.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu przy użyciu podanych danych formatowania specyficznych dla kultury.</summary>
        <returns>Ciąg reprezentujący wartość tego wystąpienia określony przez <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.IFormatProvider%29> Metoda formatujewartośćwformaciedomyślnym("G"lubogólnym<xref:System.Single> ) określonej kultury. Jeśli chcesz określić inny format lub bieżącą kulturę, użyj innych przeciążeń <xref:System.Single.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Domyślny format ("G")|Domyślna kultura (bieżąca)|<xref:System.Single.ToString>|  
|Określony format|Domyślna kultura (bieżąca)|<xref:System.Single.ToString%28System.String%29>|  
|Określony format|Określona kultura|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Wartością zwracaną może być <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>lub ciąg w postaci:  
  
 [znak]cyfry-całkowite[.[cyfry-ułamkowe]][e[znak]cyfry-wykładnicze]  
  
 Elementy opcjonalne są obramowane nawiasami kwadratowymi ([ i ]). Elementy zawierające termin "cyfry" składają się z serii znaków numerycznych od 0 do 9. W poniższej tabeli wymieniono poszczególne elementy.  
  
|Element|Opis|  
|-------------|-----------------|  
|znak|Znak ujemny lub symbol znaku dodatniego.|  
|cyfry-całkowite|Ciąg cyfr określający część całkowitą liczby. Cyfry całkowite mogą być nieobecne w przypadku cyfr ułamkowych.|  
|'.'|Symbol dziesiętny specyficzny dla kultury.|  
|cyfry-ułamkowe|Ciąg cyfr określający część ułamkową liczby.|  
|adres|Mała litera „e”, wskazująca zapis wykładniczy (naukowy).|  
|cyfry-wykładnicze|Ciąg cyfr określające wykładnik potęgi.|  
  
 Oto kilka przykładów zwracanej wartości: „100”, „-123,456,789”, „123.45e + 6”, „500”, „3.1416”, „600”, „-0.123” i „-nieskończoność”.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów liczb niestandardowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Parametr jest <xref:System.IFormatProvider> implementacją<xref:System.IFormatProvider.GetFormat%2A> , której metoda zwraca obiekt.<xref:System.Globalization.NumberFormatInfo> `provider` `provider` Zazwyczaj <xref:System.Globalization.NumberFormatInfo> jest obiektemlubobiektem.<xref:System.Globalization.CultureInfo> `provider` Parametr dostarcza informacje specyficzne dla kultury używane w formatowaniu. Jeśli `provider` jest `null` ,<xref:System.Globalization.NumberFormatInfo> wartość zwracana jest formatowana przy użyciu danych dla bieżącej kultury.  
  
 Aby przekonwertować <xref:System.Single> wartość na reprezentację ciągu przy użyciu określonej kultury i określonego ciągu formatu, <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Wywołaj metodę.  
  
   
  
## Examples  
 Poniższy przykład wyświetla ciąg reprezentujący dwie <xref:System.Single> wartości przy użyciu <xref:System.Globalization.CultureInfo> obiektów, które reprezentują kilka różnych kultur.  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="single.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu liczbowego.</param>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu przy użyciu podanego formatu.</summary>
        <returns>Ciąg reprezentujący wartość tego wystąpienia określony przez <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.String%29> Metoda formatujewartośćwokreślonymformacieprzy<xref:System.Single> użyciu Konwencji bieżącej kultury. Jeśli chcesz użyć domyślnego formatu ("G" lub ogólnego) lub określić inną kulturę, użyj innych przeciążeń <xref:System.Single.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Domyślny format ("G")|Domyślna kultura (bieżąca)|<xref:System.Single.ToString>|  
|Domyślny format ("G")|Określona kultura|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Określony format|Określona kultura|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Wartością zwracaną może być <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>lub reprezentację ciągu wartości bieżącego wystąpienia, określoną przez `format`.  
  
 `format` Parametr może być dowolnym prawidłowym standardowym specyfikatorem formatu liczbowego z wyjątkiem D i X, a także dowolną kombinacją niestandardowych specyfikatorów formatu liczbowego. Jeśli format jest `null` lub pusty ciąg, wartość zwracana jest formatowana przy użyciu ogólnego specyfikatora formatu liczbowego ("G").  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów liczb niestandardowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Domyślnie wartość zwracana zawiera tylko 7 cyfr precyzji, chociaż w wewnętrznej liczbie są przechowywane maksymalnie 9 cyfr. Jeśli wartość tego wystąpienia ma więcej niż 7 cyfr, <xref:System.Single.ToString%28System.String%29> zwraca <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> lub <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> zamiast oczekiwanej liczby. Jeśli potrzebujesz większej dokładności, określ `format` wartość w formacie "G9", która zawsze zwraca 9 cyfr precyzji lub "R", która zwraca 7 cyfr, jeśli liczba może być reprezentowana z dokładnością lub 9 cyfr, jeśli liczba może być reprezentowana tylko z maksymalną dokładnością.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wartość liczbową i formatuje ją jako wartość walutową przy użyciu standardowego ciągu formatu liczbowego "C" i jako wartość liczbowa do trzech miejsc dziesiętnych przy użyciu standardowego ciągu formatu liczbowego "N". Ciągi wynikowe są formatowane przy użyciu Konwencji kultury en-US. Aby uzyskać więcej informacji na temat ciągów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów](~/docs/standard/base-types/custom-numeric-format-strings.md)liczbowych.  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 Poniższy przykład wyświetla kilka <xref:System.Single> wartości przy użyciu każdego z obsługiwanych standardowych specyfikatorów formatu liczbowego wraz z dwoma niestandardowymi ciągami formatu liczb. Jeden z tych ciągów formatu niestandardowego ilustruje sposób uzupełniania <xref:System.Single> wartości zerami wiodącymi. W celu przeliczenia wartości liczbowych na ciągi w przykładzie użyto konwencji formatowania kultury en-US.  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Instrukcje: Uzupełnianie liczby zerami wiodącymi</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="single.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu liczbowego.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu przy użyciu podanego formatu i informacji specyficznych dla kultury.</summary>
        <returns>Ciąg reprezentujący wartość tego wystąpienia określony przez <paramref name="format" /> i. <paramref name="provider" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29> Metoda formatujewartośćw<xref:System.Single> określonym formacie określonej kultury. Jeśli chcesz użyć domyślnego formatu lub ustawień kultury, użyj innych przeciążeń <xref:System.Single.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Domyślny format ("G")|Domyślna kultura (bieżąca)|<xref:System.Single.ToString>|  
|Domyślny format ("G")|Określona kultura|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Określony format|Domyślna kultura (bieżąca)|<xref:System.Single.ToString%28System.String%29>|  
  
 Wartością zwracaną może być <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>lub reprezentację ciągu wartości bieżącego wystąpienia, określoną przez `format`.  
  
 `format` Parametr może być dowolnym prawidłowym standardowym specyfikatorem formatu liczbowego z wyjątkiem D i X, a także dowolną kombinacją niestandardowych specyfikatorów formatu liczbowego. Jeśli `format` jest `null` lub jest pustym ciągiem, wartość zwracana dla tego wystąpienia jest formatowana przy użyciu ogólnego specyfikatora formatu liczbowego ("G").  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów liczb niestandardowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Parametr jest <xref:System.IFormatProvider> implementacją<xref:System.IFormatProvider.GetFormat%2A> , której metoda zwraca obiekt.<xref:System.Globalization.NumberFormatInfo> `provider` `provider` Zazwyczaj <xref:System.Globalization.NumberFormatInfo> jest obiektemlubobiektem.<xref:System.Globalization.CultureInfo> `provider` Parametr dostarcza informacje specyficzne dla kultury używane w formatowaniu. Jeśli `provider` jest `null` ,<xref:System.Globalization.NumberFormatInfo> wartość zwracana jest formatowana przy użyciu obiektu dla bieżącej kultury.  
  
 Domyślnie wartość zwracana zawiera tylko 7 cyfr precyzji, chociaż w wewnętrznej liczbie są przechowywane maksymalnie 9 cyfr. Jeśli wartość tego wystąpienia ma więcej niż 7 cyfr, <xref:System.Single.ToString%2A> zwraca <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> lub <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> zamiast oczekiwanej liczby. Jeśli potrzebujesz większej dokładności, określ `format` wartość w formacie "G9", która zawsze zwraca 9 cyfr precyzji lub "R", która zwraca 7 cyfr, jeśli liczba może być reprezentowana z dokładnością lub 9 cyfr, jeśli liczba może być reprezentowana tylko z maksymalną dokładnością.  
  
   
  
## Examples  
 Poniższy przykład wyświetla <xref:System.Single> wartość przy użyciu każdego z obsługiwanych standardowych specyfikatorów formatu liczbowego dla kilku różnych kultur.  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Instrukcje: Uzupełnianie liczby zerami wiodącymi</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="single.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje ciąg reprezentujący liczbę na odpowiadającą mu liczbę zmiennoprzecinkową pojedynczej precyzji. Zwracana wartość wskazuje, czy konwersja powiodła się czy nie.</summary>
        <altmember cref="Overload:System.Single.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg reprezentujący liczbę do przekonwertowania.</param>
        <param name="result">Gdy ta metoda zwraca, zawiera liczbę zmiennoprzecinkową o pojedynczej precyzji odpowiadającą wartości liczbowej lub symbolowi <paramref name="s" />zawartemu w, jeśli konwersja zakończyła się powodzeniem, lub zero, jeśli konwersja nie powiodła się. Konwersja nie powiedzie się <paramref name="s" /> , jeśli <see langword="null" /> parametr <see cref="F:System.String.Empty" />ma wartość lub, nie jest liczbą w prawidłowym <see cref="F:System.Single.MinValue" /> formacie lub <see cref="F:System.Single.MaxValue" />reprezentuje liczbę mniejszą lub równą. Ten parametr jest przekazaniem niezainicjowanym; Każda wartość pokazana w <paramref name="result" /> programie zostanie nadpisywana.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę na odpowiadającą mu liczbę zmiennoprzecinkową pojedynczej precyzji. Zwracana wartość wskazuje, czy konwersja powiodła się czy nie.</summary>
        <returns><see langword="true" />Jeśli <paramref name="s" /> został przekonwertowany pomyślnie; w <see langword="false" />przeciwnym razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie różni się od <xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType> metody przez zwrócenie wartości logicznej wskazującej, czy operacja analizy zakończyła się powodzeniem, zamiast zwracać przeanalizowanej wartości liczbowej. Eliminuje to konieczność użycia obsługi wyjątków do testowania dla <xref:System.FormatException> zdarzenia, które `s` jest nieprawidłowe i nie można go pomyślnie przeanalizować.  
  
 Parametr może zawierać <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> ,<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> (porównanie ciągów jest rozróżniana wielkość liter) lub ciąg w postaci: `s`  
  
 WS zapis [cyfry całkowite], cyfry całkowite [. [ cyfry ułamkowe]] [e [sign] cyfry wykładnicze] [ws]  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Ciąg znaków spacji.|  
|*sign*|Znak ujemny lub symbol znaku dodatniego.|  
|*integral-digits*|Szereg znaków numerycznych od 0 do 9, które określają integralną część liczby. Cyfry całkowite mogą być nieobecne w przypadku cyfr ułamkowych.|  
|*,*|Symbol separatora grupy specyficzny dla kultury.|  
|*.*|Symbol dziesiętny specyficzny dla kultury.|  
|*cyfry ułamkowe*|Szereg znaków numerycznych od 0 do 9, które określają część ułamkową liczby.|  
|*E*|Wielkie lub małe litery "e", które oznacza notację wykładniczą (naukową).|  
|*cyfry wykładnicze*|Seria znaków numerycznych od 0 do 9, które określają wykładnik.|  
  
 Parametr jest interpretowany przy użyciu kombinacji <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> flag i <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>. `s` Oznacza to, że biały znak i separatory tysięczne są dozwolone, ale symbole walut nie. Aby jawnie zdefiniować elementy (takie jak symbole waluty, separatory tysięcy i białe znaki), które mogą być obecne w `s`, <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> Użyj przeciążenia metody.  
  
 Parametr jest analizowany przy użyciu informacji o formatowaniu <xref:System.Globalization.NumberFormatInfo> w obiekcie, który jest zainicjowany dla bieżącej kultury systemowej. `s` Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Aby przeanalizować ciąg przy użyciu informacji o formatowaniu innej określonej kultury, użyj <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> przeciążenia metody.  
  
 Zwykle w przypadku przekazania <xref:System.Single.TryParse%2A?displayProperty=nameWithType> metody do ciągu, który jest tworzony przez <xref:System.Single.ToString%2A?displayProperty=nameWithType> wywołanie metody, zwracana jest oryginalna <xref:System.Single> wartość. Jednak ze względu na utratę precyzji wartości mogą być różne.  
  
 Jeśli w `s` parametrze podczas operacji analizy napotkany jest separator, a odpowiednia waluta lub liczba dziesiętna i separatory grupy są takie same, operacja analizy zakłada, że separator jest separatorem dziesiętnym, a nie grupą rozdzielając. Aby uzyskać więcej informacji na temat separatorów <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>zobacz <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>,, <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>, i.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29> metodę, aby przekonwertować ciąg reprezentujący wartości liczbowe na <xref:System.Single> wartości. Przyjęto założenie, że pl-US jest bieżącą kulturą.  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizowanie ciągów liczbowych w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg reprezentujący liczbę do przekonwertowania.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia wskazująca dozwolony format <paramref name="s" />. Typowa wartość do określenia jest <see cref="F:System.Globalization.NumberStyles.Float" /> połączona <see cref="F:System.Globalization.NumberStyles.AllowThousands" />z.</param>
        <param name="provider">Obiekt, który dostarcza informacje <paramref name="s" />o formatowaniu specyficzne dla kultury.</param>
        <param name="result">Gdy ta metoda zwraca, zawiera liczbę zmiennoprzecinkową o pojedynczej precyzji odpowiadającą wartości liczbowej lub symbolowi zawartemu w <paramref name="s" />, jeśli konwersja zakończyła się powodzeniem, lub zero, jeśli konwersja nie powiodła się. Konwersja nie powiedzie się <paramref name="s" /> , jeśli <see langword="null" /> parametr <see cref="F:System.String.Empty" />ma wartość lub, nie jest w formacie <paramref name="style" /> <see cref="F:System.Single.MinValue" /> zgodnym z, reprezentuje liczbę mniejszą lub równą <see cref="F:System.Single.MaxValue" />lub jeśli <paramref name="style" /> wartość nie jest prawidłowa kombinacja stałych <see cref="T:System.Globalization.NumberStyles" /> wyliczeniowych. Ten parametr jest przekazaniem niezainicjowanym; Każda wartość pokazana w <paramref name="result" /> programie zostanie nadpisywana.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę w określonym stylu i formacie specyficznym dla kultury do jego równoważnej liczbie zmiennoprzecinkowej o pojedynczej precyzji. Zwracana wartość wskazuje, czy konwersja powiodła się czy nie.</summary>
        <returns><see langword="true" />Jeśli <paramref name="s" /> został przekonwertowany pomyślnie; w <see langword="false" />przeciwnym razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie różni się od <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metody przez zwrócenie wartości logicznej wskazującej, czy operacja analizy zakończyła się powodzeniem, zamiast zwracać przeanalizowanej wartości liczbowej. Eliminuje to konieczność użycia obsługi wyjątków do testowania dla <xref:System.FormatException> zdarzenia, które `s` jest nieprawidłowe i nie można go pomyślnie przeanalizować.  
  
 Parametr definiuje dozwolony format `s` parametru, aby operacja analizy powiodła się. `style` Musi to być kombinacja flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. Następujące <xref:System.Globalization.NumberStyles> elementy członkowskie nie są obsługiwane:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> `provider`Parametr może zawierać ,<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> ,<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> dla kultury wskazanej przez. `s` Ponadto, w zależności od wartości `style` `s` , parametr może zawierać następujące elementy:  
  
 WS [$] zapis [cyfry całkowite], cyfry całkowite [. Ułamkowo-cyfry] [e [sign] cyfry wykładnicze] [ws]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp. Biały znak może pojawić się na początku `s` , `style` jeśli zawiera <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę. Może pojawić się na końcu `s` , jeśli `style` zawiera <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagę.|  
|*$*|Symbol waluty specyficzny dla kultury. Jego pozycja w ciągu jest definiowana przez <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> lub <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> właściwości <xref:System.Globalization.NumberFormatInfo> obiektu zwróconego przez <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> metodę `provider` parametru. Symbol waluty może pojawić się `s` w `style` , <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*sign*|Opcjonalny znak. Znak `s` może występować na początku, jeśli `style` zawiera <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę `s` i może <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> być wyświetlany na końcu, jeśli `style` zawiera flagę. Nawiasów można używać w `s` celu wskazania wartości ujemnej, <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Jeśli `style` zawiera flagę.|  
|*integral-digits*|Ciąg cyfr od 0 do 9, które określają jej część całkowitą. Cyfry całkowite mogą być nieobecne w przypadku cyfr ułamkowych.|  
|*,*|Symbol separatora tysięcy specyficzny dla kultury. Symbol separatora tysięcy bieżącej kultury może pojawić się `s` w `style` , <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*.*|Symbol dziesiętny specyficzny dla kultury. Symbol dziesiętny bieżącej kultury może pojawić się w `s` , `style` <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*cyfry ułamkowe*|Ciąg cyfr od 0 do 9, które określają część ułamkową liczby. Cyfry ułamkowe mogą występować w `s` przypadku `style` , <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> gdy zawierają flagę.|  
|*e*|Znak e lub e, który wskazuje, że `s` może reprezentować liczbę przy użyciu notacji wykładniczej. Parametr może reprezentować liczbę w notacji wykładniczej, jeśli <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> styl zawiera flagę. `s`|  
|*cyfry wykładnicze*|Ciąg cyfr od 0 do 9, które określają wykładnik potęgi.|  
  
> [!NOTE]
> Wszelkie kończące się znaki NUL (U + 0000 `s` ) w programie są ignorowane przez operację analizowania, niezależnie od wartości `style` argumentu.

 Ciąg z tylko cyframi (który odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stylowi) zawsze jest analizowany pomyślnie. Pozostałe <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> elementy członkowskie kontrolki, które mogą być, ale nie muszą być obecne w ciągu wejściowym. Poniższa tabela wskazuje, w <xref:System.Globalization.NumberStyles> jaki sposób poszczególne flagi wpływają na elementy, które `s`mogą być obecne w.  
  
|Wartość wyliczenia NumberStyles|Dodatkowe (poza cyframi) elementy dozwolone w parametrze s|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Tylko elementy *całkowitej* .|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|*.* i *cyfry ułamkowe* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s` Parametr może również używać notacji wykładniczej. Ta flaga sama obsługuje wartości w postaci cyfr *całkowitych*E *-* cyfrowych. dodatkowe flagi są konieczne, aby pomyślnie analizować ciągi w notacji wykładniczej z takimi elementami jak znaki dodatnie lub ujemne oraz symbole cyfr dziesiętnych.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Element *WS* na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Element *WS* na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Element *Sign* na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Element *Sign* na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Element *Sign* w postaci nawiasów otaczających wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Element *,* .|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|*$* Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie. `s` Parametr nie może reprezentować liczby szesnastkowej ani liczby w notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Float>|Element *WS* na początku lub na `s`końcu, ** `s`znak na początku i *.* symbol. `s` Parametr może również używać notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|Elementy `ws` ,`sign`, separator tysięcy (*,)* i punkty dziesiętne (*.*).|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie style, z `s` wyjątkiem nie mogą reprezentować liczby szesnastkowej.|  
  
 Parametr jest <xref:System.IFormatProvider.GetFormat%2A> implementacją, której metoda zwraca obiekt,którydostarczainformacjeoformatowaniuspecyficznedlakultury.<xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider> `provider` <xref:System.Type> `provider` <xref:System.IFormatProvider.GetFormat%2A> Gdy metoda jest wywoływana, wywołuje metodę parametru<xref:System.Globalization.NumberFormatInfo> i przekazuje ją do obiektu, który reprezentuje typ. <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> Metoda następnie zwraca obiekt, który zawiera informacje `s` o formacie parametru. <xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider.GetFormat%2A> Istnieją trzy sposoby, aby użyć `provider` parametru w celu dostarczenia niestandardowych informacji o formatowaniu do operacji analizy:  
  
-   Można przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu liczb dla tej kultury.  
  
-   Można przekazać rzeczywisty <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje o formatowaniu liczb. (Jego implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> po prostu zwraca samą siebie).  
  
-   Można przekazać obiekt niestandardowy, który implementuje <xref:System.IFormatProvider>. Metoda tworzy wystąpienia i <xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu. <xref:System.IFormatProvider.GetFormat%2A>  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.NumberFormatInfo> formatowanie `s` jest interpretowane na podstawie obiektu bieżącej kultury.  
  
 Jeśli w `s` parametrze podczas operacji analizy napotkany jest separator, a odpowiednia waluta lub liczba dziesiętna i separatory grupy są takie same, operacja analizy zakłada, że separator jest separatorem dziesiętnym, a nie grupą rozdzielając. Aby uzyskać więcej informacji na temat separatorów <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>zobacz <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>,, <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>, i.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType> metody do analizowania ciągu reprezentującego liczby mające określony styl i są formatowane przy użyciu konwencji określonej kultury.  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" />nie <see cref="T:System.Globalization.NumberStyles" /> jest wartością.  
  
—lub— 
 <paramref name="style" /><see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> jest wartością.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizowanie ciągów liczbowych w programie .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="ResolveEventArgs" FullName="System.ResolveEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="76d4ee17a80d107d2454484d8498d79b8e36b598" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39809955" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ResolveEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ResolveEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.ResolveEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class ResolveEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResolveEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type ResolveEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia dane dla modułu ładującego rozwiązywania zdarzeń, takich jak <see cref="E:System.AppDomain.TypeResolve" />, <see cref="E:System.AppDomain.ResourceResolve" />, <see cref="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />, i <see cref="E:System.AppDomain.AssemblyResolve" /> zdarzenia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy moduł ładujący nie można rozpoznać odwołania do zestawu i program obsługi zostało dostarczone dla zdarzenia rozpoznawania odpowiedniego modułu ładującego, zdarzenie jest wywoływane i <xref:System.ResolveEventArgs> zawiera informacje na temat elementu rozwiązania.  
  
-   <xref:System.ResolveEventArgs.Name%2A> Właściwość zawiera nazwę elementu rozwiązania.  
  
-   Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A> właściwość zawiera zestaw, który zażądał zestawu, który może zapewnić nazwanego elementu. Aby uzyskać więcej informacji, zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A> właściwości.  
  
 ]]></format>
    </remarks>
    <altmember cref="E:System.AppDomain.TypeResolve" />
    <altmember cref="E:System.AppDomain.ResourceResolve" />
    <altmember cref="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
    <altmember cref="E:System.AppDomain.AssemblyResolve" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ResolveEventArgs" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResolveEventArgs (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ResolveEventArgs.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResolveEventArgs(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new ResolveEventArgs : string -&gt; ResolveEventArgs" Usage="new System.ResolveEventArgs name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu w celu rozwiązania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ResolveEventArgs" /> klasy, określając nazwę elementu do rozwiązania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest zazwyczaj wywoływana tylko przez środowisko uruchomieniowe języka wspólnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResolveEventArgs (string name, System.Reflection.Assembly requestingAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Reflection.Assembly requestingAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ResolveEventArgs.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, requestingAssembly As Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResolveEventArgs(System::String ^ name, System::Reflection::Assembly ^ requestingAssembly);" />
      <MemberSignature Language="F#" Value="new ResolveEventArgs : string * System.Reflection.Assembly -&gt; ResolveEventArgs" Usage="new System.ResolveEventArgs (name, requestingAssembly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="requestingAssembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu w celu rozwiązania.</param>
        <param name="requestingAssembly">Zestaw, do którego zależności jest rozwiązywany.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ResolveEventArgs" /> klasy, określając nazwę elementu, aby rozwiązać i zestawu, którego zależności jest rozwiązywany.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ResolveEventArgs.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.ResolveEventArgs.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę elementu do rozwiązania.</summary>
        <value>Nazwa elementu, aby rozwiązać.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać <xref:System.AppDomain.AssemblyResolve> zdarzenia <xref:System.ResolveEventArgs.Name%2A> to nazwa zestawu, przed zastosowaniem zasad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestingAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly RequestingAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly RequestingAssembly" />
      <MemberSignature Language="DocId" Value="P:System.ResolveEventArgs.RequestingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RequestingAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Assembly ^ RequestingAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestingAssembly : System.Reflection.Assembly" Usage="System.ResolveEventArgs.RequestingAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestaw, w których zależności jest rozwiązywany.</summary>
        <value>Zestaw, który zażądał element określony przez <see cref="P:System.ResolveEventArgs.Name" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw, który jest zwracany przez tę właściwość to zestaw, który nie mógł rozwiązać elementu określonego przez <xref:System.ResolveEventArgs.Name%2A> właściwość, ponieważ element nie istnieje w tym zestawie wszystkich załadowanych zależności lub jakieś zależności, moduł ładujący można znaleźć za pomocą sondowania.  
  
 Na przykład, załóżmy, że bieżący używa zestawu <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> metodę, aby załadować zestawu A z katalogu poza badania ścieżki, aby można było używać klasy urzędu certyfikacji. Załóżmy, że dalsze tej klasy urząd certyfikacji korzysta z klasy CB, w zestawie B i że zestawu A kompilacji odwołuje się do zestawu B, również znajdujących się poza ścieżkę badania. Jeśli bieżący zestaw próbuje utworzyć wystąpienie urzędu certyfikacji, moduł ładujący próbuje rozpoznać odwołania do zestawu B. Jednak ponieważ zestawu A został załadowany za pomocą <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> metody, moduł ładujący nie można rozpoznać zależności. W przypadku obsługi dla <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzenie, zdarzenie jest zgłaszane, a <xref:System.ResolveEventArgs.RequestingAssembly%2A> właściwości wynikające <xref:System.ResolveEventArgs> obiekt zawiera zestawu A, ponieważ zestaw A jest zestaw, brakuje zależności.  
  
 Semantyka <xref:System.ResolveEventArgs.RequestingAssembly%2A> właściwości różnią się w zależności od tego, jak żądania zestaw został załadowany:  
  
-   Kontekst ładowania: wartość właściwości może być `null`. Kontekst ładowania jest niezależny od kolejności ładowania i tożsamość żądania zestaw nie jest koniecznie zrozumiałe. Przykład inną niż null występuje, gdy <xref:System.Type.GetType%2A?displayProperty=nameWithType> metoda jest wywoływana i określony typ nie jest znany dla żądania zestawu lub dowolną z jego zależności.  
  
-   Kontekst Load-from: właściwość może służyć jako wskazówkę dotyczącą sondowania, ale program obsługi zdarzeń nie powinien pobrać więcej niż jedno żądanie nazwę danego zestawu.  
  
-   Brak kontekstu (oznacza to, że żądania zestaw został załadowany za pomocą <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> metody, lub jako strumień bajtów lub w trybie mieszanym): można użyć programu obsługi <xref:System.ResolveEventArgs.RequestingAssembly%2A> na podstawie właściwości, które można załadować różne implementacje tego samego zestawu z tożsamością żądanie zestawu.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.AppDomain.TypeResolve" />
        <altmember cref="E:System.AppDomain.ResourceResolve" />
        <altmember cref="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
        <altmember cref="E:System.AppDomain.AssemblyResolve" />
      </Docs>
    </Member>
  </Members>
</Type>
<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Random.xml" source-language="en-US" target-language="pl-PL">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5601795a307b1570fa0290d626c624db4c949b72e.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">601795a307b1570fa0290d626c624db4c949b72e</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.</source>
          <target state="translated">Reprezentuje pseudolosowego generatora liczb, który to urządzenie, które tworzy sekwencję liczb, które spełniają określone wymagania statystyczne losowości.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Pseudo-random numbers are chosen with equal probability from a finite set of numbers.</source>
          <target state="translated">Numery pseudolosowego można wybrać z równym prawdopodobieństwem skończoną zbioru liczb.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.</source>
          <target state="translated">Wybrany liczby nie są losowy, ponieważ matematyczne algorytm jest używany do wybierania je, ale są one dostatecznie losowe do celów praktycznych.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The current implementation of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.</source>
          <target state="translated">Bieżąca implementacja <ph id="ph1">&lt;xref:System.Random&gt;</ph> klasy jest oparta na zmodyfikowanej wersji Donalda E. Knuth subtraktywne generator algorytmu liczb.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For more information, see D. E.</source>
          <target state="translated">Aby uzyskać więcej informacji zobacz D. E.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Knuth.</source>
          <target state="translated">Knuth.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">*</bpt>The Art of Computer Programming, Volume 2: Seminumerical Algorithms<ept id="p1">*</ept>.</source>
          <target state="translated"><bpt id="p1">*</bpt>Kompozycji programistycznych wolumin 2: Seminumerical algorytmy<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Addison-Wesley, Reading, MA, third edition, 1997.</source>
          <target state="translated">Addison-Wesley, odczytu, MA wydanie trzecie 1997.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider&gt;</ph> class or derive a class from <ph id="ph2">&lt;xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Aby wygenerować kryptograficznie bezpiecznego liczbę losową, który jest odpowiedni dla tworzenia losowe hasło, należy użyć <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider&gt;</ph> klasy lub pochodzić od klasy <ph id="ph2">&lt;xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In this topic:</source>
          <target state="translated">W tym temacie:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Instantiating the random number generator<ept id="p1">](#Instantiate)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Tworzenie wystąpień generatora liczb losowych<ept id="p1">](#Instantiate)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Avoiding multiple instantiations<ept id="p1">](#Multiple)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Unikanie wiele wystąpień<ept id="p1">](#Multiple)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>The System.Random class and thread safety<ept id="p1">](#ThreadSafety)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Random bezpieczeństwa klasy i wątku<ept id="p1">](#ThreadSafety)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generating different types of random numbers<ept id="p1">](#Functionality)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Generowanie różnego rodzaju liczby losowe<ept id="p1">](#Functionality)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Substituting your own algorithm<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Podstawiając własne algorytmu<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>How do you use System.Random to…<ept id="p1">](#Operations)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Jak używać System.Random do...<ept id="p1">](#Operations)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve the same sequence of random values<ept id="p1">](#Same)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Taką samą sekwencję losowych wartości do pobrania<ept id="p1">](#Same)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve unique sequences of random values<ept id="p1">](#Unique)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Pobierz unikatowy sekwencje losowych wartości<ept id="p1">](#Unique)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve integers in a specified range<ept id="p1">](#Range)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Pobieranie liczby całkowite w określonym zakresie<ept id="p1">](#Range)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve integers with a specified number of digits<ept id="p1">](#Digits)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Pobieranie liczby całkowite z określonej liczby miejsc po przecinku<ept id="p1">](#Digits)</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve floating-point values in a specified range<ept id="p1">](#Floats)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Pobieranie wartości zmiennoprzecinkowych w określonym zakresie<ept id="p1">](#Floats)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generate random Boolean values<ept id="p1">](#Boolean)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Generowanie losowych wartości logiczna<ept id="p1">](#Boolean)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generate random 64-bit integers<ept id="p1">](#Long)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Generowanie losowe 64-bitowych liczb całkowitych<ept id="p1">](#Long)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve bytes in a specified range<ept id="p1">](#Bytes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Pobrać bajtów w określonym zakresie<ept id="p1">](#Bytes)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve an element from an array or collection at random<ept id="p1">](#Array)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Losowo pobrać element z kolekcji lub tablicy<ept id="p1">](#Array)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve a unique element from an array or collection<ept id="p1">](#UniqueArray)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Pobierz unikatowy element z kolekcji lub tablicy<ept id="p1">](#UniqueArray)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instantiating the random number generator</source>
          <target state="translated">Tworzenie wystąpień generatora liczb losowych</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <ph id="ph1">&lt;xref:System.Random.%23ctor%2A&gt;</ph> class constructor.</source>
          <target state="translated">Wystąpienia generatora liczb losowych podając wartości początkowej (początkową wartość pseudolosowego algorytmu generowania liczb), aby <ph id="ph1">&lt;xref:System.Random.%23ctor%2A&gt;</ph> konstruktora klasy.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can supply the seed value either explicitly or implicitly:</source>
          <target state="translated">Można podać wartości początkowej, jawnie lub niejawnie:</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor uses an explicit seed value that you supply.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> Konstruktor korzysta wartość jawne inicjatora.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> constructor uses the system clock to provide a seed value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> Konstruktor korzysta z zegarem systemowym podania wartości inicjatora.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This is the most common way of instantiating the random number generator.</source>
          <target state="translated">Jest to najczęściej o uruchamianiu generatora liczb losowych.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If the same seed is used for separate <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects, they will generate the same series of random numbers.</source>
          <target state="translated">Jeśli tego samego inicjatora jest używana do oddzielnego <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiekty, zostanie wygenerowany dla tej samej serii liczb losowych.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.</source>
          <target state="translated">Może to być przydatne do tworzenia zestawu testów, który przetwarza losowych wartości lub dla odtwarzanie gry wyprowadzonych swoje dane z liczb losowych.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, note that <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.</source>
          <target state="translated">Jednak należy pamiętać, że <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektów w procesów uruchomionych w różnych wersji programu .NET Framework może zwrócić innej serii liczb losowych, nawet wtedy, gdy są one wystąpienia inicjatora identycznymi wartościami.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <ph id="ph1">&lt;xref:System.Random&gt;</ph>.</source>
          <target state="translated">Do tworzenia różnych sekwencji liczb losowych, możesz wprowadzić wartości początkowej zależnych od czasu, a tym samym produkujących innej serii z każdym nowe wystąpienie klasy <ph id="ph1">&lt;xref:System.Random&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The parameterized <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor can take an <ph id="ph2">&lt;xref:System.Int32&gt;</ph> value based on the number of ticks in the current time, whereas the parameterless <ph id="ph3">&lt;xref:System.Random.%23ctor&gt;</ph> constructor uses the system clock to generate its seed value.</source>
          <target state="translated">Sparametryzowane <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> Konstruktor może zająć <ph id="ph2">&lt;xref:System.Int32&gt;</ph> wartość na podstawie ich liczba w bieżącą godzinę, podczas gdy bez parametrów <ph id="ph3">&lt;xref:System.Random.%23ctor&gt;</ph> Konstruktor korzysta zegara systemowego do generowania swojej wartości początkowej.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, because the clock has finite resolution, using the parameterless constructor to create different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in close succession creates random number generators that produce identical sequences of random numbers.</source>
          <target state="translated">Jednak ponieważ zegar ma rozdzielczość ograniczone, przy użyciu konstruktora bez parametrów do utworzenia różnych <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektów kolejno Zamknij tworzy losowe numer generatory, które powodują powstanie identyczne sekwencji liczb losowych.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example illustrates how two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects that are instantiated in close succession generate an identical series of random numbers.</source>
          <target state="translated">Poniższy przykład przedstawia sposób dwóch <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektów, które są tworzone kolejno Zamknij Generowanie serii identycznych liczb losowych.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>On most Windows systems, <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects created within 15 milliseconds of one another are likely to have identical seed values.</source>
          <target state="translated">W większości systemów Windows <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektów utworzonych w ciągu 15 milisekund siebie prawdopodobnie identycznych inicjatora wartości.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To avoid this problem, create a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object instead of multiple objects.</source>
          <target state="translated">Aby uniknąć tego problemu, należy utworzyć jeden <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektu zamiast wielu obiektów.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Avoiding multiple instantiations</source>
          <target state="translated">Unikanie wiele wystąpień</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.</source>
          <target state="translated">Inicjowanie dwóch losowych generatory numer w pętli ścisłej lub w krótkim odstępie czasu tworzy dwa losowe generatory numer powodującymi identyczne sekwencji liczb losowych.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.</source>
          <target state="translated">W większości przypadków nie jest celem dewelopera i może prowadzić do problemów z wydajnością, ponieważ tworzenie wystąpień i Inicjowanie generator liczb losowych jest stosunkowo drogie.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <ph id="ph1">&lt;xref:System.Random&gt;</ph> object to generate many random numbers over time, instead of creating new <ph id="ph2">&lt;xref:System.Random&gt;</ph> objects to generate one random number.</source>
          <target state="translated">Zarówno do zwiększenia wydajności i uniknąć przypadkowo tworzenie oddzielnych losowe generatory numerów generujących identyczne sekwencji liczbowych, zaleca się utworzenie jednego <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektu dla generatora liczb losowych wiele wraz z upływem czasu, zamiast tworzyć nowe <ph id="ph2">&lt;xref:System.Random&gt;</ph> obiekty do wygenerowania jeden liczby losowe.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class isn't thread safe.</source>
          <target state="translated">Jednak <ph id="ph1">&lt;xref:System.Random&gt;</ph> klasy nie jest bezpieczne dla wątków.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If you call <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods from multiple threads, follow the guidelines discussed in the next section.</source>
          <target state="translated">Jeśli należy wywołać <ph id="ph1">&lt;xref:System.Random&gt;</ph> metody wiele wątków, postępuj zgodnie z wytycznymi, omówiona w następnej sekcji.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The System.Random class and thread safety</source>
          <target state="translated">System.Random bezpieczeństwa klasy i wątku</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of instantiating individual <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects, we recommend that you create a single <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance to generate all the random numbers needed by your app.</source>
          <target state="translated">Zamiast tworzenia wystąpienia osoba <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiekty, zaleca się utworzenie pojedynczej <ph id="ph2">&lt;xref:System.Random&gt;</ph> wystąpienia dla generatora liczb losowych wymagane przez aplikację.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects are not thread safe.</source>
          <target state="translated">Jednak <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiekty nie są bezpieczne dla wątków.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If your app calls <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.</source>
          <target state="translated">Jeśli aplikacja wymaga <ph id="ph1">&lt;xref:System.Random&gt;</ph> metod przez wiele wątków, należy użyć obiektu synchronizacji w celu zapewnienia tylko jeden wątek dostęp do generatora liczb losowych w czasie.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If you don't ensure that the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.</source>
          <target state="translated">Jeśli użytkownik nie upewnij się, że <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiekt jest dostępny w sposób zapewniający obsługę wielowątkowości, wywołania metody, które zwracają liczb losowych zwraca 0.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses the C# <bpt id="p1">[</bpt>lock Statement<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> and the Visual Basic <bpt id="p2">[</bpt>SyncLock statement<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.</source>
          <target state="translated">W poniższym przykładzie użyto C# <bpt id="p1">[</bpt>lock — instrukcja<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> i Visual Basic <bpt id="p2">[</bpt>SyncLock — instrukcja<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> do upewnij się, że pojedynczy generatora liczb losowych jest dostępne 11 wątków w sposób wątkowo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.</source>
          <target state="translated">Każdy wątek generuje 2 milionów liczb losowych, zlicza liczby losowe wygenerowany i oblicza sumę ich, a następnie aktualizuje sumy dla wszystkich wątków po zakończeniu wykonywania.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The example ensures thread-safety in the following ways:</source>
          <target state="translated">Przykład zapewnia bezpieczeństwo wątków w następujący sposób:</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Atrybut służy do definiowania zmiennych thread-local, które śledzą sumę liczb losowych wygenerowany i ich sumy dla każdego wątku.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A lock (the <ph id="ph1">`lock`</ph> statement in C# and the <ph id="ph2">`SyncLock`</ph> statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.</source>
          <target state="translated">Blokady ( <ph id="ph1">`lock`</ph> instrukcji w języku C# i <ph id="ph2">`SyncLock`</ph> instrukcji w języku Visual Basic) chroni dostęp do zmiennych w łączna liczba i sumę wszystkich liczb losowych wygenerowany na wszystkie wątki.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A semaphore (the <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object) is used to ensure that the main thread blocks until all other threads complete execution.</source>
          <target state="translated">Semafor ( <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> obiektu) służy do zapewnienia, że bloki wątku głównego do innych wątków wykonany.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.</source>
          <target state="translated">Przykład sprawdza, czy generatora liczb losowych została uszkodzona przez określenie, czy dwa kolejne wywołania losowych liczb metody generowania zwraca 0.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If corruption is detected, the example uses the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> object to signal that all threads should be canceled.</source>
          <target state="translated">Wykrycie uszkodzenia w przykładzie użyto <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> obiektu, która sygnalizuje, że należy anulować wszystkie wątki.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Before generating each random number, each thread checks the state of the <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> object.</source>
          <target state="translated">Przed wygenerowaniem każdej liczby losowe, każdy wątek sprawdza stan <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If cancellation is requested, the example calls the <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method to cancel the thread.</source>
          <target state="translated">Jeśli zażądano anulowania <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> metodę, aby anulować wątku.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example is identical to the first, except that it uses a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and a lambda expression instead of <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> objects.</source>
          <target state="translated">Poniższy przykład jest taka sama jak pierwsza strona, z wyjątkiem tego, że używa <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> obiekt i wyrażenia lambda zamiast <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> obiektów.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It differs from the first example in the following ways:</source>
          <target state="translated">Różni się od pierwszym przykładzie w następujący sposób:</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute.</source>
          <target state="translated">Zmienne do śledzenia liczby liczb losowych wygenerowany i ich sumy w każdym zadaniu znajdują się lokalnie do zadania, a więc nie trzeba używać <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atrybutu.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The static <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method is used to ensure that the main thread doesn't complete before all tasks have finished.</source>
          <target state="translated">Statycznych <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> metoda służy do zapewnienia, że głównym wątku nie wykona przed zakończeniem wszystkie zadania.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>There is no need for the <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object.</source>
          <target state="translated">Nie istnieje potrzeba dla <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The exception that results from task cancellation is surfaced in the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Wyjątek, który jest wynikiem anulowanie zadania jest udostępniane w <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the previous example, it is handled by each thread.</source>
          <target state="translated">W poprzednim przykładzie jest obsługiwane przez poszczególne wątki.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generating different types of random numbers</source>
          <target state="translated">Generowanie różnego rodzaju liczby losowe</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The random number generator provides methods that let you generate the following kinds of random numbers:</source>
          <target state="translated">Generatora liczb losowych udostępnia metody, które pozwalają na następujące rodzaje liczby losowe generowanie:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A series of <ph id="ph1">&lt;xref:System.Byte&gt;</ph> values.</source>
          <target state="translated">Szereg <ph id="ph1">&lt;xref:System.Byte&gt;</ph> wartości.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method.</source>
          <target state="translated">Określenie liczby wartości bajtu przez przekazanie tablicy inicjowane z liczbą elementów ma metodę, aby powrócić do <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 20 bytes.</source>
          <target state="translated">Poniższy przykład generuje 20 bajtów.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A single integer.</source>
          <target state="translated">Pojedynczy liczba całkowita.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can choose whether you want an integer from 0 to a maximum value (<ph id="ph1">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> – 1) by calling the <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> method, an integer between 0 and a specific value by calling the <ph id="ph3">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> method, or an integer within a range of values by calling the <ph id="ph4">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">Można wybrać, czy ma całkowitą z zakresu od 0 do wartości maksymalnej (<ph id="ph1">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> -1) przez wywołanie metody <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> metoda, liczbą całkowitą od 0 do określonej wartości przez wywołanie metody <ph id="ph3">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> metody lub liczbą całkowitą w zakresie wartości przez wywołanie metody <ph id="ph4">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>metody.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.</source>
          <target state="translated">W sparametryzowane przeciążeń określona wartość maksymalna jest na wyłączność; Rzeczywista liczba maksymalna generowany jest jeden mniej niż określona wartość.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method to generate 10 random numbers between -10 and 10.</source>
          <target state="translated">Następujące przykładowe wywołania <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> metody dla generatora liczb losowych 10 w zakresie od -10 do 10.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.</source>
          <target state="translated">Należy pamiętać, że drugi argument do metody określa wyłącznego górna granica zakresu losowych wartości zwracanych przez metodę.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In other words, the largest integer that the method can return is one less than this value.</source>
          <target state="translated">Innymi słowy największa liczba całkowita, która metoda może zwracać jedną jest mniejsza od tej wartości.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A single floating-point value from 0.0 to less than 1.0 by calling the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">Pojedynczą wartość zmiennoprzecinkowa od 0,0 mniejszą niż 1,0 przez wywołanie metody <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.</source>
          <target state="translated">Wyłączny górna granica liczbę losową zwracany przez metodę to 1, więc jego rzeczywistego górna granica jest 0.99999999999999978.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 10 random floating-point numbers.</source>
          <target state="translated">Poniższy przykład generuje 10 losowych liczb zmiennoprzecinkowych.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method allows you to specify the range of the returned random number.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> Metoda pozwala na określenie zwrócony liczbę losową z zakresu.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, the <ph id="ph1">`maxValue`</ph> parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.</source>
          <target state="translated">Jednak <ph id="ph1">`maxValue`</ph> parametr, który określa, górna granica zwracana liczba, jest na wyłączność, nie włącznie, wartość.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This means that the method call <ph id="ph1">`Next(0, 100)`</ph> returns a value between 0 and 99, and not between 0 and 100.</source>
          <target state="translated">Oznacza to, że wywołanie metody <ph id="ph1">`Next(0, 100)`</ph> zwraca wartość z zakresu od 0 do 99, a nie z zakresu od 0 do 100.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class for such tasks as generating <bpt id="p1">[</bpt>random T:System.Boolean values<ept id="p1">](#Boolean)</ept>, generating <bpt id="p2">[</bpt>random floating point values with a range other than 0 to 1<ept id="p2">](#Floats)</ept>, generating <bpt id="p3">[</bpt>random 64-bit integers<ept id="p3">](#Long)</ept>, and <bpt id="p4">[</bpt>randomly retrieving a unique element from an array or collection<ept id="p4">](#UniqueArray)</ept>.</source>
          <target state="translated">Można również użyć <ph id="ph1">&lt;xref:System.Random&gt;</ph> klasy dla zadania, takie jak Generowanie <bpt id="p1">[</bpt>losowych wartości T:System.Boolean<ept id="p1">](#Boolean)</ept>, generowanie <bpt id="p2">[</bpt>zmiennoprzecinkowej losowych wartości z zakresu innych niż 0 lub 1<ept id="p2">](#Floats)</ept>, generowanie <bpt id="p3">[</bpt>losowe 64-bitowych liczb całkowitych<ept id="p3">](#Long)</ept>, i <bpt id="p4">[</bpt>losowo pobierania unikatowy element z kolekcji lub tablicy<ept id="p4">](#UniqueArray)</ept>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For these and other common tasks, see the <bpt id="p1">[</bpt>How do you use System.Random to…<ept id="p1">](#Operations)</ept></source>
          <target state="translated">Tych i innych typowych zadań, zobacz <bpt id="p1">[</bpt>jak używać System.Random do...<ept id="p1">](#Operations)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>section.</source>
          <target state="translated">sekcja.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Substituting your own algorithm</source>
          <target state="translated">Podstawiając własne algorytmu</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can implement your own random number generator by inheriting from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and supplying your random number generation algorithm.</source>
          <target state="translated">Można wdrożyć własne generatora liczb losowych przy dziedziczących <ph id="ph1">&lt;xref:System.Random&gt;</ph> klasy i dostarczenie z algorytmu generowania liczb.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To supply your own algorithm, you must override the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method, which implements the random number generation algorithm.</source>
          <target state="translated">Aby przekazać swoje własne algorytmu, konieczne jest przesłonięcie <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> metodę, która implementuje algorytm Generowanie liczb pseudolosowych.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You should also override the <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Random.NextBytes%2A&gt;</ph> methods to ensure that they call your overridden <ph id="ph4">&lt;xref:System.Random.Sample%2A&gt;</ph> method.</source>
          <target state="translated">Należy również zastąpić <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>, i <ph id="ph3">&lt;xref:System.Random.NextBytes%2A&gt;</ph> metod, które zapewniają one wywołać Twojej przesłoniętych <ph id="ph4">&lt;xref:System.Random.Sample%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You don't have to override the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> methods.</source>
          <target state="translated">Nie trzeba zastąpić <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> i <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For an example that derives from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and modifies its default pseudo-random number generator, see the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> reference page.</source>
          <target state="translated">Na przykład, która jest pochodną <ph id="ph1">&lt;xref:System.Random&gt;</ph> klasy i zmienia jego domyślny pseudolosowego generatora liczb, zobacz <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> strony odwołania.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>How do you use System.Random to…</source>
          <target state="translated">Jak używać System.Random do...</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.</source>
          <target state="translated">Poniższe sekcje omówienia i podaj przykładowy kod niektóre metody można używać liczb losowych w aplikacji.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve the same sequence of random values</source>
          <target state="translated">Taką samą sekwencję losowych wartości do pobrania</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.</source>
          <target state="translated">Czasami chcesz wygenerować taką samą sekwencję losowych liczb znajdujących się w scenariuszach testów oprogramowania i odtwarzanie gier.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.</source>
          <target state="translated">Testowanie za pomocą tej samej sekwencji liczb losowych umożliwia wykrywanie regresji i Potwierdź poprawki błędów.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Using the same sequence of random number in games allows you to replay previous games.</source>
          <target state="translated">Przy użyciu takiej samej kolejności liczbę losową w grach służy do powtarzania poprzednich gier.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can generate the same sequence of random numbers by providing the same seed value to the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Można wygenerować tej samej sekwencji liczb losowych, podając tę samą wartość inicjatora na <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> konstruktora.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The seed value provides a starting value for the pseudo-random number generation algorithm.</source>
          <target state="translated">Wartość zalążka zapewnia wartości początkowej pseudolosowego algorytmu generowania liczb.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses 100100 as an arbitrary seed value to instantiate the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object, displays 20 random floating-point values, and persists the seed value.</source>
          <target state="translated">W poniższym przykładzie użyto 100100 jako wartości początkowej dowolnego można utworzyć wystąpienia <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektów, wyświetla 20 losowych wartości zmiennoprzecinkowych i będzie się powtarzał wartości początkowej.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.</source>
          <target state="translated">Następnie przywraca wartości początkowej, tworzy nowy generator liczb losowych i wyświetla te same 20 losowych liczb zmiennoprzecinkowych wartości.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.</source>
          <target state="translated">Należy zwrócić uwagę na przykładzie może powodować różnych sekwencji liczb losowych Jeśli uruchomione w różnych wersjach programu .NET Framework.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve unique sequences of random numbers</source>
          <target state="translated">Pobierz unikatowy sekwencji liczb losowych</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Providing different seed values to instances of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class causes each random number generator to produce a different sequence of values.</source>
          <target state="translated">Podając wartości inicjatora różnych wystąpień <ph id="ph1">&lt;xref:System.Random&gt;</ph> klasy powoduje, że każdy generator liczb losowych wygenerowało sekwencję różnych wartości.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can provide a seed value either explicitly by calling the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor, or implicitly by calling the <ph id="ph2">&lt;xref:System.Random.%23ctor&gt;</ph> constructor.</source>
          <target state="translated">Wartość zalążka można podać albo jawnie przez wywołanie metody <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> konstruktora, lub niejawnie, wywołując <ph id="ph2">&lt;xref:System.Random.%23ctor&gt;</ph> konstruktora.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Most developers call the parameterless constructor, which uses the system clock.</source>
          <target state="translated">Większość deweloperów wywołać konstruktora, który używa zegara systemowego.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this approach to instantiate two <ph id="ph1">&lt;xref:System.Random&gt;</ph> instances.</source>
          <target state="translated">Poniższy przykład korzysta z tej metody można utworzyć dwa wystąpienia <ph id="ph1">&lt;xref:System.Random&gt;</ph> wystąpień.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Each instance displays a series of 10 random integers.</source>
          <target state="translated">Każde wystąpienie prezentuje serię 10 losowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.</source>
          <target state="translated">Jednak ze względu na jego ograniczone rozwiązanie zegar systemowy nie wykrywa różnice czasu, które są mniej niż około 15 milisekund.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Therefore, if your code calls the <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> overload to instantiate two <ph id="ph2">&lt;xref:System.Random&gt;</ph> objects in succession, you might inadvertently be providing the objects with identical seed values.</source>
          <target state="translated">W związku z tym jeśli kod wywołuje <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> przeciążenia można utworzyć dwa wystąpienia <ph id="ph2">&lt;xref:System.Random&gt;</ph> obiekty kolejno, możesz przypadkowo udostępniają obiekty z wartościami identyczne inicjatora.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To see this in the previous example, comment out the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method call, and compile and run the example again.</source>
          <target state="translated">Aby wyświetlić to w poprzednim przykładzie, komentarz <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> wywołanie metody i kompilacji i ponownie uruchom przykładzie.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To prevent this from happening, we recommend that you instantiate a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object rather than multiple ones.</source>
          <target state="translated">Aby temu zapobiec, zaleca się utworzenie wystąpienia pojedynczy <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiekt zamiast wiele migawek.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, since <ph id="ph1">&lt;xref:System.Random&gt;</ph> isn't thread safe, you must use some synchronization device if you access a <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance from multiple threads; for more information, see <bpt id="p1">[</bpt>The Random class and thread safety<ept id="p1">](#ThreadSafety)</ept> earlier in this topic.</source>
          <target state="translated">Ponieważ jednak <ph id="ph1">&lt;xref:System.Random&gt;</ph> nie jest bezpieczne, możesz uzyskać dostępu do niektórych urządzeń synchronizacji należy użyć dla wątków <ph id="ph2">&lt;xref:System.Random&gt;</ph> wystąpienia z wielu wątków; Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>losowe bezpieczeństwa klasy i wątku<ept id="p1">](#ThreadSafety)</ept> wcześniej w tym temat.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Alternately, you can use a delay mechanism, such as the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.</source>
          <target state="translated">Alternatywnie można mechanizm opóźnienia, takich jak <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> metodę używaną w poprzednim przykładzie, aby upewnić się, że wystąpień występuje więcej niż 15 milisekund od siebie.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve integers in a specified range</source>
          <target state="translated">Pobieranie liczby całkowite w określonym zakresie</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can retrieve integers in a specified range by calling the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.</source>
          <target state="translated">Można pobrać liczby całkowite z zakresu określonego przez wywołanie metody <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> metodę, która pozwala określić zarówno dolna i górna granica chcesz powrócić generator liczb losowych liczb.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The upper bound is an exclusive, not an inclusive, value.</source>
          <target state="translated">Górna granica jest na wyłączność, nie włącznie, wartość.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>That is, it isn't included in the range of values returned by the method.</source>
          <target state="translated">Oznacza to, że nie jest zawarty w zakresie wartości zwracanych przez metodę.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this method to generate random integers between -10 and 10.</source>
          <target state="translated">W poniższym przykładzie użyto tej metody do generowania losowego liczby całkowite z zakresu od -10 do 10.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that it specifies 11, which is one greater than the desired value, as the value of the <ph id="ph1">`maxValue`</ph> argument in the method call.</source>
          <target state="translated">Należy pamiętać, że określa 11, która jest większa niż żądaną wartość jako wartość o jeden z <ph id="ph1">`maxValue`</ph> argument w wywołaniu metody.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve integers with a specified number of digits</source>
          <target state="translated">Pobieranie liczby całkowite z określonej liczby miejsc po przecinku</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method to retrieve numbers with a specified number of digits.</source>
          <target state="translated">Możesz wywołać <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> metoda pobierania liczby z określonej liczby cyfr.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method with a <ph id="ph2">`minValue`</ph> value of 1000 and a <ph id="ph3">`maxValue`</ph> value of 10000, as the following example shows.</source>
          <target state="translated">Na przykład, aby pobrać liczby z czterech cyfr (czyli liczby z zakresu od 1000 do 9999), należy wywołać <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> metody z <ph id="ph2">`minValue`</ph> wartość 1000 i <ph id="ph3">`maxValue`</ph> wartość 10000, jak przedstawiono na poniższym przykładzie.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve floating-point values in a specified range</source>
          <target state="translated">Pobieranie wartości zmiennoprzecinkowych w określonym zakresie</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method returns random floating-point values that range from 0 to less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> Metoda zwraca losowych wartości zmiennoprzecinkowych zakresu od 0 do mniej niż 1.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, you'll often want to generate random values in some other range.</source>
          <target state="translated">Jednak często należy wygenerować losowych wartości w niektórych inny zakres.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">Jeśli interwał między minimalną i maksymalną odpowiednie wartości to 1, możesz dodać różnica między wymagany przedział czasu rozpoczęcia i 0 liczbę zwracanych przez <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example does this to generate 10 random numbers between -1 and 0.</source>
          <target state="translated">Poniższy przykład jest to, aby wygenerować 10 losowych liczbami z przedziału od -1 i 0.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.</source>
          <target state="translated">Dla generatora liczb losowych liczb zmiennoprzecinkowych którego dolna granica jest 0, ale górna granica jest większa niż 1 (lub, w przypadku wartości ujemne, którego dolna granica jest mniejsza niż -1 i górna granica jest 0), należy pomnożyć liczbę losową przez granicą inną niż zero.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example does this to generate 20 million random floating-point numbers that range from 0 to <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Poniższy przykład robi to dla generatora liczb losowych liczb zmiennoprzecinkowych 20 milionów zakresu od 0 do <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In also displays the distribution of the random values generated by the method.</source>
          <target state="translated">W wyświetla również dystrybucji losowych wartości generowanych przez metodę.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate random floating-point numbers between two arbitrary values, like the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method does for integers, use the following formula:</source>
          <target state="translated">Aby wygenerować losowych liczb zmiennoprzecinkowych między dwiema wartościami dowolnego, takich jak <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> metoda wykonuje liczb całkowitych, należy użyć następującej formuły:</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.</source>
          <target state="translated">Poniższy przykład generuje 1 milion liczb losowych, które należeć do zakresu od 10.0 do 11.0 i wyświetla jego dystrybucji.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generate random Boolean values</source>
          <target state="translated">Generowanie losowych wartości logiczna</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random&gt;</ph> class doesn't provide methods that generate <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random&gt;</ph> Klasy nie udostępnia metody, które generują <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> wartości.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, you can define your own class or method to do that.</source>
          <target state="translated">Można jednak zdefiniować własne klasa lub metoda w tym celu.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example defines a class, <ph id="ph1">`BooleanGenerator`</ph>, with a single method, <ph id="ph2">`NextBoolean`</ph>.</source>
          <target state="translated">W poniższym przykładzie zdefiniowano klasę, <ph id="ph1">`BooleanGenerator`</ph>, z jedną metodę <ph id="ph2">`NextBoolean`</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`BooleanGenerator`</ph> class stores a <ph id="ph2">&lt;xref:System.Random&gt;</ph> object as a private variable.</source>
          <target state="translated"><ph id="ph1">`BooleanGenerator`</ph> Klasy magazynów <ph id="ph2">&lt;xref:System.Random&gt;</ph> obiektu jako zmiennej prywatnej.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`NextBoolean`</ph> method calls the <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method and passes the result to the <ph id="ph3">&lt;xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`NextBoolean`</ph> Wywołania metody <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> — metoda i przekazuje jego wynik do <ph id="ph3">&lt;xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that 2 is used as the argument to specify the upper bound of the random number.</source>
          <target state="translated">Należy pamiętać, że 2 jest używany jako argument do określenia górnej granicy liczby losowe.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Since this is an exclusive value, the method call returns either 0 or 1.</source>
          <target state="translated">Ponieważ jest to wartość wyłączności, wywołanie metody zwraca 0 lub 1.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of creating a separate class to generate random <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> values, the example could simply have defined a single method.</source>
          <target state="translated">Zamiast tworzyć osobnej klasy do generowania losowego <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> wartości, na przykład można po prostu zdefiniowanych pojedynczej metody.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In that case, however, the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object should have been defined as a class-level variable to avoid instantiating a new <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance in each method call.</source>
          <target state="translated">W takim przypadku jednak <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektu powinien zostały zdefiniowane jako zmienna poziomie klasy, aby zapobiec uruchamianiu nową <ph id="ph2">&lt;xref:System.Random&gt;</ph> wystąpienia w każdym wywołaniu metody.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In Visual Basic, the Random instance can be defined as a <bpt id="p1">[</bpt>Static<ept id="p1">](~/docs/visual-basic/language-reference/modifiers/static.md)</ept> variable in the <ph id="ph1">`NextBoolean`</ph> method.</source>
          <target state="translated">W języku Visual Basic, można zdefiniować jako wystąpienie losowe <bpt id="p1">[</bpt>statycznych<ept id="p1">](~/docs/visual-basic/language-reference/modifiers/static.md)</ept> zmiennej w <ph id="ph1">`NextBoolean`</ph> metody.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example provides an implementation.</source>
          <target state="translated">W poniższym przykładzie przedstawiono implementację.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generate random 64-bit integers</source>
          <target state="translated">Generowanie losowe 64-bitowych liczb całkowitych</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method return 32-bit integers.</source>
          <target state="translated">Przeciążeń <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> zwracany przez metodę 32-bitowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, in some cases, you might want to work with 64-bit integers.</source>
          <target state="translated">W niektórych przypadkach może być do pracy z 64-bitowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can do this as follows:</source>
          <target state="translated">Można to zrobić w następujący sposób:</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Call the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to retrieve a double-precision floating point value.</source>
          <target state="translated">Wywołanie <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> wartość punktów metoda pobierania zmiennoprzecinkowej podwójnej precyzji.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Multiply that value by <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Należy pomnożyć tę wartość przez <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.</source>
          <target state="translated">Poniższy przykład korzysta z tej techniki do generowania milionów 20 losowe długich liczb całkowitych i kategoryzuje je w grupach równy 10.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Następnie oblicza rozkład liczby losowe liczbą w każdej grupie z zakresu od 0 do <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.</source>
          <target state="translated">Jak pokazano na dane wyjściowe z przykładu, numery są dystrybuowane mniej lub bardziej równomiernie w zakresie długich liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>An alternative technique that uses bit manipulation does not generate truly random numbers.</source>
          <target state="translated">Alternatywne technika używa bit manipulowanie nie generuje naprawdę losowych liczb.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This technique calls <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> to generate two integers, left-shifts one by 32 bits, and ORs them together.</source>
          <target state="translated">Ta metoda wywołuje <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> do generowania dwie liczb całkowitych, co na 32 przesunięcia w lewo bitów i ORs je razem.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This technique has two limitations:</source>
          <target state="translated">Ta technika ma dwa ograniczenia:</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.</source>
          <target state="translated">Ponieważ bitowe 31 jest znaku, wartość w bit 31 wynikowy długich liczb całkowitych jest zawsze 0.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.</source>
          <target state="translated">Można temu zaradzić, generując losowe 0 lub 1, lewo przesuwania go 31 bitów i ORing go przy użyciu oryginalnego losowe długich liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>More seriously, because the probability that the value returned by <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.</source>
          <target state="translated">Więcej poważnie ponieważ prawdopodobieństwo, że wartość zwracana przez <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> będzie równa 0, w zakresie od 0x0 0x00000000FFFFFFFF będzie kilka ewentualne liczb losowych.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve bytes in a specified range</source>
          <target state="translated">Pobrać bajtów w określonym zakresie</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method allow you to specify the range of random numbers, but the <ph id="ph2">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method does not.</source>
          <target state="translated">Przeciążeń <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> metody umożliwiają określenie zakresu liczb losowych, ale <ph id="ph2">&lt;xref:System.Random.NextBytes%2A&gt;</ph> nie ma metody.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example implements a <ph id="ph1">`NextBytes`</ph> method that lets you specify the range of the returned bytes.</source>
          <target state="translated">Poniższy przykład implementuje <ph id="ph1">`NextBytes`</ph> metodę, która umożliwia określenie zakresu bajtów zwrócona.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It defines a <ph id="ph1">`Random2`</ph> class that derives from <ph id="ph2">&lt;xref:System.Random&gt;</ph> and overloads its <ph id="ph3">`NextBytes`</ph> method.</source>
          <target state="translated">Definiuje <ph id="ph1">`Random2`</ph> klasą pochodzącą z <ph id="ph2">&lt;xref:System.Random&gt;</ph> i overloads jego <ph id="ph3">`NextBytes`</ph> metody.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`NextBytes(Byte[], Byte, Byte)`</ph> method wraps a call to the <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.</source>
          <target state="translated"><ph id="ph1">`NextBytes(Byte[], Byte, Byte)`</ph> Metoda opakowuje wywołanie <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> — metoda i określa wartość minimalną i jeden większa niż wartość maksymalna (w tym przypadku 0 i 101) czy chcemy zwrócony w tablicy bajtów.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Because we are sure that the integer values returned by the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method are within the range of the <ph id="ph2">&lt;xref:System.Byte&gt;</ph> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.</source>
          <target state="translated">Ponieważ firma Microsoft pewności, czy wartości całkowite zwrócone przez <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> metody są w zakresie <ph id="ph2">&lt;xref:System.Byte&gt;</ph> typu danych, firma Microsoft może bezpiecznie rzutowanie je (C#) i konwertowanie (w języku Visual Basic) z liczbami całkowitymi bajtów.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve an element from an array or collection at random</source>
          <target state="translated">Losowo pobrać element z kolekcji lub tablicy</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Random numbers often serve as indexes to retrieve values from arrays or collections.</source>
          <target state="translated">Liczby losowe często służą jako indeksów do pobierania wartości z tablicą lub kolekcji.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To retrieve a random index value, you can call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method, and use the lower bound of the array as the value of its <ph id="ph2">`minValue`</ph> argument and one greater than the upper bound of the array as the value of its <ph id="ph3">`maxValue`</ph> argument.</source>
          <target state="translated">Można pobrać wartości losowych indeksu, należy wywołać <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> — metoda i użyj dolnej granicy tablicy jako wartość jego <ph id="ph2">`minValue`</ph> argument i jeden większa niż górna granica tablicy jako wartości jego <ph id="ph3">`maxValue`</ph> argumentu.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For a zero-based array, this is equivalent to its <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property, or one greater than the value returned by the <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Dla tablicy liczony od zera, co jest równoważne jego <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> właściwości lub większa niż wartość zwrócona przez jedną <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example randomly retrieves the name of a city in the United States from an array of cities.</source>
          <target state="translated">Poniższy przykład losowo pobiera nazwę miejscowości w Stanach Zjednoczonych z tablicy miast.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve a unique element from an array or collection</source>
          <target state="translated">Pobierz unikatowy element z kolekcji lub tablicy</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A random number generator can always return duplicate values.</source>
          <target state="translated">Generator liczb losowych zawsze wrócić zduplikowane wartości.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.</source>
          <target state="translated">Zakres numerów staje się mniejszą lub liczbę wartości wygenerowany staje się większy, rozwoju prawdopodobieństwo duplikaty.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.</source>
          <target state="translated">Jeśli losowych wartości muszą być unikatowe, numery więcej są generowane odpowiednio duplikatów, co coraz pogorszenie wydajności.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>There are a number of techniques to handle this scenario.</source>
          <target state="translated">Istnieje szereg technik w celu obsługi tego scenariusza.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.</source>
          <target state="translated">Jest jednym z typowych rozwiązań do utworzenia tablicy lub kolekcję, która zawiera wartości, które mają zostać pobrane i Tablica równoległa losowych liczb zmiennoprzecinkowych.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The second array is populated with random numbers at the time the first array is created, and the <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> method is used to sort the first array by using the values in the parallel array.</source>
          <target state="translated">Druga tablica jest wypełniana liczb losowych w chwili pierwszego tablicy jest tworzony, i <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> metoda jest używana do sortowania pierwszego tablicy przy użyciu wartości w tablicy równoległych.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.</source>
          <target state="translated">Na przykład Jeśli projektujesz gra Pasjans chcesz upewnij się, że każda karta jest używana tylko raz.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.</source>
          <target state="translated">Zamiast generowania liczby losowe, aby pobrać karty i śledzenie czy karty już zostały uwzględnione, można utworzyć tablica równoległa losowych liczb, które mogą być używane do sortowania talii.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.</source>
          <target state="translated">Po talii jest sortowana, aplikację można zachować wskaźnik wskazuje indeks następnej karty w talii.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example illustrates this approach.</source>
          <target state="translated">To podejście pokazano w poniższym przykładzie.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It defines a <ph id="ph1">`Card`</ph> class that represents a playing card and a <ph id="ph2">`Dealer`</ph> class that deals a deck of shuffled cards.</source>
          <target state="translated">Definiuje <ph id="ph1">`Card`</ph> Klasa reprezentująca karty do gry i a <ph id="ph2">`Dealer`</ph> klasy, która zajmuje talii przesuniętą kart.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`Dealer`</ph> class constructor populates two arrays: a <ph id="ph2">`deck`</ph> array that has class scope and that represents all the cards in the deck; and a local <ph id="ph3">`order`</ph> array that has the same number of elements as the <ph id="ph4">`deck`</ph> array and is populated with randomly generated <ph id="ph5">&lt;xref:System.Double&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">`Dealer`</ph> Konstruktora klasy wypełnia dwie tablice: <ph id="ph2">`deck`</ph> tablicy z zakresem klasy, który reprezentuje wszystkie karty w talii; i lokalnym <ph id="ph3">`order`</ph> tablica, która ma taką samą liczbę elementów jako <ph id="ph4">`deck`</ph> tablicy i jest wypełniana z losowo generowany <ph id="ph5">&lt;xref:System.Double&gt;</ph> wartości.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> method is then called to sort the <ph id="ph2">`deck`</ph> array based on the values in the <ph id="ph3">`order`</ph> array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> Wywoływana jest metoda następnie Sortuj <ph id="ph2">`deck`</ph> tablicy na podstawie wartości w <ph id="ph3">`order`</ph> tablicy.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example creates a single random number generator and calls its <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Random.NextDouble%2A&gt;</ph> methods to generate sequences of random numbers within different ranges.</source>
          <target state="translated">Poniższy przykład tworzy pojedynczy generatora liczb losowych i wywołania jego <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%2A&gt;</ph>, i <ph id="ph3">&lt;xref:System.Random.NextDouble%2A&gt;</ph> metod do wygenerowania sekwencji liczb losowych w różnych zakresów.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">Poniższy przykład generuje losową liczbę całkowitą, która jest używana jako indeks można pobrać wartości ciągu z tablicy.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> required overriding the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method to define a new or modified algorithm for generating random numbers.</source>
          <target state="translated">.NET Framework 1.0 i 1.1, minimalna implementacji klasy pochodzące z <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> wymagane zastępowanie <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> metody do definiowania nowych lub zmodyfikowanych algorytmu generowania liczb losowych.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The derived class could then rely on the base class implementation of the <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32)" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>, and <ph id="ph5">&lt;see cref="M:System.Random.NextDouble" /&gt;</ph> methods to call the derived class implementation of the <ph id="ph6">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method.</source>
          <target state="translated">Klasa pochodna może następnie zależne od implementacji klasy podstawowej <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32)" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>, i <ph id="ph5">&lt;see cref="M:System.Random.NextDouble" /&gt;</ph> metod do wywołania implementacji klasy pochodnej <ph id="ph6">&lt;see cref="M:System.Random.Sample" /&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the .NET Framework 2.0 and later, the behavior of the <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, and <ph id="ph3">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> methods have changed so that these methods do not necessarily call the derived class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method.</source>
          <target state="translated">W programie .NET Framework 2.0 lub nowszy, zachowanie <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, i <ph id="ph3">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> metody zostały zmienione tak, aby te metody nie wymagają wykonania klasy pochodnej <ph id="ph4">&lt;see cref="M:System.Random.Sample" /&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As a result, classes derived from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> that target the .NET Framework 2.0 and later should also override these three methods.</source>
          <target state="translated">W związku z tym klas pochodnych <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> który docelową programu .NET Framework 2.0 i później również powinny zastępować tych trzech metod.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The implementation of the random number generator in the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class isn't guaranteed to remain the same across major versions of the .NET Framework.</source>
          <target state="translated">Implementacja generatora liczb losowych w <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> klasy nie jest gwarantowana ma pozostać niezmienione przez główne wersje programu .NET Framework.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</source>
          <target state="translated">W związku z tym nie należy założono, tej samej inicjatora spowoduje taką samą sekwencję pseudolosowego w różnych wersjach programu .NET Framework.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class, using a time-dependent default seed value.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> przy użyciu wartości początkowej domyślny zależny od czasu.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>The default seed value is derived from the system clock and has finite resolution.</source>
          <target state="translated">Domyślna wartość zalążka pochodzi z zegara systemowego i ma ograniczone rozpoznawania.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>As a result, different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers.</source>
          <target state="translated">Dzięki temu różnych <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektów, które są tworzone Zamknij kolejno przez wywołanie konstruktora domyślnego będzie mieć identyczne domyślne wartości inicjatora i, w związku z tym spowoduje identyczne zestawy liczb losowych.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>This problem can be avoided by using a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object to generate all random numbers.</source>
          <target state="translated">Ten problem można uniknąć przy użyciu pojedynczej <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektu do wygenerowania wszystkich liczb losowych.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Można również obejść go przez zmodyfikowanie wartości początkowej zwrócony przez zegara systemowego i podają jawnie tej nowej wartości inicjatora <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> konstruktora.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> konstruktora.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Call this constructor if you want your random number generator to generate a random sequence of numbers.</source>
          <target state="translated">Jeśli chcesz, aby Twoje generator liczb losowych wygenerować sekwencję losowych liczb, należy wywołać tego konstruktora.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor with a fixed seed value .</source>
          <target state="translated">Aby wygenerować stałym sekwencji liczb losowych, który ma być taka sama dla różnych generatory liczb losowych, należy wywołać <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> konstruktora o wartości inicjatora stałej.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>This <ph id="ph1">&lt;xref:System.Random&gt;</ph> constructor overload is frequently used when testing apps that use random numbers.</source>
          <target state="translated">To <ph id="ph1">&lt;xref:System.Random&gt;</ph> przeładowania konstruktora jest często używany podczas testowania aplikacji, które używają liczb losowych.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Once you've instantiated the random number generator, you call individual <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods, such as <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> or <ph id="ph3">&lt;xref:System.Random.NextDouble&gt;</ph>, to generate random numbers.</source>
          <target state="translated">Po został uruchomiony generatora liczb losowych, należy wywołać poszczególnych <ph id="ph1">&lt;xref:System.Random&gt;</ph> metod, takich jak <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> lub <ph id="ph3">&lt;xref:System.Random.NextDouble&gt;</ph>, aby generatora liczb losowych.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>The following example uses the default constructor to instantiate three <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects and displays a sequence of five random integers for each.</source>
          <target state="translated">W poniższym przykładzie użyto domyślnego konstruktora do utworzenia wystąpienia trzy <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiekty i wyświetla sekwencję pięć losowych liczb całkowitych dla każdego.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Because the first two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers.</source>
          <target state="translated">Ponieważ dwa pierwsze <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiekty są tworzone po kolei Zamknij, są tworzone, używając inicjatora identyczne wartości na podstawie zegara systemowego i, w związku z tym wygenerowanie identyczne sekwencji liczb losowych.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>On the other hand, the default constructor of the third <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is called after a two-second delay caused by calling the <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Z drugiej strony, domyślny konstruktor obiektu trzeci <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektu jest wywoływana po wykonaniu dwóch sekund opóźnienia spowodowane przez wywołanie metody <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Because this produces a different seed value for the third <ph id="ph1">&lt;xref:System.Random&gt;</ph> object, it produces a different sequence of random numbers.</source>
          <target state="translated">Ponieważ to daje wartość inicjatora różnych trzeci <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiekt, tworzy inną sekwencję liczb losowych.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>A number used to calculate a starting value for the pseudo-random number sequence.</source>
          <target state="translated">Liczba używane do obliczania wartości początkowej pseudolosowego numeru sekwencji.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>If a negative number is specified, the absolute value of the number is used.</source>
          <target state="translated">Jeśli określono wartość ujemną, jest używana wartość bezwzględną liczby.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class, using the specified seed value.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> przy użyciu wartości początkowej określony.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>Providing an identical seed value to different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects causes each instance to produce identical sequences of random numbers.</source>
          <target state="translated">Podawania wartości inicjatora identyczne do różnych <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektów powoduje, że każde wystąpienie wygenerować identyczne sekwencji liczb losowych.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This is often done when testing apps that rely on random number generators.</source>
          <target state="translated">Często jest to podczas testowania aplikacji, które opierają się na generatory liczb losowych.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.</source>
          <target state="translated">Jeśli aplikacja wymaga innego losowe sekwencje, wywołaj ten konstruktor wielokrotnie z inicjatora różnych wartości.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>One way to produce a unique seed value is to make it time-dependent.</source>
          <target state="translated">Jednym ze sposobów uzyskiwania wartości inicjatora unikatowy jest aby była zależna od czasu.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>For example, derive the seed value from the system clock, as the <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> overload does.</source>
          <target state="translated">Na przykład pochodzi z zegarem systemowym wartości początkowej jako <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> jest przeciążenia.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.</source>
          <target state="translated">Jednak zegara systemowego może nie mieć wystarczającą rozdzielczość zapewnienie różnymi wywołaniami tego konstruktora z wartością innego inicjatora.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in the following example.</source>
          <target state="translated">W efekcie losowych liczb generatory, generujących identyczne sekwencji liczb pseudolosowego, jak pokazano dwa pierwsze <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektów w poniższym przykładzie.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to ensure that you provide each constructor with a different seed value.</source>
          <target state="translated">Aby tego uniknąć, należy zastosować algorytm rozróżnianie wartości początkowej w każdym wywołania lub wywołanie <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> sposób zapewnienia zapewniają każdego konstruktora z wartością innego inicjatora.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>Another option is to instantiate a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object that you use to generate all the random numbers in your application.</source>
          <target state="translated">Innym rozwiązaniem jest utworzenie wystąpienia pojedynczy <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektu umożliwia generowanie liczb losowych w aplikacji.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This yields slightly better performance, since instantiating a random number generator is fairly expensive.</source>
          <target state="translated">Daje to nieco lepszą wydajność, ponieważ tworzenie wystąpień generator liczb losowych jest dość kosztowna.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>The following example creates <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles.</source>
          <target state="translated">Poniższy przykład tworzy <ph id="ph1">&lt;xref:System.Random&gt;</ph> obiektów z konstruktora klasy, która przyjmuje parametr inicjatora i generuje sekwencję losowych liczb całkowitych i na symulacyjnych.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>The example illustrates that the same sequence is generated when the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is created again with the constructor and seed parameter.</source>
          <target state="translated">Pokazano w przykładzie wygenerowania takiej samej kolejności podczas <ph id="ph1">&lt;xref:System.Random&gt;</ph> ponownie utworzyć obiektu z parametrem Konstruktor i inicjatora.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Returns a random integer.</source>
          <target state="translated">Zwraca losową liczbę całkowitą.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Random.Next">
          <source>Returns a non-negative random integer.</source>
          <target state="translated">Zwraca nieujemną losową liczbę całkowitą.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Random.Next">
          <source>A 32-bit signed integer that is greater than or equal to 0 and less than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">32-bitowe liczby całkowite ze znakiem jest większa niż lub równa 0 i mniejsza niż <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source><ph id="ph1">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> generates a random number whose value ranges from 0 to less than <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> generuje losową liczbę, którego wartość należy do zakresu od 0 do mniej niż <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To generate a random number whose value ranges from 0 to some other positive number, use the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Aby generować losową liczbę, którego wartość należy do zakresu od 0 dodatnią liczbę, należy użyć <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType&gt;</ph> przeciążenie metody.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To generate a random number within a different range, use the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Aby generować losową liczbę z zakresu innego, należy użyć <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> przeciążenie metody.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The following example makes repeated calls to the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method to generate a specific number of random numbers requested by the user.</source>
          <target state="translated">Poniższy przykład powoduje, że powtarzane wywołania <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> metody do wygenerowania określoną liczbę liczb losowych żądanej przez użytkownika.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The <ph id="ph1">&lt;xref:System.Console.ReadLine%2A?displayProperty=nameWithType&gt;</ph> method is used to get customer input.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Console.ReadLine%2A?displayProperty=nameWithType&gt;</ph> Metody jest używany do pobierania danych wejściowych klienta.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The following example derives a class from <ph id="ph1">&lt;xref:System.Random&gt;</ph> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method of the base class.</source>
          <target state="translated">Poniższy przykład pochodzi z klasy <ph id="ph1">&lt;xref:System.Random&gt;</ph> do generowania sekwencji liczb losowych, którego dystrybucji różni się z dystrybucji uniform generowane przez <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> metody klasy podstawowej.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method to provide the distribution of random numbers, and overrides the <ph id="ph2">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> method to use series of random numbers.</source>
          <target state="translated">Zastępuje on <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> metodę w celu zapewnienia dystrybucji liczb losowych i zastąpienia <ph id="ph2">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> metodę serii liczb losowych.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated">W programie .NET Framework w wersji 2.0, jeśli pochodzi z klasy <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> i zastąpić <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> metoda, dystrybucji dostarczonej przez implementację klasy pochodnej z <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> — metoda nie jest używany w wywołania do klasy podstawowej Implementacja <ph id="ph4">&lt;see cref="M:System.Random.Next" /&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Zamiast tego uniform dystrybucji zwrócony przez podstawowym <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> klasa jest używana.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">To zachowanie zwiększa ogólną wydajność <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated">Aby zmienić to zachowanie do wywołania <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> metody w klasie pochodnej, konieczne jest również przesłonięcie <ph id="ph2">&lt;see cref="M:System.Random.Next" /&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>The exclusive upper bound of the random number to be generated.</source>
          <target state="translated">Wyłączny górnej granicy liczby losowe do wygenerowania.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> must be greater than or equal to 0.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> musi być większa lub równa 0.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>Returns a non-negative random integer that is less than the specified maximum.</source>
          <target state="translated">Zwraca nieujemną losową liczbę całkowitą mniejszą niż określona wartość maksymalna.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>A 32-bit signed integer that is greater than or equal to 0, and less than <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph>; that is, the range of return values ordinarily includes 0 but not <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated">32-bitowe liczby całkowite ze znakiem jest większa niż lub równa 0 i mniejsza niż <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph>; oznacza to, że zakres wartości zwracanych zwykle obejmuje 0, ale nie <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>However, if <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> equals 0, <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph> is returned.</source>
          <target state="translated">Jednak jeśli <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> jest równe 0, <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph> jest zwracany.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> overload returns random integers that range from 0 to <ph id="ph2">`maxValue`</ph> – 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> Przeciążenia zwraca losowych liczb całkowitych zakresu od 0 do <ph id="ph2">`maxValue`</ph> -1.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>However, if <ph id="ph1">`maxValue`</ph> is 0, the method returns 0.</source>
          <target state="translated">Jednak jeśli <ph id="ph1">`maxValue`</ph> wynosi 0, metoda zwraca wartość 0.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The following example generates random integers with various overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method.</source>
          <target state="translated">Poniższy przykład generuje losowych liczb całkowitych z różnych przeciążeń <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">Poniższy przykład generuje losową liczbę całkowitą, która jest używana jako indeks można pobrać wartości ciągu z tablicy.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>Because the highest index of the array is one less than its length, the value of the <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> property is supplied as a the <ph id="ph2">`maxValue`</ph> parameter.</source>
          <target state="translated">Ponieważ najwyższy indeks tablicy jest jeden mniejsza niż długość, wartość <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> właściwość jest podana jako <ph id="ph2">`maxValue`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> jest mniejsza niż 0.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The inclusive lower bound of the random number returned.</source>
          <target state="translated">Dolna granica włącznie liczbę losową zwracane.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The exclusive upper bound of the random number returned.</source>
          <target state="translated">Wyłączny górnej granicy liczby losowe są zwracane.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> must be greater than or equal to <bpt id="p2">&lt;c&gt;</bpt>minValue<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> musi być większa niż lub równa <bpt id="p2">&lt;c&gt;</bpt>minValue<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Returns a random integer that is within a specified range.</source>
          <target state="translated">Zwraca losową liczbę całkowitą, która znajduje się w określonym zakresie.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>A 32-bit signed integer greater than or equal to <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> and less than <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>; that is, the range of return values includes <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> but not <ph id="ph4">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated">32-bitowe całkowita większa lub równa <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> i mniejsza niż <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>; zakres wartości zwracanych obejmuje <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> , ale nie <ph id="ph4">&lt;paramref name="maxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> equals <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>, <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> is returned.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> jest równe <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>, <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> jest zwracany.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> overload returns random integers that range from <ph id="ph2">`minValue`</ph> to <ph id="ph3">`maxValue`</ph> – 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> Przeciążenia zwraca losowych liczb całkowitych w zakresie od <ph id="ph2">`minValue`</ph> do <ph id="ph3">`maxValue`</ph> -1.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>However, if <ph id="ph1">`maxValue`</ph> equals <ph id="ph2">`minValue`</ph>, the method returns <ph id="ph3">`minValue`</ph>.</source>
          <target state="translated">Jednak jeśli <ph id="ph1">`maxValue`</ph> jest równe <ph id="ph2">`minValue`</ph>, metoda zwraca <ph id="ph3">`minValue`</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Unlike the other overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method, which return only non-negative values, this method can return a negative random integer.</source>
          <target state="translated">W przeciwieństwie do innych przeciążeń <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> , która zwracać tylko nieujemnej wartości, ta metoda może zwracać metoda ujemna losową liczbę całkowitą.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to generate random integers with three distinct ranges.</source>
          <target state="translated">W poniższym przykładzie użyto <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> metody do wygenerowania losowych liczb całkowitych na trzy różne zakresy.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Note that the exact output from the example depends on the system-supplied seed value passed to the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class constructor.</source>
          <target state="translated">Należy pamiętać, że dokładne dane wyjściowe z przykładu zależy od wartości inicjatora dostarczany przez system przekazany do <ph id="ph1">&lt;xref:System.Random&gt;</ph> konstruktora klasy.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">Poniższy przykład generuje losową liczbę całkowitą, która jest używana jako indeks można pobrać wartości ciągu z tablicy.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Because the highest index of the array is one less than its length, the value of the <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> property is supplied as a the <ph id="ph2">`maxValue`</ph> parameter.</source>
          <target state="translated">Ponieważ najwyższy indeks tablicy jest jeden mniejsza niż długość, wartość <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> właściwość jest podana jako <ph id="ph2">`maxValue`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> jest większa niż <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method overload if the difference between the <ph id="ph5">&lt;paramref name="minValue" /&gt;</ph> and <ph id="ph6">&lt;paramref name="maxValue" /&gt;</ph> parameters is greater than <ph id="ph7">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">W programie .NET Framework w wersji 2.0, jeśli pochodzi z klasy <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> i zastąpić <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> metoda, dystrybucji dostarczonej przez implementację klasy pochodnej z <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> — metoda nie jest używany w wywołania do klasy podstawowej Implementacja <ph id="ph4">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> przeciążenia metody, jeśli różnica między <ph id="ph5">&lt;paramref name="minValue" /&gt;</ph> i <ph id="ph6">&lt;paramref name="maxValue" /&gt;</ph> parametrów jest większa niż <ph id="ph7">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Zamiast tego uniform dystrybucji zwrócony przez podstawowym <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> klasa jest używana.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">To zachowanie zwiększa ogólną wydajność <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method overload.</source>
          <target state="translated">Aby zmienić to zachowanie do wywołania <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> metody w klasie pochodnej, konieczne jest również przesłonięcie <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> przeciążenie metody.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>An array of bytes to contain random numbers.</source>
          <target state="translated">Tablica bajtów, aby zawierała liczby losowe.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Fills the elements of a specified array of bytes with random numbers.</source>
          <target state="translated">Wstawia elementy określonej tablicy bajtów liczb losowych.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <ph id="ph1">&lt;xref:System.Byte.MaxValue&gt;</ph>.</source>
          <target state="translated">Każdy element tablicy bajtów ma ustawioną liczbę losową większą niż lub równa 0 i mniejsza niż lub równa <ph id="ph1">&lt;xref:System.Byte.MaxValue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Na przykład aby wygenerować zabezpieczone kryptograficznie liczbę losową odpowiedni w przypadku tworzenia losowe hasło, użyj metody takie jak <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method to fill an array of bytes with random byte values.</source>
          <target state="translated">W poniższym przykładzie pokazano sposób użycia <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> metody, aby wypełnić tablicę bajtów losowych wartości bajtów.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated">W programie .NET Framework w wersji 2.0, jeśli pochodzi z klasy <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> i zastąpić <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> metoda, dystrybucji dostarczonej przez implementację klasy pochodnej z <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> — metoda nie jest używany w wywołania do klasy podstawowej Implementacja <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Zamiast tego uniform dystrybucji zwrócony przez podstawowym <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> klasa jest używana.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">To zachowanie zwiększa ogólną wydajność <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated">Aby zmienić to zachowanie do wywołania <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> metody w klasie pochodnej, konieczne jest również przesłonięcie <ph id="ph2">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Random.NextDouble">
          <source>Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">Zwraca zmiennoprzecinkowe liczba jest większa niż lub równa 0,0 i mniejszą niż 1,0.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Random.NextDouble">
          <source>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">Podwójnej precyzji liczba zmiennoprzecinkowa, która jest większa niż lub równa 0,0 i mniejszą niż 1,0.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The actual upper bound of the random number returned by this method is 0.99999999999999978.</source>
          <target state="translated">Górna granica rzeczywista liczba zwracanych przez tę metodę jest 0.99999999999999978.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>To retrieve random floating-point values within a range other than 0.0 and 1.0, see the "Retrieve floating-point values in a specified range" section of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class topic.</source>
          <target state="translated">Aby pobrać losowych wartości zmiennoprzecinkowych w zakresie innym niż 0,0 do 1,0, zobacz sekcję "Pobrać wartości zmiennoprzecinkowych w określonym zakresie" <ph id="ph1">&lt;xref:System.Random&gt;</ph> klasy tematu.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>This method is the public version of the protected method, <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph>.</source>
          <target state="translated">Ta metoda jest publicznej wersji Metoda chroniona <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to generate sequences of random doubles.</source>
          <target state="translated">W poniższym przykładzie użyto <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> do generowania sekwencji symulacyjnych losowych.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to generate 100 random numbers and displays their frequency distribution.</source>
          <target state="translated">Następujące wywołania przykład <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> do generowania losowego 100 numery i wyświetlenie ich rozkład częstotliwości.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Random.Sample">
          <source>Returns a random floating-point number between 0.0 and 1.0.</source>
          <target state="translated">Zwraca liczbę losową zmiennoprzecinkowe z przedziału od 0,0 do 1,0.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Random.Sample">
          <source>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">Podwójnej precyzji liczba zmiennoprzecinkowa, która jest większa niż lub równa 0,0 i mniejszą niż 1,0.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To produce a different random distribution or a different random number generator principle, derive a class from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and override the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method.</source>
          <target state="translated">Do tworzenia różnych dystrybucji losowych lub różnych losowych liczb generator regułę, klasa wyprowadzona z <ph id="ph1">&lt;xref:System.Random&gt;</ph> klasy i zastąpić <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method is <ph id="ph2">`protected`</ph>, which means that it is accessible only within the <ph id="ph3">&lt;xref:System.Random&gt;</ph> class and its derived classes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> Jest metoda <ph id="ph2">`protected`</ph>, co oznacza, że jest dostępny tylko w obrębie <ph id="ph3">&lt;xref:System.Random&gt;</ph> klasy i jej klas pochodnych.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To generate a random number between 0 and 1 from a <ph id="ph1">&lt;xref:System.Random&gt;</ph> instance, call the <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">Do generowania losowego liczbą z zakresu od 0 i 1 z <ph id="ph1">&lt;xref:System.Random&gt;</ph> wystąpienia, należy wywołać <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The following example derives a class from <ph id="ph1">&lt;xref:System.Random&gt;</ph> and overrides the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method to generate a distribution of random numbers.</source>
          <target state="translated">Poniższy przykład pochodzi z klasy <ph id="ph1">&lt;xref:System.Random&gt;</ph> i zastępuje <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> metody do wygenerowania dystrybucji liczb losowych.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>This distribution is different than the uniform distribution generated by the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method of the base class.</source>
          <target state="translated">Tej dystrybucji jest inny niż uniform dystrybucji wygenerowanych przez <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> metody klasy podstawowej.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the following methods:</source>
          <target state="translated">W programie .NET Framework w wersji 2.0, jeśli pochodzi z klasy <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> i zastąpić <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> metoda, dystrybucji dostarczonej przez implementację klasy pochodnej z <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> — metoda nie jest używany w wywołania do klasy podstawowej Implementacja następujących metod:</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> Metody.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph> Metody.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method, if (<ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="minValue" /&gt;</ph>) is greater than <ph id="ph5">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> Metody, jeśli (<ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="minValue" /&gt;</ph>) jest większa niż <ph id="ph5">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>Instead, the uniform distribution provided by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Zamiast tego uniform dystrybucji dostarczone przez podstawowym <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> klasa jest używana.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">To zachowanie zwiększa ogólną wydajność <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To modify this behavior to call the implementation of the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the behavior of these three members.</source>
          <target state="translated">Aby zmodyfikować to działanie do wykonania wywołania <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> metody w klasie pochodnej, musi także zastępować zachowanie tych trzech elementów członkowskich.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The example provides an illustration.</source>
          <target state="translated">Przykład stanowi ilustrację.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
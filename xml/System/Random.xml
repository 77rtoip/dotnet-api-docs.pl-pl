<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5a9ab5223f061610781d60d0586c407114bafe65" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39766022" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje generator liczb losowych pseudolosowego, który jest urządzeniem, który wytwarza sekwencję liczb, które spełniają pewne statystyczne dotyczące losowości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numery pseudolosową można wybrać z równym prawdopodobieństwem skończoną zbioru liczb. Wybranej liczby nie są całkowicie losowych, ponieważ matematyczne algorytm jest używany do wybierania je, ale są one dostatecznie losowe ze względów praktycznych. Bieżąca implementacja parametru <xref:System.Random> klasy opiera się na zmodyfikowaną wersję Donald E. Knuth subtraktywne generator algorytmu liczb. Aby uzyskać więcej informacji zobacz D. E. Knuth. *Art of programistycznych woluminie 2: algorytmy Seminumerical*. Addison-Wesley, odczytu, MA, wydanie trzecie 1997.  
  
 Aby wygenerować kryptograficznie bezpieczne losową liczbę taki, który jest odpowiedni do tworzenia losowe hasło <xref:System.Security.Cryptography.RNGCryptoServiceProvider> klasy lub wyprowadzić klasę z <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.  
  
 W tym temacie:  
  
 [Utworzenie wystąpienia generator liczb losowych](#Instantiate)   
 [Unikanie wiele wystąpień](#Multiple)   
 [System.Random bezpieczeństwa klasy i wątku](#ThreadSafety)   
 [Generowanie różnych typów liczb losowych](#Functionality)   
 [Podstawiając własny algorytmu](#Overriding)   
 [Jak używać System.Random do...](#Operations)   
 [Pobierz tę samą sekwencję losowych wartości](#Same)  
 [Pobieranie unikatowych sekwencji losowe wartości](#Unique)  
 [Pobieranie liczby całkowite w określonym zakresie](#Range)  
 [Pobieranie liczby całkowite z określonej liczby cyfr](#Digits)  
 [Pobieranie wartości zmiennoprzecinkowych w określonym zakresie](#Floats)  
 [Generowanie losowe wartości logicznych](#Boolean)  
 [Generowanie losowe 64-bitowych liczb całkowitych](#Long)  
 [Pobieranie bajtów w określonym zakresie](#Bytes)  
 [Pobieranie elementu z tablicy lub kolekcji losowo](#Array)  
 [Pobieranie unikatowy element z tablicy lub kolekcji](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>Utworzenie wystąpienia generator liczb losowych  
 Wystąpienia generator liczb losowych, podając wartości początkowej (wartość początkową dla generowania algorytmu liczb), aby <xref:System.Random.%23ctor%2A> konstruktora klasy.  Możesz podać wartości początkowej, jawnie lub niejawnie:  
  
-   <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor korzysta z inicjatora jawną wartość.  
  
-   <xref:System.Random.%23ctor> Konstruktor korzysta z zegara systemowego podania wartości inicjatora. Jest to najbardziej popularny sposób tworzenia wystąpienia generator liczb losowych.  
  
 Jeśli ten sam inicjatora jest używana do oddzielnych <xref:System.Random> obiektów, generują one serii identycznych liczb losowych. Może to być przydatne do tworzenia zestawu testów, który przetwarza losowe wartości lub dla odtwarzanie gry utworzone swoje dane na podstawie liczby losowe. Jednak należy pamiętać, że <xref:System.Random> obiektów w procesy uruchomione na różnych wersji programu .NET Framework mogą zwracać różnych serii liczb losowych, nawet wtedy, gdy są one tworzone z wartościami inicjującymi identyczne.  
  
 Aby wygenerować różne sekwencje liczby losowych, wprowadzona wartość początkową zależne od czasu, a tym samym tworzenie różnych serii z każdym wystąpieniem nowe <xref:System.Random>. Sparametryzowany <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor może potrwać <xref:System.Int32> wartości na podstawie liczby taktów w bieżący czas, dlatego bez parametrów <xref:System.Random.%23ctor> Konstruktor korzysta z zegara systemowego do generowania jego wartości inicjatora. Jednak ponieważ zegar ma skończony rozdzielczości, przy użyciu konstruktora bez parametrów do tworzenia różnych <xref:System.Random> obiektów kolejno Zamknij tworzy generatorów liczb losowych, które generują identyczny sekwencje liczby losowych. Poniższy przykład pokazuje, jak dwa <xref:System.Random> obiektów, które są tworzone w odstępie czasu Zamknij Generowanie identyczne szeregu liczb losowych. W większości systemów Windows <xref:System.Random> obiektów utworzonych w ciągu 15 milisekund od siebie prawdopodobnie wartościami inicjującymi identyczne.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 Aby uniknąć tego problemu, należy utworzyć jeden <xref:System.Random> obiekt, a nie wielu obiektów.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Unikanie wiele wystąpień  
 Inicjowanie dwóch liczb losowych w pętli lub w krótkim odstępie czasu powoduje utworzenie dwóch liczb losowych generujących identyczne sekwencje liczby losowych. W większości przypadków to nie jest celem dewelopera i może prowadzić do problemów z wydajnością, ponieważ wystąpienia i Inicjowanie generator liczb losowych jest procesem relatywnie kosztowne.  
  
 Zarówno do zwiększenia wydajności i uniknięcia przypadkowo tworzenie oddzielnych generatorów liczb losowych, które generują identyczne sekwencje numeryczne, zaleca się utworzenie jednego <xref:System.Random> obiektu umożliwiającą wygenerowanie wiele liczb losowych wraz z upływem czasu, zamiast tworzyć nowe <xref:System.Random> obiekty do generowania jednego liczbę losową.  
  
 Jednak <xref:System.Random> klasy nie jest bezpieczny dla wątków. Jeśli wywołasz <xref:System.Random> metody z wielu wątków, postępuj zgodnie z wytycznymi omówiona w następnej sekcji.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>System.Random bezpieczeństwa klasy i wątku  
 Zamiast tworzenia wystąpienia osoba <xref:System.Random> obiektów, zaleca się utworzenie pojedynczego <xref:System.Random> wystąpienie do generowania liczb losowych wymagane przez aplikację. Jednak <xref:System.Random> obiekty nie są bezpieczne dla wątków. Jeśli aplikacja odwołuje się <xref:System.Random> metod z wielu wątków, musi być obiektem synchronizacji upewnij się, że tylko jeden wątek mają dostęp do generator liczb losowych w danym momencie. Jeśli użytkownik nie upewnij się, że <xref:System.Random> obiektu odbywa się w sposób wątkowo, wywołania do metod, które zwracają liczby losowe zwracają 0.  
  
 W poniższym przykładzie użyto języka C# [lock — instrukcja](~/docs/csharp/language-reference/keywords/lock-statement.md) i Visual Basic [SyncLock — instrukcja](~/docs/visual-basic/language-reference/statements/synclock-statement.md) aby upewnić się, że pojedynczy generator liczb losowych odbywa się przez 11 wątki w sposób bezpieczny dla wątków. Każdy wątek generuje liczby losowe 2 miliony, zlicza liczb losowych, które są generowane i oblicza sumę ich, a następnie aktualizuje łączne wartości dla wszystkich wątków, po zakończeniu wykonywania.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 Przykład zapewnia bezpieczeństwo wątków w następujący sposób:  
  
-   <xref:System.ThreadStaticAttribute> Atrybut jest używany do definiowania zmiennych thread-local, które śledzą sumę liczb losowych generowane i ich sumy dla każdego wątku.  
  
-   Blokady ( `lock` instrukcji w języku C# i `SyncLock` instrukcji w języku Visual Basic) chroni dostęp do zmiennych, łączna liczba i sumę wszystkich liczb losowych, wygenerowany we wszystkich wątkach.  
  
-   Semafor ( <xref:System.Threading.CountdownEvent> obiektów) służy do zapewnienia, że bloki głównego wątku, aż do innych wątków wykonany.  
  
-   Przykład sprawdza, czy generator liczb losowych naruszona przez określenie czy dwóch kolejnych wywołań losowych liczb metody generowania zwracają 0. W przypadku wykrycia uszkodzenie w przykładzie użyto <xref:System.Threading.CancellationTokenSource> obiekt do sygnalizowania, że wszystkie wątki powinna zostać anulowana.  
  
-   Przed wygenerowaniem poszczególnych liczb losowych, każdy wątek służy do sprawdzania stanu <xref:System.Threading.CancellationToken> obiektu. Jeśli zażądano anulowania <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metodę, aby anulować wątku.  
  
 Poniższy przykład jest identyczny z pierwszym, z tą różnicą, że używa <xref:System.Threading.Tasks.Task> obiekt i Wyrażenie lambda, zamiast <xref:System.Threading.Thread> obiektów.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 Różni się od pierwszego przykładu w następujący sposób:  
  
-   Zmienne, aby śledzić liczbę liczb losowych generowane i ich sumy w każdym zadaniu są lokalne do zadania, więc nie trzeba używać <xref:System.ThreadStaticAttribute> atrybutu.  
  
-   Statyczne <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metoda służy do zapewnienia, że główny wątek nie wykona przed zakończeniem wszystkich zadań. Nie ma potrzeby dla <xref:System.Threading.CountdownEvent> obiektu.  
  
-   Wyjątek, który jest wynikiem anulowanie zadania jest udostępniane w <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metody. W poprzednim przykładzie jest obsługiwane przez poszczególne wątki.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Generowanie różnych typów liczb losowych  
 Generator liczb losowych zawiera metody, które umożliwiają generowanie następujące rodzaje losowych liczb:  
  
-   Szereg <xref:System.Byte> wartości. Możesz określić liczbę wartości bajtów, przekazując tablicę, zainicjować do liczby elementów ma metodę, aby powrócić do <xref:System.Random.NextBytes%2A> metody. Poniższy przykład generuje 20 bajtów.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Pojedyncze liczby całkowite. Można wybrać, czy chcesz, aby liczba całkowita z zakresu od 0 do maksymalnej wartości (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1) przez wywołanie metody <xref:System.Random.Next> metody, całkowitą z zakresu od 0 do określonej wartości, wywołując <xref:System.Random.Next%28System.Int32%29> metody lub liczbą całkowitą w zakresie wartości przez wywołanie metody <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>metody. W sparametryzowanych przeciążeń jest wyłącznym; określona wartość maksymalna Rzeczywista maksymalna liczba generowany jest jeden mniejsza niż określona wartość.  
  
     Poniższy przykład wywołuje <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodę w celu wygenerowania 10 losowych liczb w zakresie od -10 do 10. Należy pamiętać, że drugi argument do metody określa wyłączne górna granica zakresu wartości losowych zwracany przez metodę. Innymi słowy największa liczba całkowita, która metoda może zwracać jeden mniejsza od tej wartości.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Jednej wartości zmiennoprzecinkowych od 0,0 mniejszą niż 1,0 przez wywołanie metody <xref:System.Random.NextDouble%2A> metody. Wyłączne górnej granicy liczby losowe, zwracany przez metodę wynosi 1, dzięki czemu jego rzeczywista górna granica jest 0.99999999999999978. Poniższy przykład generuje 10 losowych liczb zmiennoprzecinkowych.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Metody umożliwia określenie zakresu zwrócone liczbę losową. Jednak `maxValue` parametr, który określa górna granica zwracana liczba jest wyłącznie, nie obejmują, wartość. Oznacza to, że wywołanie metody `Next(0, 100)` zwraca wartość z zakresu od 0 do 99, a nie z zakresu od 0 do 100.  
  
 Można również użyć <xref:System.Random> klasy dla zadania, takie jak Generowanie [losowe wartości T:System.Boolean](#Boolean), generowanie [losowych zmiennoprzecinkowej wartości z zakresu innego niż 0 i 1](#Floats), generowanie [losowych 64-bitowych liczb całkowitych](#Long), i [losowo pobieranie unikatowy element z tablicy lub kolekcji](#UniqueArray). Dla tych i innych typowych zadań, zobacz [jak używać System.Random do...](#Operations) sekcja.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Podstawiając własny algorytmu  
 Możesz zaimplementować własnego generator liczb losowych przez dziedziczenie z <xref:System.Random> klasy i dostarczenie usługi algorytm generowania liczb pseudolosowych. Aby przekazać własne algorytmu, konieczne jest przesłonięcie <xref:System.Random.Sample%2A> metody, która implementuje algorytm generowania liczb losowych. Należy również zastąpić <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, i <xref:System.Random.NextBytes%2A> metod w celu zapewnienia będą wywoływać usługi zastąpione <xref:System.Random.Sample%2A> metody. Nie trzeba zastąpić <xref:System.Random.Next%28System.Int32%29> i <xref:System.Random.NextDouble%2A> metody.  
  
 Aby uzyskać przykład, która pochodzi od klasy <xref:System.Random> klasy i modyfikuje jego domyślne pseudolosowego generator liczb losowych, zobacz <xref:System.Random.Sample%2A> odwołania do stron.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Jak używać System.Random do...  
 W poniższych sekcjach omówiono i podaj przykładowy kod na kilka sposobów, możesz chcieć użyć liczb losowych w aplikacji.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Pobierz tę samą sekwencję losowych wartości  
 Czasami chcesz wygenerować taką samą sekwencję liczb losowych w scenariuszach testów oprogramowania oraz granie w gry. Testowanie za pomocą tej samej sekwencji liczb losowych umożliwia wykrywanie regresji i upewnij się, poprawki błędów. Za pomocą tej samej sekwencji liczb losowych w grach pozwala na poprzednim gry oparte na metodzie powtórzeń.  
  
 Możesz wygenerować taką samą sekwencję liczb losowych, podając tę samą wartość inicjatora do <xref:System.Random.%23ctor%28System.Int32%29> konstruktora. Wartość początkową udostępnia wartość początkową dla generowania algorytmu liczb. W poniższym przykładzie użyto 100100 jako wartość dowolnego inicjatora do utworzenia wystąpienia <xref:System.Random> obiektów, wyświetla 20 losowych wartości zmiennoprzecinkowe i będzie się powtarzał wartości początkowej. Następnie przywraca wartość początkową, tworzy nowy generator liczb losowych i wyświetla te same 20 losowych wartości zmiennoprzecinkowych.  Należy zwrócić uwagę na przykład mogą dawać różne sekwencje liczby losowych uruchomienia różnych wersji programu .NET Framework.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Pobieranie unikatowy sekwencje liczby losowych  
 Podając wartości różnych inicjatora do wystąpień <xref:System.Random> klasy powoduje, że każdy generator liczb losowych do tworzenia różnych sekvence hodnot. Wartość początkową można podać albo jawnie przez wywołanie metody <xref:System.Random.%23ctor%28System.Int32%29> konstruktora, lub niejawnie przez wywołanie <xref:System.Random.%23ctor> konstruktora. Większość programistów wywołanie konstruktora bez parametrów, który korzysta z zegara systemowego. W poniższym przykładzie użyto tego podejścia do tworzenia wystąpienia dwóch <xref:System.Random> wystąpień. Każde wystąpienie prezentuje serię 10 losowych liczb całkowitych.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Jednak ze względu na jego skończoną rozdzielczość zegara systemowego nie wykrywa różnice czasu, które są mniej niż około 15 milisekund. W związku z tym jeśli kod wywołuje <xref:System.Random.%23ctor> przeładowania do utworzenia wystąpienia dwóch <xref:System.Random> obiektów w odstępie czasu, możesz przypadkowo udostępniają obiekty z wartościami inicjującymi identyczne. Aby to zobaczyć w poprzednim przykładzie, komentarz <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> wywołania metody i kompilacji i ponownie uruchom przykład.  
  
 Aby temu zapobiec, firma Microsoft zaleca, Utwórz wystąpienie jednego <xref:System.Random> obiektu zamiast wiele migawek. Jednak ponieważ <xref:System.Random> nie jest bezpieczny wątkowo, możesz uzyskać dostęp, należy użyć niektórych urządzeń synchronizacji <xref:System.Random> wystąpienia z wielu wątków; Aby uzyskać więcej informacji, zobacz [losowych bezpieczeństwa klasy i wątku](#ThreadSafety) wcześniej w tym temat. Alternatywnie służy mechanizm opóźnienie, takie jak <xref:System.Threading.Thread.Sleep%2A> metodę używaną w poprzednim przykładzie, aby upewnić się, że wystąpień wystąpić więcej niż 15 milisekund od siebie.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Pobieranie liczby całkowite w określonym zakresie  
 Możesz pobrać liczb całkowitych w określonym zakresie, wywołując <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metody, która umożliwia określenie zarówno dolną i górną granicę numery chcesz generator liczb losowych do zwrócenia. Górna granica jest wyłącznie, nie obejmują, wartość. Oznacza to, że nie jest zawarty w zakresie wartości zwracanych przez metodę. W poniższym przykładzie użyto tej metody do wygenerowania losowych liczby całkowite z zakresu od -10 do 10. Należy pamiętać, że Określa on 11, która jest większa o jeden od żądaną wartość, jako wartość z `maxValue` argumentu w wywołaniu metody.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Pobieranie liczby całkowite z określonej liczby cyfr  
 Możesz wywołać <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metoda pobierania liczb z określonej liczby cyfr. Na przykład, aby pobrać liczby cztery cyfry (oznacza to, liczby, w zakresie od-1000 do 9999), należy wywołać <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metody z `minValue` wartość 1000 i `maxValue` wartość 10000, co ilustruje poniższy przykład.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Pobieranie wartości zmiennoprzecinkowych w określonym zakresie  
 <xref:System.Random.NextDouble%2A> Metoda zwraca losowych wartości zmiennoprzecinkowych tego zakresu od 0 do mniej niż 1. Jednak często warto Generowanie losowe wartości w niektórych innych zakresu.  
  
 Jeśli interwał między minimalną i maksymalną żądaną wartość wynosi 1, można dodać różnicę między żądany przedział wyjścia i 0 liczbę zwróconych przez <xref:System.Random.NextDouble%2A> metody. Poniższy przykład robi to w celu generowania liczb losowych 10, od -1 i 0.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Do wygenerowania losowych liczb zmiennoprzecinkowych, którego dolna granica jest 0, ale górna granica jest większa niż 1 (lub, w przypadku wartości ujemne, którego dolna granica jest mniejsza niż -1 i górną granicę wynosi 0), należy pomnożyć liczbę losową przez granicę różna od zera. Poniższy przykład robi to w celu wygenerowania losowych liczb zmiennoprzecinkowych 20 milionów tego zakresu od 0 do <xref:System.Int64.MaxValue?displayProperty=nameWithType>. W wyświetla również dystrybucję losowych wartości generowanych przez metodę.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Do wygenerowania losowych liczb zmiennoprzecinkowych między dwiema wartościami dowolnego, takich jak <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metoda wykonuje liczb całkowitych, należy użyć następującej formuły:  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 Poniższy przykład generuje 1 milion losowych liczb z zakresu od 10.0 do 11.0 i wyświetla ich dystrybucji.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Generowanie losowe wartości logicznych  
 <xref:System.Random> Klasy nie udostępnia metody, które generują <xref:System.Boolean> wartości. Można jednak zdefiniować własne klasy lub metody, aby to zrobić. W poniższym przykładzie zdefiniowano klasę, `BooleanGenerator`, z jedną metodą `NextBoolean`. `BooleanGenerator` Klasa przechowuje <xref:System.Random> obiektu jako zmienną prywatną. `NextBoolean` Wywołania metody <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metody i przekazuje jego wynik do <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> metody. Należy pamiętać, że 2 służy jako argument do określania górną granicę liczbę losową. Ponieważ jest to wartość będącą liczbą wyłączny, wywołanie metody zwraca wartość 0 lub 1.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Zamiast tworzyć osobnej klasy do wygenerowania losowych <xref:System.Boolean> , przykładu można po prostu zdefiniowane wartości pojedynczej metody. W takim jednak <xref:System.Random> obiektu powinien został zdefiniowany jako zmiennej na poziomie klasy, aby uniknąć tworzenia wystąpienia nowego <xref:System.Random> wystąpienia w każdym wywołaniu metody. W języku Visual Basic można zdefiniować jako wystąpienie Random [statyczne](~/docs/visual-basic/language-reference/modifiers/static.md) zmienną `NextBoolean` metody.  W poniższym przykładzie przedstawiono implementację.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Generowanie losowe 64-bitowych liczb całkowitych  
 Przeciążenia <xref:System.Random.Next%2A> zwracany przez metodę 32-bitowych liczb całkowitych. Jednak w niektórych przypadkach można pracować z 64-bitowych liczb całkowitych. Można to zrobić w następujący sposób:  
  
1.  Wywołaj <xref:System.Random.NextDouble%2A> metodę, która pobierze zmiennoprzecinkową podwójnej precyzji punktu wartości.  
  
2.  Pomnóż tę wartość przez <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 Poniższy przykład używa tej techniki w celu wygenerowania losowych długich liczb całkowitych 20 milionów i klasyfikuje je w grupach równy 10. Następnie oblicza rozkład liczb losowych liczbą w każdej grupie od 0 do <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Dane wyjściowe z przykładu pokazują, liczby są dystrybuowane więcej lub mniej równie w zakresie liczba całkowita typu long.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Technika alternatywne, manipulowania bit używa nie generuje naprawdę losowych liczb. Ta metoda wywołuje <xref:System.Random.Next> do generowania dwóch liczb całkowitych, bity jeden na 32 przesunięcia w lewo i ORs je razem. Technika ta ma dwa ograniczenia:  
  
1.  Ponieważ bitowe 31 bitu znaku, wartość bitowa 31 wynikowa liczba całkowita typu long jest zawsze 0.  Można temu zaradzić przez Generowanie losowe 0 lub 1, po lewej stronie zmiany jego 31 bitów i ORing ją za pomocą oryginalnego losowe długich liczb całkowitych.  
  
2.  Więcej naszych użytkowników bardzo poważnie ponieważ prawdopodobieństwo, że wartość zwracana przez <xref:System.Random.Next> będzie mieć wartość 0, będzie kilka ewentualne losowych liczb z zakresu od 0x0 0x00000000FFFFFFFF.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Pobieranie bajtów w określonym zakresie  
 Przeciążenia <xref:System.Random.Next%2A> metody pozwalają na określenie zakresu liczb losowych, ale <xref:System.Random.NextBytes%2A> nie obsługuje metody. Poniższy przykład implementuje `NextBytes` metodę, która umożliwia określenie zakresu bajtów zwrócona. Definiuje on `Random2` klasę pochodzącą od <xref:System.Random> i przeciążenia jego `NextBytes` metody.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 `NextBytes(Byte[], Byte, Byte)` Metoda zawija wywołanie do <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metody i określa wartość minimalna i jeden większa niż wartość maksymalna (w tym przypadku 0 i 101), firma Microsoft mają być zwracane w tablicy bajtów. Ponieważ firma Microsoft pewności, czy zwrócone wartości całkowitych, przez <xref:System.Random.Next%2A> metody są w zakresie <xref:System.Byte> typu danych, firma Microsoft może bezpiecznie je rzutowania (w języku C#) lub też przekonwertować je (w języku Visual Basic) z liczbami całkowitymi bajtów.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Pobieranie elementu z tablicy lub kolekcji losowo  
 Liczby losowe często służą jako indeksy, aby pobrać wartości z tablic lub kolekcji. Do pobierania wartości losowych indeksu, można wywołać <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metoda i użyj dolnej granicy tablicy jako wartość jej `minValue` argument i jeden większa niż górna granica tablicy jako wartość jej `maxValue` argumentu. Tablicę indeksowaną od zera, jest to odpowiednik do jego <xref:System.Array.Length%2A> właściwości lub jeden większa niż wartość zwrócona przez obiekt <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> metody. Poniższy przykład pobiera losowo nazwę miasta w Stanach Zjednoczonych z tablicy miast.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Pobieranie unikatowy element z tablicy lub kolekcji  
 Generator liczb losowych, zawsze możesz wrócić zduplikowanych wartości. Zakres numerów staje się mniejszy lub liczba wartości generowane staje się większe, zwiększa się prawdopodobieństwo duplikaty. Jeśli losowych wartości muszą być unikatowe, więcej cyfr są generowane kompensuje duplikaty, skutkuje coraz bardziej pogorszenia wydajności.  
  
 Istnieje kilka technik do obsługi tego scenariusza. Jest jednym z typowych rozwiązań do utworzenia tablicy lub kolekcji, która zawiera wartości, które mają zostać pobrane i równoległych tablicę, która zawiera losowych liczb zmiennoprzecinkowych. Druga tablica jest wypełniana przy użyciu liczb losowych w momencie pierwszej tablicy jest tworzony, i <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> metoda jest używana do sortowania pierwszą tablicę przy użyciu wartości w tablicy równoległych.  
  
 Na przykład jeśli tworzysz gry Pasjans chcesz upewnić się, że każda karta jest używana tylko raz. Zamiast generowania liczb losowych, aby pobrać karty i śledzenia, czy karty już zostały uwzględnione, można utworzyć równoległej tablicy liczb losowych, który może służyć do sortowania na pokład. Po talii jest sortowana, aplikacja może zachować wskaźnik do wskazania indeks następnej karty na pokładzie.  
  
 To podejście pokazano w poniższym przykładzie. Definiuje on `Card` klasy, który reprezentuje kartę i a `Dealer` klasę, która zajmuje talii kart losowe. `Dealer` Konstruktora klasy wypełnia dwie tablice: `deck` tablicy, która ma zakres klasy i reprezentujący wszystkie karty w talii; i lokalnym `order` tablica, która ma taką samą liczbę elementów jak `deck` macierz, a następnie jest wypełniana z losowym <xref:System.Double> wartości.  <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> Następnie wywoływana jest metoda, aby posortować `deck` tablicy na podstawie wartości w `order` tablicy.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 Poniższy przykład tworzy pojedynczy generator liczb losowych i wywołuje jego <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, i <xref:System.Random.NextDouble%2A> metod do wygenerowania sekwencje liczby losowych w różnych zakresach.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 Poniższy przykład generuje przypadkową liczbę całkowitą, która jest używana jako indeks do pobierania wartości ciągu z tablicy.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>W .NET Framework 1.0 i 1.1 minimalne wdrożenie klasę pochodną <see cref="T:System.Random" /> wymagane zastępowanie <see cref="M:System.Random.Sample" /> metodę, aby zdefiniować nowe lub zmodyfikowane algorytmu do generowania liczb losowych. Klasa pochodna może następnie zależą od implementacji klasy podstawowej <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, i <see cref="M:System.Random.NextDouble" /> metod do wywołania implementacji klasy pochodnej <see cref="M:System.Random.Sample" /> metody.  W .NET Framework 2.0 i nowsze wersje, z zachowaniem <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, i <see cref="M:System.Random.NextBytes(System.Byte[])" /> metody zostały zmienione tak, aby te metody nie wywołuj implementacji klasy pochodnej <see cref="M:System.Random.Sample" /> metody. W rezultacie klasy pochodne klasy <see cref="T:System.Random" /> docelowych programu .NET Framework 2.0 i nowszej powinien także zastąpić te trzy metody.</para>
    </block>
    <block subset="none" type="usage">
      <para>Implementacja generator liczb losowych w <see cref="T:System.Random" /> klasy nie jest gwarantowane pozostają takie same w różnych wersjach głównych programu .NET Framework. Co w efekcie nie należy zakładać, że tego samego inicjatora spowodują tę samą sekwencję pseudolosową w różnych wersjach programu .NET Framework.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Random" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Random" /> klasy za pomocą inicjatora zależne od czasu domyślnie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna, inicjator jest tworzony na podstawie zegara systemowego i skończoną rozdzielczości. W wyniku innego <xref:System.Random> obiektów, które są tworzone w odstępie czasu Zamknij przez wywołanie konstruktora domyślnego mają identyczne domyślnymi wartościami inicjującymi i dlatego dadzą identyczne zestawy warunków o losowych liczb. Można uniknąć tego problemu przy użyciu pojedynczej <xref:System.Random> obiektu umożliwiającą wygenerowanie wszystkich liczb losowych. Można również obejść go przy użyciu inicjatora wartości zwracane przez zegar systemowy i następnie jawnie podając tej nowej wartości inicjatora do <xref:System.Random.%23ctor%28System.Int32%29> konstruktora. Aby uzyskać więcej informacji, zobacz <xref:System.Random.%23ctor%28System.Int32%29> konstruktora.  
  
 Wywołania tego konstruktora, jeśli chcesz, aby Twoje generator liczb losowych do wygenerowania losowych sekwencji liczb. Aby wygenerować stały sekwencji liczb losowych, który ma być takie same dla różnych generatorów liczb losowych, należy wywołać <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor wartością inicjatora stałej. To <xref:System.Random> przeciążenia konstruktora jest często używany podczas testowania aplikacji, które używają liczb losowych.  
  
 Po został uruchomiony generator liczb losowych, należy wywołać poszczególnych <xref:System.Random> metod, takich jak <xref:System.Random.Next> lub <xref:System.Random.NextDouble>w celu generowania liczb losowych.  
  
   
  
## Examples  
 W poniższym przykładzie użyto domyślnego konstruktora do utworzenia wystąpienia trzech <xref:System.Random> obiektów i wyświetla sekwencję pięciu losowych liczb całkowitych dla każdego. Ponieważ pierwsze dwa <xref:System.Random> obiekty są tworzone w odstępie czasu Zamknij, są tworzone przy użyciu inicjatora identyczne wartości na podstawie zegara systemowego i dlatego produkują identyczne sekwencji liczb losowych. Z drugiej strony, domyślny konstruktor obiektu trzeci <xref:System.Random> obiektu jest wywoływana po dwóch sekund opóźnienia spowodowane przez wywołanie metody <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody. Ponieważ to daje wartość inicjatora różnych trzeci <xref:System.Random> obiektu, wywołuje inną kombinację liczb losowych.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Liczba, używane do obliczania wartość początkową dla pseudolosową numer sekwencji. Jeśli określono wartość ujemną, jest używana wartość bezwzględną liczby.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Random" /> klasy przy użyciu wartości inicjatora określona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podawania wartości inicjatora identyczne do różnych <xref:System.Random> obiektów powoduje, że każde wystąpienie wygenerować identyczne sekwencje liczby losowych. Często jest to wykonywane podczas testowania aplikacji, które zależą od generatorów liczb losowych.  
  
 Jeśli aplikacja wymaga różnych sekwencji liczb losowych, należy wywołać ten konstruktor wielokrotnie z wartościami inicjującymi różne. Jednym ze sposobów uzyskiwania wartości inicjatora unikatowy jest zapewnienie zależne od czasu. Na przykład dziedziczyć wartość początkową jako zegara systemowego <xref:System.Random.%23ctor> jest przeciążenia. Jednak zegara systemowego może nie mieć wystarczającą rozdzielczość zapewnienie różnych wywołania tego konstruktora z wartością innego inicjatora. Skutkuje to generatorów liczb losowych, które generują identyczny sekwencji pseudolosową liczb, zgodnie z przedstawionymi pierwsze dwa <xref:System.Random> obiektów w poniższym przykładzie. Aby tego uniknąć, należy zastosować algorytm odróżnienie wartości początkowej, w każdym wywołaniem lub wywołanie <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodę, aby upewnić się, udostępnia każdego konstruktora wartością inicjatora różnych.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Innym rozwiązaniem jest utworzenie wystąpienia jednego <xref:System.Random> obiektu służącego do generowania liczb losowych w aplikacji. Daje to nieznacznie wyższa wydajność, ponieważ wystąpienia generator liczb losowych jest dość kosztowna.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Random> obiektów za pomocą konstruktora klasy, która przyjmuje parametr inicjatora i generuje sekwencję losowych liczb całkowitych oraz wartości podwójnej precyzji. W przykładzie pokazano, że tej samej sekwencji jest generowany podczas <xref:System.Random> obiekt zostanie utworzony ponownie z parametrem Konstruktor i inicjatora.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca losową liczbę całkowitą.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca losową wartość nieujemną liczbę całkowitą.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem jest większa niż lub równa 0 i mniejsza niż <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> generuje losową liczbę, którego wartość należy do zakresu od 0 do mniej niż <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Aby wygenerować losową liczbę, którego wartość należy do zakresu od 0 dodatnią liczbę, należy użyć <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> przeciążenie metody. Aby wygenerować losową liczbę do innego zakresu, należy użyć <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> przeciążenie metody.  
  
   
  
## Examples  
 Poniższy przykład wykonuje wielokrotnego wywołania <xref:System.Random.Next%2A> metodę w celu wygenerowania określoną liczbę liczb losowych żądanej przez użytkownika. <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> Metoda jest używana do pobierania danych wejściowych klienta.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 Poniższy przykład pochodzi z klasy <xref:System.Random> na wygenerowanie sekwencji liczb losowych, których dystrybucja różni się od jednolity rozkład generowane przez <xref:System.Random.Sample%2A> metody klasy bazowej. Zastępuje ona <xref:System.Random.Sample%2A> metody w celu zapewnienia rozkład liczb losowych i zastąpień <xref:System.Random.Next%2A?displayProperty=nameWithType> metodę serii liczb losowych.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Począwszy od programu .NET Framework w wersji 2.0, jeśli wyprowadzić klasę z <see cref="T:System.Random" /> i zastąpić <see cref="M:System.Random.Sample" /> metody, dystrybucji dostarczone przez implementację klasy pochodnej <see cref="M:System.Random.Sample" /> metoda nie jest używany w wywołania do klasy bazowej Implementacja <see cref="M:System.Random.Next" /> metody. Zamiast tego jednolity rozkład zwrócony przez base <see cref="T:System.Random" /> klasa jest używana. To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy. Aby zmienić to zachowanie, aby wywołać <see cref="M:System.Random.Sample" /> metody w klasie pochodnej, konieczne jest również przesłonięcie <see cref="M:System.Random.Next" /> metody.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Wyłączne górną granicę losową liczbę do wygenerowania. <c>maxValue</c> musi być większa lub równa 0.</param>
        <summary>Zwraca wartość nieujemną losową wartość całkowitą mniejszą niż określona wartość maksymalna.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem jest większa niż lub równa 0 i mniejsza niż <paramref name="maxValue" />; oznacza to, że zakres zwracanych wartości zwykle obejmuje 0, ale nie <paramref name="maxValue" />. Jednak jeśli <paramref name="maxValue" /> jest równa 0, <paramref name="maxValue" /> jest zwracana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%29> Przeciążenia zwraca losowych liczb całkowitych tego zakresu od 0 do `maxValue` – 1. Jednak jeśli `maxValue` wynosi 0, metoda zwróci wartość 0.  
  
   
  
## Examples  
 Poniższy przykład generuje losowych liczb całkowitych przy użyciu różnych przeciążenia <xref:System.Random.Next%2A> metody.  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 Poniższy przykład generuje przypadkową liczbę całkowitą, która jest używana jako indeks do pobierania wartości ciągu z tablicy. Ponieważ najwyższy indeks tablicy jest jeden mniejsza od jego długości, wartość <xref:System.Array.Length%2A?displayProperty=nameWithType> właściwość jest dostarczany jako `maxValue` parametru.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxValue" /> jest mniejsza niż 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Zwracane włącznie dolna granica liczbę losową.</param>
        <param name="maxValue">Wyłączne górnej granicy liczby losowe są zwracane. <c>maxValue</c> musi być większa lub równa <c>minValue</c>.</param>
        <summary>Zwraca losową liczbę całkowitą, która znajduje się w określonym zakresie.</summary>
        <returns>32-bitowych całkowita większa lub równa <paramref name="minValue" /> i mniej niż <paramref name="maxValue" />; to, że zakres wartości zwracanych obejmuje <paramref name="minValue" /> , ale nie <paramref name="maxValue" />. Jeśli <paramref name="minValue" /> jest równa <paramref name="maxValue" />, <paramref name="minValue" /> jest zwracana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Przeciążenia zwraca losowych liczb całkowitych w zakresie od `minValue` do `maxValue` – 1. Jednak jeśli `maxValue` jest równa `minValue`, metoda zwraca `minValue`.  
  
 W przeciwieństwie do innych przeciążeń <xref:System.Random.Next%2A> metody zwracają wartości tylko wartość nieujemną, ta metoda może zwracać ujemna losową wartość całkowitą.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodę w celu wygenerowania losowych liczb całkowitych z trzech różnych zakresów. Należy pamiętać, że dokładnie wynika z przykładu zależy od wartości inicjatora dostarczane przez system przekazany do <xref:System.Random> konstruktora klasy.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 Poniższy przykład generuje przypadkową liczbę całkowitą, która jest używana jako indeks do pobierania wartości ciągu z tablicy. Ponieważ najwyższy indeks tablicy jest jeden mniejsza od jego długości, wartość <xref:System.Array.Length%2A?displayProperty=nameWithType> właściwość jest dostarczany jako `maxValue` parametru.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="minValue" /> jest większa niż <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides">
          <para>Począwszy od programu .NET Framework w wersji 2.0, jeśli wyprowadzić klasę z <see cref="T:System.Random" /> i zastąpić <see cref="M:System.Random.Sample" /> metody, dystrybucji dostarczone przez implementację klasy pochodnej <see cref="M:System.Random.Sample" /> metoda nie jest używany w wywołania do klasy bazowej Implementacja <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> przeciążenia metody, jeśli różnica między <paramref name="minValue" /> i <paramref name="maxValue" /> parametrów jest większa niż <see cref="F:System.Int32.MaxValue" />. Zamiast tego jednolity rozkład zwrócony przez base <see cref="T:System.Random" /> klasa jest używana. To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy. Aby zmienić to zachowanie, aby wywołać <see cref="M:System.Random.Sample" /> metody w klasie pochodnej, konieczne jest również przesłonięcie <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> przeciążenie metody.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica bajtów, które mają zawierać liczb losowych.</param>
        <summary>Wypełnia elementów określonej tablicy bajtów przy użyciu liczb losowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element tablicy bajtów jest równa losową liczbę większy lub równy 0 i mniejsza niż lub równa <xref:System.Byte.MaxValue>.  
  
 Na przykład, aby wygenerować zabezpieczone kryptograficznie losową liczbę umożliwiających tworzenie losowego hasła, użyć metody takie jak <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Random.NextBytes%2A> metodę, aby wypełnić tablicę bajtów losowych wartości bajtów.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Począwszy od programu .NET Framework w wersji 2.0, jeśli wyprowadzić klasę z <see cref="T:System.Random" /> i zastąpić <see cref="M:System.Random.Sample" /> metody, dystrybucji dostarczone przez implementację klasy pochodnej <see cref="M:System.Random.Sample" /> metoda nie jest używany w wywołania do klasy bazowej Implementacja <see cref="M:System.Random.NextBytes(System.Byte[])" /> metody. Zamiast tego jednolity rozkład zwrócony przez base <see cref="T:System.Random" /> klasa jest używana. To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy. Aby zmienić to zachowanie, aby wywołać <see cref="M:System.Random.Sample" /> metody w klasie pochodnej, konieczne jest również przesłonięcie <see cref="M:System.Random.NextBytes(System.Byte[])" /> metody.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca losową liczbę zmiennoprzecinkową, która jest większa niż lub równy od 0,0 i mniejszą niż 1,0.</summary>
        <returns>Podwójnej precyzji ruchomy punkt liczba, która jest większa niż lub równy od 0,0 i mniejszą niż 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rzeczywiste górnej granicy liczby losowe zwracanego przez tę metodę jest 0.99999999999999978.  
  
 Aby pobrać losowych wartości zmiennoprzecinkowych w zakresie innym niż od 0,0 do 1,0, zobacz sekcję "Pobieranie wartości zmiennoprzecinkowych w określonym zakresie" <xref:System.Random> temat poświęcony klasie.  
  
 Ta metoda jest w publicznej wersji Metoda chroniona <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Random.NextDouble%2A> metodę w celu wygenerowania sekwencje losowych wartości podwójnej precyzji.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 Poniższy przykład wywołuje <xref:System.Random.NextDouble%2A> metodę w celu wygenerowania losowych 100 liczby i wyświetla ich dystrybucji częstotliwości.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca liczbę losową zmiennoprzecinkową z zakresu od 0,0 do 1,0.</summary>
        <returns>Podwójnej precyzji ruchomy punkt liczba, która jest większa niż lub równy od 0,0 i mniejszą niż 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby wygenerować różne losowa dystrybucja lub różnych losowych liczb generator regułę, należy wyprowadzić klasę z <xref:System.Random> klasy, a także Przesłoń <xref:System.Random.Sample%2A> metody.  
  
> [!IMPORTANT]
>  <xref:System.Random.Sample%2A> Metodą jest `protected`, co oznacza, że jest dostępny tylko w obrębie <xref:System.Random> klasy i jej klasy pochodne. Aby wygenerować losową liczbę od 0 do 1 z <xref:System.Random> wystąpienia, wywołaj <xref:System.Random.NextDouble%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład pochodzi z klasy <xref:System.Random> i zastępuje <xref:System.Random.Sample%2A> metodę w celu wygenerowania dystrybucji liczb losowych. Tej dystrybucji jest inny niż jednolity rozkład generowane przez <xref:System.Random.Sample%2A> metody klasy bazowej.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Począwszy od programu .NET Framework w wersji 2.0, jeśli wyprowadzić klasę z <see cref="T:System.Random" /> i zastąpić <see cref="M:System.Random.Sample" /> metody, dystrybucji dostarczone przez implementację klasy pochodnej <see cref="M:System.Random.Sample" /> metoda nie jest używany w wywołania do klasy bazowej Implementacja następujących metod: — <see cref="M:System.Random.NextBytes(System.Byte[])" /> metody.  <see cref="M:System.Random.Next" /> Metody.  <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> Metody, jeśli (<paramref name="maxValue" /> - <paramref name="minValue" />) jest większa niż <see cref="F:System.Int32.MaxValue" />.  Zamiast tego jednolity rozkład dostarczone przez base <see cref="T:System.Random" /> klasa jest używana. To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy. Aby zmienić to zachowanie, aby wywołać implementację <see cref="M:System.Random.Sample" /> metody w klasie pochodnej, możesz również zastąpić zachowanie te trzy elementy członkowskie. Przykład stanowi ilustrację.</para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>
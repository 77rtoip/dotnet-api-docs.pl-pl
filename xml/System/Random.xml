<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a5d099662a51c9ac6e434b6e8eb94d1a73c68700" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69419508" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="4f275-101">Reprezentuje generator liczb losowych, który jest urządzeniem, które tworzy sekwencję liczb, które spełniają pewne wymagania statystyczne losowości.</span><span class="sxs-lookup"><span data-stu-id="4f275-101">Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4f275-102">Liczby losowe są wybierane z równym prawdopodobieństwem z skończonego zestawu liczb.</span><span class="sxs-lookup"><span data-stu-id="4f275-102">Pseudo-random numbers are chosen with equal probability from a finite set of numbers.</span></span> <span data-ttu-id="4f275-103">Wybrane numery nie są całkowicie losowe, ponieważ algorytm matematyczny jest używany do ich zaznaczania, ale są wystarczająco losowe do celów praktycznych.</span><span class="sxs-lookup"><span data-stu-id="4f275-103">The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.</span></span> <span data-ttu-id="4f275-104">Bieżąca implementacja <xref:System.Random> klasy jest oparta na zmodyfikowanej wersji algorytmu generatora liczb losowych Donald E. Knuth.</span><span class="sxs-lookup"><span data-stu-id="4f275-104">The current implementation of the <xref:System.Random> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.</span></span> <span data-ttu-id="4f275-105">Aby uzyskać więcej informacji, zobacz D. E.</span><span class="sxs-lookup"><span data-stu-id="4f275-105">For more information, see D. E.</span></span> <span data-ttu-id="4f275-106">Knuth.</span><span class="sxs-lookup"><span data-stu-id="4f275-106">Knuth.</span></span> <span data-ttu-id="4f275-107">*Kompozycja programowania komputerów, Tom 2: Algorytmy*Seminumerical.</span><span class="sxs-lookup"><span data-stu-id="4f275-107">*The Art of Computer Programming, Volume 2: Seminumerical Algorithms*.</span></span> <span data-ttu-id="4f275-108">Addison-Wesley, czytanie, MA, wersja trzecia, 1997.</span><span class="sxs-lookup"><span data-stu-id="4f275-108">Addison-Wesley, Reading, MA, third edition, 1997.</span></span>  
  
 <span data-ttu-id="4f275-109">Aby wygenerować kryptograficzną kryptograficznie liczbę losową, na przykład odpowiednią do tworzenia hasła losowego, użyj <xref:System.Security.Cryptography.RNGCryptoServiceProvider> klasy lub Utwórz klasę z. <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="4f275-109">To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class or derive a class from <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="4f275-110">W tym temacie:</span><span class="sxs-lookup"><span data-stu-id="4f275-110">In this topic:</span></span>  
  
 <span data-ttu-id="4f275-111">[Tworzenie wystąpienia generatora liczb losowych](#Instantiate) </span><span class="sxs-lookup"><span data-stu-id="4f275-111">[Instantiating the random number generator](#Instantiate) </span></span>  
 <span data-ttu-id="4f275-112">[Unikanie wielu wystąpień](#Multiple) </span><span class="sxs-lookup"><span data-stu-id="4f275-112">[Avoiding multiple instantiations](#Multiple) </span></span>  
 <span data-ttu-id="4f275-113">[System. Random — bezpieczeństwo klasy i wątku](#ThreadSafety) </span><span class="sxs-lookup"><span data-stu-id="4f275-113">[The System.Random class and thread safety](#ThreadSafety) </span></span>  
 <span data-ttu-id="4f275-114">[Generowanie różnych typów liczb losowych](#Functionality) </span><span class="sxs-lookup"><span data-stu-id="4f275-114">[Generating different types of random numbers](#Functionality) </span></span>  
 <span data-ttu-id="4f275-115">[Podstawianie własnego algorytmu](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="4f275-115">[Substituting your own algorithm](#Overriding) </span></span>  
 <span data-ttu-id="4f275-116">[Jak używać System. Random do...](#Operations) </span><span class="sxs-lookup"><span data-stu-id="4f275-116">[How do you use System.Random to…](#Operations) </span></span>  
 [<span data-ttu-id="4f275-117">Pobierz tę samą sekwencję wartości losowych</span><span class="sxs-lookup"><span data-stu-id="4f275-117">Retrieve the same sequence of random values</span></span>](#Same)  
 [<span data-ttu-id="4f275-118">Pobieranie unikatowych sekwencji wartości losowych</span><span class="sxs-lookup"><span data-stu-id="4f275-118">Retrieve unique sequences of random values</span></span>](#Unique)  
 [<span data-ttu-id="4f275-119">Pobierz liczby całkowite w określonym zakresie</span><span class="sxs-lookup"><span data-stu-id="4f275-119">Retrieve integers in a specified range</span></span>](#Range)  
 [<span data-ttu-id="4f275-120">Pobierz liczby całkowite z określoną liczbą cyfr</span><span class="sxs-lookup"><span data-stu-id="4f275-120">Retrieve integers with a specified number of digits</span></span>](#Digits)  
 [<span data-ttu-id="4f275-121">Pobierz wartości zmiennoprzecinkowe w określonym zakresie</span><span class="sxs-lookup"><span data-stu-id="4f275-121">Retrieve floating-point values in a specified range</span></span>](#Floats)  
 [<span data-ttu-id="4f275-122">Generuj losowe wartości logiczne</span><span class="sxs-lookup"><span data-stu-id="4f275-122">Generate random Boolean values</span></span>](#Boolean)  
 [<span data-ttu-id="4f275-123">Generuj losowe 64-bitowe liczby całkowite</span><span class="sxs-lookup"><span data-stu-id="4f275-123">Generate random 64-bit integers</span></span>](#Long)  
 [<span data-ttu-id="4f275-124">Pobierz bajty w określonym zakresie</span><span class="sxs-lookup"><span data-stu-id="4f275-124">Retrieve bytes in a specified range</span></span>](#Bytes)  
 [<span data-ttu-id="4f275-125">Pobieranie elementu z tablicy lub kolekcji losowo</span><span class="sxs-lookup"><span data-stu-id="4f275-125">Retrieve an element from an array or collection at random</span></span>](#Array)  
 [<span data-ttu-id="4f275-126">Pobieranie unikatowego elementu z tablicy lub kolekcji</span><span class="sxs-lookup"><span data-stu-id="4f275-126">Retrieve a unique element from an array or collection</span></span>](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a><span data-ttu-id="4f275-127">Tworzenie wystąpienia generatora liczb losowych</span><span class="sxs-lookup"><span data-stu-id="4f275-127">Instantiating the random number generator</span></span>  
 <span data-ttu-id="4f275-128">Tworzenie wystąpienia generatora liczb losowych przez podanie wartości inicjatora (wartości początkowej dla algorytmu generowania losowych liczb pseudolosowych) do <xref:System.Random.%23ctor%2A> konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="4f275-128">You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <xref:System.Random.%23ctor%2A> class constructor.</span></span>  <span data-ttu-id="4f275-129">Możesz podać wartość inicjatora jawnie lub niejawnie:</span><span class="sxs-lookup"><span data-stu-id="4f275-129">You can supply the seed value either explicitly or implicitly:</span></span>  
  
-   <span data-ttu-id="4f275-130"><xref:System.Random.%23ctor%28System.Int32%29> Konstruktor używa jawnej wartości inicjatora, która została dostarczona.</span><span class="sxs-lookup"><span data-stu-id="4f275-130">The <xref:System.Random.%23ctor%28System.Int32%29> constructor uses an explicit seed value that you supply.</span></span>  
  
-   <span data-ttu-id="4f275-131"><xref:System.Random.%23ctor> Konstruktor używa zegara systemowego do zapewnienia wartości inicjatora.</span><span class="sxs-lookup"><span data-stu-id="4f275-131">The <xref:System.Random.%23ctor> constructor uses the system clock to provide a seed value.</span></span> <span data-ttu-id="4f275-132">Jest to najbardziej typowy sposób tworzenia wystąpienia generatora liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-132">This is the most common way of instantiating the random number generator.</span></span>  
  
 <span data-ttu-id="4f275-133">Jeśli ten sam inicjator jest używany w odniesieniu do oddzielnych <xref:System.Random> obiektów, spowoduje to wygenerowanie tej samej serii liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-133">If the same seed is used for separate <xref:System.Random> objects, they will generate the same series of random numbers.</span></span> <span data-ttu-id="4f275-134">Może to być przydatne w przypadku tworzenia zestawu testów, który przetwarza losowe wartości lub odtwarzania gier, które pobierają dane z liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-134">This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.</span></span> <span data-ttu-id="4f275-135">Należy jednak pamiętać, <xref:System.Random> że obiekty w procesach działających w różnych wersjach .NET Framework mogą zwracać różne serie liczb losowych, nawet jeśli są tworzone z identycznymi wartościami inicjatora.</span><span class="sxs-lookup"><span data-stu-id="4f275-135">However, note that <xref:System.Random> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.</span></span>  
  
 <span data-ttu-id="4f275-136">Aby generować różne sekwencje liczb losowych, można wprowadzić wartość inicjatora zależnie od czasu, generując inną serię przy każdym nowym wystąpieniu <xref:System.Random>.</span><span class="sxs-lookup"><span data-stu-id="4f275-136">To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <xref:System.Random>.</span></span> <span data-ttu-id="4f275-137">Sparametryzowany <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor może <xref:System.Int32> przyjmować wartość na podstawie liczby taktów w bieżącym czasie <xref:System.Random.%23ctor> , natomiast Konstruktor bez parametrów używa zegara systemowego do wygenerowania jego wartości inicjatora.</span><span class="sxs-lookup"><span data-stu-id="4f275-137">The parameterized <xref:System.Random.%23ctor%28System.Int32%29> constructor can take an <xref:System.Int32> value based on the number of ticks in the current time, whereas the parameterless <xref:System.Random.%23ctor> constructor uses the system clock to generate its seed value.</span></span> <span data-ttu-id="4f275-138">Ponieważ jednak zegar ma skończone rozwiązanie, przy użyciu konstruktora bez parametrów, aby utworzyć różne <xref:System.Random> obiekty w zamknięciu, tworzy losowe generatory liczb, które generują identyczne sekwencje liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-138">However, because the clock has finite resolution, using the parameterless constructor to create different <xref:System.Random> objects in close succession creates random number generators that produce identical sequences of random numbers.</span></span> <span data-ttu-id="4f275-139">Poniższy przykład ilustruje, jak dwa <xref:System.Random> obiekty, które są tworzone w zamknięciu, generują identyczną serię liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-139">The following example illustrates how two <xref:System.Random> objects that are instantiated in close succession generate an identical series of random numbers.</span></span> <span data-ttu-id="4f275-140">W większości systemów <xref:System.Random> Windows obiekty utworzone w ciągu 15 milisekund od siebie prawdopodobnie mają identyczne wartości inicjatora.</span><span class="sxs-lookup"><span data-stu-id="4f275-140">On most Windows systems, <xref:System.Random> objects created within 15 milliseconds of one another are likely to have identical seed values.</span></span>  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 <span data-ttu-id="4f275-141">Aby uniknąć tego problemu, należy utworzyć pojedynczy <xref:System.Random> obiekt zamiast wielu obiektów.</span><span class="sxs-lookup"><span data-stu-id="4f275-141">To avoid this problem, create a single <xref:System.Random> object instead of multiple objects.</span></span>  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a><span data-ttu-id="4f275-142">Unikanie wielu wystąpień</span><span class="sxs-lookup"><span data-stu-id="4f275-142">Avoiding multiple instantiations</span></span>  
 <span data-ttu-id="4f275-143">Zainicjowanie dwóch losowych generatorów liczbowych w ścisłej pętli lub szybkiej powodzeniu powoduje utworzenie dwóch generatorów liczb losowych, które mogą generować identyczne sekwencje liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-143">Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.</span></span> <span data-ttu-id="4f275-144">W większości przypadków nie jest to zamiara dewelopera i może prowadzić do problemów z wydajnością, ponieważ Tworzenie wystąpień i Inicjowanie generatora liczb losowych jest stosunkowo kosztownym procesem.</span><span class="sxs-lookup"><span data-stu-id="4f275-144">In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.</span></span>  
  
 <span data-ttu-id="4f275-145">Aby zwiększyć wydajność i uniknąć przypadkowego tworzenia oddzielnych generatorów liczb losowych generujących identyczne sekwencje liczbowe, zalecamy utworzenie jednego <xref:System.Random> obiektu w celu wygenerowania wielu losowych liczb w czasie, zamiast tworzyć nowe <xref:System.Random> obiekty do wygenerowania jednej liczby losowej.</span><span class="sxs-lookup"><span data-stu-id="4f275-145">Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <xref:System.Random> object to generate many random numbers over time, instead of creating new <xref:System.Random> objects to generate one random number.</span></span>  
  
 <span data-ttu-id="4f275-146"><xref:System.Random> Jednak Klasa nie jest bezpieczna wątkowo.</span><span class="sxs-lookup"><span data-stu-id="4f275-146">However, the <xref:System.Random> class isn't thread safe.</span></span> <span data-ttu-id="4f275-147">Jeśli wywołasz <xref:System.Random> metody z wielu wątków, postępuj zgodnie z wytycznymi opisanymi w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="4f275-147">If you call <xref:System.Random> methods from multiple threads, follow the guidelines discussed in the next section.</span></span>  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a><span data-ttu-id="4f275-148">System. Random — bezpieczeństwo klasy i wątku</span><span class="sxs-lookup"><span data-stu-id="4f275-148">The System.Random class and thread safety</span></span>  
 <span data-ttu-id="4f275-149">Zamiast tworzenia wystąpień pojedynczych <xref:System.Random> obiektów zalecamy utworzenie pojedynczego <xref:System.Random> wystąpienia w celu wygenerowania wszystkich losowych liczb wymaganych przez aplikację.</span><span class="sxs-lookup"><span data-stu-id="4f275-149">Instead of instantiating individual <xref:System.Random> objects, we recommend that you create a single <xref:System.Random> instance to generate all the random numbers needed by your app.</span></span> <span data-ttu-id="4f275-150"><xref:System.Random> Jednak obiekty nie są bezpieczne wątkowo.</span><span class="sxs-lookup"><span data-stu-id="4f275-150">However, <xref:System.Random> objects are not thread safe.</span></span> <span data-ttu-id="4f275-151">Jeśli aplikacja wywołuje <xref:System.Random> metody z wielu wątków, należy użyć obiektu synchronizacji, aby upewnić się, że tylko jeden wątek może uzyskać dostęp do generatora liczb losowych jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="4f275-151">If your app calls <xref:System.Random> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.</span></span> <span data-ttu-id="4f275-152">Jeśli nie masz pewność, że <xref:System.Random> dostęp do obiektu odbywa się w sposób bezpieczny dla wątków, wywołania metod, które zwracają liczby losowe, zwracają 0.</span><span class="sxs-lookup"><span data-stu-id="4f275-152">If you don't ensure that the <xref:System.Random> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.</span></span>  
  
 <span data-ttu-id="4f275-153">W poniższym przykładzie przedstawiono użycie C# [instrukcji lock](~/docs/csharp/language-reference/keywords/lock-statement.md) i instrukcji Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) w celu zapewnienia, że pojedynczy generator liczb losowych jest dostępny przez 11 wątków w sposób bezpieczny dla wątków.</span><span class="sxs-lookup"><span data-stu-id="4f275-153">The following example uses the C# [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) and the Visual Basic [SyncLock statement](~/docs/visual-basic/language-reference/statements/synclock-statement.md) to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.</span></span> <span data-ttu-id="4f275-154">Każdy wątek generuje liczby losowe 2 000 000, zlicza liczby losowe wygenerowane i oblicza ich sumę, a następnie aktualizuje sumy dla wszystkich wątków po zakończeniu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="4f275-154">Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.</span></span>  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 <span data-ttu-id="4f275-155">Przykład zapewnia bezpieczeństwo wątków w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="4f275-155">The example ensures thread-safety in the following ways:</span></span>  
  
-   <span data-ttu-id="4f275-156">Ten <xref:System.ThreadStaticAttribute> atrybut służy do definiowania zmiennych lokalnych wątku, które śledzą łączną liczbę wygenerowanych liczb losowych i ich sumę dla każdego wątku.</span><span class="sxs-lookup"><span data-stu-id="4f275-156">The <xref:System.ThreadStaticAttribute> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.</span></span>  
  
-   <span data-ttu-id="4f275-157">Blokada ( `lock` instrukcja w C# `SyncLock` instrukcji i w Visual Basic) chroni dostęp do zmiennych, aby uzyskać całkowitą liczbę i sumę liczb losowych generowanych na wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="4f275-157">A lock (the `lock` statement in C# and the `SyncLock` statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.</span></span>  
  
-   <span data-ttu-id="4f275-158">Semafor ( <xref:System.Threading.CountdownEvent> obiekt) służy do upewnienia się, że główny wątek jest blokowany przed ukończeniem wszystkich innych wątków.</span><span class="sxs-lookup"><span data-stu-id="4f275-158">A semaphore (the <xref:System.Threading.CountdownEvent> object) is used to ensure that the main thread blocks until all other threads complete execution.</span></span>  
  
-   <span data-ttu-id="4f275-159">Przykład sprawdza, czy generator liczb losowych stał się uszkodzony przez określenie, czy dwa kolejne wywołania metod generowania liczb losowych zwracają 0.</span><span class="sxs-lookup"><span data-stu-id="4f275-159">The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.</span></span> <span data-ttu-id="4f275-160">W przypadku wykrycia uszkodzenia, w przykładzie używa <xref:System.Threading.CancellationTokenSource> obiektu do sygnalizowania, że wszystkie wątki powinny być anulowane.</span><span class="sxs-lookup"><span data-stu-id="4f275-160">If corruption is detected, the example uses the <xref:System.Threading.CancellationTokenSource> object to signal that all threads should be canceled.</span></span>  
  
-   <span data-ttu-id="4f275-161">Przed wygenerowaniem poszczególnych liczb losowych każdy wątek sprawdza stan <xref:System.Threading.CancellationToken> obiektu.</span><span class="sxs-lookup"><span data-stu-id="4f275-161">Before generating each random number, each thread checks the state of the <xref:System.Threading.CancellationToken> object.</span></span> <span data-ttu-id="4f275-162">Jeśli zażądano anulowania, przykład wywołuje <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metodę w celu anulowania wątku.</span><span class="sxs-lookup"><span data-stu-id="4f275-162">If cancellation is requested, the example calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method to cancel the thread.</span></span>  
  
 <span data-ttu-id="4f275-163">Poniższy przykład jest identyczny z pierwszym, z tą różnicą, że <xref:System.Threading.Tasks.Task> używa obiektu i wyrażenia lambda <xref:System.Threading.Thread> zamiast obiektów.</span><span class="sxs-lookup"><span data-stu-id="4f275-163">The following example is identical to the first, except that it uses a <xref:System.Threading.Tasks.Task> object and a lambda expression instead of <xref:System.Threading.Thread> objects.</span></span>  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 <span data-ttu-id="4f275-164">Różni się od pierwszego przykładu w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="4f275-164">It differs from the first example in the following ways:</span></span>  
  
-   <span data-ttu-id="4f275-165">Zmienne, aby śledzić liczbę wygenerowanych liczb losowych i ich sumę w każdym zadaniu, są lokalne do zadania, więc nie ma potrzeby używania <xref:System.ThreadStaticAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="4f275-165">The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="4f275-166">Metoda statyczna <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> jest używana do upewnienia się, że główny wątek nie zostanie ukończony przed ukończeniem wszystkich zadań.</span><span class="sxs-lookup"><span data-stu-id="4f275-166">The static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method is used to ensure that the main thread doesn't complete before all tasks have finished.</span></span> <span data-ttu-id="4f275-167">Nie ma potrzeby dla <xref:System.Threading.CountdownEvent> obiektu.</span><span class="sxs-lookup"><span data-stu-id="4f275-167">There is no need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
-   <span data-ttu-id="4f275-168">Wyjątek, który wynika z anulowania zadania, jest przystawny <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> w metodzie.</span><span class="sxs-lookup"><span data-stu-id="4f275-168">The exception that results from task cancellation is surfaced in the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4f275-169">W poprzednim przykładzie jest obsługiwany przez każdy wątek.</span><span class="sxs-lookup"><span data-stu-id="4f275-169">In the previous example, it is handled by each thread.</span></span>  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a><span data-ttu-id="4f275-170">Generowanie różnych typów liczb losowych</span><span class="sxs-lookup"><span data-stu-id="4f275-170">Generating different types of random numbers</span></span>  
 <span data-ttu-id="4f275-171">Generator liczb losowych udostępnia metody, które pozwalają generować następujące rodzaje liczb losowych:</span><span class="sxs-lookup"><span data-stu-id="4f275-171">The random number generator provides methods that let you generate the following kinds of random numbers:</span></span>  
  
-   <span data-ttu-id="4f275-172">Szereg <xref:System.Byte> wartości.</span><span class="sxs-lookup"><span data-stu-id="4f275-172">A series of <xref:System.Byte> values.</span></span> <span data-ttu-id="4f275-173">Należy określić liczbę wartości bajtowych przez przekazanie zainicjowanej tablicy do liczby elementów, które Metoda ma zwrócić do <xref:System.Random.NextBytes%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-173">You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <xref:System.Random.NextBytes%2A> method.</span></span> <span data-ttu-id="4f275-174">Poniższy przykład generuje 20 bajtów.</span><span class="sxs-lookup"><span data-stu-id="4f275-174">The following example generates 20 bytes.</span></span>  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   <span data-ttu-id="4f275-175">Pojedyncza liczba całkowita.</span><span class="sxs-lookup"><span data-stu-id="4f275-175">A single integer.</span></span> <span data-ttu-id="4f275-176">Można wybrać, czy ma być liczbą całkowitą z zakresu od 0 do wartości maksymalnej<xref:System.Int32.MaxValue?displayProperty=nameWithType> (-1), <xref:System.Random.Next> wywołując metodę, liczbę całkowitą z przedziału od 0 do <xref:System.Random.Next%28System.Int32%29> określonej wartości, wywołując metodę lub liczbę całkowitą w zakresie wartości przez wywołanie <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>Metoda.</span><span class="sxs-lookup"><span data-stu-id="4f275-176">You can choose whether you want an integer from 0 to a maximum value (<xref:System.Int32.MaxValue?displayProperty=nameWithType> - 1) by calling the <xref:System.Random.Next> method, an integer between 0 and a specific value by calling the <xref:System.Random.Next%28System.Int32%29> method, or an integer within a range of values by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="4f275-177">W przypadku przeciążeń parametrycznych określona wartość maksymalna jest wyłączna; oznacza to, że rzeczywista Maksymalna liczba wygenerowanych jest mniejsza niż określona wartość.</span><span class="sxs-lookup"><span data-stu-id="4f275-177">In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.</span></span>  
  
     <span data-ttu-id="4f275-178">Poniższy przykład wywołuje <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodę w celu wygenerowania 10 losowych liczb z przedziału od-10 do 10.</span><span class="sxs-lookup"><span data-stu-id="4f275-178">The following example calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to generate 10 random numbers between -10 and 10.</span></span> <span data-ttu-id="4f275-179">Należy zauważyć, że drugi argument metody określa wyłączną górną granicę zakresu losowych wartości zwracanych przez metodę.</span><span class="sxs-lookup"><span data-stu-id="4f275-179">Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.</span></span> <span data-ttu-id="4f275-180">Innymi słowy, największa liczba całkowita, jaką może zwrócić Metoda, jest mniejsza niż ta wartość.</span><span class="sxs-lookup"><span data-stu-id="4f275-180">In other words, the largest integer that the method can return is one less than this value.</span></span>  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   <span data-ttu-id="4f275-181">Pojedyncza wartość zmiennoprzecinkowa od 0,0 do mniejszej niż 1,0 przez wywołanie <xref:System.Random.NextDouble%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-181">A single floating-point value from 0.0 to less than 1.0 by calling the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="4f275-182">Górną granicą wartości losowej zwracanej przez metodę jest 1, więc jej rzeczywista Górna granica to 0.99999999999999978.</span><span class="sxs-lookup"><span data-stu-id="4f275-182">The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.</span></span> <span data-ttu-id="4f275-183">Poniższy przykład generuje 10 losowych liczb zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-183">The following example generates 10 random floating-point numbers.</span></span>  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="4f275-184"><xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Metoda pozwala określić zakres zwracanych liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-184">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method allows you to specify the range of the returned random number.</span></span> <span data-ttu-id="4f275-185">`maxValue` Jednak parametr, który określa wartość zwracaną przez górny zakres, jest wyłączny, a nie włącznie.</span><span class="sxs-lookup"><span data-stu-id="4f275-185">However, the `maxValue` parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="4f275-186">Oznacza to, że wywołanie `Next(0, 100)` metody zwraca wartość z zakresu od 0 do 99, a nie z zakresu od 0 do 100.</span><span class="sxs-lookup"><span data-stu-id="4f275-186">This means that the method call `Next(0, 100)` returns a value between 0 and 99, and not between 0 and 100.</span></span>  
  
 <span data-ttu-id="4f275-187"><xref:System.Random> Można również użyć klasy dla takich zadań jako generujących [losowe wartości T:System.Boolean](#Boolean), generując [losowo wartości zmiennoprzecinkowe z zakresem innym niż 0 do 1](#Floats), generując [losowo 64-bitowe liczby całkowite](#Long)i [losowo Pobieranie unikatowego elementu z tablicy lub kolekcji](#UniqueArray).</span><span class="sxs-lookup"><span data-stu-id="4f275-187">You can also use the <xref:System.Random> class for such tasks as generating [random T:System.Boolean values](#Boolean), generating [random floating point values with a range other than 0 to 1](#Floats), generating [random 64-bit integers](#Long), and [randomly retrieving a unique element from an array or collection](#UniqueArray).</span></span> <span data-ttu-id="4f275-188">Te i inne typowe zadania znajdują się w temacie [jak używać System. random to...](#Operations)</span><span class="sxs-lookup"><span data-stu-id="4f275-188">For these and other common tasks, see the [How do you use System.Random to…](#Operations)</span></span> <span data-ttu-id="4f275-189">Paragraf.</span><span class="sxs-lookup"><span data-stu-id="4f275-189">section.</span></span>  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a><span data-ttu-id="4f275-190">Podstawianie własnego algorytmu</span><span class="sxs-lookup"><span data-stu-id="4f275-190">Substituting your own algorithm</span></span>  
 <span data-ttu-id="4f275-191">Można zaimplementować własny generator liczb losowych przez dziedziczenie z <xref:System.Random> klasy i dostarczenie algorytmu losowego generowania liczb.</span><span class="sxs-lookup"><span data-stu-id="4f275-191">You can implement your own random number generator by inheriting from the <xref:System.Random> class and supplying your random number generation algorithm.</span></span> <span data-ttu-id="4f275-192">Aby podać własny algorytm, należy zastąpić <xref:System.Random.Sample%2A> metodę, która implementuje algorytm losowej generacji liczb.</span><span class="sxs-lookup"><span data-stu-id="4f275-192">To supply your own algorithm, you must override the <xref:System.Random.Sample%2A> method, which implements the random number generation algorithm.</span></span> <span data-ttu-id="4f275-193">Należy również zastąpić <xref:System.Random.Next>metody, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, i <xref:System.Random.NextBytes%2A> , aby upewnić się, że wywoła przesłoniętą <xref:System.Random.Sample%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="4f275-193">You should also override the <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, and <xref:System.Random.NextBytes%2A> methods to ensure that they call your overridden <xref:System.Random.Sample%2A> method.</span></span> <span data-ttu-id="4f275-194">Nie trzeba przesłonić <xref:System.Random.Next%28System.Int32%29> metod i <xref:System.Random.NextDouble%2A> .</span><span class="sxs-lookup"><span data-stu-id="4f275-194">You don't have to override the <xref:System.Random.Next%28System.Int32%29> and <xref:System.Random.NextDouble%2A> methods.</span></span>  
  
 <span data-ttu-id="4f275-195">Aby zapoznać się z przykładem, <xref:System.Random> który pochodzi z klasy i modyfikuje domyślny generator liczb losowych, <xref:System.Random.Sample%2A> Zobacz stronę referencyjną.</span><span class="sxs-lookup"><span data-stu-id="4f275-195">For an example that derives from the <xref:System.Random> class and modifies its default pseudo-random number generator, see the <xref:System.Random.Sample%2A> reference page.</span></span>  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a><span data-ttu-id="4f275-196">Jak używać System. Random do...</span><span class="sxs-lookup"><span data-stu-id="4f275-196">How do you use System.Random to…</span></span>  
 <span data-ttu-id="4f275-197">W poniższych sekcjach omówiono i przedstawiono przykładowy kod dla niektórych sposobów używania liczb losowych w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4f275-197">The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.</span></span>  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a><span data-ttu-id="4f275-198">Pobierz tę samą sekwencję wartości losowych</span><span class="sxs-lookup"><span data-stu-id="4f275-198">Retrieve the same sequence of random values</span></span>  
 <span data-ttu-id="4f275-199">Czasami chcesz wygenerować tę samą sekwencję liczb losowych w scenariuszach testowania oprogramowania i odtwarzaniu gry.</span><span class="sxs-lookup"><span data-stu-id="4f275-199">Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.</span></span> <span data-ttu-id="4f275-200">Testowanie z tą samą sekwencją liczb losowych umożliwia wykrywanie regresji i Potwierdzanie poprawek błędów.</span><span class="sxs-lookup"><span data-stu-id="4f275-200">Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.</span></span> <span data-ttu-id="4f275-201">Używanie tej samej sekwencji liczby losowej w grach pozwala na powtarzanie poprzednich gier.</span><span class="sxs-lookup"><span data-stu-id="4f275-201">Using the same sequence of random number in games allows you to replay previous games.</span></span>  
  
 <span data-ttu-id="4f275-202">Można wygenerować tę samą sekwencję liczb losowych, dostarczając tę samą wartość inicjatora do <xref:System.Random.%23ctor%28System.Int32%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="4f275-202">You can generate the same sequence of random numbers by providing the same seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="4f275-203">Wartość inicjatora zawiera wartość początkową dla algorytmu generowania liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-203">The seed value provides a starting value for the pseudo-random number generation algorithm.</span></span> <span data-ttu-id="4f275-204">Poniższy przykład używa 100100 jako dowolnej wartości inicjatora do utworzenia wystąpienia <xref:System.Random> obiektu, wyświetla 20 losowych wartości zmiennoprzecinkowych i utrzymuje wartość inicjatora.</span><span class="sxs-lookup"><span data-stu-id="4f275-204">The following example uses 100100 as an arbitrary seed value to instantiate the <xref:System.Random> object, displays 20 random floating-point values, and persists the seed value.</span></span> <span data-ttu-id="4f275-205">Następnie przywraca wartość inicjatora, tworzy wystąpienie nowego generatora liczb losowych i wyświetla te same 20 losowych wartości zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-205">It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.</span></span>  <span data-ttu-id="4f275-206">Należy zauważyć, że przykład może generować różne sekwencje liczb losowych, jeśli są uruchamiane w różnych wersjach .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="4f275-206">Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.</span></span>  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a><span data-ttu-id="4f275-207">Pobieranie unikatowych sekwencji liczb losowych</span><span class="sxs-lookup"><span data-stu-id="4f275-207">Retrieve unique sequences of random numbers</span></span>  
 <span data-ttu-id="4f275-208">Dostarczanie różnych wartości inicjatora do wystąpień <xref:System.Random> klasy powoduje, że każdy generator liczb losowych tworzy inną sekwencję wartości.</span><span class="sxs-lookup"><span data-stu-id="4f275-208">Providing different seed values to instances of the <xref:System.Random> class causes each random number generator to produce a different sequence of values.</span></span> <span data-ttu-id="4f275-209">Można podać wartość inicjatora jawnie przez wywołanie <xref:System.Random.%23ctor%28System.Int32%29> konstruktora lub niejawnie przez <xref:System.Random.%23ctor> wywołanie konstruktora.</span><span class="sxs-lookup"><span data-stu-id="4f275-209">You can provide a seed value either explicitly by calling the <xref:System.Random.%23ctor%28System.Int32%29> constructor, or implicitly by calling the <xref:System.Random.%23ctor> constructor.</span></span> <span data-ttu-id="4f275-210">Większość deweloperów wywołuje konstruktora bez parametrów, który używa zegara systemowego.</span><span class="sxs-lookup"><span data-stu-id="4f275-210">Most developers call the parameterless constructor, which uses the system clock.</span></span> <span data-ttu-id="4f275-211">Poniższy przykład używa tego podejścia do tworzenia wystąpienia dwóch <xref:System.Random> wystąpień.</span><span class="sxs-lookup"><span data-stu-id="4f275-211">The following example uses this approach to instantiate two <xref:System.Random> instances.</span></span> <span data-ttu-id="4f275-212">Każde wystąpienie wyświetla serię 10 losowych liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="4f275-212">Each instance displays a series of 10 random integers.</span></span>  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 <span data-ttu-id="4f275-213">Jednak ze względu na skończone rozwiązanie zegara systemowego nie wykrywa różnic czasu, które są mniejsze niż około 15 milisekund.</span><span class="sxs-lookup"><span data-stu-id="4f275-213">However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.</span></span> <span data-ttu-id="4f275-214">W związku z tym, jeśli kod <xref:System.Random.%23ctor> wywołuje Przeciążenie w celu <xref:System.Random> utworzenia wystąpienia dwóch obiektów, może przypadkowo dostarczyć obiekty z identycznymi wartościami inicjatora.</span><span class="sxs-lookup"><span data-stu-id="4f275-214">Therefore, if your code calls the <xref:System.Random.%23ctor> overload to instantiate two <xref:System.Random> objects in succession, you might inadvertently be providing the objects with identical seed values.</span></span> <span data-ttu-id="4f275-215">Aby zobaczyć to w poprzednim przykładzie, należy dodać komentarz do <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> wywołania metody i skompilować i ponownie uruchomić przykład.</span><span class="sxs-lookup"><span data-stu-id="4f275-215">To see this in the previous example, comment out the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method call, and compile and run the example again.</span></span>  
  
 <span data-ttu-id="4f275-216">Aby temu zapobiec, zalecamy utworzenie wystąpienia pojedynczego <xref:System.Random> obiektu, a nie wielu.</span><span class="sxs-lookup"><span data-stu-id="4f275-216">To prevent this from happening, we recommend that you instantiate a single <xref:System.Random> object rather than multiple ones.</span></span> <span data-ttu-id="4f275-217">Jednak ponieważ <xref:System.Random> nie jest bezpieczna wątkowo, należy użyć pewnego urządzenia <xref:System.Random> do synchronizacji, Jeśli uzyskujesz dostęp do wystąpienia z wielu wątków. Aby uzyskać więcej informacji, zobacz losowe [bezpieczeństwo klasy i wątku](#ThreadSafety) wcześniej w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="4f275-217">However, since <xref:System.Random> isn't thread safe, you must use some synchronization device if you access a <xref:System.Random> instance from multiple threads; for more information, see [The Random class and thread safety](#ThreadSafety) earlier in this topic.</span></span> <span data-ttu-id="4f275-218">Alternatywnie można użyć mechanizmu opóźnienia, takiego jak <xref:System.Threading.Thread.Sleep%2A> metoda użyta w poprzednim przykładzie, aby upewnić się, że wystąpienia są wykonywane więcej niż 15 milisekund.</span><span class="sxs-lookup"><span data-stu-id="4f275-218">Alternately, you can use a delay mechanism, such as the <xref:System.Threading.Thread.Sleep%2A> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.</span></span>  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a><span data-ttu-id="4f275-219">Pobierz liczby całkowite w określonym zakresie</span><span class="sxs-lookup"><span data-stu-id="4f275-219">Retrieve integers in a specified range</span></span>  
 <span data-ttu-id="4f275-220">Liczby całkowite można pobrać w określonym zakresie, wywołując <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodę, która pozwala określić dolną i górną granicę liczb, które mają być zwracane przez generator liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-220">You can retrieve integers in a specified range by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.</span></span> <span data-ttu-id="4f275-221">Górna granica jest wyłączną, a nie łączną wartością.</span><span class="sxs-lookup"><span data-stu-id="4f275-221">The upper bound is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="4f275-222">Oznacza to, że nie jest uwzględniony w zakresie wartości zwracanych przez metodę.</span><span class="sxs-lookup"><span data-stu-id="4f275-222">That is, it isn't included in the range of values returned by the method.</span></span> <span data-ttu-id="4f275-223">Poniższy przykład używa tej metody do generowania losowych liczb całkowitych z zakresu od-10 do 10.</span><span class="sxs-lookup"><span data-stu-id="4f275-223">The following example uses this method to generate random integers between -10 and 10.</span></span> <span data-ttu-id="4f275-224">Należy zauważyć, że określa ona 11, która jest większa niż wymagana wartość, jako wartość `maxValue` argumentu wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-224">Note that it specifies 11, which is one greater than the desired value, as the value of the `maxValue` argument in the method call.</span></span>  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a><span data-ttu-id="4f275-225">Pobierz liczby całkowite z określoną liczbą cyfr</span><span class="sxs-lookup"><span data-stu-id="4f275-225">Retrieve integers with a specified number of digits</span></span>  
 <span data-ttu-id="4f275-226">Możesz wywołać metodę, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> aby pobrać liczby z określoną liczbą cyfr.</span><span class="sxs-lookup"><span data-stu-id="4f275-226">You can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to retrieve numbers with a specified number of digits.</span></span> <span data-ttu-id="4f275-227">Na przykład aby pobrać liczby z czterema cyframi (czyli liczbami z zakresu od 1000 do 9999), należy wywołać <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodę `minValue` z `maxValue` wartością 1000 i wartość 10000, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="4f275-227">For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method with a `minValue` value of 1000 and a `maxValue` value of 10000, as the following example shows.</span></span>  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a><span data-ttu-id="4f275-228">Pobierz wartości zmiennoprzecinkowe w określonym zakresie</span><span class="sxs-lookup"><span data-stu-id="4f275-228">Retrieve floating-point values in a specified range</span></span>  
 <span data-ttu-id="4f275-229"><xref:System.Random.NextDouble%2A> Metoda zwraca losowe wartości zmiennoprzecinkowe z zakresu od 0 do mniej niż 1.</span><span class="sxs-lookup"><span data-stu-id="4f275-229">The <xref:System.Random.NextDouble%2A> method returns random floating-point values that range from 0 to less than 1.</span></span> <span data-ttu-id="4f275-230">Jednak często chcesz generować losowe wartości w innym zakresie.</span><span class="sxs-lookup"><span data-stu-id="4f275-230">However, you'll often want to generate random values in some other range.</span></span>  
  
 <span data-ttu-id="4f275-231">Jeśli interwał między minimalną i maksymalną pożądaną wartością wynosi 1, można dodać różnicę między żądanym interwałem początkowym a wartością 0 do numeru zwróconego przez <xref:System.Random.NextDouble%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="4f275-231">If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="4f275-232">Poniższy przykład służy do generowania 10 losowych liczb z zakresu od-1 do 0.</span><span class="sxs-lookup"><span data-stu-id="4f275-232">The following example does this to generate 10 random numbers between -1 and 0.</span></span>  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 <span data-ttu-id="4f275-233">Aby wygenerować losowe liczby zmiennoprzecinkowe, których Dolna granica to 0, ale Górna granica jest większa niż 1 (lub, w przypadku liczb ujemnych, których Dolna granica jest mniejsza niż-1, a górna granica to 0), pomnóż liczbę losową przez niezerową granicę.</span><span class="sxs-lookup"><span data-stu-id="4f275-233">To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.</span></span> <span data-ttu-id="4f275-234">Poniższy przykład służy do generowania 20 000 000 losowych liczb zmiennoprzecinkowych, które mieszczą się w zakresie od <xref:System.Int64.MaxValue?displayProperty=nameWithType>0 do.</span><span class="sxs-lookup"><span data-stu-id="4f275-234">The following example does this to generate 20 million random floating-point numbers that range from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4f275-235">W programie jest również wyświetlana dystrybucja wartości losowych generowanych przez metodę.</span><span class="sxs-lookup"><span data-stu-id="4f275-235">In also displays the distribution of the random values generated by the method.</span></span>  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 <span data-ttu-id="4f275-236">Aby wygenerować losowe liczby zmiennoprzecinkowe między dwoma dowolnymi wartościami, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> takimi jak metoda dla liczb całkowitych, należy użyć następującej formuły:</span><span class="sxs-lookup"><span data-stu-id="4f275-236">To generate random floating-point numbers between two arbitrary values, like the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method does for integers, use the following formula:</span></span>  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 <span data-ttu-id="4f275-237">Poniższy przykład generuje liczby losowe 1 000 000 należące do zakresu od 10,0 do 11,0 i wyświetla ich dystrybucję.</span><span class="sxs-lookup"><span data-stu-id="4f275-237">The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.</span></span>  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a><span data-ttu-id="4f275-238">Generuj losowe wartości logiczne</span><span class="sxs-lookup"><span data-stu-id="4f275-238">Generate random Boolean values</span></span>  
 <span data-ttu-id="4f275-239">Klasa nie dostarcza metod, które generują <xref:System.Boolean> wartości. <xref:System.Random></span><span class="sxs-lookup"><span data-stu-id="4f275-239">The <xref:System.Random> class doesn't provide methods that generate <xref:System.Boolean> values.</span></span> <span data-ttu-id="4f275-240">Można jednak zdefiniować własną klasę lub metodę, aby to zrobić.</span><span class="sxs-lookup"><span data-stu-id="4f275-240">However, you can define your own class or method to do that.</span></span> <span data-ttu-id="4f275-241">W poniższym przykładzie zdefiniowano klasę, `BooleanGenerator`przy użyciu pojedynczej `NextBoolean`metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-241">The following example defines a class, `BooleanGenerator`, with a single method, `NextBoolean`.</span></span> <span data-ttu-id="4f275-242">`BooleanGenerator` Klasa<xref:System.Random> przechowuje obiekt jako zmienną prywatną.</span><span class="sxs-lookup"><span data-stu-id="4f275-242">The `BooleanGenerator` class stores a <xref:System.Random> object as a private variable.</span></span> <span data-ttu-id="4f275-243">Metoda wywołuje metodę i<xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> przekazuje wynik do metody. <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> `NextBoolean`</span><span class="sxs-lookup"><span data-stu-id="4f275-243">The `NextBoolean` method calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method and passes the result to the <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4f275-244">Należy zauważyć, że wartość 2 jest używana jako argument do określenia górnej granicy liczby losowej.</span><span class="sxs-lookup"><span data-stu-id="4f275-244">Note that 2 is used as the argument to specify the upper bound of the random number.</span></span> <span data-ttu-id="4f275-245">Ponieważ jest to wartość wyłączna, wywołanie metody zwraca wartość 0 lub 1.</span><span class="sxs-lookup"><span data-stu-id="4f275-245">Since this is an exclusive value, the method call returns either 0 or 1.</span></span>  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 <span data-ttu-id="4f275-246">Zamiast tworzenia oddzielnej klasy do generowania losowych <xref:System.Boolean> wartości, przykład może po prostu zdefiniować pojedynczą metodę.</span><span class="sxs-lookup"><span data-stu-id="4f275-246">Instead of creating a separate class to generate random <xref:System.Boolean> values, the example could simply have defined a single method.</span></span> <span data-ttu-id="4f275-247">Jednak <xref:System.Random> w takim przypadku obiekt powinien być zdefiniowany jako zmienna na poziomie klasy, aby uniknąć tworzenia wystąpienia nowego <xref:System.Random> wystąpienia w każdym wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-247">In that case, however, the <xref:System.Random> object should have been defined as a class-level variable to avoid instantiating a new <xref:System.Random> instance in each method call.</span></span> <span data-ttu-id="4f275-248">W Visual Basic wystąpienie losowe może być zdefiniowane jako zmienna [statyczna](~/docs/visual-basic/language-reference/modifiers/static.md) w `NextBoolean` metodzie.</span><span class="sxs-lookup"><span data-stu-id="4f275-248">In Visual Basic, the Random instance can be defined as a [Static](~/docs/visual-basic/language-reference/modifiers/static.md) variable in the `NextBoolean` method.</span></span>  <span data-ttu-id="4f275-249">W poniższym przykładzie przedstawiono implementację.</span><span class="sxs-lookup"><span data-stu-id="4f275-249">The following example provides an implementation.</span></span>  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a><span data-ttu-id="4f275-250">Generuj losowe 64-bitowe liczby całkowite</span><span class="sxs-lookup"><span data-stu-id="4f275-250">Generate random 64-bit integers</span></span>  
 <span data-ttu-id="4f275-251">Przeciążenia <xref:System.Random.Next%2A> metody zwracają 32-bitowe liczby całkowite.</span><span class="sxs-lookup"><span data-stu-id="4f275-251">The overloads of the <xref:System.Random.Next%2A> method return 32-bit integers.</span></span> <span data-ttu-id="4f275-252">Jednak w niektórych przypadkach może zajść potrzeba pracy z 64-bitowymi liczbami całkowitymi.</span><span class="sxs-lookup"><span data-stu-id="4f275-252">However, in some cases, you might want to work with 64-bit integers.</span></span> <span data-ttu-id="4f275-253">Można to zrobić w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="4f275-253">You can do this as follows:</span></span>  
  
1.  <span data-ttu-id="4f275-254">Wywołaj <xref:System.Random.NextDouble%2A> metodę, aby pobrać wartość zmiennoprzecinkową o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="4f275-254">Call the <xref:System.Random.NextDouble%2A> method to retrieve a double-precision floating point value.</span></span>  
  
2.  <span data-ttu-id="4f275-255">Pomnóż tę wartość przez <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4f275-255">Multiply that value by <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="4f275-256">W poniższym przykładzie zastosowano tę technikę do generowania 20 000 000 losowo długich liczb całkowitych i kategoryzacji ich w 10 równych grupach.</span><span class="sxs-lookup"><span data-stu-id="4f275-256">The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.</span></span> <span data-ttu-id="4f275-257">Następnie oblicza rozkład liczb losowych przez liczenie liczby w każdej grupie z przedziału od 0 do <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4f275-257">It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4f275-258">Dane wyjściowe z przykładu pokazują, że liczby są dystrybuowane więcej lub mniej równomiernie przez zakres długiej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="4f275-258">As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.</span></span>  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 <span data-ttu-id="4f275-259">Alternatywna technika korzystająca z manipulowania bit nie generuje rzeczywiście losowych liczb.</span><span class="sxs-lookup"><span data-stu-id="4f275-259">An alternative technique that uses bit manipulation does not generate truly random numbers.</span></span> <span data-ttu-id="4f275-260">Ta technika wywołuje <xref:System.Random.Next> generowanie dwóch liczb całkowitych, lewy przesunie jeden o 32 bitów i ORs je razem.</span><span class="sxs-lookup"><span data-stu-id="4f275-260">This technique calls <xref:System.Random.Next> to generate two integers, left-shifts one by 32 bits, and ORs them together.</span></span> <span data-ttu-id="4f275-261">Ta technika ma dwa ograniczenia:</span><span class="sxs-lookup"><span data-stu-id="4f275-261">This technique has two limitations:</span></span>  
  
1.  <span data-ttu-id="4f275-262">Ponieważ bit 31 jest bitem znaku, wartość w polu bit 31 dodatniej liczby całkowitej jest zawsze równa 0.</span><span class="sxs-lookup"><span data-stu-id="4f275-262">Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.</span></span>  <span data-ttu-id="4f275-263">Można to rozwiązać, generując losowo 0 lub 1, przesunięcie w lewo o 31 bitów i ORing go z pierwotną losowo długą liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="4f275-263">This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.</span></span>  
  
2.  <span data-ttu-id="4f275-264">Bardziej poważnie, ponieważ prawdopodobieństwo zwrócenia wartości przez <xref:System.Random.Next> wartość to 0, będzie kilka liczb losowych w zakresie 0x0-0x00000000FFFFFFFF.</span><span class="sxs-lookup"><span data-stu-id="4f275-264">More seriously, because the probability that the value returned by <xref:System.Random.Next> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.</span></span>  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a><span data-ttu-id="4f275-265">Pobierz bajty w określonym zakresie</span><span class="sxs-lookup"><span data-stu-id="4f275-265">Retrieve bytes in a specified range</span></span>  
 <span data-ttu-id="4f275-266">Przeciążenia <xref:System.Random.Next%2A> metody umożliwiają określenie zakresu liczb losowych, ale nie jest to <xref:System.Random.NextBytes%2A> Metoda.</span><span class="sxs-lookup"><span data-stu-id="4f275-266">The overloads of the <xref:System.Random.Next%2A> method allow you to specify the range of random numbers, but the <xref:System.Random.NextBytes%2A> method does not.</span></span> <span data-ttu-id="4f275-267">Poniższy przykład implementuje `NextBytes` metodę, która umożliwia określenie zakresu zwracanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="4f275-267">The following example implements a `NextBytes` method that lets you specify the range of the returned bytes.</span></span> <span data-ttu-id="4f275-268">Definiuje `Random2` klasę, która pochodzi od <xref:System.Random> i przeciążania `NextBytes` metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-268">It defines a `Random2` class that derives from <xref:System.Random> and overloads its `NextBytes` method.</span></span>  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 <span data-ttu-id="4f275-269">Metoda zawija wywołanie <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metody i określa wartość minimalną i większą niż wartość maksymalna (w tym przypadku, 0 i 101), które chcemy zwrócić w tablicy bajtów. `NextBytes(Byte[], Byte, Byte)`</span><span class="sxs-lookup"><span data-stu-id="4f275-269">The `NextBytes(Byte[], Byte, Byte)` method wraps a call to the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.</span></span> <span data-ttu-id="4f275-270">Ze względu na to, że wartości całkowite zwracane przez <xref:System.Random.Next%2A> metodę znajdują się w zakresie <xref:System.Byte> typu danych, możemy bezpiecznie je rzutować (in C#) lub konwertować je (w Visual Basic) z liczb całkowitych na bajty.</span><span class="sxs-lookup"><span data-stu-id="4f275-270">Because we are sure that the integer values returned by the <xref:System.Random.Next%2A> method are within the range of the <xref:System.Byte> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.</span></span>  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a><span data-ttu-id="4f275-271">Pobieranie elementu z tablicy lub kolekcji losowo</span><span class="sxs-lookup"><span data-stu-id="4f275-271">Retrieve an element from an array or collection at random</span></span>  
 <span data-ttu-id="4f275-272">Liczby losowe często używają jako indeksów do pobierania wartości z tablic lub kolekcji.</span><span class="sxs-lookup"><span data-stu-id="4f275-272">Random numbers often serve as indexes to retrieve values from arrays or collections.</span></span> <span data-ttu-id="4f275-273">Aby pobrać losową wartość indeksu, można wywołać <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodę i użyć dolnego zakresu tablicy jako wartości `minValue` argumentu i jednego większego niż górna granica tablicy `maxValue` jako wartości argumentu.</span><span class="sxs-lookup"><span data-stu-id="4f275-273">To retrieve a random index value, you can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, and use the lower bound of the array as the value of its `minValue` argument and one greater than the upper bound of the array as the value of its `maxValue` argument.</span></span> <span data-ttu-id="4f275-274">W przypadku tablicy o wartości zero jest to równoznaczne z jej <xref:System.Array.Length%2A> właściwością lub większą wartością zwracaną <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> przez metodę.</span><span class="sxs-lookup"><span data-stu-id="4f275-274">For a zero-based array, this is equivalent to its <xref:System.Array.Length%2A> property, or one greater than the value returned by the <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4f275-275">Poniższy przykład losowo Pobiera nazwę miasta w Stany Zjednoczone z tablicy miejscowości.</span><span class="sxs-lookup"><span data-stu-id="4f275-275">The following example randomly retrieves the name of a city in the United States from an array of cities.</span></span>  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a><span data-ttu-id="4f275-276">Pobieranie unikatowego elementu z tablicy lub kolekcji</span><span class="sxs-lookup"><span data-stu-id="4f275-276">Retrieve a unique element from an array or collection</span></span>  
 <span data-ttu-id="4f275-277">Generator liczb losowych zawsze może zwracać zduplikowane wartości.</span><span class="sxs-lookup"><span data-stu-id="4f275-277">A random number generator can always return duplicate values.</span></span> <span data-ttu-id="4f275-278">Gdy zakres liczb staje się mniejszy lub liczba wygenerowanych wartości staje się większa, prawdopodobieństwo wzrostu duplikatów.</span><span class="sxs-lookup"><span data-stu-id="4f275-278">As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.</span></span> <span data-ttu-id="4f275-279">Jeśli wartości losowe muszą być unikatowe, wygenerowane są więcej liczb w celu zrekompensowania duplikatów, co powoduje zwiększenie niskiej wydajności.</span><span class="sxs-lookup"><span data-stu-id="4f275-279">If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.</span></span>  
  
 <span data-ttu-id="4f275-280">Istnieje wiele technik obsługi tego scenariusza.</span><span class="sxs-lookup"><span data-stu-id="4f275-280">There are a number of techniques to handle this scenario.</span></span> <span data-ttu-id="4f275-281">Jednym z typowych rozwiązań jest utworzenie tablicy lub kolekcji zawierającej wartości do pobrania, a także tablicę równoległą zawierającą losowe liczby zmiennoprzecinkowe.</span><span class="sxs-lookup"><span data-stu-id="4f275-281">One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.</span></span> <span data-ttu-id="4f275-282">Druga tablica jest wypełniana liczbą losową w momencie utworzenia pierwszej tablicy, a <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> Metoda jest używana do sortowania pierwszej tablicy przy użyciu wartości w tablicy równoległej.</span><span class="sxs-lookup"><span data-stu-id="4f275-282">The second array is populated with random numbers at the time the first array is created, and the <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is used to sort the first array by using the values in the parallel array.</span></span>  
  
 <span data-ttu-id="4f275-283">Na przykład jeśli tworzysz grę Pasjans, chcesz upewnić się, że każda karta jest używana tylko raz.</span><span class="sxs-lookup"><span data-stu-id="4f275-283">For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.</span></span> <span data-ttu-id="4f275-284">Zamiast generować liczby losowe w celu pobrania karty i śledzenia tego, czy dana karta została już zastosowana, można utworzyć równoległą tablicę liczb losowych, które mogą być używane do sortowania talii.</span><span class="sxs-lookup"><span data-stu-id="4f275-284">Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.</span></span> <span data-ttu-id="4f275-285">Po posortowaniu talii aplikacja może zachować wskaźnik, aby wskazać indeks następnej karty na pokładzie.</span><span class="sxs-lookup"><span data-stu-id="4f275-285">Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.</span></span>  
  
 <span data-ttu-id="4f275-286">To podejście pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="4f275-286">The following example illustrates this approach.</span></span> <span data-ttu-id="4f275-287">Definiuje `Card` klasę, która reprezentuje kartę z odtwarzaniem `Dealer` i klasę, która zajmuje się talią kart przestawnych.</span><span class="sxs-lookup"><span data-stu-id="4f275-287">It defines a `Card` class that represents a playing card and a `Dealer` class that deals a deck of shuffled cards.</span></span> <span data-ttu-id="4f275-288">Konstruktor klasy wypełnia dwie tablice `deck` : tablicę, która ma zakres klasy i która reprezentuje wszystkie karty na pokładzie; oraz tablicę lokalną `order` , która `deck` ma taką samą liczbę elementów jak tablica i jest wypełniana `Dealer` z losowo generowanymi <xref:System.Double> wartościami.</span><span class="sxs-lookup"><span data-stu-id="4f275-288">The `Dealer` class constructor populates two arrays: a `deck` array that has class scope and that represents all the cards in the deck; and a local `order` array that has the same number of elements as the `deck` array and is populated with randomly generated <xref:System.Double> values.</span></span>  <span data-ttu-id="4f275-289">Metoda jest następnie wywoływana w celu `deck` posortowania tablicy na podstawie wartości w `order` tablicy. <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="4f275-289">The <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is then called to sort the `deck` array based on the values in the `order` array.</span></span>  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 <span data-ttu-id="4f275-290">W poniższym przykładzie przedstawiono tworzenie pojedynczego generatora liczb losowych i <xref:System.Random.NextBytes%2A>wywoływanie metod <xref:System.Random.NextDouble%2A> , <xref:System.Random.Next%2A>i, aby wygenerować sekwencje liczb losowych w różnych zakresach.</span><span class="sxs-lookup"><span data-stu-id="4f275-290">The following example creates a single random number generator and calls its <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, and <xref:System.Random.NextDouble%2A> methods to generate sequences of random numbers within different ranges.</span></span>  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 <span data-ttu-id="4f275-291">Poniższy przykład generuje losową liczbę całkowitą, która używa jako indeksu do pobrania wartości ciągu z tablicy.</span><span class="sxs-lookup"><span data-stu-id="4f275-291">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="4f275-292">W .NET Framework 1,0 i 1,1, minimalna implementacja klasy pochodnej od <see cref="T:System.Random" /> wymaganej <see cref="M:System.Random.Sample" /> przesłania metodę w celu zdefiniowania nowego lub zmodyfikowanego algorytmu do generowania liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-292">In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <see cref="T:System.Random" /> required overriding the <see cref="M:System.Random.Sample" /> method to define a new or modified algorithm for generating random numbers.</span></span> <span data-ttu-id="4f275-293">Klasa pochodna może <see cref="M:System.Random.Next" />następnie polegać na implementacji klasy podstawowej metod, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />i <see cref="M:System.Random.NextDouble" /> , aby wywołać implementację <see cref="M:System.Random.Sample" /> klasy pochodnej metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-293">The derived class could then rely on the base class implementation of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, and <see cref="M:System.Random.NextDouble" /> methods to call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span></span>  
  
<span data-ttu-id="4f275-294">W .NET Framework 2,0 <see cref="M:System.Random.Next" />i nowszych zachowanie metod, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />i <see cref="M:System.Random.NextBytes(System.Byte[])" /> zostało zmienione tak, aby te metody <see cref="M:System.Random.Sample" /> niekoniecznie wywoływać implementację klasy pochodnej metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-294">In the .NET Framework 2.0 and later, the behavior of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, and <see cref="M:System.Random.NextBytes(System.Byte[])" /> methods have changed so that these methods do not necessarily call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span></span> <span data-ttu-id="4f275-295">W efekcie klasy pochodzące z <see cref="T:System.Random" /> tego obiektu docelowego .NET Framework 2,0 i nowsze powinny również zastąpić te trzy metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-295">As a result, classes derived from <see cref="T:System.Random" /> that target the .NET Framework 2.0 and later should also override these three methods.</span></span></para></block>
    <block subset="none" type="usage"><para><span data-ttu-id="4f275-296">Implementacja generatora liczb losowych w <see cref="T:System.Random" /> klasie nie gwarantuje, że pozostanie taka sama w głównych wersjach .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="4f275-296">The implementation of the random number generator in the <see cref="T:System.Random" /> class isn't guaranteed to remain the same across major versions of the .NET Framework.</span></span> <span data-ttu-id="4f275-297">W związku z tym nie należy zastanowić się, że ten sam inicjator będzie miał tę samą pseudo losowo sekwencję w różnych wersjach .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="4f275-297">As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</span></span></para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4f275-298">Inicjuje nowe wystąpienie klasy <see cref="T:System.Random" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="4f275-298">Initializes a new instance of the <see cref="T:System.Random" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4f275-299">Inicjuje nowe wystąpienie <see cref="T:System.Random" /> klasy, używając domyślnej wartości inicjatora zależnego od czasu.</span><span class="sxs-lookup"><span data-stu-id="4f275-299">Initializes a new instance of the <see cref="T:System.Random" /> class, using a time-dependent default seed value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4f275-300">Domyślna wartość inicjatora jest określana na podstawie zegara systemowego i ma skończone rozwiązanie.</span><span class="sxs-lookup"><span data-stu-id="4f275-300">The default seed value is derived from the system clock and has finite resolution.</span></span> <span data-ttu-id="4f275-301">W związku z tym różne <xref:System.Random> obiekty, które są tworzone w zamknięciu, przez wywołanie konstruktora bez parametrów, będą mieć identyczne domyślne wartości inicjatora i, w związku z tym, będą generować identyczne zestawy liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-301">As a result, different <xref:System.Random> objects that are created in close succession by a call to the parameterless constructor will have identical default seed values and, therefore, will produce identical sets of random numbers.</span></span> <span data-ttu-id="4f275-302">Ten problem można uniknąć, używając pojedynczego <xref:System.Random> obiektu do wygenerowania wszystkich liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-302">This problem can be avoided by using a single <xref:System.Random> object to generate all random numbers.</span></span> <span data-ttu-id="4f275-303">Można to również obejść, modyfikując wartość inicjatora zwracanego przez zegar systemowy, a następnie jawnie dostarczając tę nową wartość inicjatora <xref:System.Random.%23ctor%28System.Int32%29> do konstruktora.</span><span class="sxs-lookup"><span data-stu-id="4f275-303">You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="4f275-304">Aby uzyskać więcej informacji, zobacz <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="4f275-304">For more information, see the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span>  
  
 <span data-ttu-id="4f275-305">Wywołaj ten Konstruktor, jeśli chcesz, aby generator liczb losowych generował losową sekwencję liczb.</span><span class="sxs-lookup"><span data-stu-id="4f275-305">Call this constructor if you want your random number generator to generate a random sequence of numbers.</span></span> <span data-ttu-id="4f275-306">Aby wygenerować stałą sekwencję liczb losowych, która będzie taka sama dla różnych generatorów liczb losowych, <xref:System.Random.%23ctor%28System.Int32%29> Wywołaj konstruktora ze stałą wartością inicjatora.</span><span class="sxs-lookup"><span data-stu-id="4f275-306">To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <xref:System.Random.%23ctor%28System.Int32%29> constructor with a fixed seed value .</span></span> <span data-ttu-id="4f275-307">Ten <xref:System.Random> przeciążenie konstruktora jest często używany podczas testowania aplikacji, które używają liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-307">This <xref:System.Random> constructor overload is frequently used when testing apps that use random numbers.</span></span>  
  
 <span data-ttu-id="4f275-308">Po utworzeniu wystąpienia generatora liczb losowych należy wywołać poszczególne <xref:System.Random> metody, takie jak <xref:System.Random.Next> lub <xref:System.Random.NextDouble>, aby generować liczby losowe.</span><span class="sxs-lookup"><span data-stu-id="4f275-308">Once you've instantiated the random number generator, you call individual <xref:System.Random> methods, such as <xref:System.Random.Next> or <xref:System.Random.NextDouble>, to generate random numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4f275-309">Poniższy przykład używa konstruktora bez parametrów, aby utworzyć wystąpienie trzech <xref:System.Random> obiektów i wyświetla sekwencję pięciu losowych liczb całkowitych dla każdego z nich.</span><span class="sxs-lookup"><span data-stu-id="4f275-309">The following example uses the parameterless constructor to instantiate three <xref:System.Random> objects and displays a sequence of five random integers for each.</span></span> <span data-ttu-id="4f275-310">Ze względu na <xref:System.Random> to, że pierwsze dwa obiekty są tworzone w ciągu zamykania, są tworzone przy użyciu identycznych wartości inicjatora na podstawie zegara systemowego i dlatego generują identyczną sekwencję liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-310">Because the first two <xref:System.Random> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers.</span></span> <span data-ttu-id="4f275-311">Z drugiej strony, Konstruktor bez parametrów trzeciego <xref:System.Random> obiektu jest wywoływany po dwusekundowym opóźnieniu spowodowanym <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> wywołaniem metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-311">On the other hand, the parameterless constructor of the third <xref:System.Random> object is called after a two-second delay caused by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4f275-312">Ponieważ spowoduje to utworzenie innej wartości inicjatora dla trzeciego <xref:System.Random> obiektu, powstaje różne sekwencje liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-312">Because this produces a different seed value for the third <xref:System.Random> object, it produces a different sequence of random numbers.</span></span>  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed"><span data-ttu-id="4f275-313">Numer używany do obliczania wartości początkowej dla wielolosowej sekwencji liczbowej.</span><span class="sxs-lookup"><span data-stu-id="4f275-313">A number used to calculate a starting value for the pseudo-random number sequence.</span></span> <span data-ttu-id="4f275-314">Jeśli określono ujemną liczbę, używana jest wartość bezwzględna liczby.</span><span class="sxs-lookup"><span data-stu-id="4f275-314">If a negative number is specified, the absolute value of the number is used.</span></span></param>
        <summary><span data-ttu-id="4f275-315">Inicjuje nowe wystąpienie <see cref="T:System.Random" /> klasy przy użyciu określonej wartości inicjatora.</span><span class="sxs-lookup"><span data-stu-id="4f275-315">Initializes a new instance of the <see cref="T:System.Random" /> class, using the specified seed value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4f275-316">Dostarczenie identycznej wartości inicjatora <xref:System.Random> do różnych obiektów powoduje, że każde wystąpienie będzie generować identyczne sekwencje liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-316">Providing an identical seed value to different <xref:System.Random> objects causes each instance to produce identical sequences of random numbers.</span></span> <span data-ttu-id="4f275-317">Jest to często wykonywane podczas testowania aplikacji, które korzystają z losowych generatorów liczbowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-317">This is often done when testing apps that rely on random number generators.</span></span>  
  
 <span data-ttu-id="4f275-318">Jeśli aplikacja wymaga różnych losowych sekwencji liczbowych, wywołaj tego konstruktora wielokrotnie przy użyciu różnych wartości inicjatora.</span><span class="sxs-lookup"><span data-stu-id="4f275-318">If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.</span></span> <span data-ttu-id="4f275-319">Jednym ze sposobów tworzenia unikatowej wartości inicjatora jest to, że jest ona zależna od czasu.</span><span class="sxs-lookup"><span data-stu-id="4f275-319">One way to produce a unique seed value is to make it time-dependent.</span></span> <span data-ttu-id="4f275-320">Na przykład pouzyskuj wartość inicjatora z zegara systemowego, ponieważ <xref:System.Random.%23ctor> Przeciążenie wykonuje przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="4f275-320">For example, derive the seed value from the system clock, as the <xref:System.Random.%23ctor> overload does.</span></span> <span data-ttu-id="4f275-321">Jednak zegar systemowy może nie mieć wystarczającej rozdzielczości, aby zapewnić różne wywołania tego konstruktora z inną wartością inicjatora.</span><span class="sxs-lookup"><span data-stu-id="4f275-321">However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.</span></span> <span data-ttu-id="4f275-322">Powoduje to losowe generatory liczb generujące identyczne sekwencje liczb losowych, jak pokazano na dwóch <xref:System.Random> pierwszych obiektach w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="4f275-322">This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <xref:System.Random> objects in the following example.</span></span> <span data-ttu-id="4f275-323">Aby temu zapobiec, Zastosuj algorytm do odróżnienia wartości inicjatora w każdym wywołaniu lub wywołaj <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodę, aby upewnić się, że każdy Konstruktor ma inną wartość inicjatora.</span><span class="sxs-lookup"><span data-stu-id="4f275-323">To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to ensure that you provide each constructor with a different seed value.</span></span>  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 <span data-ttu-id="4f275-324">Innym rozwiązaniem jest utworzenie wystąpienia pojedynczego <xref:System.Random> obiektu, który służy do generowania wszystkich losowych liczb w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4f275-324">Another option is to instantiate a single <xref:System.Random> object that you use to generate all the random numbers in your application.</span></span> <span data-ttu-id="4f275-325">Zapewnia to nieco lepszą wydajność, ponieważ utworzenie wystąpienia generatora liczb losowych jest dość kosztowne.</span><span class="sxs-lookup"><span data-stu-id="4f275-325">This yields slightly better performance, since instantiating a random number generator is fairly expensive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4f275-326">Poniższy przykład tworzy <xref:System.Random> obiekty z konstruktorem klasy, który pobiera parametr inicjatora i generuje sekwencję losowych liczb całkowitych i podwaja.</span><span class="sxs-lookup"><span data-stu-id="4f275-326">The following example creates <xref:System.Random> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles.</span></span> <span data-ttu-id="4f275-327">Przykład ilustruje, że ta sama sekwencja jest generowana, <xref:System.Random> gdy obiekt zostanie utworzony ponownie z konstruktorem i parametrem inicjatora.</span><span class="sxs-lookup"><span data-stu-id="4f275-327">The example illustrates that the same sequence is generated when the <xref:System.Random> object is created again with the constructor and seed parameter.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4f275-328">Zwraca losową liczbę całkowitą.</span><span class="sxs-lookup"><span data-stu-id="4f275-328">Returns a random integer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4f275-329">Zwraca nieujemną liczbę całkowitą losową.</span><span class="sxs-lookup"><span data-stu-id="4f275-329">Returns a non-negative random integer.</span></span></summary>
        <returns><span data-ttu-id="4f275-330">32-bitowa liczba całkowita ze znakiem, która jest większa lub równa 0 i <see cref="F:System.Int32.MaxValue" />mniejsza niż.</span><span class="sxs-lookup"><span data-stu-id="4f275-330">A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4f275-331"><xref:System.Random.Next%2A?displayProperty=nameWithType>generuje liczbę losową z zakresu od 0 do mniejszej niż <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4f275-331"><xref:System.Random.Next%2A?displayProperty=nameWithType> generates a random number whose value ranges from 0 to less than <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4f275-332">Aby wygenerować liczbę losową z zakresu od 0 do innej liczby dodatniej, użyj <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-332">To generate a random number whose value ranges from 0 to some other positive number, use the <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="4f275-333">Aby wygenerować liczbę losową z innego zakresu, użyj <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-333">To generate a random number within a different range, use the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4f275-334">Poniższy przykład wykonuje powtórzone wywołania <xref:System.Random.Next%2A> metody, aby wygenerować określoną liczbę losowych liczb żądanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="4f275-334">The following example makes repeated calls to the <xref:System.Random.Next%2A> method to generate a specific number of random numbers requested by the user.</span></span> <span data-ttu-id="4f275-335"><xref:System.Console.ReadLine%2A?displayProperty=nameWithType> Metoda jest używana do uzyskiwania danych wejściowych klienta.</span><span class="sxs-lookup"><span data-stu-id="4f275-335">The <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> method is used to get customer input.</span></span>  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 <span data-ttu-id="4f275-336">Poniższy przykład dziedziczy klasy z <xref:System.Random> programu w celu wygenerowania sekwencji liczb losowych, których dystrybucja różni się od rozkładu jednorodnego wygenerowanego <xref:System.Random.Sample%2A> przez metodę klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="4f275-336">The following example derives a class from <xref:System.Random> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span> <span data-ttu-id="4f275-337">Zastępuje <xref:System.Random.Sample%2A> metodę w celu zapewnienia rozkładu liczb losowych i <xref:System.Random.Next%2A?displayProperty=nameWithType> zastępuje metodę, aby użyć serii liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-337">It overrides the <xref:System.Random.Sample%2A> method to provide the distribution of random numbers, and overrides the <xref:System.Random.Next%2A?displayProperty=nameWithType> method to use series of random numbers.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="4f275-338">Począwszy od .NET Framework w wersji 2,0, jeśli pochodna jest Klasa z <see cref="T:System.Random" /> i <see cref="M:System.Random.Sample" /> przesłaniasz metodę, dystrybucja udostępniona przez implementację klasy <see cref="M:System.Random.Sample" /> pochodnej metody nie jest używana w wywołaniach klasy bazowej <see cref="M:System.Random.Next" /> implementacja metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-338">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next" /> method.</span></span> <span data-ttu-id="4f275-339">Zamiast tego jest używana jednolita dystrybucja zwrócona <see cref="T:System.Random" /> przez klasę bazową.</span><span class="sxs-lookup"><span data-stu-id="4f275-339">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="4f275-340">To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="4f275-340">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="4f275-341">Aby zmodyfikować to zachowanie, aby wywołać <see cref="M:System.Random.Sample" /> metodę w klasie pochodnej, należy również <see cref="M:System.Random.Next" /> zastąpić metodę.</span><span class="sxs-lookup"><span data-stu-id="4f275-341">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next" /> method.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue"><span data-ttu-id="4f275-342">Wyłączne górne ograniczenie liczby losowej do wygenerowania.</span><span class="sxs-lookup"><span data-stu-id="4f275-342">The exclusive upper bound of the random number to be generated.</span></span> <span data-ttu-id="4f275-343"><paramref name="maxValue" />musi być większa lub równa 0.</span><span class="sxs-lookup"><span data-stu-id="4f275-343"><paramref name="maxValue" /> must be greater than or equal to 0.</span></span></param>
        <summary><span data-ttu-id="4f275-344">Zwraca nieujemną losową liczbę całkowitą, która jest mniejsza niż określona wartość maksymalna.</span><span class="sxs-lookup"><span data-stu-id="4f275-344">Returns a non-negative random integer that is less than the specified maximum.</span></span></summary>
        <returns><span data-ttu-id="4f275-345">32-bitowa liczba całkowita ze znakiem, która jest większa niż lub równa 0, <paramref name="maxValue" />i mniejsza niż; oznacza to, że zakres wartości zwracanych zwykle zawiera <paramref name="maxValue" />0, ale nie.</span><span class="sxs-lookup"><span data-stu-id="4f275-345">A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />; that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.</span></span> <span data-ttu-id="4f275-346">Jednakże, jeśli <paramref name="maxValue" /> jest równa <paramref name="maxValue" /> 0, jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="4f275-346">However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4f275-347">Przeciążenie zwraca losowe liczby całkowite z zakresu od 0 do `maxValue` -1. <xref:System.Random.Next%28System.Int32%29></span><span class="sxs-lookup"><span data-stu-id="4f275-347">The <xref:System.Random.Next%28System.Int32%29> overload returns random integers that range from 0 to `maxValue` - 1.</span></span> <span data-ttu-id="4f275-348">Jeśli `maxValue` jednak ma wartość 0, metoda zwraca 0.</span><span class="sxs-lookup"><span data-stu-id="4f275-348">However, if `maxValue` is 0, the method returns 0.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4f275-349">Poniższy przykład generuje losowe liczby całkowite z różnymi przeciążeniami <xref:System.Random.Next%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-349">The following example generates random integers with various overloads of the <xref:System.Random.Next%2A> method.</span></span>  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 <span data-ttu-id="4f275-350">Poniższy przykład generuje losową liczbę całkowitą, która używa jako indeksu do pobrania wartości ciągu z tablicy.</span><span class="sxs-lookup"><span data-stu-id="4f275-350">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="4f275-351">Ponieważ najwyższy indeks tablicy jest mniejszy niż jego długość, wartość <xref:System.Array.Length%2A?displayProperty=nameWithType> właściwości jest podawana jako `maxValue` parametr.</span><span class="sxs-lookup"><span data-stu-id="4f275-351">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4f275-352"><paramref name="maxValue" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="4f275-352"><paramref name="maxValue" /> is less than 0.</span></span></exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue"><span data-ttu-id="4f275-353">Dopuszczająca Dolna granica zwracanej liczby losowej.</span><span class="sxs-lookup"><span data-stu-id="4f275-353">The inclusive lower bound of the random number returned.</span></span></param>
        <param name="maxValue"><span data-ttu-id="4f275-354">Jedyna Górna granica zwracanej liczby losowej.</span><span class="sxs-lookup"><span data-stu-id="4f275-354">The exclusive upper bound of the random number returned.</span></span> <span data-ttu-id="4f275-355"><paramref name="maxValue" />musi być większa lub równa <paramref name="minValue" />.</span><span class="sxs-lookup"><span data-stu-id="4f275-355"><paramref name="maxValue" /> must be greater than or equal to <paramref name="minValue" />.</span></span></param>
        <summary><span data-ttu-id="4f275-356">Zwraca losową liczbę całkowitą znajdującą się w określonym zakresie.</span><span class="sxs-lookup"><span data-stu-id="4f275-356">Returns a random integer that is within a specified range.</span></span></summary>
        <returns><span data-ttu-id="4f275-357">32-bitową liczbę całkowitą ze znakiem większą lub <paramref name="minValue" /> równą i <paramref name="maxValue" />mniejszą niż; czyli zakres wartości zwracanych obejmuje <paramref name="minValue" /> , ale nie <paramref name="maxValue" />.</span><span class="sxs-lookup"><span data-stu-id="4f275-357">A 32-bit signed integer greater than or equal to <paramref name="minValue" /> and less than <paramref name="maxValue" />; that is, the range of return values includes <paramref name="minValue" /> but not <paramref name="maxValue" />.</span></span> <span data-ttu-id="4f275-358">Jeśli <paramref name="minValue" /> jest <paramref name="maxValue" />równa, <paramref name="minValue" /> jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="4f275-358">If <paramref name="minValue" /> equals <paramref name="maxValue" />, <paramref name="minValue" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4f275-359">Przeciążenie zwraca losowe liczby całkowite z zakresu od `minValue` do `maxValue` -1. <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29></span><span class="sxs-lookup"><span data-stu-id="4f275-359">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload returns random integers that range from `minValue` to `maxValue` - 1.</span></span> <span data-ttu-id="4f275-360">Jednak jeśli `maxValue` jest równa `minValue`, metoda zwraca `minValue`.</span><span class="sxs-lookup"><span data-stu-id="4f275-360">However, if `maxValue` equals `minValue`, the method returns `minValue`.</span></span>  
  
 <span data-ttu-id="4f275-361">W przeciwieństwie do innych przeciążeń <xref:System.Random.Next%2A> metody, które zwracają tylko wartości nieujemnych, ta metoda może zwracać ujemną losową liczbę całkowitą.</span><span class="sxs-lookup"><span data-stu-id="4f275-361">Unlike the other overloads of the <xref:System.Random.Next%2A> method, which return only non-negative values, this method can return a negative random integer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4f275-362">Poniższy przykład używa <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metody do generowania losowych liczb całkowitych z trzema różnymi zakresami.</span><span class="sxs-lookup"><span data-stu-id="4f275-362">The following example uses the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to generate random integers with three distinct ranges.</span></span> <span data-ttu-id="4f275-363">Należy zauważyć, że dokładne dane wyjściowe z przykładu są zależne od wartości inicjatora dostarczonego przez <xref:System.Random> system do konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="4f275-363">Note that the exact output from the example depends on the system-supplied seed value passed to the <xref:System.Random> class constructor.</span></span>  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 <span data-ttu-id="4f275-364">Poniższy przykład generuje losową liczbę całkowitą, która używa jako indeksu do pobrania wartości ciągu z tablicy.</span><span class="sxs-lookup"><span data-stu-id="4f275-364">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="4f275-365">Ponieważ najwyższy indeks tablicy jest mniejszy niż jego długość, wartość <xref:System.Array.Length%2A?displayProperty=nameWithType> właściwości jest podawana jako `maxValue` parametr.</span><span class="sxs-lookup"><span data-stu-id="4f275-365">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4f275-366"><paramref name="minValue" />jest większa niż <paramref name="maxValue" />.</span><span class="sxs-lookup"><span data-stu-id="4f275-366"><paramref name="minValue" /> is greater than <paramref name="maxValue" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="4f275-367">Począwszy od .NET Framework w wersji 2,0, jeśli pochodna jest Klasa z <see cref="T:System.Random" /> i <see cref="M:System.Random.Sample" /> przesłaniasz metodę, dystrybucja udostępniona przez implementację klasy <see cref="M:System.Random.Sample" /> pochodnej metody nie jest używana w wywołaniach klasy bazowej Implementacja przeciążenia <paramref name="minValue" /> <paramref name="maxValue" /> <see cref="F:System.Int32.MaxValue" />metody, jeśli różnica między parametrami i jest większa niż. <see cref="M:System.Random.Next(System.Int32,System.Int32)" /></span><span class="sxs-lookup"><span data-stu-id="4f275-367">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload if the difference between the <paramref name="minValue" /> and <paramref name="maxValue" /> parameters is greater than <see cref="F:System.Int32.MaxValue" />.</span></span> <span data-ttu-id="4f275-368">Zamiast tego jest używana jednolita dystrybucja zwrócona <see cref="T:System.Random" /> przez klasę bazową.</span><span class="sxs-lookup"><span data-stu-id="4f275-368">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="4f275-369">To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="4f275-369">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="4f275-370">Aby zmodyfikować to zachowanie, aby wywołać <see cref="M:System.Random.Sample" /> metodę w klasie pochodnej, należy również <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> zastąpić Przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-370">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4f275-371">Tablica bajtów zawierająca liczby losowe.</span><span class="sxs-lookup"><span data-stu-id="4f275-371">An array of bytes to contain random numbers.</span></span></param>
        <summary><span data-ttu-id="4f275-372">Wypełnia elementy określonej tablicy bajtów liczbą losową.</span><span class="sxs-lookup"><span data-stu-id="4f275-372">Fills the elements of a specified array of bytes with random numbers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4f275-373">Każdy element tablicy bajtów ma ustawioną liczbę losową większą lub równą 0 i mniejszą lub równą <xref:System.Byte.MaxValue>.</span><span class="sxs-lookup"><span data-stu-id="4f275-373">Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <xref:System.Byte.MaxValue>.</span></span>  
  
 <span data-ttu-id="4f275-374">Na przykład aby wygenerować kryptograficzną kryptograficznie liczbę losową odpowiednią do tworzenia hasła losowego, użyj metody takiej jak <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4f275-374">For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4f275-375">Poniższy przykład ilustruje sposób użycia <xref:System.Random.NextBytes%2A> metody w celu wypełnienia tablicy bajtów z wartościami losowych bajtów.</span><span class="sxs-lookup"><span data-stu-id="4f275-375">The following example demonstrates how to use the <xref:System.Random.NextBytes%2A> method to fill an array of bytes with random byte values.</span></span>  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4f275-376"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4f275-376"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="4f275-377">Począwszy od .NET Framework w wersji 2,0, jeśli pochodna jest Klasa z <see cref="T:System.Random" /> i <see cref="M:System.Random.Sample" /> przesłaniasz metodę, dystrybucja udostępniona przez implementację klasy <see cref="M:System.Random.Sample" /> pochodnej metody nie jest używana w wywołaniach klasy bazowej <see cref="M:System.Random.NextBytes(System.Byte[])" /> implementacja metody.</span><span class="sxs-lookup"><span data-stu-id="4f275-377">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span> <span data-ttu-id="4f275-378">Zamiast tego jest używana jednolita dystrybucja zwrócona <see cref="T:System.Random" /> przez klasę bazową.</span><span class="sxs-lookup"><span data-stu-id="4f275-378">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="4f275-379">To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="4f275-379">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="4f275-380">Aby zmodyfikować to zachowanie, aby wywołać <see cref="M:System.Random.Sample" /> metodę w klasie pochodnej, należy również <see cref="M:System.Random.NextBytes(System.Byte[])" /> zastąpić metodę.</span><span class="sxs-lookup"><span data-stu-id="4f275-380">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span></para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4f275-381">Zwraca losową liczbę zmiennoprzecinkową o wartości większej lub równej 0,0 i mniejszą niż 1,0.</span><span class="sxs-lookup"><span data-stu-id="4f275-381">Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</span></span></summary>
        <returns><span data-ttu-id="4f275-382">Liczba zmiennoprzecinkowa o podwójnej precyzji, która jest większa lub równa 0,0, i mniejsza niż 1,0.</span><span class="sxs-lookup"><span data-stu-id="4f275-382">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4f275-383">Rzeczywista Górna granica liczby losowej zwracanej przez tę metodę to 0.99999999999999978.</span><span class="sxs-lookup"><span data-stu-id="4f275-383">The actual upper bound of the random number returned by this method is 0.99999999999999978.</span></span>  
  
 <span data-ttu-id="4f275-384">Aby pobrać losowe wartości zmiennoprzecinkowe w zakresie innym niż 0,0 i 1,0, zobacz sekcję "Pobieranie wartości zmiennoprzecinkowych w określonym zakresie" w temacie dotyczącym <xref:System.Random> klas.</span><span class="sxs-lookup"><span data-stu-id="4f275-384">To retrieve random floating-point values within a range other than 0.0 and 1.0, see the "Retrieve floating-point values in a specified range" section of the <xref:System.Random> class topic.</span></span>  
  
 <span data-ttu-id="4f275-385">Ta metoda jest publiczną wersją metody <xref:System.Random.Sample%2A>chronionej.</span><span class="sxs-lookup"><span data-stu-id="4f275-385">This method is the public version of the protected method, <xref:System.Random.Sample%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4f275-386">W poniższym przykładzie zastosowano <xref:System.Random.NextDouble%2A> metodę w celu wygenerowania sekwencji losowego podwajania.</span><span class="sxs-lookup"><span data-stu-id="4f275-386">The following example uses the <xref:System.Random.NextDouble%2A> method to generate sequences of random doubles.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 <span data-ttu-id="4f275-387">Poniższy przykład wywołuje <xref:System.Random.NextDouble%2A> metodę w celu wygenerowania 100 liczb losowych i wyświetla ich rozkład częstotliwości.</span><span class="sxs-lookup"><span data-stu-id="4f275-387">The following example calls the <xref:System.Random.NextDouble%2A> method to generate 100 random numbers and displays their frequency distribution.</span></span>  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4f275-388">Zwraca losową liczbę zmiennoprzecinkową z zakresu od 0,0 do 1,0.</span><span class="sxs-lookup"><span data-stu-id="4f275-388">Returns a random floating-point number between 0.0 and 1.0.</span></span></summary>
        <returns><span data-ttu-id="4f275-389">Liczba zmiennoprzecinkowa o podwójnej precyzji, która jest większa lub równa 0,0, i mniejsza niż 1,0.</span><span class="sxs-lookup"><span data-stu-id="4f275-389">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4f275-390">Aby utworzyć inną zasadę losowej dystrybucji lub inną regułę generatora liczb losowych, należy utworzyć klasę <xref:System.Random> z klasy i <xref:System.Random.Sample%2A> zastąpić metodę.</span><span class="sxs-lookup"><span data-stu-id="4f275-390">To produce a different random distribution or a different random number generator principle, derive a class from the <xref:System.Random> class and override the <xref:System.Random.Sample%2A> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4f275-391">Metoda jest `protected`, co oznacza, że <xref:System.Random> jest dostępna tylko w klasie i jej klasach pochodnych. <xref:System.Random.Sample%2A></span><span class="sxs-lookup"><span data-stu-id="4f275-391">The <xref:System.Random.Sample%2A> method is `protected`, which means that it is accessible only within the <xref:System.Random> class and its derived classes.</span></span> <span data-ttu-id="4f275-392">Aby wygenerować liczbę losową z zakresu od 0 do 1 <xref:System.Random> z wystąpienia, <xref:System.Random.NextDouble%2A> Wywołaj metodę.</span><span class="sxs-lookup"><span data-stu-id="4f275-392">To generate a random number between 0 and 1 from a <xref:System.Random> instance, call the <xref:System.Random.NextDouble%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4f275-393">Poniższy przykład dziedziczy klasy z <xref:System.Random> i <xref:System.Random.Sample%2A> przesłania metodę w celu wygenerowania dystrybucji liczb losowych.</span><span class="sxs-lookup"><span data-stu-id="4f275-393">The following example derives a class from <xref:System.Random> and overrides the <xref:System.Random.Sample%2A> method to generate a distribution of random numbers.</span></span> <span data-ttu-id="4f275-394">Ta dystrybucja różni się od jednorodnej dystrybucji wygenerowanej <xref:System.Random.Sample%2A> przez metodę klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="4f275-394">This distribution is different than the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="4f275-395">Począwszy od .NET Framework w wersji 2,0, jeśli pochodna jest Klasa z <see cref="T:System.Random" /> i <see cref="M:System.Random.Sample" /> przesłaniasz metodę, dystrybucja udostępniona przez implementację klasy <see cref="M:System.Random.Sample" /> pochodnej metody nie jest używana w wywołaniach klasy bazowej Implementacja następujących metod:</span><span class="sxs-lookup"><span data-stu-id="4f275-395">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the following methods:</span></span> 
<span data-ttu-id="4f275-396"><see cref="M:System.Random.NextBytes(System.Byte[])" /> -Metoda.</span><span class="sxs-lookup"><span data-stu-id="4f275-396">-   The <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span>  
  
<span data-ttu-id="4f275-397"><see cref="M:System.Random.Next" /> -Metoda.</span><span class="sxs-lookup"><span data-stu-id="4f275-397">-   The <see cref="M:System.Random.Next" /> method.</span></span>  
  
<span data-ttu-id="4f275-398"><paramref name="maxValue" /> - -Metoda, if <see cref="F:System.Int32.MaxValue" />()jestwiększaniż<paramref name="minValue" />. <see cref="M:System.Random.Next(System.Int32,System.Int32)" /></span><span class="sxs-lookup"><span data-stu-id="4f275-398">-   The <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method, if (<paramref name="maxValue" /> - <paramref name="minValue" />) is greater than <see cref="F:System.Int32.MaxValue" />.</span></span>  
  
<span data-ttu-id="4f275-399">Zamiast tego używana jest jednolita dystrybucja udostępniona przez <see cref="T:System.Random" /> klasę bazową.</span><span class="sxs-lookup"><span data-stu-id="4f275-399">Instead, the uniform distribution provided by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="4f275-400">To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="4f275-400">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="4f275-401">Aby zmodyfikować to zachowanie, aby wywołać implementację <see cref="M:System.Random.Sample" /> metody w klasie pochodnej, należy również zastąpić zachowanie tych trzech elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="4f275-401">To modify this behavior to call the implementation of the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the behavior of these three members.</span></span> <span data-ttu-id="4f275-402">Przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="4f275-402">The example provides an illustration.</span></span></para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>

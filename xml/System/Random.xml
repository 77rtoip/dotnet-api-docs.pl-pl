<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1882888454ba893e09e07a3982a51c8cd49b656c" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68398257" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje generator liczb losowych, który jest urządzeniem, które tworzy sekwencję liczb, które spełniają pewne wymagania statystyczne losowości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczby losowe są wybierane z równym prawdopodobieństwem z skończonego zestawu liczb. Wybrane numery nie są całkowicie losowe, ponieważ algorytm matematyczny jest używany do ich zaznaczania, ale są wystarczająco losowe do celów praktycznych. Bieżąca implementacja <xref:System.Random> klasy jest oparta na zmodyfikowanej wersji algorytmu generatora liczb losowych Donald E. Knuth. Aby uzyskać więcej informacji, zobacz D. E. Knuth. *Kompozycja programowania komputerów, Tom 2: Algorytmy*Seminumerical. Addison-Wesley, czytanie, MA, wersja trzecia, 1997.  
  
 Aby wygenerować kryptograficzną kryptograficznie liczbę losową, na przykład odpowiednią do tworzenia hasła losowego, użyj <xref:System.Security.Cryptography.RNGCryptoServiceProvider> klasy lub Utwórz klasę z. <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>  
  
 W tym temacie:  
  
 [Tworzenie wystąpienia generatora liczb losowych](#Instantiate)   
 [Unikanie wielu wystąpień](#Multiple)   
 [System. Random — bezpieczeństwo klasy i wątku](#ThreadSafety)   
 [Generowanie różnych typów liczb losowych](#Functionality)   
 [Podstawianie własnego algorytmu](#Overriding)   
 [Jak używać System. Random do...](#Operations)   
 [Pobierz tę samą sekwencję wartości losowych](#Same)  
 [Pobieranie unikatowych sekwencji wartości losowych](#Unique)  
 [Pobierz liczby całkowite w określonym zakresie](#Range)  
 [Pobierz liczby całkowite z określoną liczbą cyfr](#Digits)  
 [Pobierz wartości zmiennoprzecinkowe w określonym zakresie](#Floats)  
 [Generuj losowe wartości logiczne](#Boolean)  
 [Generuj losowe 64-bitowe liczby całkowite](#Long)  
 [Pobierz bajty w określonym zakresie](#Bytes)  
 [Pobieranie elementu z tablicy lub kolekcji losowo](#Array)  
 [Pobieranie unikatowego elementu z tablicy lub kolekcji](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>Tworzenie wystąpienia generatora liczb losowych  
 Tworzenie wystąpienia generatora liczb losowych przez podanie wartości inicjatora (wartości początkowej dla algorytmu generowania losowych liczb pseudolosowych) do <xref:System.Random.%23ctor%2A> konstruktora klasy.  Możesz podać wartość inicjatora jawnie lub niejawnie:  
  
-   <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor używa jawnej wartości inicjatora, która została dostarczona.  
  
-   <xref:System.Random.%23ctor> Konstruktor używa zegara systemowego do zapewnienia wartości inicjatora. Jest to najbardziej typowy sposób tworzenia wystąpienia generatora liczb losowych.  
  
 Jeśli ten sam inicjator jest używany w odniesieniu do oddzielnych <xref:System.Random> obiektów, spowoduje to wygenerowanie tej samej serii liczb losowych. Może to być przydatne w przypadku tworzenia zestawu testów, który przetwarza losowe wartości lub odtwarzania gier, które pobierają dane z liczb losowych. Należy jednak pamiętać, <xref:System.Random> że obiekty w procesach działających w różnych wersjach .NET Framework mogą zwracać różne serie liczb losowych, nawet jeśli są tworzone z identycznymi wartościami inicjatora.  
  
 Aby generować różne sekwencje liczb losowych, można wprowadzić wartość inicjatora zależnie od czasu, generując inną serię przy każdym nowym wystąpieniu <xref:System.Random>. Sparametryzowany <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor może <xref:System.Int32> przyjmować wartość na podstawie liczby taktów w bieżącym czasie <xref:System.Random.%23ctor> , natomiast Konstruktor bez parametrów używa zegara systemowego do wygenerowania jego wartości inicjatora. Ponieważ jednak zegar ma skończone rozwiązanie, przy użyciu konstruktora bez parametrów, aby utworzyć różne <xref:System.Random> obiekty w zamknięciu, tworzy losowe generatory liczb, które generują identyczne sekwencje liczb losowych. Poniższy przykład ilustruje, jak dwa <xref:System.Random> obiekty, które są tworzone w zamknięciu, generują identyczną serię liczb losowych. W większości systemów <xref:System.Random> Windows obiekty utworzone w ciągu 15 milisekund od siebie prawdopodobnie mają identyczne wartości inicjatora.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 Aby uniknąć tego problemu, należy utworzyć pojedynczy <xref:System.Random> obiekt zamiast wielu obiektów.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Unikanie wielu wystąpień  
 Zainicjowanie dwóch losowych generatorów liczbowych w ścisłej pętli lub szybkiej powodzeniu powoduje utworzenie dwóch generatorów liczb losowych, które mogą generować identyczne sekwencje liczb losowych. W większości przypadków nie jest to zamiara dewelopera i może prowadzić do problemów z wydajnością, ponieważ Tworzenie wystąpień i Inicjowanie generatora liczb losowych jest stosunkowo kosztownym procesem.  
  
 Aby zwiększyć wydajność i uniknąć przypadkowego tworzenia oddzielnych generatorów liczb losowych generujących identyczne sekwencje liczbowe, zalecamy utworzenie jednego <xref:System.Random> obiektu w celu wygenerowania wielu losowych liczb w czasie, zamiast tworzyć nowe <xref:System.Random> obiekty do wygenerowania jednej liczby losowej.  
  
 <xref:System.Random> Jednak Klasa nie jest bezpieczna wątkowo. Jeśli wywołasz <xref:System.Random> metody z wielu wątków, postępuj zgodnie z wytycznymi opisanymi w następnej sekcji.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>System. Random — bezpieczeństwo klasy i wątku  
 Zamiast tworzenia wystąpień pojedynczych <xref:System.Random> obiektów zalecamy utworzenie pojedynczego <xref:System.Random> wystąpienia w celu wygenerowania wszystkich losowych liczb wymaganych przez aplikację. <xref:System.Random> Jednak obiekty nie są bezpieczne wątkowo. Jeśli aplikacja wywołuje <xref:System.Random> metody z wielu wątków, należy użyć obiektu synchronizacji, aby upewnić się, że tylko jeden wątek może uzyskać dostęp do generatora liczb losowych jednocześnie. Jeśli nie masz pewność, że <xref:System.Random> dostęp do obiektu odbywa się w sposób bezpieczny dla wątków, wywołania metod, które zwracają liczby losowe, zwracają 0.  
  
 W poniższym przykładzie przedstawiono użycie C# [instrukcji lock](~/docs/csharp/language-reference/keywords/lock-statement.md) i instrukcji Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) w celu zapewnienia, że pojedynczy generator liczb losowych jest dostępny przez 11 wątków w sposób bezpieczny dla wątków. Każdy wątek generuje liczby losowe 2 000 000, zlicza liczby losowe wygenerowane i oblicza ich sumę, a następnie aktualizuje sumy dla wszystkich wątków po zakończeniu wykonywania.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 Przykład zapewnia bezpieczeństwo wątków w następujący sposób:  
  
-   Ten <xref:System.ThreadStaticAttribute> atrybut służy do definiowania zmiennych lokalnych wątku, które śledzą łączną liczbę wygenerowanych liczb losowych i ich sumę dla każdego wątku.  
  
-   Blokada ( `lock` instrukcja w C# `SyncLock` instrukcji i w Visual Basic) chroni dostęp do zmiennych, aby uzyskać całkowitą liczbę i sumę liczb losowych generowanych na wszystkich wątkach.  
  
-   Semafor ( <xref:System.Threading.CountdownEvent> obiekt) służy do upewnienia się, że główny wątek jest blokowany przed ukończeniem wszystkich innych wątków.  
  
-   Przykład sprawdza, czy generator liczb losowych stał się uszkodzony przez określenie, czy dwa kolejne wywołania metod generowania liczb losowych zwracają 0. W przypadku wykrycia uszkodzenia, w przykładzie używa <xref:System.Threading.CancellationTokenSource> obiektu do sygnalizowania, że wszystkie wątki powinny być anulowane.  
  
-   Przed wygenerowaniem poszczególnych liczb losowych każdy wątek sprawdza stan <xref:System.Threading.CancellationToken> obiektu. Jeśli zażądano anulowania, przykład wywołuje <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metodę w celu anulowania wątku.  
  
 Poniższy przykład jest identyczny z pierwszym, z tą różnicą, że <xref:System.Threading.Tasks.Task> używa obiektu i wyrażenia lambda <xref:System.Threading.Thread> zamiast obiektów.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 Różni się od pierwszego przykładu w następujący sposób:  
  
-   Zmienne, aby śledzić liczbę wygenerowanych liczb losowych i ich sumę w każdym zadaniu, są lokalne do zadania, więc nie ma potrzeby używania <xref:System.ThreadStaticAttribute> atrybutu.  
  
-   Metoda statyczna <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> jest używana do upewnienia się, że główny wątek nie zostanie ukończony przed ukończeniem wszystkich zadań. Nie ma potrzeby dla <xref:System.Threading.CountdownEvent> obiektu.  
  
-   Wyjątek, który wynika z anulowania zadania, jest przystawny <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> w metodzie. W poprzednim przykładzie jest obsługiwany przez każdy wątek.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Generowanie różnych typów liczb losowych  
 Generator liczb losowych udostępnia metody, które pozwalają generować następujące rodzaje liczb losowych:  
  
-   Szereg <xref:System.Byte> wartości. Należy określić liczbę wartości bajtowych przez przekazanie zainicjowanej tablicy do liczby elementów, które Metoda ma zwrócić do <xref:System.Random.NextBytes%2A> metody. Poniższy przykład generuje 20 bajtów.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Pojedyncza liczba całkowita. Można wybrać, czy ma być liczbą całkowitą z zakresu od 0 do wartości maksymalnej<xref:System.Int32.MaxValue?displayProperty=nameWithType> (-1), <xref:System.Random.Next> wywołując metodę, liczbę całkowitą z przedziału od 0 do <xref:System.Random.Next%28System.Int32%29> określonej wartości, wywołując metodę lub liczbę całkowitą w zakresie wartości przez wywołanie <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>Metoda. W przypadku przeciążeń parametrycznych określona wartość maksymalna jest wyłączna; oznacza to, że rzeczywista Maksymalna liczba wygenerowanych jest mniejsza niż określona wartość.  
  
     Poniższy przykład wywołuje <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodę w celu wygenerowania 10 losowych liczb z przedziału od-10 do 10. Należy zauważyć, że drugi argument metody określa wyłączną górną granicę zakresu losowych wartości zwracanych przez metodę. Innymi słowy, największa liczba całkowita, jaką może zwrócić Metoda, jest mniejsza niż ta wartość.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Pojedyncza wartość zmiennoprzecinkowa od 0,0 do mniejszej niż 1,0 przez wywołanie <xref:System.Random.NextDouble%2A> metody. Górną granicą wartości losowej zwracanej przez metodę jest 1, więc jej rzeczywista Górna granica to 0.99999999999999978. Poniższy przykład generuje 10 losowych liczb zmiennoprzecinkowych.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Metoda pozwala określić zakres zwracanych liczb losowych. `maxValue` Jednak parametr, który określa wartość zwracaną przez górny zakres, jest wyłączny, a nie włącznie. Oznacza to, że wywołanie `Next(0, 100)` metody zwraca wartość z zakresu od 0 do 99, a nie z zakresu od 0 do 100.  
  
 <xref:System.Random> Można również użyć klasy dla takich zadań jako generujących [losowe wartości T:System.Boolean](#Boolean), generując [losowo wartości zmiennoprzecinkowe z zakresem innym niż 0 do 1](#Floats), generując [losowo 64-bitowe liczby całkowite](#Long)i [losowo Pobieranie unikatowego elementu z tablicy lub kolekcji](#UniqueArray). Te i inne typowe zadania znajdują się w temacie [jak używać System. random to...](#Operations) Paragraf.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Podstawianie własnego algorytmu  
 Można zaimplementować własny generator liczb losowych przez dziedziczenie z <xref:System.Random> klasy i dostarczenie algorytmu losowego generowania liczb. Aby podać własny algorytm, należy zastąpić <xref:System.Random.Sample%2A> metodę, która implementuje algorytm losowej generacji liczb. Należy również zastąpić <xref:System.Random.Next>metody, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, i <xref:System.Random.NextBytes%2A> , aby upewnić się, że wywoła przesłoniętą <xref:System.Random.Sample%2A> metodę. Nie trzeba przesłonić <xref:System.Random.Next%28System.Int32%29> metod i <xref:System.Random.NextDouble%2A> .  
  
 Aby zapoznać się z przykładem, <xref:System.Random> który pochodzi z klasy i modyfikuje domyślny generator liczb losowych, <xref:System.Random.Sample%2A> Zobacz stronę referencyjną.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Jak używać System. Random do...  
 W poniższych sekcjach omówiono i przedstawiono przykładowy kod dla niektórych sposobów używania liczb losowych w aplikacji.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Pobierz tę samą sekwencję wartości losowych  
 Czasami chcesz wygenerować tę samą sekwencję liczb losowych w scenariuszach testowania oprogramowania i odtwarzaniu gry. Testowanie z tą samą sekwencją liczb losowych umożliwia wykrywanie regresji i Potwierdzanie poprawek błędów. Używanie tej samej sekwencji liczby losowej w grach pozwala na powtarzanie poprzednich gier.  
  
 Można wygenerować tę samą sekwencję liczb losowych, dostarczając tę samą wartość inicjatora do <xref:System.Random.%23ctor%28System.Int32%29> konstruktora. Wartość inicjatora zawiera wartość początkową dla algorytmu generowania liczb losowych. Poniższy przykład używa 100100 jako dowolnej wartości inicjatora do utworzenia wystąpienia <xref:System.Random> obiektu, wyświetla 20 losowych wartości zmiennoprzecinkowych i utrzymuje wartość inicjatora. Następnie przywraca wartość inicjatora, tworzy wystąpienie nowego generatora liczb losowych i wyświetla te same 20 losowych wartości zmiennoprzecinkowych.  Należy zauważyć, że przykład może generować różne sekwencje liczb losowych, jeśli są uruchamiane w różnych wersjach .NET Framework.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Pobieranie unikatowych sekwencji liczb losowych  
 Dostarczanie różnych wartości inicjatora do wystąpień <xref:System.Random> klasy powoduje, że każdy generator liczb losowych tworzy inną sekwencję wartości. Można podać wartość inicjatora jawnie przez wywołanie <xref:System.Random.%23ctor%28System.Int32%29> konstruktora lub niejawnie przez <xref:System.Random.%23ctor> wywołanie konstruktora. Większość deweloperów wywołuje konstruktora bez parametrów, który używa zegara systemowego. Poniższy przykład używa tego podejścia do tworzenia wystąpienia dwóch <xref:System.Random> wystąpień. Każde wystąpienie wyświetla serię 10 losowych liczb całkowitych.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Jednak ze względu na skończone rozwiązanie zegara systemowego nie wykrywa różnic czasu, które są mniejsze niż około 15 milisekund. W związku z tym, jeśli kod <xref:System.Random.%23ctor> wywołuje Przeciążenie w celu <xref:System.Random> utworzenia wystąpienia dwóch obiektów, może przypadkowo dostarczyć obiekty z identycznymi wartościami inicjatora. Aby zobaczyć to w poprzednim przykładzie, należy dodać komentarz do <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> wywołania metody i skompilować i ponownie uruchomić przykład.  
  
 Aby temu zapobiec, zalecamy utworzenie wystąpienia pojedynczego <xref:System.Random> obiektu, a nie wielu. Jednak ponieważ <xref:System.Random> nie jest bezpieczna wątkowo, należy użyć pewnego urządzenia <xref:System.Random> do synchronizacji, Jeśli uzyskujesz dostęp do wystąpienia z wielu wątków. Aby uzyskać więcej informacji, zobacz losowe [bezpieczeństwo klasy i wątku](#ThreadSafety) wcześniej w tym temacie. Alternatywnie można użyć mechanizmu opóźnienia, takiego jak <xref:System.Threading.Thread.Sleep%2A> metoda użyta w poprzednim przykładzie, aby upewnić się, że wystąpienia są wykonywane więcej niż 15 milisekund.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Pobierz liczby całkowite w określonym zakresie  
 Liczby całkowite można pobrać w określonym zakresie, wywołując <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodę, która pozwala określić dolną i górną granicę liczb, które mają być zwracane przez generator liczb losowych. Górna granica jest wyłączną, a nie łączną wartością. Oznacza to, że nie jest uwzględniony w zakresie wartości zwracanych przez metodę. Poniższy przykład używa tej metody do generowania losowych liczb całkowitych z zakresu od-10 do 10. Należy zauważyć, że określa ona 11, która jest większa niż wymagana wartość, jako wartość `maxValue` argumentu wywołania metody.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Pobierz liczby całkowite z określoną liczbą cyfr  
 Możesz wywołać metodę, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> aby pobrać liczby z określoną liczbą cyfr. Na przykład aby pobrać liczby z czterema cyframi (czyli liczbami z zakresu od 1000 do 9999), należy wywołać <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodę `minValue` z `maxValue` wartością 1000 i wartość 10000, jak pokazano w poniższym przykładzie.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Pobierz wartości zmiennoprzecinkowe w określonym zakresie  
 <xref:System.Random.NextDouble%2A> Metoda zwraca losowe wartości zmiennoprzecinkowe z zakresu od 0 do mniej niż 1. Jednak często chcesz generować losowe wartości w innym zakresie.  
  
 Jeśli interwał między minimalną i maksymalną pożądaną wartością wynosi 1, można dodać różnicę między żądanym interwałem początkowym a wartością 0 do numeru zwróconego przez <xref:System.Random.NextDouble%2A> metodę. Poniższy przykład służy do generowania 10 losowych liczb z zakresu od-1 do 0.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Aby wygenerować losowe liczby zmiennoprzecinkowe, których Dolna granica to 0, ale Górna granica jest większa niż 1 (lub, w przypadku liczb ujemnych, których Dolna granica jest mniejsza niż-1, a górna granica to 0), pomnóż liczbę losową przez niezerową granicę. Poniższy przykład służy do generowania 20 000 000 losowych liczb zmiennoprzecinkowych, które mieszczą się w zakresie od <xref:System.Int64.MaxValue?displayProperty=nameWithType>0 do. W programie jest również wyświetlana dystrybucja wartości losowych generowanych przez metodę.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Aby wygenerować losowe liczby zmiennoprzecinkowe między dwoma dowolnymi wartościami, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> takimi jak metoda dla liczb całkowitych, należy użyć następującej formuły:  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 Poniższy przykład generuje liczby losowe 1 000 000 należące do zakresu od 10,0 do 11,0 i wyświetla ich dystrybucję.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Generuj losowe wartości logiczne  
 Klasa nie dostarcza metod, które generują <xref:System.Boolean> wartości. <xref:System.Random> Można jednak zdefiniować własną klasę lub metodę, aby to zrobić. W poniższym przykładzie zdefiniowano klasę, `BooleanGenerator`przy użyciu pojedynczej `NextBoolean`metody. `BooleanGenerator` Klasa<xref:System.Random> przechowuje obiekt jako zmienną prywatną. Metoda wywołuje metodę i<xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> przekazuje wynik do metody. <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> `NextBoolean` Należy zauważyć, że wartość 2 jest używana jako argument do określenia górnej granicy liczby losowej. Ponieważ jest to wartość wyłączna, wywołanie metody zwraca wartość 0 lub 1.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Zamiast tworzenia oddzielnej klasy do generowania losowych <xref:System.Boolean> wartości, przykład może po prostu zdefiniować pojedynczą metodę. Jednak <xref:System.Random> w takim przypadku obiekt powinien być zdefiniowany jako zmienna na poziomie klasy, aby uniknąć tworzenia wystąpienia nowego <xref:System.Random> wystąpienia w każdym wywołaniu metody. W Visual Basic wystąpienie losowe może być zdefiniowane jako zmienna [statyczna](~/docs/visual-basic/language-reference/modifiers/static.md) w `NextBoolean` metodzie.  W poniższym przykładzie przedstawiono implementację.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Generuj losowe 64-bitowe liczby całkowite  
 Przeciążenia <xref:System.Random.Next%2A> metody zwracają 32-bitowe liczby całkowite. Jednak w niektórych przypadkach może zajść potrzeba pracy z 64-bitowymi liczbami całkowitymi. Można to zrobić w następujący sposób:  
  
1.  Wywołaj <xref:System.Random.NextDouble%2A> metodę, aby pobrać wartość zmiennoprzecinkową o podwójnej precyzji.  
  
2.  Pomnóż tę wartość przez <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 W poniższym przykładzie zastosowano tę technikę do generowania 20 000 000 losowo długich liczb całkowitych i kategoryzacji ich w 10 równych grupach. Następnie oblicza rozkład liczb losowych przez liczenie liczby w każdej grupie z przedziału od 0 do <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Dane wyjściowe z przykładu pokazują, że liczby są dystrybuowane więcej lub mniej równomiernie przez zakres długiej liczby całkowitej.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Alternatywna technika korzystająca z manipulowania bit nie generuje rzeczywiście losowych liczb. Ta technika wywołuje <xref:System.Random.Next> generowanie dwóch liczb całkowitych, lewy przesunie jeden o 32 bitów i ORs je razem. Ta technika ma dwa ograniczenia:  
  
1.  Ponieważ bit 31 jest bitem znaku, wartość w polu bit 31 dodatniej liczby całkowitej jest zawsze równa 0.  Można to rozwiązać, generując losowo 0 lub 1, przesunięcie w lewo o 31 bitów i ORing go z pierwotną losowo długą liczbą całkowitą.  
  
2.  Bardziej poważnie, ponieważ prawdopodobieństwo zwrócenia wartości przez <xref:System.Random.Next> wartość to 0, będzie kilka liczb losowych w zakresie 0x0-0x00000000FFFFFFFF.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Pobierz bajty w określonym zakresie  
 Przeciążenia <xref:System.Random.Next%2A> metody umożliwiają określenie zakresu liczb losowych, ale nie jest to <xref:System.Random.NextBytes%2A> Metoda. Poniższy przykład implementuje `NextBytes` metodę, która umożliwia określenie zakresu zwracanych bajtów. Definiuje `Random2` klasę, która pochodzi od <xref:System.Random> i przeciążania `NextBytes` metody.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 Metoda zawija wywołanie <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metody i określa wartość minimalną i większą niż wartość maksymalna (w tym przypadku, 0 i 101), które chcemy zwrócić w tablicy bajtów. `NextBytes(Byte[], Byte, Byte)` Ze względu na to, że wartości całkowite zwracane przez <xref:System.Random.Next%2A> metodę znajdują się w zakresie <xref:System.Byte> typu danych, możemy bezpiecznie je rzutować (in C#) lub konwertować je (w Visual Basic) z liczb całkowitych na bajty.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Pobieranie elementu z tablicy lub kolekcji losowo  
 Liczby losowe często używają jako indeksów do pobierania wartości z tablic lub kolekcji. Aby pobrać losową wartość indeksu, można wywołać <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodę i użyć dolnego zakresu tablicy jako wartości `minValue` argumentu i jednego większego niż górna granica tablicy `maxValue` jako wartości argumentu. W przypadku tablicy o wartości zero jest to równoznaczne z jej <xref:System.Array.Length%2A> właściwością lub większą wartością zwracaną <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> przez metodę. Poniższy przykład losowo Pobiera nazwę miasta w Stany Zjednoczone z tablicy miejscowości.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Pobieranie unikatowego elementu z tablicy lub kolekcji  
 Generator liczb losowych zawsze może zwracać zduplikowane wartości. Gdy zakres liczb staje się mniejszy lub liczba wygenerowanych wartości staje się większa, prawdopodobieństwo wzrostu duplikatów. Jeśli wartości losowe muszą być unikatowe, wygenerowane są więcej liczb w celu zrekompensowania duplikatów, co powoduje zwiększenie niskiej wydajności.  
  
 Istnieje wiele technik obsługi tego scenariusza. Jednym z typowych rozwiązań jest utworzenie tablicy lub kolekcji zawierającej wartości do pobrania, a także tablicę równoległą zawierającą losowe liczby zmiennoprzecinkowe. Druga tablica jest wypełniana liczbą losową w momencie utworzenia pierwszej tablicy, a <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> Metoda jest używana do sortowania pierwszej tablicy przy użyciu wartości w tablicy równoległej.  
  
 Na przykład jeśli tworzysz grę Pasjans, chcesz upewnić się, że każda karta jest używana tylko raz. Zamiast generować liczby losowe w celu pobrania karty i śledzenia tego, czy dana karta została już zastosowana, można utworzyć równoległą tablicę liczb losowych, które mogą być używane do sortowania talii. Po posortowaniu talii aplikacja może zachować wskaźnik, aby wskazać indeks następnej karty na pokładzie.  
  
 To podejście pokazano w poniższym przykładzie. Definiuje `Card` klasę, która reprezentuje kartę z odtwarzaniem `Dealer` i klasę, która zajmuje się talią kart przestawnych. Konstruktor klasy wypełnia dwie tablice `deck` : tablicę, która ma zakres klasy i która reprezentuje wszystkie karty na pokładzie; oraz tablicę lokalną `order` , która `deck` ma taką samą liczbę elementów jak tablica i jest wypełniana `Dealer` z losowo generowanymi <xref:System.Double> wartościami.  Metoda jest następnie wywoływana w celu `deck` posortowania tablicy na podstawie wartości w `order` tablicy. <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono tworzenie pojedynczego generatora liczb losowych i <xref:System.Random.NextBytes%2A>wywoływanie metod <xref:System.Random.NextDouble%2A> , <xref:System.Random.Next%2A>i, aby wygenerować sekwencje liczb losowych w różnych zakresach.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 Poniższy przykład generuje losową liczbę całkowitą, która używa jako indeksu do pobrania wartości ciągu z tablicy.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>W .NET Framework 1,0 i 1,1, minimalna implementacja klasy pochodnej od <see cref="T:System.Random" /> wymaganej <see cref="M:System.Random.Sample" /> przesłania metodę w celu zdefiniowania nowego lub zmodyfikowanego algorytmu do generowania liczb losowych. Klasa pochodna może <see cref="M:System.Random.Next" />następnie polegać na implementacji klasy podstawowej metod, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />i <see cref="M:System.Random.NextDouble" /> , aby wywołać implementację <see cref="M:System.Random.Sample" /> klasy pochodnej metody.  
  
W .NET Framework 2,0 <see cref="M:System.Random.Next" />i nowszych zachowanie metod, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />i <see cref="M:System.Random.NextBytes(System.Byte[])" /> zostało zmienione tak, aby te metody <see cref="M:System.Random.Sample" /> niekoniecznie wywoływać implementację klasy pochodnej metody. W efekcie klasy pochodzące z <see cref="T:System.Random" /> tego obiektu docelowego .NET Framework 2,0 i nowsze powinny również zastąpić te trzy metody.</para></block>
    <block subset="none" type="usage"><para>Implementacja generatora liczb losowych w <see cref="T:System.Random" /> klasie nie gwarantuje, że pozostanie taka sama w głównych wersjach .NET Framework. W związku z tym nie należy zastanowić się, że ten sam inicjator będzie miał tę samą pseudo losowo sekwencję w różnych wersjach .NET Framework.</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Random" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Random" /> klasy, używając domyślnej wartości inicjatora zależnego od czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna wartość inicjatora jest określana na podstawie zegara systemowego i ma skończone rozwiązanie. W związku z tym różne <xref:System.Random> obiekty, które są tworzone w zamknięciu, przez wywołanie konstruktora bez parametrów, będą mieć identyczne domyślne wartości inicjatora i, w związku z tym, będą generować identyczne zestawy liczb losowych. Ten problem można uniknąć, używając pojedynczego <xref:System.Random> obiektu do wygenerowania wszystkich liczb losowych. Można to również obejść, modyfikując wartość inicjatora zwracanego przez zegar systemowy, a następnie jawnie dostarczając tę nową wartość inicjatora <xref:System.Random.%23ctor%28System.Int32%29> do konstruktora. Aby uzyskać więcej informacji, zobacz <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor.  
  
 Wywołaj ten Konstruktor, jeśli chcesz, aby generator liczb losowych generował losową sekwencję liczb. Aby wygenerować stałą sekwencję liczb losowych, która będzie taka sama dla różnych generatorów liczb losowych, <xref:System.Random.%23ctor%28System.Int32%29> Wywołaj konstruktora ze stałą wartością inicjatora. Ten <xref:System.Random> przeciążenie konstruktora jest często używany podczas testowania aplikacji, które używają liczb losowych.  
  
 Po utworzeniu wystąpienia generatora liczb losowych należy wywołać poszczególne <xref:System.Random> metody, takie jak <xref:System.Random.Next> lub <xref:System.Random.NextDouble>, aby generować liczby losowe.  
  
   
  
## Examples  
 Poniższy przykład używa konstruktora bez parametrów, aby utworzyć wystąpienie trzech <xref:System.Random> obiektów i wyświetla sekwencję pięciu losowych liczb całkowitych dla każdego z nich. Ze względu na <xref:System.Random> to, że pierwsze dwa obiekty są tworzone w ciągu zamykania, są tworzone przy użyciu identycznych wartości inicjatora na podstawie zegara systemowego i dlatego generują identyczną sekwencję liczb losowych. Z drugiej strony, Konstruktor bez parametrów trzeciego <xref:System.Random> obiektu jest wywoływany po dwusekundowym opóźnieniu spowodowanym <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> wywołaniem metody. Ponieważ spowoduje to utworzenie innej wartości inicjatora dla trzeciego <xref:System.Random> obiektu, powstaje różne sekwencje liczb losowych.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Numer używany do obliczania wartości początkowej dla wielolosowej sekwencji liczbowej. Jeśli określono ujemną liczbę, używana jest wartość bezwzględna liczby.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Random" /> klasy przy użyciu określonej wartości inicjatora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dostarczenie identycznej wartości inicjatora <xref:System.Random> do różnych obiektów powoduje, że każde wystąpienie będzie generować identyczne sekwencje liczb losowych. Jest to często wykonywane podczas testowania aplikacji, które korzystają z losowych generatorów liczbowych.  
  
 Jeśli aplikacja wymaga różnych losowych sekwencji liczbowych, wywołaj tego konstruktora wielokrotnie przy użyciu różnych wartości inicjatora. Jednym ze sposobów tworzenia unikatowej wartości inicjatora jest to, że jest ona zależna od czasu. Na przykład pouzyskuj wartość inicjatora z zegara systemowego, ponieważ <xref:System.Random.%23ctor> Przeciążenie wykonuje przeciążenia. Jednak zegar systemowy może nie mieć wystarczającej rozdzielczości, aby zapewnić różne wywołania tego konstruktora z inną wartością inicjatora. Powoduje to losowe generatory liczb generujące identyczne sekwencje liczb losowych, jak pokazano na dwóch <xref:System.Random> pierwszych obiektach w poniższym przykładzie. Aby temu zapobiec, Zastosuj algorytm do odróżnienia wartości inicjatora w każdym wywołaniu lub wywołaj <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodę, aby upewnić się, że każdy Konstruktor ma inną wartość inicjatora.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Innym rozwiązaniem jest utworzenie wystąpienia pojedynczego <xref:System.Random> obiektu, który służy do generowania wszystkich losowych liczb w aplikacji. Zapewnia to nieco lepszą wydajność, ponieważ utworzenie wystąpienia generatora liczb losowych jest dość kosztowne.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Random> obiekty z konstruktorem klasy, który pobiera parametr inicjatora i generuje sekwencję losowych liczb całkowitych i podwaja. Przykład ilustruje, że ta sama sekwencja jest generowana, <xref:System.Random> gdy obiekt zostanie utworzony ponownie z konstruktorem i parametrem inicjatora.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca losową liczbę całkowitą.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nieujemną liczbę całkowitą losową.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem, która jest większa lub równa 0 i <see cref="F:System.Int32.MaxValue" />mniejsza niż.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType>generuje liczbę losową z zakresu od 0 do mniejszej niż <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Aby wygenerować liczbę losową z zakresu od 0 do innej liczby dodatniej, użyj <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> przeciążenia metody. Aby wygenerować liczbę losową z innego zakresu, użyj <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> przeciążenia metody.  
  
   
  
## Examples  
 Poniższy przykład wykonuje powtórzone wywołania <xref:System.Random.Next%2A> metody, aby wygenerować określoną liczbę losowych liczb żądanych przez użytkownika. <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> Metoda jest używana do uzyskiwania danych wejściowych klienta.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 Poniższy przykład dziedziczy klasy z <xref:System.Random> programu w celu wygenerowania sekwencji liczb losowych, których dystrybucja różni się od rozkładu jednorodnego wygenerowanego <xref:System.Random.Sample%2A> przez metodę klasy bazowej. Zastępuje <xref:System.Random.Sample%2A> metodę w celu zapewnienia rozkładu liczb losowych i <xref:System.Random.Next%2A?displayProperty=nameWithType> zastępuje metodę, aby użyć serii liczb losowych.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Począwszy od .NET Framework w wersji 2,0, jeśli pochodna jest Klasa z <see cref="T:System.Random" /> i <see cref="M:System.Random.Sample" /> przesłaniasz metodę, dystrybucja udostępniona przez implementację klasy <see cref="M:System.Random.Sample" /> pochodnej metody nie jest używana w wywołaniach klasy bazowej <see cref="M:System.Random.Next" /> implementacja metody. Zamiast tego jest używana jednolita dystrybucja zwrócona <see cref="T:System.Random" /> przez klasę bazową. To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy. Aby zmodyfikować to zachowanie, aby wywołać <see cref="M:System.Random.Sample" /> metodę w klasie pochodnej, należy również <see cref="M:System.Random.Next" /> zastąpić metodę.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Wyłączne górne ograniczenie liczby losowej do wygenerowania. <paramref name="maxValue" />musi być większa lub równa 0.</param>
        <summary>Zwraca nieujemną losową liczbę całkowitą, która jest mniejsza niż określona wartość maksymalna.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem, która jest większa niż lub równa 0, <paramref name="maxValue" />i mniejsza niż; oznacza to, że zakres wartości zwracanych zwykle zawiera <paramref name="maxValue" />0, ale nie. Jednakże, jeśli <paramref name="maxValue" /> jest równa <paramref name="maxValue" /> 0, jest zwracana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenie zwraca losowe liczby całkowite z zakresu od 0 do `maxValue` -1. <xref:System.Random.Next%28System.Int32%29> Jeśli `maxValue` jednak ma wartość 0, metoda zwraca 0.  
  
   
  
## Examples  
 Poniższy przykład generuje losowe liczby całkowite z różnymi przeciążeniami <xref:System.Random.Next%2A> metody.  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 Poniższy przykład generuje losową liczbę całkowitą, która używa jako indeksu do pobrania wartości ciągu z tablicy. Ponieważ najwyższy indeks tablicy jest mniejszy niż jego długość, wartość <xref:System.Array.Length%2A?displayProperty=nameWithType> właściwości jest podawana jako `maxValue` parametr.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue" />jest mniejsza niż 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Dopuszczająca Dolna granica zwracanej liczby losowej.</param>
        <param name="maxValue">Jedyna Górna granica zwracanej liczby losowej. <paramref name="maxValue" />musi być większa lub równa <paramref name="minValue" />.</param>
        <summary>Zwraca losową liczbę całkowitą znajdującą się w określonym zakresie.</summary>
        <returns>32-bitową liczbę całkowitą ze znakiem większą lub <paramref name="minValue" /> równą i <paramref name="maxValue" />mniejszą niż; czyli zakres wartości zwracanych obejmuje <paramref name="minValue" /> , ale nie <paramref name="maxValue" />. Jeśli <paramref name="minValue" /> jest <paramref name="maxValue" />równa, <paramref name="minValue" /> jest zwracana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenie zwraca losowe liczby całkowite z zakresu od `minValue` do `maxValue` -1. <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Jednak jeśli `maxValue` jest równa `minValue`, metoda zwraca `minValue`.  
  
 W przeciwieństwie do innych przeciążeń <xref:System.Random.Next%2A> metody, które zwracają tylko wartości nieujemnych, ta metoda może zwracać ujemną losową liczbę całkowitą.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metody do generowania losowych liczb całkowitych z trzema różnymi zakresami. Należy zauważyć, że dokładne dane wyjściowe z przykładu są zależne od wartości inicjatora dostarczonego przez <xref:System.Random> system do konstruktora klasy.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 Poniższy przykład generuje losową liczbę całkowitą, która używa jako indeksu do pobrania wartości ciągu z tablicy. Ponieważ najwyższy indeks tablicy jest mniejszy niż jego długość, wartość <xref:System.Array.Length%2A?displayProperty=nameWithType> właściwości jest podawana jako `maxValue` parametr.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minValue" />jest większa niż <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides"><para>Począwszy od .NET Framework w wersji 2,0, jeśli pochodna jest Klasa z <see cref="T:System.Random" /> i <see cref="M:System.Random.Sample" /> przesłaniasz metodę, dystrybucja udostępniona przez implementację klasy <see cref="M:System.Random.Sample" /> pochodnej metody nie jest używana w wywołaniach klasy bazowej Implementacja przeciążenia <paramref name="minValue" /> <paramref name="maxValue" /> <see cref="F:System.Int32.MaxValue" />metody, jeśli różnica między parametrami i jest większa niż. <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> Zamiast tego jest używana jednolita dystrybucja zwrócona <see cref="T:System.Random" /> przez klasę bazową. To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy. Aby zmodyfikować to zachowanie, aby wywołać <see cref="M:System.Random.Sample" /> metodę w klasie pochodnej, należy również <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> zastąpić Przeciążenie metody.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica bajtów zawierająca liczby losowe.</param>
        <summary>Wypełnia elementy określonej tablicy bajtów liczbą losową.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element tablicy bajtów ma ustawioną liczbę losową większą lub równą 0 i mniejszą lub równą <xref:System.Byte.MaxValue>.  
  
 Na przykład aby wygenerować kryptograficzną kryptograficznie liczbę losową odpowiednią do tworzenia hasła losowego, użyj metody takiej jak <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Random.NextBytes%2A> metody w celu wypełnienia tablicy bajtów z wartościami losowych bajtów.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Począwszy od .NET Framework w wersji 2,0, jeśli pochodna jest Klasa z <see cref="T:System.Random" /> i <see cref="M:System.Random.Sample" /> przesłaniasz metodę, dystrybucja udostępniona przez implementację klasy <see cref="M:System.Random.Sample" /> pochodnej metody nie jest używana w wywołaniach klasy bazowej <see cref="M:System.Random.NextBytes(System.Byte[])" /> implementacja metody. Zamiast tego jest używana jednolita dystrybucja zwrócona <see cref="T:System.Random" /> przez klasę bazową. To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy. Aby zmodyfikować to zachowanie, aby wywołać <see cref="M:System.Random.Sample" /> metodę w klasie pochodnej, należy również <see cref="M:System.Random.NextBytes(System.Byte[])" /> zastąpić metodę.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca losową liczbę zmiennoprzecinkową o wartości większej lub równej 0,0 i mniejszą niż 1,0.</summary>
        <returns>Liczba zmiennoprzecinkowa o podwójnej precyzji, która jest większa lub równa 0,0, i mniejsza niż 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rzeczywista Górna granica liczby losowej zwracanej przez tę metodę to 0.99999999999999978.  
  
 Aby pobrać losowe wartości zmiennoprzecinkowe w zakresie innym niż 0,0 i 1,0, zobacz sekcję "Pobieranie wartości zmiennoprzecinkowych w określonym zakresie" w temacie dotyczącym <xref:System.Random> klas.  
  
 Ta metoda jest publiczną wersją metody <xref:System.Random.Sample%2A>chronionej.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Random.NextDouble%2A> metodę w celu wygenerowania sekwencji losowego podwajania.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 Poniższy przykład wywołuje <xref:System.Random.NextDouble%2A> metodę w celu wygenerowania 100 liczb losowych i wyświetla ich rozkład częstotliwości.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca losową liczbę zmiennoprzecinkową z zakresu od 0,0 do 1,0.</summary>
        <returns>Liczba zmiennoprzecinkowa o podwójnej precyzji, która jest większa lub równa 0,0, i mniejsza niż 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby utworzyć inną zasadę losowej dystrybucji lub inną regułę generatora liczb losowych, należy utworzyć klasę <xref:System.Random> z klasy i <xref:System.Random.Sample%2A> zastąpić metodę.  
  
> [!IMPORTANT]
>  Metoda jest `protected`, co oznacza, że <xref:System.Random> jest dostępna tylko w klasie i jej klasach pochodnych. <xref:System.Random.Sample%2A> Aby wygenerować liczbę losową z zakresu od 0 do 1 <xref:System.Random> z wystąpienia, <xref:System.Random.NextDouble%2A> Wywołaj metodę.  
  
   
  
## Examples  
 Poniższy przykład dziedziczy klasy z <xref:System.Random> i <xref:System.Random.Sample%2A> przesłania metodę w celu wygenerowania dystrybucji liczb losowych. Ta dystrybucja różni się od jednorodnej dystrybucji wygenerowanej <xref:System.Random.Sample%2A> przez metodę klasy bazowej.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Począwszy od .NET Framework w wersji 2,0, jeśli pochodna jest Klasa z <see cref="T:System.Random" /> i <see cref="M:System.Random.Sample" /> przesłaniasz metodę, dystrybucja udostępniona przez implementację klasy <see cref="M:System.Random.Sample" /> pochodnej metody nie jest używana w wywołaniach klasy bazowej Implementacja następujących metod: 
<see cref="M:System.Random.NextBytes(System.Byte[])" /> -Metoda.  
  
<see cref="M:System.Random.Next" /> -Metoda.  
  
<paramref name="maxValue" /> - -Metoda, if <see cref="F:System.Int32.MaxValue" />()jestwiększaniż<paramref name="minValue" />. <see cref="M:System.Random.Next(System.Int32,System.Int32)" />  
  
Zamiast tego używana jest jednolita dystrybucja udostępniona przez <see cref="T:System.Random" /> klasę bazową. To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy. Aby zmodyfikować to zachowanie, aby wywołać implementację <see cref="M:System.Random.Sample" /> metody w klasie pochodnej, należy również zastąpić zachowanie tych trzech elementów członkowskich. Przykład stanowi ilustrację.</para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>
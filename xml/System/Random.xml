<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="db0be843724a3e5db9bde798d384dd7ecf5a6c0f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36429197" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje pseudolosowego generatora liczb, który to urządzenie, które tworzy sekwencję liczb, które spełniają określone wymagania statystyczne losowości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numery pseudolosowego można wybrać z równym prawdopodobieństwem skończoną zbioru liczb. Wybrany liczby nie są losowy, ponieważ matematyczne algorytm jest używany do wybierania je, ale są one dostatecznie losowe do celów praktycznych. Bieżąca implementacja <xref:System.Random> klasy jest oparta na zmodyfikowanej wersji Donalda E. Knuth subtraktywne generator algorytmu liczb. Aby uzyskać więcej informacji zobacz D. E. Knuth. *Kompozycji programistycznych wolumin 2: Seminumerical algorytmy*. Addison-Wesley, odczytu, MA wydanie trzecie 1997.  
  
 Aby wygenerować kryptograficznie bezpiecznego liczbę losową, który jest odpowiedni dla tworzenia losowe hasło, należy użyć <xref:System.Security.Cryptography.RNGCryptoServiceProvider> klasy lub pochodzić od klasy <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.  
  
 W tym temacie:  
  
 [Tworzenie wystąpień generatora liczb losowych](#Instantiate)   
 [Unikanie wiele wystąpień](#Multiple)   
 [System.Random bezpieczeństwa klasy i wątku](#ThreadSafety)   
 [Generowanie różnego rodzaju liczby losowe](#Functionality)   
 [Podstawiając własne algorytmu](#Overriding)   
 [Jak używać System.Random do...](#Operations)   
 [Taką samą sekwencję losowych wartości do pobrania](#Same)  
 [Pobierz unikatowy sekwencje losowych wartości](#Unique)  
 [Pobieranie liczby całkowite w określonym zakresie](#Range)  
 [Pobieranie liczby całkowite z określonej liczby miejsc po przecinku](#Digits)  
 [Pobieranie wartości zmiennoprzecinkowych w określonym zakresie](#Floats)  
 [Generowanie losowych wartości logiczna](#Boolean)  
 [Generowanie losowe 64-bitowych liczb całkowitych](#Long)  
 [Pobrać bajtów w określonym zakresie](#Bytes)  
 [Losowo pobrać element z kolekcji lub tablicy](#Array)  
 [Pobierz unikatowy element z kolekcji lub tablicy](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>Tworzenie wystąpień generatora liczb losowych  
 Wystąpienia generatora liczb losowych podając wartości początkowej (początkową wartość pseudolosowego algorytmu generowania liczb), aby <xref:System.Random.%23ctor%2A> konstruktora klasy.  Można podać wartości początkowej, jawnie lub niejawnie:  
  
-   <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor korzysta wartość jawne inicjatora.  
  
-   <xref:System.Random.%23ctor> Konstruktor korzysta z zegarem systemowym podania wartości inicjatora. Jest to najczęściej o uruchamianiu generatora liczb losowych.  
  
 Jeśli tego samego inicjatora jest używana do oddzielnego <xref:System.Random> obiekty, zostanie wygenerowany dla tej samej serii liczb losowych. Może to być przydatne do tworzenia zestawu testów, który przetwarza losowych wartości lub dla odtwarzanie gry wyprowadzonych swoje dane z liczb losowych. Jednak należy pamiętać, że <xref:System.Random> obiektów w procesów uruchomionych w różnych wersji programu .NET Framework może zwrócić innej serii liczb losowych, nawet wtedy, gdy są one wystąpienia inicjatora identycznymi wartościami.  
  
 Do tworzenia różnych sekwencji liczb losowych, możesz wprowadzić wartości początkowej zależnych od czasu, a tym samym produkujących innej serii z każdym nowe wystąpienie klasy <xref:System.Random>. Sparametryzowane <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor może zająć <xref:System.Int32> wartość na podstawie ich liczba w bieżącą godzinę, podczas gdy bez parametrów <xref:System.Random.%23ctor> Konstruktor korzysta zegara systemowego do generowania swojej wartości początkowej. Jednak ponieważ zegar ma rozdzielczość ograniczone, przy użyciu konstruktora bez parametrów do utworzenia różnych <xref:System.Random> obiektów kolejno Zamknij tworzy losowe numer generatory, które powodują powstanie identyczne sekwencji liczb losowych. Poniższy przykład przedstawia sposób dwóch <xref:System.Random> obiektów, które są tworzone kolejno Zamknij Generowanie serii identycznych liczb losowych. W większości systemów Windows <xref:System.Random> obiektów utworzonych w ciągu 15 milisekund siebie prawdopodobnie identycznych inicjatora wartości.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 Aby uniknąć tego problemu, należy utworzyć jeden <xref:System.Random> obiektu zamiast wielu obiektów.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Unikanie wiele wystąpień  
 Inicjowanie dwóch losowych generatory numer w pętli ścisłej lub w krótkim odstępie czasu tworzy dwa losowe generatory numer powodującymi identyczne sekwencji liczb losowych. W większości przypadków nie jest celem dewelopera i może prowadzić do problemów z wydajnością, ponieważ tworzenie wystąpień i Inicjowanie generator liczb losowych jest stosunkowo drogie.  
  
 Zarówno do zwiększenia wydajności i uniknąć przypadkowo tworzenie oddzielnych losowe generatory numerów generujących identyczne sekwencji liczbowych, zaleca się utworzenie jednego <xref:System.Random> obiektu dla generatora liczb losowych wiele wraz z upływem czasu, zamiast tworzyć nowe <xref:System.Random> obiekty do wygenerowania jeden liczby losowe.  
  
 Jednak <xref:System.Random> klasy nie jest bezpieczne dla wątków. Jeśli należy wywołać <xref:System.Random> metody wiele wątków, postępuj zgodnie z wytycznymi, omówiona w następnej sekcji.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>System.Random bezpieczeństwa klasy i wątku  
 Zamiast tworzenia wystąpienia osoba <xref:System.Random> obiekty, zaleca się utworzenie pojedynczej <xref:System.Random> wystąpienia dla generatora liczb losowych wymagane przez aplikację. Jednak <xref:System.Random> obiekty nie są bezpieczne dla wątków. Jeśli aplikacja wymaga <xref:System.Random> metod przez wiele wątków, należy użyć obiektu synchronizacji w celu zapewnienia tylko jeden wątek dostęp do generatora liczb losowych w czasie. Jeśli użytkownik nie upewnij się, że <xref:System.Random> obiekt jest dostępny w sposób zapewniający obsługę wielowątkowości, wywołania metody, które zwracają liczb losowych zwraca 0.  
  
 W poniższym przykładzie użyto C# [lock — instrukcja](~/docs/csharp/language-reference/keywords/lock-statement.md) i Visual Basic [SyncLock — instrukcja](~/docs/visual-basic/language-reference/statements/synclock-statement.md) do upewnij się, że pojedynczy generatora liczb losowych jest dostępne 11 wątków w sposób wątkowo. Każdy wątek generuje 2 milionów liczb losowych, zlicza liczby losowe wygenerowany i oblicza sumę ich, a następnie aktualizuje sumy dla wszystkich wątków po zakończeniu wykonywania.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 Przykład zapewnia bezpieczeństwo wątków w następujący sposób:  
  
-   <xref:System.ThreadStaticAttribute> Atrybut służy do definiowania zmiennych thread-local, które śledzą sumę liczb losowych wygenerowany i ich sumy dla każdego wątku.  
  
-   Blokady ( `lock` instrukcji w języku C# i `SyncLock` instrukcji w języku Visual Basic) chroni dostęp do zmiennych w łączna liczba i sumę wszystkich liczb losowych wygenerowany na wszystkie wątki.  
  
-   Semafor ( <xref:System.Threading.CountdownEvent> obiektu) służy do zapewnienia, że bloki wątku głównego do innych wątków wykonany.  
  
-   Przykład sprawdza, czy generatora liczb losowych została uszkodzona przez określenie, czy dwa kolejne wywołania losowych liczb metody generowania zwraca 0. Wykrycie uszkodzenia w przykładzie użyto <xref:System.Threading.CancellationTokenSource> obiektu, która sygnalizuje, że należy anulować wszystkie wątki.  
  
-   Przed wygenerowaniem każdej liczby losowe, każdy wątek sprawdza stan <xref:System.Threading.CancellationToken> obiektu. Jeśli zażądano anulowania <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metodę, aby anulować wątku.  
  
 Poniższy przykład jest taka sama jak pierwsza strona, z wyjątkiem tego, że używa <xref:System.Threading.Tasks.Task> obiekt i wyrażenia lambda zamiast <xref:System.Threading.Thread> obiektów.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 Różni się od pierwszym przykładzie w następujący sposób:  
  
-   Zmienne do śledzenia liczby liczb losowych wygenerowany i ich sumy w każdym zadaniu znajdują się lokalnie do zadania, a więc nie trzeba używać <xref:System.ThreadStaticAttribute> atrybutu.  
  
-   Statycznych <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metoda służy do zapewnienia, że głównym wątku nie wykona przed zakończeniem wszystkie zadania. Nie istnieje potrzeba dla <xref:System.Threading.CountdownEvent> obiektu.  
  
-   Wyjątek, który jest wynikiem anulowanie zadania jest udostępniane w <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metody. W poprzednim przykładzie jest obsługiwane przez poszczególne wątki.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Generowanie różnego rodzaju liczby losowe  
 Generatora liczb losowych udostępnia metody, które pozwalają na następujące rodzaje liczby losowe generowanie:  
  
-   Szereg <xref:System.Byte> wartości. Określenie liczby wartości bajtu przez przekazanie tablicy inicjowane z liczbą elementów ma metodę, aby powrócić do <xref:System.Random.NextBytes%2A> metody. Poniższy przykład generuje 20 bajtów.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Pojedynczy liczba całkowita. Można wybrać, czy ma całkowitą z zakresu od 0 do wartości maksymalnej (<xref:System.Int32.MaxValue?displayProperty=nameWithType> -1) przez wywołanie metody <xref:System.Random.Next> metoda, liczbą całkowitą od 0 do określonej wartości przez wywołanie metody <xref:System.Random.Next%28System.Int32%29> metody lub liczbą całkowitą w zakresie wartości przez wywołanie metody <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>metody. W sparametryzowane przeciążeń określona wartość maksymalna jest na wyłączność; Rzeczywista liczba maksymalna generowany jest jeden mniej niż określona wartość.  
  
     Następujące przykładowe wywołania <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metody dla generatora liczb losowych 10 w zakresie od -10 do 10. Należy pamiętać, że drugi argument do metody określa wyłącznego górna granica zakresu losowych wartości zwracanych przez metodę. Innymi słowy największa liczba całkowita, która metoda może zwracać jedną jest mniejsza od tej wartości.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Pojedynczą wartość zmiennoprzecinkowa od 0,0 mniejszą niż 1,0 przez wywołanie metody <xref:System.Random.NextDouble%2A> metody. Wyłączny górna granica liczbę losową zwracany przez metodę to 1, więc jego rzeczywistego górna granica jest 0.99999999999999978. Poniższy przykład generuje 10 losowych liczb zmiennoprzecinkowych.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Metoda pozwala na określenie zwrócony liczbę losową z zakresu. Jednak `maxValue` parametr, który określa, górna granica zwracana liczba, jest na wyłączność, nie włącznie, wartość. Oznacza to, że wywołanie metody `Next(0, 100)` zwraca wartość z zakresu od 0 do 99, a nie z zakresu od 0 do 100.  
  
 Można również użyć <xref:System.Random> klasy dla zadania, takie jak Generowanie [losowych wartości T:System.Boolean](#Boolean), generowanie [zmiennoprzecinkowej losowych wartości z zakresu innych niż 0 lub 1](#Floats), generowanie [losowe 64-bitowych liczb całkowitych](#Long), i [losowo pobierania unikatowy element z kolekcji lub tablicy](#UniqueArray). Tych i innych typowych zadań, zobacz [jak używać System.Random do...](#Operations) sekcja.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Podstawiając własne algorytmu  
 Można wdrożyć własne generatora liczb losowych przy dziedziczących <xref:System.Random> klasy i dostarczenie z algorytmu generowania liczb. Aby przekazać swoje własne algorytmu, konieczne jest przesłonięcie <xref:System.Random.Sample%2A> metodę, która implementuje algorytm Generowanie liczb pseudolosowych. Należy również zastąpić <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, i <xref:System.Random.NextBytes%2A> metod, które zapewniają one wywołać Twojej przesłoniętych <xref:System.Random.Sample%2A> metody. Nie trzeba zastąpić <xref:System.Random.Next%28System.Int32%29> i <xref:System.Random.NextDouble%2A> metody.  
  
 Na przykład, która jest pochodną <xref:System.Random> klasy i zmienia jego domyślny pseudolosowego generatora liczb, zobacz <xref:System.Random.Sample%2A> strony odwołania.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Jak używać System.Random do...  
 Poniższe sekcje omówienia i podaj przykładowy kod niektóre metody można używać liczb losowych w aplikacji.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Taką samą sekwencję losowych wartości do pobrania  
 Czasami chcesz wygenerować taką samą sekwencję losowych liczb znajdujących się w scenariuszach testów oprogramowania i odtwarzanie gier. Testowanie za pomocą tej samej sekwencji liczb losowych umożliwia wykrywanie regresji i Potwierdź poprawki błędów. Przy użyciu takiej samej kolejności liczbę losową w grach służy do powtarzania poprzednich gier.  
  
 Można wygenerować tej samej sekwencji liczb losowych, podając tę samą wartość inicjatora na <xref:System.Random.%23ctor%28System.Int32%29> konstruktora. Wartość zalążka zapewnia wartości początkowej pseudolosowego algorytmu generowania liczb. W poniższym przykładzie użyto 100100 jako wartości początkowej dowolnego można utworzyć wystąpienia <xref:System.Random> obiektów, wyświetla 20 losowych wartości zmiennoprzecinkowych i będzie się powtarzał wartości początkowej. Następnie przywraca wartości początkowej, tworzy nowy generator liczb losowych i wyświetla te same 20 losowych liczb zmiennoprzecinkowych wartości.  Należy zwrócić uwagę na przykładzie może powodować różnych sekwencji liczb losowych Jeśli uruchomione w różnych wersjach programu .NET Framework.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Pobierz unikatowy sekwencji liczb losowych  
 Podając wartości inicjatora różnych wystąpień <xref:System.Random> klasy powoduje, że każdy generator liczb losowych wygenerowało sekwencję różnych wartości. Wartość zalążka można podać albo jawnie przez wywołanie metody <xref:System.Random.%23ctor%28System.Int32%29> konstruktora, lub niejawnie, wywołując <xref:System.Random.%23ctor> konstruktora. Większość deweloperów wywołać konstruktora, który używa zegara systemowego. Poniższy przykład korzysta z tej metody można utworzyć dwa wystąpienia <xref:System.Random> wystąpień. Każde wystąpienie prezentuje serię 10 losowych liczb całkowitych.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Jednak ze względu na jego ograniczone rozwiązanie zegar systemowy nie wykrywa różnice czasu, które są mniej niż około 15 milisekund. W związku z tym jeśli kod wywołuje <xref:System.Random.%23ctor> przeciążenia można utworzyć dwa wystąpienia <xref:System.Random> obiekty kolejno, możesz przypadkowo udostępniają obiekty z wartościami identyczne inicjatora. Aby wyświetlić to w poprzednim przykładzie, komentarz <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> wywołanie metody i kompilacji i ponownie uruchom przykładzie.  
  
 Aby temu zapobiec, zaleca się utworzenie wystąpienia pojedynczy <xref:System.Random> obiekt zamiast wiele migawek. Ponieważ jednak <xref:System.Random> nie jest bezpieczne, możesz uzyskać dostępu do niektórych urządzeń synchronizacji należy użyć dla wątków <xref:System.Random> wystąpienia z wielu wątków; Aby uzyskać więcej informacji, zobacz [losowe bezpieczeństwa klasy i wątku](#ThreadSafety) wcześniej w tym temat. Alternatywnie można mechanizm opóźnienia, takich jak <xref:System.Threading.Thread.Sleep%2A> metodę używaną w poprzednim przykładzie, aby upewnić się, że wystąpień występuje więcej niż 15 milisekund od siebie.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Pobieranie liczby całkowite w określonym zakresie  
 Można pobrać liczby całkowite z zakresu określonego przez wywołanie metody <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodę, która pozwala określić zarówno dolna i górna granica chcesz powrócić generator liczb losowych liczb. Górna granica jest na wyłączność, nie włącznie, wartość. Oznacza to, że nie jest zawarty w zakresie wartości zwracanych przez metodę. W poniższym przykładzie użyto tej metody do generowania losowego liczby całkowite z zakresu od -10 do 10. Należy pamiętać, że określa 11, która jest większa niż żądaną wartość jako wartość o jeden z `maxValue` argument w wywołaniu metody.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Pobieranie liczby całkowite z określonej liczby miejsc po przecinku  
 Możesz wywołać <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metoda pobierania liczby z określonej liczby cyfr. Na przykład, aby pobrać liczby z czterech cyfr (czyli liczby z zakresu od 1000 do 9999), należy wywołać <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metody z `minValue` wartość 1000 i `maxValue` wartość 10000, jak przedstawiono na poniższym przykładzie.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Pobieranie wartości zmiennoprzecinkowych w określonym zakresie  
 <xref:System.Random.NextDouble%2A> Metoda zwraca losowych wartości zmiennoprzecinkowych zakresu od 0 do mniej niż 1. Jednak często należy wygenerować losowych wartości w niektórych inny zakres.  
  
 Jeśli interwał między minimalną i maksymalną odpowiednie wartości to 1, możesz dodać różnica między wymagany przedział czasu rozpoczęcia i 0 liczbę zwracanych przez <xref:System.Random.NextDouble%2A> metody. Poniższy przykład jest to, aby wygenerować 10 losowych liczbami z przedziału od -1 i 0.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Dla generatora liczb losowych liczb zmiennoprzecinkowych którego dolna granica jest 0, ale górna granica jest większa niż 1 (lub, w przypadku wartości ujemne, którego dolna granica jest mniejsza niż -1 i górna granica jest 0), należy pomnożyć liczbę losową przez granicą inną niż zero. Poniższy przykład robi to dla generatora liczb losowych liczb zmiennoprzecinkowych 20 milionów zakresu od 0 do <xref:System.Int64.MaxValue?displayProperty=nameWithType>. W wyświetla również dystrybucji losowych wartości generowanych przez metodę.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Aby wygenerować losowych liczb zmiennoprzecinkowych między dwiema wartościami dowolnego, takich jak <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metoda wykonuje liczb całkowitych, należy użyć następującej formuły:  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 Poniższy przykład generuje 1 milion liczb losowych, które należeć do zakresu od 10.0 do 11.0 i wyświetla jego dystrybucji.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Generowanie losowych wartości logiczna  
 <xref:System.Random> Klasy nie udostępnia metody, które generują <xref:System.Boolean> wartości. Można jednak zdefiniować własne klasa lub metoda w tym celu. W poniższym przykładzie zdefiniowano klasę, `BooleanGenerator`, z jedną metodę `NextBoolean`. `BooleanGenerator` Klasy magazynów <xref:System.Random> obiektu jako zmiennej prywatnej. `NextBoolean` Wywołania metody <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> — metoda i przekazuje jego wynik do <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> metody. Należy pamiętać, że 2 jest używany jako argument do określenia górnej granicy liczby losowe. Ponieważ jest to wartość wyłączności, wywołanie metody zwraca 0 lub 1.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Zamiast tworzyć osobnej klasy do generowania losowego <xref:System.Boolean> wartości, na przykład można po prostu zdefiniowanych pojedynczej metody. W takim przypadku jednak <xref:System.Random> obiektu powinien zostały zdefiniowane jako zmienna poziomie klasy, aby zapobiec uruchamianiu nową <xref:System.Random> wystąpienia w każdym wywołaniu metody. W języku Visual Basic, można zdefiniować jako wystąpienie losowe [statycznych](~/docs/visual-basic/language-reference/modifiers/static.md) zmiennej w `NextBoolean` metody.  W poniższym przykładzie przedstawiono implementację.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Generowanie losowe 64-bitowych liczb całkowitych  
 Przeciążeń <xref:System.Random.Next%2A> zwracany przez metodę 32-bitowych liczb całkowitych. W niektórych przypadkach może być do pracy z 64-bitowych liczb całkowitych. Można to zrobić w następujący sposób:  
  
1.  Wywołanie <xref:System.Random.NextDouble%2A> wartość punktów metoda pobierania zmiennoprzecinkowej podwójnej precyzji.  
  
2.  Należy pomnożyć tę wartość przez <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 Poniższy przykład korzysta z tej techniki do generowania milionów 20 losowe długich liczb całkowitych i kategoryzuje je w grupach równy 10. Następnie oblicza rozkład liczby losowe liczbą w każdej grupie z zakresu od 0 do <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Jak pokazano na dane wyjściowe z przykładu, numery są dystrybuowane mniej lub bardziej równomiernie w zakresie długich liczb całkowitych.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Alternatywne technika używa bit manipulowanie nie generuje naprawdę losowych liczb. Ta metoda wywołuje <xref:System.Random.Next> do generowania dwie liczb całkowitych, co na 32 przesunięcia w lewo bitów i ORs je razem. Ta technika ma dwa ograniczenia:  
  
1.  Ponieważ bitowe 31 jest znaku, wartość w bit 31 wynikowy długich liczb całkowitych jest zawsze 0.  Można temu zaradzić, generując losowe 0 lub 1, lewo przesuwania go 31 bitów i ORing go przy użyciu oryginalnego losowe długich liczb całkowitych.  
  
2.  Więcej poważnie ponieważ prawdopodobieństwo, że wartość zwracana przez <xref:System.Random.Next> będzie równa 0, w zakresie od 0x0 0x00000000FFFFFFFF będzie kilka ewentualne liczb losowych.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Pobrać bajtów w określonym zakresie  
 Przeciążeń <xref:System.Random.Next%2A> metody umożliwiają określenie zakresu liczb losowych, ale <xref:System.Random.NextBytes%2A> nie ma metody. Poniższy przykład implementuje `NextBytes` metodę, która umożliwia określenie zakresu bajtów zwrócona. Definiuje `Random2` klasą pochodzącą z <xref:System.Random> i overloads jego `NextBytes` metody.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 `NextBytes(Byte[], Byte, Byte)` Metoda opakowuje wywołanie <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> — metoda i określa wartość minimalną i jeden większa niż wartość maksymalna (w tym przypadku 0 i 101) czy chcemy zwrócony w tablicy bajtów. Ponieważ firma Microsoft pewności, czy wartości całkowite zwrócone przez <xref:System.Random.Next%2A> metody są w zakresie <xref:System.Byte> typu danych, firma Microsoft może bezpiecznie rzutowanie je (C#) i konwertowanie (w języku Visual Basic) z liczbami całkowitymi bajtów.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Losowo pobrać element z kolekcji lub tablicy  
 Liczby losowe często służą jako indeksów do pobierania wartości z tablicą lub kolekcji. Można pobrać wartości losowych indeksu, należy wywołać <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> — metoda i użyj dolnej granicy tablicy jako wartość jego `minValue` argument i jeden większa niż górna granica tablicy jako wartości jego `maxValue` argumentu. Dla tablicy liczony od zera, co jest równoważne jego <xref:System.Array.Length%2A> właściwości lub większa niż wartość zwrócona przez jedną <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> metody. Poniższy przykład losowo pobiera nazwę miejscowości w Stanach Zjednoczonych z tablicy miast.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Pobierz unikatowy element z kolekcji lub tablicy  
 Generator liczb losowych zawsze wrócić zduplikowane wartości. Zakres numerów staje się mniejszą lub liczbę wartości wygenerowany staje się większy, rozwoju prawdopodobieństwo duplikaty. Jeśli losowych wartości muszą być unikatowe, numery więcej są generowane odpowiednio duplikatów, co coraz pogorszenie wydajności.  
  
 Istnieje szereg technik w celu obsługi tego scenariusza. Jest jednym z typowych rozwiązań do utworzenia tablicy lub kolekcję, która zawiera wartości, które mają zostać pobrane i Tablica równoległa losowych liczb zmiennoprzecinkowych. Druga tablica jest wypełniana liczb losowych w chwili pierwszego tablicy jest tworzony, i <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> metoda jest używana do sortowania pierwszego tablicy przy użyciu wartości w tablicy równoległych.  
  
 Na przykład Jeśli projektujesz gra Pasjans chcesz upewnij się, że każda karta jest używana tylko raz. Zamiast generowania liczby losowe, aby pobrać karty i śledzenie czy karty już zostały uwzględnione, można utworzyć tablica równoległa losowych liczb, które mogą być używane do sortowania talii. Po talii jest sortowana, aplikację można zachować wskaźnik wskazuje indeks następnej karty w talii.  
  
 To podejście pokazano w poniższym przykładzie. Definiuje `Card` Klasa reprezentująca karty do gry i a `Dealer` klasy, która zajmuje talii przesuniętą kart. `Dealer` Konstruktora klasy wypełnia dwie tablice: `deck` tablicy z zakresem klasy, który reprezentuje wszystkie karty w talii; i lokalnym `order` tablica, która ma taką samą liczbę elementów jako `deck` tablicy i jest wypełniana z losowo generowany <xref:System.Double> wartości.  <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> Wywoływana jest metoda następnie Sortuj `deck` tablicy na podstawie wartości w `order` tablicy.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 Poniższy przykład tworzy pojedynczy generatora liczb losowych i wywołania jego <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, i <xref:System.Random.NextDouble%2A> metod do wygenerowania sekwencji liczb losowych w różnych zakresów.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 Poniższy przykład generuje losową liczbę całkowitą, która jest używana jako indeks można pobrać wartości ciągu z tablicy.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>.NET Framework 1.0 i 1.1, minimalna implementacji klasy pochodzące z <see cref="T:System.Random" /> wymagane zastępowanie <see cref="M:System.Random.Sample" /> metody do definiowania nowych lub zmodyfikowanych algorytmu generowania liczb losowych. Klasa pochodna może następnie zależne od implementacji klasy podstawowej <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, i <see cref="M:System.Random.NextDouble" /> metod do wywołania implementacji klasy pochodnej <see cref="M:System.Random.Sample" /> metody.  W programie .NET Framework 2.0 lub nowszy, zachowanie <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, i <see cref="M:System.Random.NextBytes(System.Byte[])" /> metody zostały zmienione tak, aby te metody nie wymagają wykonania klasy pochodnej <see cref="M:System.Random.Sample" /> metody. W związku z tym klas pochodnych <see cref="T:System.Random" /> który docelową programu .NET Framework 2.0 i później również powinny zastępować tych trzech metod.</para>
    </block>
    <block subset="none" type="usage">
      <para>Implementacja generatora liczb losowych w <see cref="T:System.Random" /> klasy nie jest gwarantowana ma pozostać niezmienione przez główne wersje programu .NET Framework. W związku z tym nie należy założono, tej samej inicjatora spowoduje taką samą sekwencję pseudolosowego w różnych wersjach programu .NET Framework.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Random" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Random" /> przy użyciu wartości początkowej domyślny zależny od czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna wartość zalążka pochodzi z zegara systemowego i ma ograniczone rozpoznawania. Dzięki temu różnych <xref:System.Random> obiektów, które są tworzone Zamknij kolejno przez wywołanie konstruktora domyślnego będzie mieć identyczne domyślne wartości inicjatora i, w związku z tym spowoduje identyczne zestawy liczb losowych. Ten problem można uniknąć przy użyciu pojedynczej <xref:System.Random> obiektu do wygenerowania wszystkich liczb losowych. Można również obejść go przez zmodyfikowanie wartości początkowej zwrócony przez zegara systemowego i podają jawnie tej nowej wartości inicjatora <xref:System.Random.%23ctor%28System.Int32%29> konstruktora. Aby uzyskać więcej informacji, zobacz <xref:System.Random.%23ctor%28System.Int32%29> konstruktora.  
  
 Jeśli chcesz, aby Twoje generator liczb losowych wygenerować sekwencję losowych liczb, należy wywołać tego konstruktora. Aby wygenerować stałym sekwencji liczb losowych, który ma być taka sama dla różnych generatory liczb losowych, należy wywołać <xref:System.Random.%23ctor%28System.Int32%29> konstruktora o wartości inicjatora stałej. To <xref:System.Random> przeładowania konstruktora jest często używany podczas testowania aplikacji, które używają liczb losowych.  
  
 Po został uruchomiony generatora liczb losowych, należy wywołać poszczególnych <xref:System.Random> metod, takich jak <xref:System.Random.Next> lub <xref:System.Random.NextDouble>, aby generatora liczb losowych.  
  
   
  
## Examples  
 W poniższym przykładzie użyto domyślnego konstruktora do utworzenia wystąpienia trzy <xref:System.Random> obiekty i wyświetla sekwencję pięć losowych liczb całkowitych dla każdego. Ponieważ dwa pierwsze <xref:System.Random> obiekty są tworzone po kolei Zamknij, są tworzone, używając inicjatora identyczne wartości na podstawie zegara systemowego i, w związku z tym wygenerowanie identyczne sekwencji liczb losowych. Z drugiej strony, domyślny konstruktor obiektu trzeci <xref:System.Random> obiektu jest wywoływana po wykonaniu dwóch sekund opóźnienia spowodowane przez wywołanie metody <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody. Ponieważ to daje wartość inicjatora różnych trzeci <xref:System.Random> obiekt, tworzy inną sekwencję liczb losowych.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Liczba używane do obliczania wartości początkowej pseudolosowego numeru sekwencji. Jeśli określono wartość ujemną, jest używana wartość bezwzględną liczby.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Random" /> przy użyciu wartości początkowej określony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podawania wartości inicjatora identyczne do różnych <xref:System.Random> obiektów powoduje, że każde wystąpienie wygenerować identyczne sekwencji liczb losowych. Często jest to podczas testowania aplikacji, które opierają się na generatory liczb losowych.  
  
 Jeśli aplikacja wymaga innego losowe sekwencje, wywołaj ten konstruktor wielokrotnie z inicjatora różnych wartości. Jednym ze sposobów uzyskiwania wartości inicjatora unikatowy jest aby była zależna od czasu. Na przykład pochodzi z zegarem systemowym wartości początkowej jako <xref:System.Random.%23ctor> jest przeciążenia. Jednak zegara systemowego może nie mieć wystarczającą rozdzielczość zapewnienie różnymi wywołaniami tego konstruktora z wartością innego inicjatora. W efekcie losowych liczb generatory, generujących identyczne sekwencji liczb pseudolosowego, jak pokazano dwa pierwsze <xref:System.Random> obiektów w poniższym przykładzie. Aby tego uniknąć, należy zastosować algorytm rozróżnianie wartości początkowej w każdym wywołania lub wywołanie <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> sposób zapewnienia zapewniają każdego konstruktora z wartością innego inicjatora.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Innym rozwiązaniem jest utworzenie wystąpienia pojedynczy <xref:System.Random> obiektu umożliwia generowanie liczb losowych w aplikacji. Daje to nieco lepszą wydajność, ponieważ tworzenie wystąpień generator liczb losowych jest dość kosztowna.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Random> obiektów z konstruktora klasy, która przyjmuje parametr inicjatora i generuje sekwencję losowych liczb całkowitych i na symulacyjnych. Pokazano w przykładzie wygenerowania takiej samej kolejności podczas <xref:System.Random> ponownie utworzyć obiektu z parametrem Konstruktor i inicjatora.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca losową liczbę całkowitą.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nieujemną losową liczbę całkowitą.</summary>
        <returns>32-bitowe liczby całkowite ze znakiem jest większa niż lub równa 0 i mniejsza niż <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> generuje losową liczbę, którego wartość należy do zakresu od 0 do mniej niż <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Aby generować losową liczbę, którego wartość należy do zakresu od 0 dodatnią liczbę, należy użyć <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> przeciążenie metody. Aby generować losową liczbę z zakresu innego, należy użyć <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> przeciążenie metody.  
  
   
  
## Examples  
 Poniższy przykład powoduje, że powtarzane wywołania <xref:System.Random.Next%2A> metody do wygenerowania określoną liczbę liczb losowych żądanej przez użytkownika. <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> Metody jest używany do pobierania danych wejściowych klienta.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 Poniższy przykład pochodzi z klasy <xref:System.Random> do generowania sekwencji liczb losowych, którego dystrybucji różni się z dystrybucji uniform generowane przez <xref:System.Random.Sample%2A> metody klasy podstawowej. Zastępuje on <xref:System.Random.Sample%2A> metodę w celu zapewnienia dystrybucji liczb losowych i zastąpienia <xref:System.Random.Next%2A?displayProperty=nameWithType> metodę serii liczb losowych.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W programie .NET Framework w wersji 2.0, jeśli pochodzi z klasy <see cref="T:System.Random" /> i zastąpić <see cref="M:System.Random.Sample" /> metoda, dystrybucji dostarczonej przez implementację klasy pochodnej z <see cref="M:System.Random.Sample" /> — metoda nie jest używany w wywołania do klasy podstawowej Implementacja <see cref="M:System.Random.Next" /> metody. Zamiast tego uniform dystrybucji zwrócony przez podstawowym <see cref="T:System.Random" /> klasa jest używana. To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy. Aby zmienić to zachowanie do wywołania <see cref="M:System.Random.Sample" /> metody w klasie pochodnej, konieczne jest również przesłonięcie <see cref="M:System.Random.Next" /> metody.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Wyłączny górnej granicy liczby losowe do wygenerowania. <c>maxValue</c> musi być większa lub równa 0.</param>
        <summary>Zwraca nieujemną losową liczbę całkowitą mniejszą niż określona wartość maksymalna.</summary>
        <returns>32-bitowe liczby całkowite ze znakiem jest większa niż lub równa 0 i mniejsza niż <paramref name="maxValue" />; oznacza to, że zakres wartości zwracanych zwykle obejmuje 0, ale nie <paramref name="maxValue" />. Jednak jeśli <paramref name="maxValue" /> jest równe 0, <paramref name="maxValue" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%29> Przeciążenia zwraca losowych liczb całkowitych zakresu od 0 do `maxValue` -1. Jednak jeśli `maxValue` wynosi 0, metoda zwraca wartość 0.  
  
   
  
## Examples  
 Poniższy przykład generuje losowych liczb całkowitych z różnych przeciążeń <xref:System.Random.Next%2A> metody.  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 Poniższy przykład generuje losową liczbę całkowitą, która jest używana jako indeks można pobrać wartości ciągu z tablicy. Ponieważ najwyższy indeks tablicy jest jeden mniejsza niż długość, wartość <xref:System.Array.Length%2A?displayProperty=nameWithType> właściwość jest podana jako `maxValue` parametru.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxValue" /> jest mniejsza niż 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Dolna granica włącznie liczbę losową zwracane.</param>
        <param name="maxValue">Wyłączny górnej granicy liczby losowe są zwracane. <c>maxValue</c> musi być większa niż lub równa <c>minValue</c>.</param>
        <summary>Zwraca losową liczbę całkowitą, która znajduje się w określonym zakresie.</summary>
        <returns>32-bitowe całkowita większa lub równa <paramref name="minValue" /> i mniejsza niż <paramref name="maxValue" />; zakres wartości zwracanych obejmuje <paramref name="minValue" /> , ale nie <paramref name="maxValue" />. Jeśli <paramref name="minValue" /> jest równe <paramref name="maxValue" />, <paramref name="minValue" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Przeciążenia zwraca losowych liczb całkowitych w zakresie od `minValue` do `maxValue` -1. Jednak jeśli `maxValue` jest równe `minValue`, metoda zwraca `minValue`.  
  
 W przeciwieństwie do innych przeciążeń <xref:System.Random.Next%2A> , która zwracać tylko nieujemnej wartości, ta metoda może zwracać metoda ujemna losową liczbę całkowitą.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metody do wygenerowania losowych liczb całkowitych na trzy różne zakresy. Należy pamiętać, że dokładne dane wyjściowe z przykładu zależy od wartości inicjatora dostarczany przez system przekazany do <xref:System.Random> konstruktora klasy.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 Poniższy przykład generuje losową liczbę całkowitą, która jest używana jako indeks można pobrać wartości ciągu z tablicy. Ponieważ najwyższy indeks tablicy jest jeden mniejsza niż długość, wartość <xref:System.Array.Length%2A?displayProperty=nameWithType> właściwość jest podana jako `maxValue` parametru.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="minValue" /> jest większa niż <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides">
          <para>W programie .NET Framework w wersji 2.0, jeśli pochodzi z klasy <see cref="T:System.Random" /> i zastąpić <see cref="M:System.Random.Sample" /> metoda, dystrybucji dostarczonej przez implementację klasy pochodnej z <see cref="M:System.Random.Sample" /> — metoda nie jest używany w wywołania do klasy podstawowej Implementacja <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> przeciążenia metody, jeśli różnica między <paramref name="minValue" /> i <paramref name="maxValue" /> parametrów jest większa niż <see cref="F:System.Int32.MaxValue" />. Zamiast tego uniform dystrybucji zwrócony przez podstawowym <see cref="T:System.Random" /> klasa jest używana. To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy. Aby zmienić to zachowanie do wywołania <see cref="M:System.Random.Sample" /> metody w klasie pochodnej, konieczne jest również przesłonięcie <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> przeciążenie metody.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica bajtów, aby zawierała liczby losowe.</param>
        <summary>Wstawia elementy określonej tablicy bajtów liczb losowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element tablicy bajtów ma ustawioną liczbę losową większą niż lub równa 0 i mniejsza niż lub równa <xref:System.Byte.MaxValue>.  
  
 Na przykład aby wygenerować zabezpieczone kryptograficznie liczbę losową odpowiedni w przypadku tworzenia losowe hasło, użyj metody takie jak <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Random.NextBytes%2A> metody, aby wypełnić tablicę bajtów losowych wartości bajtów.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>W programie .NET Framework w wersji 2.0, jeśli pochodzi z klasy <see cref="T:System.Random" /> i zastąpić <see cref="M:System.Random.Sample" /> metoda, dystrybucji dostarczonej przez implementację klasy pochodnej z <see cref="M:System.Random.Sample" /> — metoda nie jest używany w wywołania do klasy podstawowej Implementacja <see cref="M:System.Random.NextBytes(System.Byte[])" /> metody. Zamiast tego uniform dystrybucji zwrócony przez podstawowym <see cref="T:System.Random" /> klasa jest używana. To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy. Aby zmienić to zachowanie do wywołania <see cref="M:System.Random.Sample" /> metody w klasie pochodnej, konieczne jest również przesłonięcie <see cref="M:System.Random.NextBytes(System.Byte[])" /> metody.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca zmiennoprzecinkowe liczba jest większa niż lub równa 0,0 i mniejszą niż 1,0.</summary>
        <returns>Podwójnej precyzji liczba zmiennoprzecinkowa, która jest większa niż lub równa 0,0 i mniejszą niż 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Górna granica rzeczywista liczba zwracanych przez tę metodę jest 0.99999999999999978.  
  
 Aby pobrać losowych wartości zmiennoprzecinkowych w zakresie innym niż 0,0 do 1,0, zobacz sekcję "Pobrać wartości zmiennoprzecinkowych w określonym zakresie" <xref:System.Random> klasy tematu.  
  
 Ta metoda jest publicznej wersji Metoda chroniona <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Random.NextDouble%2A> do generowania sekwencji symulacyjnych losowych.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 Następujące wywołania przykład <xref:System.Random.NextDouble%2A> do generowania losowego 100 numery i wyświetlenie ich rozkład częstotliwości.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca liczbę losową zmiennoprzecinkowe z przedziału od 0,0 do 1,0.</summary>
        <returns>Podwójnej precyzji liczba zmiennoprzecinkowa, która jest większa niż lub równa 0,0 i mniejszą niż 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do tworzenia różnych dystrybucji losowych lub różnych losowych liczb generator regułę, klasa wyprowadzona z <xref:System.Random> klasy i zastąpić <xref:System.Random.Sample%2A> metody.  
  
> [!IMPORTANT]
>  <xref:System.Random.Sample%2A> Jest metoda `protected`, co oznacza, że jest dostępny tylko w obrębie <xref:System.Random> klasy i jej klas pochodnych. Do generowania losowego liczbą z zakresu od 0 i 1 z <xref:System.Random> wystąpienia, należy wywołać <xref:System.Random.NextDouble%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład pochodzi z klasy <xref:System.Random> i zastępuje <xref:System.Random.Sample%2A> metody do wygenerowania dystrybucji liczb losowych. Tej dystrybucji jest inny niż uniform dystrybucji wygenerowanych przez <xref:System.Random.Sample%2A> metody klasy podstawowej.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W programie .NET Framework w wersji 2.0, jeśli pochodzi z klasy <see cref="T:System.Random" /> i zastąpić <see cref="M:System.Random.Sample" /> metoda, dystrybucji dostarczonej przez implementację klasy pochodnej z <see cref="M:System.Random.Sample" /> — metoda nie jest używany w wywołania do klasy podstawowej wdrożenia z następujących metod: - <see cref="M:System.Random.NextBytes(System.Byte[])" /> metody.  - <see cref="M:System.Random.Next" /> Metody.  - <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> Metody, jeśli (<paramref name="maxValue" /> - <paramref name="minValue" />) jest większa niż <see cref="F:System.Int32.MaxValue" />.  Zamiast tego uniform dystrybucji dostarczone przez podstawowym <see cref="T:System.Random" /> klasa jest używana. To zachowanie zwiększa ogólną wydajność <see cref="T:System.Random" /> klasy. Aby zmodyfikować to działanie do wykonania wywołania <see cref="M:System.Random.Sample" /> metody w klasie pochodnej, musi także zastępować zachowanie tych trzech elementów członkowskich. W przykładzie przedstawiono ilustracji.</para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>
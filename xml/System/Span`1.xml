<Type Name="Span&lt;T&gt;" FullName="System.Span&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1d68d00b7cc0df1fcf352bc3e0d2ce77c7595e52" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69405023" /></Metadata><TypeSignature Language="C#" Value="public struct Span&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Span`1&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Span`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Span(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public value class Span" />
  <TypeSignature Language="F#" Value="type Span&lt;'T&gt; = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T"><span data-ttu-id="47f35-101">Typ elementów w <see cref="System.Span`1" />.</span><span class="sxs-lookup"><span data-stu-id="47f35-101">The type of items in the <see cref="System.Span`1" />.</span></span></typeparam>
    <summary><span data-ttu-id="47f35-102">Udostępnia bezpieczną reprezentację typu i pamięci dla ciągłego regionu dowolnej pamięci.</span><span class="sxs-lookup"><span data-stu-id="47f35-102">Provides a type- and memory-safe representation of a contiguous region of arbitrary memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

<span data-ttu-id="47f35-103">`Span<T>`jest [strukturą ref](~/docs/csharp/language-reference/keywords/ref.md#ref-struct-types) przydzieloną na stosie, a nie na stosie zarządzanym.</span><span class="sxs-lookup"><span data-stu-id="47f35-103">`Span<T>` is a [ref struct](~/docs/csharp/language-reference/keywords/ref.md#ref-struct-types) that is allocated on the stack rather than on the managed heap.</span></span> <span data-ttu-id="47f35-104">Typy struktur ref mają wiele ograniczeń, aby upewnić się, że nie można ich podwyższyć do zarządzanej sterty, w tym, że nie można ich przetworzyć <xref:System.Object>, `dynamic` nie można ich przypisać do zmiennych typu, lub do żadnego typu interfejsu, nie mogą być polami w typ referencyjny i nie mogą być używane między `await` ani `yield` granicami.</span><span class="sxs-lookup"><span data-stu-id="47f35-104">Ref struct types have a number of restrictions to ensure that they cannot be promoted to the managed heap, including that they can't be boxed, they can't be assigned to variables of type <xref:System.Object>, `dynamic` or to any interface type, they can't be fields in a reference type, and they can't be used across `await` and `yield` boundaries.</span></span> <span data-ttu-id="47f35-105">Dodatkowo wywołania do dwóch metod <xref:System.Span%601.Equals(System.Object)> i <xref:System.Span%601.GetHashCode%2A>, throw a <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="47f35-105">In addition, calls to two methods, <xref:System.Span%601.Equals(System.Object)> and <xref:System.Span%601.GetHashCode%2A>, throw a <xref:System.NotSupportedException>.</span></span> 

> [!IMPORTANT]
> <span data-ttu-id="47f35-106">Ponieważ jest to typ tylko stosu, `Span<T>` jest nieodpowiedni dla wielu scenariuszy, które wymagają zapisywania odwołań do buforów na stercie.</span><span class="sxs-lookup"><span data-stu-id="47f35-106">Because it is a stack-only type, `Span<T>` is unsuitable for many scenarios that require storing references to buffers on the heap.</span></span> <span data-ttu-id="47f35-107">Dotyczy to na przykład procedur, które powodują wywołania metod asynchronicznych.</span><span class="sxs-lookup"><span data-stu-id="47f35-107">This is true, for example, of routines that make asynchronous method calls.</span></span> <span data-ttu-id="47f35-108">W takich scenariuszach można używać uzupełniania <xref:System.Memory%601?displayProperty=nameWithType> i <xref:System.ReadOnlyMemory%601?displayProperty=nameWithType> typów.</span><span class="sxs-lookup"><span data-stu-id="47f35-108">For such scenarios, you can use the complementary <xref:System.Memory%601?displayProperty=nameWithType> and <xref:System.ReadOnlyMemory%601?displayProperty=nameWithType> types.</span></span>

<span data-ttu-id="47f35-109">Dla zakresów, które reprezentują niezmienne lub tylko do odczytu struktury, <xref:System.ReadOnlySpan%601?displayProperty=nameWithType>Użyj.</span><span class="sxs-lookup"><span data-stu-id="47f35-109">For spans that represent immutable or read-only structures, use <xref:System.ReadOnlySpan%601?displayProperty=nameWithType>.</span></span>

## <a name="spant-and-memory"></a><span data-ttu-id="47f35-110">Zakres\<T > i pamięć</span><span class="sxs-lookup"><span data-stu-id="47f35-110">Span\<T> and memory</span></span>

<span data-ttu-id="47f35-111">`Span<T>` Reprezentuje ciągły region wolnej pamięci.</span><span class="sxs-lookup"><span data-stu-id="47f35-111">A `Span<T>` represents a contiguous region of arbitrary memory.</span></span> <span data-ttu-id="47f35-112">`Span<T>` Wystąpienie jest często używane do przechowywania elementów tablicy lub fragmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="47f35-112">A `Span<T>` instance is often used to hold the elements of an array or a portion of an array.</span></span> <span data-ttu-id="47f35-113">W przeciwieństwie do tablicy, `Span<T>` wystąpienie może wskazywać na pamięć zarządzaną, pamięć natywną lub pamięć zarządzaną na stosie.</span><span class="sxs-lookup"><span data-stu-id="47f35-113">Unlike an array, however, a `Span<T>` instance can point to managed memory, native memory, or memory managed on the stack.</span></span> <span data-ttu-id="47f35-114">Poniższy przykład tworzy obiekt `Span<Byte>` z tablicy:</span><span class="sxs-lookup"><span data-stu-id="47f35-114">The following example creates a `Span<Byte>` from an array:</span></span>

[!code-csharp[Creating a Span\<Byte> from an array](~/samples/snippets/csharp/api/system/span/program.cs#1)]
     
<span data-ttu-id="47f35-115">Poniższy przykład tworzy `Span<Byte>` z 100 bajtów pamięci natywnej:</span><span class="sxs-lookup"><span data-stu-id="47f35-115">The following example creates a `Span<Byte>` from 100 bytes of native memory:</span></span>

[!code-csharp[Creating a Span\<Byte> from native memory](~/samples/snippets/csharp/api/system/span/program.cs#2)]

<span data-ttu-id="47f35-116">W poniższym przykładzie za pomocą C# słowa kluczowego [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) można przydzielić 100 bajtów pamięci na stosie:</span><span class="sxs-lookup"><span data-stu-id="47f35-116">The following example uses the C# [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) keyword to allocate 100 bytes of memory on the stack:</span></span>

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#3)]

<span data-ttu-id="47f35-117">Ponieważ `Span<T>` jest abstrakcją dla dowolnego bloku pamięci, metody `Span<T>` klasy i metody z `Span<T>` parametrami działają na dowolnym `Span<T>` obiekcie niezależnie od rodzaju pamięci, która jest hermetyzowana.</span><span class="sxs-lookup"><span data-stu-id="47f35-117">Because `Span<T>` is an abstraction over an arbitrary block of memory, methods of the `Span<T>` class and methods with `Span<T>` parameters operate on any `Span<T>` object regardless of the kind of memory it encapsulates.</span></span> <span data-ttu-id="47f35-118">Na przykład każdą z oddzielnych sekcji kodu, które inicjują zakres i obliczania sumy jego elementów, można zmienić na pojedyncze metody inicjacji i obliczeń, jak pokazano w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="47f35-118">For example, each of the separate sections of code that initialize the span and calculate the sum of its elements can be changed into single initialization and calculation methods, as the following example illustrates:</span></span>

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#4)]

## <a name="spant-and-arrays"></a><span data-ttu-id="47f35-119">Zakres\<T > i tablic</span><span class="sxs-lookup"><span data-stu-id="47f35-119">Span\<T> and arrays</span></span>

<span data-ttu-id="47f35-120">Gdy otacza tablicę, `Span<T>` może zawijać całą tablicę, tak jak w przykładach w sekcji [span\<T > i pamięć](#spant-and-memory) .</span><span class="sxs-lookup"><span data-stu-id="47f35-120">When it wraps an array, `Span<T>` can wrap an entire array, as it did in the examples in the [Span\<T> and memory](#spant-and-memory) section.</span></span> <span data-ttu-id="47f35-121">Ponieważ obsługuje ona dzielenie, `Span<T>` może także wskazywać dowolny zakres ciągły w tablicy.</span><span class="sxs-lookup"><span data-stu-id="47f35-121">Because it supports slicing, `Span<T>` can also point to any contiguous range within the array.</span></span>  

<span data-ttu-id="47f35-122">Poniższy przykład powoduje utworzenie wycinka 5 elementów w pionie 10-elementowej tablicy całkowitej.</span><span class="sxs-lookup"><span data-stu-id="47f35-122">The following example creates a slice of the middle five elements of a 10-element integer array.</span></span> <span data-ttu-id="47f35-123">Należy zauważyć, że kod podwaja wartości każdej liczby całkowitej w wycinku.</span><span class="sxs-lookup"><span data-stu-id="47f35-123">Note that the code doubles the values of each integer in the slice.</span></span> <span data-ttu-id="47f35-124">W miarę wyświetlania danych wyjściowych zmiany wprowadzone przez zakres są uwzględniane w wartościach tablicy.</span><span class="sxs-lookup"><span data-stu-id="47f35-124">As the output shows, the changes made by the span are reflected in the values of the array.</span></span>

[!code-csharp[Creating a slice from a portion of a span](~/samples/snippets/csharp/api/system/span/slice/program.cs)]

## <a name="spant-and-slices"></a><span data-ttu-id="47f35-125">Zakres\<T > i wycinków</span><span class="sxs-lookup"><span data-stu-id="47f35-125">Span\<T> and slices</span></span>

<span data-ttu-id="47f35-126">`Span<T>`obejmuje dwa przeciążenia <xref:System.Span%601.Slice%2A> metody, które tworzą wycink z bieżącego zakresu, który zaczyna się od określonego indeksu.</span><span class="sxs-lookup"><span data-stu-id="47f35-126">`Span<T>` includes two overloads of the <xref:System.Span%601.Slice%2A> method that form a slice out of the current span that starts at a specified index.</span></span> <span data-ttu-id="47f35-127">Umożliwia to traktowanie danych w `Span<T>` postaci jako zestawu fragmentów logicznych, które mogą być przetwarzane w razie potrzeby przez fragmenty potoku przetwarzania danych z minimalnym wpływem na wydajność.</span><span class="sxs-lookup"><span data-stu-id="47f35-127">This makes it possible to treat the data in a `Span<T>` as a set of logical chunks that can be processed as needed by portions of a data processing pipeline with minimal performance impact.</span></span> <span data-ttu-id="47f35-128">Na przykład, ponieważ nowoczesne protokoły serwera często są oparte na tekście, manipulowanie ciągami i podciągami jest szczególnie ważne.</span><span class="sxs-lookup"><span data-stu-id="47f35-128">For example, since modern server protocols are often text-based, manipulation of strings and substrings is particularly important.</span></span> <span data-ttu-id="47f35-129">W klasie główna Metoda wyodrębniania podciągów ma <xref:System.String.Substring%2A>wartość. <xref:System.String></span><span class="sxs-lookup"><span data-stu-id="47f35-129">In the <xref:System.String> class, the major method for extracting substrings is <xref:System.String.Substring%2A>.</span></span> <span data-ttu-id="47f35-130">W przypadku potoków danych, które opierają się na rozdzielnym manipulowaniu ciągami, jego użycie zapewnia pewne kary wydajnościowe, ponieważ:</span><span class="sxs-lookup"><span data-stu-id="47f35-130">For data pipelines that rely on extensive string manipulation, its use offers some performance penalties, since it:</span></span>

1. <span data-ttu-id="47f35-131">Tworzy nowy ciąg do przechowywania podciągu.</span><span class="sxs-lookup"><span data-stu-id="47f35-131">Creates a new string to hold the substring.</span></span>

2. <span data-ttu-id="47f35-132">Kopiuje podzestaw znaków z oryginalnego ciągu do nowego ciągu.</span><span class="sxs-lookup"><span data-stu-id="47f35-132">Copies a subset of the characters from the original string to the new string.</span></span>

<span data-ttu-id="47f35-133">Tę operację alokacji i kopiowania można wyeliminować przy użyciu jednego `Span<T>` lub <xref:System.ReadOnlySpan%601>, jak pokazano na poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="47f35-133">This allocation and copy operation can be eliminated by using either `Span<T>` or <xref:System.ReadOnlySpan%601>, as the following example shows:</span></span>

[!code-csharp[Creating a slice from a substring](~/samples/snippets/csharp/api/system/span/slice2/program.cs)]


      ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; array" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="47f35-134">Tablica, z której ma zostać utworzony <see cref="T:System.Span`1" /> obiekt.</span><span class="sxs-lookup"><span data-stu-id="47f35-134">The array from which to create the <see cref="T:System.Span`1" /> object.</span></span></param>
        <summary><span data-ttu-id="47f35-135">Tworzy nowy <see cref="T:System.Span`1" /> obiekt w całości dla określonej tablicy.</span><span class="sxs-lookup"><span data-stu-id="47f35-135">Creates a new <see cref="T:System.Span`1" /> object over the entirety of a specified array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="47f35-136">Jeśli `array` jest `null` ,`null`ten Konstruktor`Span<T>`zwraca.</span><span class="sxs-lookup"><span data-stu-id="47f35-136">If `array` is `null`, this constructor returns a `null` `Span<T>`.</span></span>

      ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="47f35-137"><paramref name="T" />jest typem referencyjnym i <paramref name="array" /> nie jest tablicą typu. <paramref name="T" /></span><span class="sxs-lookup"><span data-stu-id="47f35-137"><paramref name="T" /> is a reference type, and <paramref name="array" /> is not an array of type <paramref name="T" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (void* pointer, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* pointer, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(System.Void*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(void* pointer, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : nativeptr&lt;unit&gt; * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (pointer, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Void*" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="47f35-138">Wskaźnik na adres początkowy określonej liczby <typeparamref name="T" /> elementów w pamięci.</span><span class="sxs-lookup"><span data-stu-id="47f35-138">A pointer to the starting address of a specified number of <typeparamref name="T" /> elements in memory.</span></span></param>
        <param name="length"><span data-ttu-id="47f35-139">Liczba <typeparamref name="T" /> elementów, które mają być zawarte <see cref="T:System.Span`1" />w.</span><span class="sxs-lookup"><span data-stu-id="47f35-139">The number of <typeparamref name="T" /> elements to be included in the <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="47f35-140">Tworzy nowy <see cref="T:System.Span`1" /> obiekt z określonej <typeparamref name="T" /> liczby elementów, rozpoczynając od określonego adresu pamięci.</span><span class="sxs-lookup"><span data-stu-id="47f35-140">Creates a new <see cref="T:System.Span`1" /> object  from a specified number of <typeparamref name="T" /> elements starting at a specified memory address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

        This constructor should be used with care, since it creates arbitrarily typed `T`s from a `void*`-typed block of memory, and `length` is not checked. However, if the constructor succeeds in creating a new <xref:System.Span%601> object, all subsequent uses are correct.        

      ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="47f35-141"><paramref name="T" />jest typem referencyjnym lub zawiera wskaźniki i dlatego nie można go przechowywać w pamięci niezarządzanej.</span><span class="sxs-lookup"><span data-stu-id="47f35-141"><paramref name="T" /> is a reference type or contains pointers and therefore cannot be stored in unmanaged memory.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="47f35-142"><paramref name="length" />jest wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="47f35-142"><paramref name="length" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] * int * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (array, start, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="47f35-143">Tablica źródłowa.</span><span class="sxs-lookup"><span data-stu-id="47f35-143">The source array.</span></span></param>
        <param name="start"><span data-ttu-id="47f35-144">Indeks pierwszego elementu do uwzględnienia w nowym <see cref="T:System.Span`1" />.</span><span class="sxs-lookup"><span data-stu-id="47f35-144">The index of the first element to include in the new <see cref="T:System.Span`1" />.</span></span></param>
        <param name="length"><span data-ttu-id="47f35-145">Liczba elementów do uwzględnienia w nowym <see cref="T:System.Span`1" />.</span><span class="sxs-lookup"><span data-stu-id="47f35-145">The number of elements to include in the new <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="47f35-146">Tworzy nowy <see cref="T:System.Span`1" /> obiekt, który zawiera określoną liczbę elementów tablicy, rozpoczynając od określonego indeksu.</span><span class="sxs-lookup"><span data-stu-id="47f35-146">Creates a new <see cref="T:System.Span`1" /> object that includes a specified number of elements of an array starting at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

### Remarks

<span data-ttu-id="47f35-147">Ta metoda zwraca `default` Kiedy `array` is `null`.</span><span class="sxs-lookup"><span data-stu-id="47f35-147">This method returns `default` when `array` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="47f35-148"><paramref name="array" />is <see langword="null" />, ale <paramref name="start" /> lub <paramref name="length" /> jest różna od zera.</span><span class="sxs-lookup"><span data-stu-id="47f35-148"><paramref name="array" /> is <see langword="null" />, but <paramref name="start" /> or <paramref name="length" /> is non-zero.</span></span>

<span data-ttu-id="47f35-149">—lub—</span><span class="sxs-lookup"><span data-stu-id="47f35-149">-or-</span></span>

<span data-ttu-id="47f35-150"><paramref name="start" />wykracza poza granice tablicy.</span><span class="sxs-lookup"><span data-stu-id="47f35-150"><paramref name="start" /> is outside the bounds of the array.</span></span>

<span data-ttu-id="47f35-151">—lub—</span><span class="sxs-lookup"><span data-stu-id="47f35-151">-or-</span></span>

<span data-ttu-id="47f35-152"><paramref name="start" />i <paramref name="length" /> przekracza liczbę elementów w tablicy.</span><span class="sxs-lookup"><span data-stu-id="47f35-152"><paramref name="start" /> and <paramref name="length" /> exceeds the number of elements in the array.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="47f35-153"><paramref name="T" />jest typem referencyjnym i <paramref name="array" /> nie jest tablicą typu. <paramref name="T" /></span><span class="sxs-lookup"><span data-stu-id="47f35-153"><paramref name="T" /> is a reference type, and <paramref name="array" /> is not an array of type <paramref name="T" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="span.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="47f35-154">Czyści zawartość tego <see cref="T:System.Span`1" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="47f35-154">Clears the contents of this <see cref="T:System.Span`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="47f35-155">Metoda ustawia elementy <xref:System.Span%601> w obiekcie na ich wartości domyślne. `Clear`</span><span class="sxs-lookup"><span data-stu-id="47f35-155">The `Clear` method sets the items in the <xref:System.Span%601> object to their default values.</span></span> <span data-ttu-id="47f35-156">Nie usuwa elementów z <xref:System.Span%601>.</span><span class="sxs-lookup"><span data-stu-id="47f35-156">It does not remove items from the <xref:System.Span%601>.</span></span>  

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.CopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Span&lt;'T&gt; -&gt; unit" Usage="span.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="47f35-157">Obiekt docelowy <see cref="System.Span`1" /> .</span><span class="sxs-lookup"><span data-stu-id="47f35-157">The destination <see cref="System.Span`1" /> object.</span></span></param>
        <summary><span data-ttu-id="47f35-158">Kopiuje zawartość tego <see cref="System.Span`1" /> elementu do lokalizacji docelowej <see cref="System.Span`1" />.</span><span class="sxs-lookup"><span data-stu-id="47f35-158">Copies the contents of this <see cref="System.Span`1" /> into a destination <see cref="System.Span`1" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="47f35-159">Ta metoda `source` kopiuje wszystkie do nawet wtedy, gdy `destination` `source` i nakładają się `destination` .</span><span class="sxs-lookup"><span data-stu-id="47f35-159">This method copies all of `source` to `destination` even if `source` and `destination` overlap.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="47f35-160"><paramref name="destination" />jest krótszy niż źródło <see cref="System.Span`1" />.</span><span class="sxs-lookup"><span data-stu-id="47f35-160"><paramref name="destination" /> is shorter than the source <see cref="System.Span`1" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Span`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Span&lt;T&gt; Empty { Span&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Empty : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Empty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="47f35-161">Zwraca pusty <see cref="T:System.Span`1" /> obiekt.</span><span class="sxs-lookup"><span data-stu-id="47f35-161">Returns an empty <see cref="T:System.Span`1" /> object.</span></span></summary>
        <value><span data-ttu-id="47f35-162">Pusty <see cref="T:System.Span`1" /> obiekt.</span><span class="sxs-lookup"><span data-stu-id="47f35-162">An empty <see cref="T:System.Span`1" /> object.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="span.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Equals() on Span will always throw an exception. Use == instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="47f35-163">Nieobsługiwane.</span><span class="sxs-lookup"><span data-stu-id="47f35-163">Not supported.</span></span></param>
        <summary><span data-ttu-id="47f35-164">Wywołania tej metody nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="47f35-164">Calls to this method are not supported.</span></span></summary>
        <returns><span data-ttu-id="47f35-165">Wywołania tej metody nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="47f35-165">Calls to this method are not supported.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="47f35-166"><xref:System.Span%601.Equals%2A> Wywołania metody nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="47f35-166">Calls to the <xref:System.Span%601.Equals%2A> method are not supported.</span></span> <span data-ttu-id="47f35-167"><xref:System.Span%601.Equals%2A> Wywołania metod tworzą jeden z dwóch wyników:</span><span class="sxs-lookup"><span data-stu-id="47f35-167">Calls to the <xref:System.Span%601.Equals%2A> methods produce either of two results:</span></span>

- <span data-ttu-id="47f35-168">`obj` Jeśli<xref:System.Span%601>jest, wywołanie metody generuje błąd kompilatora CS1503: "nie można skonwertować z" System. span "na" Object ". Jest to spowodowane <xref:System.Span%601> tym, że jest [strukturą ref](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) , która nie może być opakowana i <xref:System.Object>dlatego nie można jej przekonwertować na obiekt.</span><span class="sxs-lookup"><span data-stu-id="47f35-168">If `obj` is a <xref:System.Span%601>, the method call generates compiler error CS1503: "cannot convert from 'System.Span' to 'object'." This is because <xref:System.Span%601> is a [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) that cannot be boxed and therefore cannot be converted to an <xref:System.Object>.</span></span>

- <span data-ttu-id="47f35-169">Jeśli typ `obj` <xref:System.Span%601>nie jest, wywołanie metody zgłosi. <xref:System.NotSupportedException></span><span class="sxs-lookup"><span data-stu-id="47f35-169">If the type of `obj` is not a <xref:System.Span%601>, the method call throws a <xref:System.NotSupportedException>.</span></span> 

<span data-ttu-id="47f35-170">Aby porównać dwa <xref:System.Span%601> obiekty pod kątem równości, <xref:System.Span%601.op_Equality%2A> Użyj operatora porównania.</span><span class="sxs-lookup"><span data-stu-id="47f35-170">To compare two <xref:System.Span%601> objects for equality, use the <xref:System.Span%601.op_Equality%2A> comparison operator.</span></span>

        ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="47f35-171">Wywołania tej metody nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="47f35-171">Calls to this method are not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public void Fill (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Fill(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Fill(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Fill (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Fill(T value);" />
      <MemberSignature Language="F#" Value="member this.Fill : 'T -&gt; unit" Usage="span.Fill value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="47f35-172">Wartość, która ma zostać przypisana do każdego elementu zakresu.</span><span class="sxs-lookup"><span data-stu-id="47f35-172">The value to assign to each element of the span.</span></span></param>
        <summary><span data-ttu-id="47f35-173">Wypełnia elementy tego zakresu przy użyciu określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="47f35-173">Fills the elements of this span with a specified value.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Span(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; Span&lt;'T&gt;.Enumerator" Usage="span.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="47f35-174">Zwraca moduł wyliczający dla <see cref="T:System.Span`1" />tego elementu.</span><span class="sxs-lookup"><span data-stu-id="47f35-174">Returns an enumerator for this <see cref="T:System.Span`1" />.</span></span></summary>
        <returns><span data-ttu-id="47f35-175">Moduł wyliczający dla tego zakresu.</span><span class="sxs-lookup"><span data-stu-id="47f35-175">An enumerator for this span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="47f35-176">Zamiast bezpośrednio wywołać <xref:System.Span%601.GetEnumerator%2A> metodę, można C# `foreach` użyć instrukcji i Visual Basic `For Each`... konstrukcja umożliwiająca Wyliczenie <xref:System.Span%601>. `Next`</span><span class="sxs-lookup"><span data-stu-id="47f35-176">Instead of calling the <xref:System.Span%601.GetEnumerator%2A> method directly, you can use the C# `foreach` statement and the Visual Basic `For Each`...`Next` construct to enumerate a <xref:System.Span%601>.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="span.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetHashCode() on Span will always throw an exception.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="47f35-177"><see cref="T:System.NotSupportedException" />Zgłasza.</span><span class="sxs-lookup"><span data-stu-id="47f35-177">Throws a <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <returns><span data-ttu-id="47f35-178">Wywołania tej metody zawsze generują <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="47f35-178">Calls to this method always throw a <see cref="T:System.NotSupportedException" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="47f35-179">Wywołania tej metody nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="47f35-179">Calls to this method are not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public T GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T % GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; " Usage="span.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T@</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="47f35-180">Zwraca odwołanie do elementu <see cref="T:System.Span`1" /> o indeksie równym zero.</span><span class="sxs-lookup"><span data-stu-id="47f35-180">Returns a reference to the element of the <see cref="T:System.Span`1" /> at index zero.</span></span></summary>
        <returns><span data-ttu-id="47f35-181">Odwołanie do elementu <see cref="T:System.Span`1" /> o indeksie równym zero lub <see langword="null" /> if <see cref="M:System.Span`1.IsEmpty" /> <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="47f35-181">A reference to the element of the <see cref="T:System.Span`1" /> at index zero, or <see langword="null" /> if <see cref="M:System.Span`1.IsEmpty" /> is  <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="47f35-182">Metoda zwraca [strukturę ref.](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) `GetPinnableReference`</span><span class="sxs-lookup"><span data-stu-id="47f35-182">The `GetPinnableReference` method returns a [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type).</span></span> <span data-ttu-id="47f35-183">Może służyć do przypinania <xref:System.Span%601> w pamięci.</span><span class="sxs-lookup"><span data-stu-id="47f35-183">It can be used for pinning a <xref:System.Span%601> in memory.</span></span> <span data-ttu-id="47f35-184">Jest to wymagane do obsługi użycia a <xref:System.Span%601> wewnątrz [ustalonej](~/docs/csharp/language-reference/keywords/fixed-statement.md) instrukcji.</span><span class="sxs-lookup"><span data-stu-id="47f35-184">It is required to support the use of a <xref:System.Span%601> within a [fixed](~/docs/csharp/language-reference/keywords/fixed-statement.md) statement.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Span&lt;'T&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="47f35-185">Zwraca wartość wskazującą, czy bieżąca <see cref="T:System.Span`1" /> jest pusta.</span><span class="sxs-lookup"><span data-stu-id="47f35-185">Returns a value that indicates whether the current <see cref="T:System.Span`1" /> is empty.</span></span></summary>
        <value><span data-ttu-id="47f35-186"><see langword="true" />Jeśli bieżący zakres jest pusty; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="47f35-186"><see langword="true" /> if the current span is empty; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[Index index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(valuetype System.Index)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Index) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[Index] { T % get(Index index); };" />
      <MemberSignature Language="F#" Value="member this.Item(Index) : " Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[int] { T % get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : " Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="47f35-187">Indeks (liczony od zera) elementu.</span><span class="sxs-lookup"><span data-stu-id="47f35-187">The zero-based index of the element.</span></span></param>
        <summary><span data-ttu-id="47f35-188">Pobiera element w określonym indeksie liczonym od zera.</span><span class="sxs-lookup"><span data-stu-id="47f35-188">Gets the element at the specified zero-based index.</span></span></summary>
        <value><span data-ttu-id="47f35-189">Element pod określonym indeksem.</span><span class="sxs-lookup"><span data-stu-id="47f35-189">The element at the specified index.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="47f35-190"><paramref name="index" />jest mniejsza od zera lub większa lub równa <see cref="P:System.Span`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="47f35-190"><paramref name="index" /> is less than zero or greater than or equal to <see cref="P:System.Span`1.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; this[Range range] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Span`1&lt;!T&gt; Item(valuetype System.Range)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Range)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(range As Range) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Span&lt;T&gt; default[Range] { Span&lt;T&gt; get(Range range); };" />
      <MemberSignature Language="F#" Value="member this.Item(Range) : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Span&lt;'T&gt;.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="47f35-191">Zwraca długość bieżącego zakresu.</span><span class="sxs-lookup"><span data-stu-id="47f35-191">Returns the length of the current span.</span></span></summary>
        <value><span data-ttu-id="47f35-192">Długość bieżącego zakresu.</span><span class="sxs-lookup"><span data-stu-id="47f35-192">The length of the current span.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="47f35-193">Pierwszy zakres do porównania.</span><span class="sxs-lookup"><span data-stu-id="47f35-193">The first span to compare.</span></span></param>
        <param name="right"><span data-ttu-id="47f35-194">Drugi zakres do porównania.</span><span class="sxs-lookup"><span data-stu-id="47f35-194">The second span to compare.</span></span></param>
        <summary><span data-ttu-id="47f35-195">Zwraca wartość wskazującą, czy dwa <see cref="T:System.Span`1" /> obiekty są równe.</span><span class="sxs-lookup"><span data-stu-id="47f35-195">Returns a value that indicates whether two <see cref="T:System.Span`1" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="47f35-196"><see langword="true" />Jeśli dwa <see cref="T:System.Span`1" /> obiekty są równe; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="47f35-196"><see langword="true" /> if the two <see cref="T:System.Span`1" /> objects are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="47f35-197">Dwa <xref:System.Span%601> obiekty są równe, jeśli mają taką samą długość i odpowiadające im `left` elementy i `right` wskazują tę samą pamięć.</span><span class="sxs-lookup"><span data-stu-id="47f35-197">Two <xref:System.Span%601> objects are equal if they have the same length and the corresponding elements of `left` and `right` point to the same memory.</span></span> <span data-ttu-id="47f35-198">Należy zauważyć, że test pod kątem \*\* równości nie próbuje określić, czy zawartość jest równa.</span><span class="sxs-lookup"><span data-stu-id="47f35-198">Note that the test for equality does *not* attempt to determine whether the contents are equal.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; arraySegment) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (arraySegment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; segment) cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.ArraySegment{`0})~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (segment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member op_Implicit : ArraySegment&lt;'T&gt; -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="segment"><span data-ttu-id="47f35-199">Segment tablicy, który ma zostać przekonwertowany <see cref="T:System.Span`1" />na.</span><span class="sxs-lookup"><span data-stu-id="47f35-199">The array segment to be converted to a <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="47f35-200">Definiuje niejawną konwersję <see cref="T:System.ArraySegment`1" /> <see cref="T:System.Span`1" />do.</span><span class="sxs-lookup"><span data-stu-id="47f35-200">Defines an implicit conversion of an <see cref="T:System.ArraySegment`1" /> to a <see cref="T:System.Span`1" />.</span></span></summary>
        <returns><span data-ttu-id="47f35-201">Zakres, który odnosi się do segmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="47f35-201">A span that corresponds to the array segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;T&gt; (Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;!T&gt; op_Implicit(valuetype System.Span`1&lt;!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.Span{`0})~System.ReadOnlySpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (span As Span(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;T&gt;(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : Span&lt;'T&gt; -&gt; ReadOnlySpan&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="47f35-202">Obiekt do przekonwertowania na <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="47f35-202">The object to convert to a <see cref="T:System.ReadOnlySpan`1" />.</span></span></param>
        <summary><span data-ttu-id="47f35-203">Definiuje niejawną konwersję <see cref="T:System.Span`1" /> <see cref="T:System.ReadOnlySpan`1" />do.</span><span class="sxs-lookup"><span data-stu-id="47f35-203">Defines an implicit conversion of a <see cref="T:System.Span`1" /> to a <see cref="T:System.ReadOnlySpan`1" />.</span></span></summary>
        <returns><span data-ttu-id="47f35-204">Zakres tylko do odczytu, który odpowiada bieżącemu wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="47f35-204">A read-only span that corresponds to the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(`0[])~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : 'T[] -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="47f35-205">Tablica do przekonwertowania na <see cref="T:System.Span`1" />.</span><span class="sxs-lookup"><span data-stu-id="47f35-205">The array to convert to a <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="47f35-206">Definiuje niejawną konwersję tablicy na <see cref="T:System.Span`1" />.</span><span class="sxs-lookup"><span data-stu-id="47f35-206">Defines an implicit conversion of an array to a <see cref="T:System.Span`1" />.</span></span></summary>
        <returns><span data-ttu-id="47f35-207">Zakres, który odnosi się <paramref name="array" />do.</span><span class="sxs-lookup"><span data-stu-id="47f35-207">The span that corresponds to <paramref name="array" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="System.Span&lt;'T&gt;.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="47f35-208">Pierwszy zakres do porównania.</span><span class="sxs-lookup"><span data-stu-id="47f35-208">The first span to compare.</span></span></param>
        <param name="right"><span data-ttu-id="47f35-209">Drugi zakres do porównania.</span><span class="sxs-lookup"><span data-stu-id="47f35-209">The second span to compare.</span></span></param>
        <summary><span data-ttu-id="47f35-210">Zwraca wartość wskazującą, czy dwa <see cref="T:System.Span`1" /> obiekty nie są równe.</span><span class="sxs-lookup"><span data-stu-id="47f35-210">Returns a value that indicates whether two <see cref="T:System.Span`1" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="47f35-211"><see langword="true" />Jeśli dwa <see cref="T:System.Span`1" /> obiekty nie są równe; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="47f35-211"><see langword="true" /> if the two <see cref="T:System.Span`1" /> objects are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="47f35-212">Dwa <xref:System.Span%601> obiekty są równe, jeśli mają różne długości lub jeśli odpowiadające im `left` elementy i `right` nie wskazują tej samej pamięci.</span><span class="sxs-lookup"><span data-stu-id="47f35-212">Two <xref:System.Span%601> objects are equal if they have different lengths or if the corresponding elements of `left` and `right` do not point to the same memory.</span></span> 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (startIndex As Index) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(Index startIndex);" />
      <MemberSignature Language="F#" Value="member this.Slice : Index -&gt; Span&lt;'T&gt;" Usage="span.Slice startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start);" />
      <MemberSignature Language="F#" Value="member this.Slice : int -&gt; Span&lt;'T&gt;" Usage="span.Slice start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="47f35-213">Indeks, w którym ma zostać umieszczony plasterek.</span><span class="sxs-lookup"><span data-stu-id="47f35-213">The index at which to begin the slice.</span></span></param>
        <summary><span data-ttu-id="47f35-214">Tworzy wycink poza bieżącym zakresem, który rozpoczyna się od określonego indeksu.</span><span class="sxs-lookup"><span data-stu-id="47f35-214">Forms a slice out of the current span that begins at a specified index.</span></span></summary>
        <returns><span data-ttu-id="47f35-215">Zakres, który składa się z wszystkich elementów bieżącego zakresu od <paramref name="start" /> do końca zakresu.</span><span class="sxs-lookup"><span data-stu-id="47f35-215">A span that consists of all elements of the current span from <paramref name="start" /> to the end of the span.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="47f35-216"><paramref name="start" />jest mniejsza od zera lub większa niż <see cref="T:System.Span`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="47f35-216"><paramref name="start" /> is less than zero or greater than <see cref="T:System.Span`1.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(Range range);" />
      <MemberSignature Language="F#" Value="member this.Slice : Range -&gt; Span&lt;'T&gt;" Usage="span.Slice range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start, int length);" />
      <MemberSignature Language="F#" Value="member this.Slice : int * int -&gt; Span&lt;'T&gt;" Usage="span.Slice (start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="47f35-217">Indeks, w którym ma zostać umieszczony ten plasterek.</span><span class="sxs-lookup"><span data-stu-id="47f35-217">The index at which to begin this slice.</span></span></param>
        <param name="length"><span data-ttu-id="47f35-218">Wymagana długość wycinka.</span><span class="sxs-lookup"><span data-stu-id="47f35-218">The desired length for the slice.</span></span></param>
        <summary><span data-ttu-id="47f35-219">Tworzy wycink poza bieżącym zakresem, rozpoczynając od określonego indeksu przez określoną długość.</span><span class="sxs-lookup"><span data-stu-id="47f35-219">Forms a slice out of the current span starting at a specified index for a specified length.</span></span></summary>
        <returns><span data-ttu-id="47f35-220">Zakres, który składa <paramref name="length" /> się z elementów z bieżącego zakresu, <paramref name="start" />rozpoczynając od.</span><span class="sxs-lookup"><span data-stu-id="47f35-220">A span that consists of <paramref name="length" /> elements from the current span starting at <paramref name="start" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="47f35-221"><paramref name="start" />lub <paramref name="start" /> jestmniejszaod +  zera lub większa niż <see cref="T:System.Span`1.Length" />. <paramref name="length" /></span><span class="sxs-lookup"><span data-stu-id="47f35-221"><paramref name="start" /> or <paramref name="start" /> + <paramref name="length" /> is less than zero or greater than <see cref="T:System.Span`1.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="span.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="47f35-222">Kopiuje zawartość tego zakresu do nowej tablicy.</span><span class="sxs-lookup"><span data-stu-id="47f35-222">Copies the contents of this span into a new array.</span></span></summary>
        <returns><span data-ttu-id="47f35-223">Tablica zawierająca dane z bieżącego zakresu.</span><span class="sxs-lookup"><span data-stu-id="47f35-223">An array containing the data in the current span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="47f35-224">Ta metoda wykonuje alokację sterty i dlatego należy ją unikać, jeśli jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="47f35-224">This method performs a heap allocation and therefore should be avoided if possible.</span></span> <span data-ttu-id="47f35-225">Czasami jest to konieczne, gdy interfejsy API <xref:System.Span%601> obsługujące obiekty są niedostępne, ale interfejsy API, które współpracują z tablicami, to.</span><span class="sxs-lookup"><span data-stu-id="47f35-225">It it sometimes necessary when APIs that support <xref:System.Span%601> objects are not available but APIs that work with arrays are.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="span.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="47f35-226">Zwraca ciąg reprezentujący ten <see cref="T:System.Span`1" /> obiekt.</span><span class="sxs-lookup"><span data-stu-id="47f35-226">Returns the string representation of this <see cref="T:System.Span`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="47f35-227">Ciąg reprezentujący ten <see cref="T:System.Span`1" /> obiekt.</span><span class="sxs-lookup"><span data-stu-id="47f35-227">The string representation of this <see cref="T:System.Span`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="47f35-228">Dla `Span<Char>` <xref:System.String> , metoda zwraca obiekt ,<xref:System.Span%601>który zawiera znaki wskazywane przez. `ToString`</span><span class="sxs-lookup"><span data-stu-id="47f35-228">For a `Span<Char>`, the `ToString` method returns a <xref:System.String> that contains the characters pointed to by the <xref:System.Span%601>.</span></span> <span data-ttu-id="47f35-229">W przeciwnym razie zwraca <xref:System.String> wartość z nazwą typu i liczbą elementów <xref:System.Span%601> , które zawiera.</span><span class="sxs-lookup"><span data-stu-id="47f35-229">Otherwise, it returns a <xref:System.String> with the name of the type and the number of elements that the <xref:System.Span%601> contains.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.TryCopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.TryCopyTo : Span&lt;'T&gt; -&gt; bool" Usage="span.TryCopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="47f35-230">Obiekt docelowy operacji kopiowania.</span><span class="sxs-lookup"><span data-stu-id="47f35-230">The target of the copy operation.</span></span></param>
        <summary><span data-ttu-id="47f35-231">Próbuje skopiować bieżącą <see cref="T:System.Span`1" /> do lokalizacji docelowej <see cref="T:System.Span`1" /> i zwraca wartość wskazującą, czy operacja kopiowania zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="47f35-231">Attempts to copy the current <see cref="T:System.Span`1" /> to a destination <see cref="T:System.Span`1" /> and returns a value that indicates whether the copy operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="47f35-232"><see langword="true" />Jeśli operacja kopiowania zakończyła się pomyślnie; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="47f35-232"><see langword="true" /> if the copy operation succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="47f35-233">Ta metoda `source` kopiuje wszystkie do nawet wtedy, gdy `destination` `source` i nakładają się `destination` .</span><span class="sxs-lookup"><span data-stu-id="47f35-233">This method copies all of `source` to `destination` even if `source` and `destination` overlap.</span></span>

<span data-ttu-id="47f35-234">Jeśli `destination` jest krótszy niż źródło <xref:System.Span%601>, ta metoda zwraca `false`i nie są zapisywane `destination`żadne dane.</span><span class="sxs-lookup"><span data-stu-id="47f35-234">If `destination` is shorter than the source <xref:System.Span%601>, this method returns `false`, and no data is written to `destination`.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

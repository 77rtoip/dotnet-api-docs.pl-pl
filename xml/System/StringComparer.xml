<Type Name="StringComparer" FullName="System.StringComparer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4526a2be99a0d71cadf77bf33e7a741674b5dea4" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31910222" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class StringComparer : System.Collections.Generic.IComparer&lt;string&gt;, System.Collections.Generic.IEqualityComparer&lt;string&gt;, System.Collections.IComparer, System.Collections.IEqualityComparer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit StringComparer extends System.Object implements class System.Collections.Generic.IComparer`1&lt;string&gt;, class System.Collections.Generic.IEqualityComparer`1&lt;string&gt;, class System.Collections.IComparer, class System.Collections.IEqualityComparer" />
  <TypeSignature Language="DocId" Value="T:System.StringComparer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class StringComparer&#xA;Implements IComparer, IComparer(Of String), IEqualityComparer, IEqualityComparer(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringComparer abstract : System::Collections::Generic::IComparer&lt;System::String ^&gt;, System::Collections::Generic::IEqualityComparer&lt;System::String ^&gt;, System::Collections::IComparer, System::Collections::IEqualityComparer" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IComparer&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEqualityComparer&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IComparer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEqualityComparer</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje operacja porównywania ciągów, korzystającym z konkretnego przypadku i reguły kultury lub liczby porządkowej porównania.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt pochodną <xref:System.StringComparer> klasy zawiera ciąg na podstawie porównania równości, operacje i wyznaczania wartości skrótu kodu uwzględniające wielkość oraz specyficzne dla kultury porównanie reguł. Można użyć <xref:System.StringComparer> klasy w celu utworzenia porównanie określonego typu sortowania elementów w zbiorze ogólnym. Klas takich jak <xref:System.Collections.Hashtable>, <xref:System.Collections.Generic.Dictionary%602>, <xref:System.Collections.SortedList>, i <xref:System.Collections.Generic.SortedList%602> użyj <xref:System.StringComparer> klasy na potrzeby sortowania.  
  
 Operacja porównania, która jest reprezentowana przez <xref:System.StringComparer> klasa jest zdefiniowana z uwzględnieniem wielkości liter lub bez uwzględniania wielkości liter, oraz używanie program Microsoft word (zależne od kultury) lub reguł porządkowych porównania (niezależne od kultury). Aby uzyskać więcej informacji na temat programu word i reguł porządkowych porównanie, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
## <a name="implemented-properties"></a>Zaimplementowane właściwości  
 Może być pomylone o sposobie używania <xref:System.StringComparer> właściwościami klasy z powodu seeming sprzeczności. <xref:System.StringComparer> Zadeklarowana jest klasa `abstract` (`MustInherit` w języku Visual Basic), co oznacza jego elementów członkowskich może być wywoływany tylko w obiekcie klasy pochodzącej od <xref:System.StringComparer> klasy. Sprzeczności oznacza, że każda właściwość <xref:System.StringComparer> zadeklarowana jest klasa `static` (`Shared` w języku Visual Basic), co oznacza, że właściwość może być wywołany bez tworzenia klasy pochodnej.  
  
 Możesz wywołać <xref:System.StringComparer> właściwości bezpośrednio, ponieważ każda właściwość faktycznie Zwraca wystąpienie klasy anonimowe, która jest pochodną <xref:System.StringComparer> klasy. W rezultacie jest typ wartości właściwości <xref:System.StringComparer>, który nie jest klasa podstawowa klasy anonimowego typu anonimowego klasy sam. Każdy <xref:System.StringComparer> klasy zwraca <xref:System.StringComparer> obiekt, który obsługuje wstępnie zdefiniowanych reguł wielkość liter i porównania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano właściwości i <xref:System.StringComparer.Create%2A> metody <xref:System.StringComparer> klasy. Pokazano w przykładzie różnych <xref:System.StringComparer> obiektów sortowania trzy wersje Latin litera I.  
  
 [!code-cpp[System.StringComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.StringComparer/cpp/omni.cpp#1)]
 [!code-csharp[System.StringComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer/cs/omni.cs#1)]
 [!code-vb[System.StringComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer/vb/omni.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.String" />
    <altmember cref="T:System.Globalization.CompareOptions" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected StringComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; StringComparer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.StringComparer" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje dwa obiekty lub ciągi i zwraca wskazanie ich kolejność sortowania względną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public int Compare (object x, object y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(object x, object y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.Compare(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compare (x As Object, y As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Compare(System::Object ^ x, System::Object ^ y);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IComparer.Compare(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Object" />
        <Parameter Name="y" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="x">Obiekt do porównania <c>y</c>.</param>
        <param name="y">Obiekt do porównania <c>x</c>.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, porównuje dwa obiekty i zwraca wskazanie ich kolejność sortowania względną.</summary>
        <returns>Całkowita wskazująca wartości <paramref name="x" /> i <paramref name="y" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość  
  
 </term><description> Znaczenie  
  
 </description></listheader><item><term> Mniejsza od zera.  
  
 </term><description><paramref name="x" /> poprzedza <paramref name="y" /> w kolejności sortowania.  
  
 —lub—  
  
 <paramref name="x" /> jest <see langword="null" /> i <paramref name="y" /> nie jest <see langword="null" />.  
  
 </description></item><item><term> Zero  
  
 </term><description><paramref name="x" /> jest równa <paramref name="y" />.  
  
 —lub—  
  
 <paramref name="x" /> i <paramref name="y" /> są <see langword="null" />.  
  
 </description></item><item><term> Większa niż zero  
  
 </term><description><paramref name="x" /> następuje <paramref name="y" /> w kolejności sortowania.  
  
 —lub—  
  
 <paramref name="y" /> jest <see langword="null" /> i <paramref name="x" /> nie jest <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> Jest nieco bardziej wydajna niż metoda <xref:System.StringComparer.Compare%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> metody ponieważ konwersja `x` i `y` argumentów jest potrzebne do porównania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ani <paramref name="x" /> ani <paramref name="y" /> jest <see cref="T:System.String" /> obiektu, a nie <paramref name="x" /> ani <paramref name="y" /> implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public abstract int Compare (string x, string y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(string x, string y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Compare (x As String, y As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int Compare(System::String ^ x, System::String ^ y);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IComparer`1.Compare(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.String" />
        <Parameter Name="y" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="x">Ciąg do porównania <c>y</c>.</param>
        <param name="y">Ciąg do porównania <c>x</c>.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, porównuje dwa ciągi i zwraca wskazanie ich kolejność sortowania względną.</summary>
        <returns>Całkowita wskazująca wartości <paramref name="x" /> i <paramref name="y" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość  
  
 </term><description> Znaczenie  
  
 </description></listheader><item><term> Mniejsza od zera.  
  
 </term><description><paramref name="x" /> poprzedza <paramref name="y" /> w kolejności sortowania.  
  
 —lub—  
  
 <paramref name="x" /> jest <see langword="null" /> i <paramref name="y" /> nie jest <see langword="null" />.  
  
 </description></item><item><term> Zero  
  
 </term><description><paramref name="x" /> jest równa <paramref name="y" />.  
  
 —lub—  
  
 <paramref name="x" /> i <paramref name="y" /> są <see langword="null" />.  
  
 </description></item><item><term> Większa niż zero  
  
 </term><description><paramref name="x" /> następuje <paramref name="y" /> w kolejności sortowania.  
  
 —lub—  
  
 <paramref name="y" /> jest <see langword="null" /> i <paramref name="x" /> nie jest <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> Jest nieco bardziej wydajna niż metoda <xref:System.StringComparer.Compare%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> metody ponieważ konwersja `x` i `y` argumentów jest potrzebne do porównania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static StringComparer Create (System.Globalization.CultureInfo culture, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.StringComparer Create(class System.Globalization.CultureInfo culture, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.Create(System.Globalization.CultureInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (culture As CultureInfo, ignoreCase As Boolean) As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static StringComparer ^ Create(System::Globalization::CultureInfo ^ culture, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">Kultura, których językowe zasady są używane do przeprowadzenia porównania ciągów.</param>
        <param name="ignoreCase">
          <see langword="true" /> Aby określić operacje porównania bez uwzględniania wielkości liter; <see langword="false" /> Aby określić, że porównanie operacje być uwzględniana wielkość liter.</param>
        <summary>Tworzy <see cref="T:System.StringComparer" /> obiekt, który porównuje ciągi zgodnie z regułami określonej kultury.</summary>
        <returns>Nowy <see cref="T:System.StringComparer" /> obiekt, który wykonuje porównania ciągu zgodnie z regułami porównania używane przez <paramref name="culture" /> parametr i wielkość określona przez reguła <paramref name="ignoreCase" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje właściwości i <xref:System.StringComparer.Create%2A> metody <xref:System.StringComparer> klasy. Pokazano w przykładzie różnych <xref:System.StringComparer> obiektów sortowania trzy wersje Latin litera I.  
  
 [!code-cpp[System.StringComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.StringComparer/cpp/omni.cpp#1)]
 [!code-csharp[System.StringComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer/cs/omni.cs#1)]
 [!code-vb[System.StringComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer/vb/omni.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static StringComparer Create (System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.StringComparer Create(class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.Create(System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (culture As CultureInfo, options As CompareOptions) As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static StringComparer ^ Create(System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="culture">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static StringComparer CurrentCulture { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.StringComparer CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.StringComparer.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentCulture As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property StringComparer ^ CurrentCulture { StringComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.StringComparer" /> obiekt, który wykonuje porównanie ciągu z uwzględnieniem wielkości liter, przy użyciu reguł porównania word bieżącej kultury.</summary>
        <value>Nowy <see cref="T:System.StringComparer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer> Zwrócony przez <xref:System.StringComparer.CurrentCulture%2A> właściwość może być używana, gdy zależnej istotnych ciągów. Na przykład jeśli ciągi są wyświetlane dla użytkownika lub jeśli ciągi są wyniku interakcji z użytkownikiem, porównanie ciągu z uwzględnieniem kultury powinien służyć do kolejność danych ciągu.  
  
 Bieżąca kultura jest <xref:System.Globalization.CultureInfo> obiekt skojarzony z bieżącego wątku.  
  
 <xref:System.StringComparer.CurrentCulture%2A> Właściwość faktycznie Zwraca wystąpienie klasy anonimowe pochodzące z <xref:System.StringComparer> klasy.  
  
 Każde wywołanie <xref:System.StringComparer.CurrentCulture%2A> właściwości `get` akcesor zwraca nową <xref:System.StringComparer> obiektu, jak przedstawiono na poniższym kodem.  
  
 [!code-csharp[System.StringComparer.CurrentCulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer.CurrentCulture/cs/CompareObjects.cs#1)]
 [!code-vb[System.StringComparer.CurrentCulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer.CurrentCulture/vb/CompareObjects.vb#1)]  
  
 Aby zwiększyć wydajność, można przechowywać <xref:System.StringComparer> obiekt w zmiennej lokalnej, a nie pobrać wartość <xref:System.StringComparer.CurrentCulture%2A> właściwości wiele razy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje właściwości i <xref:System.StringComparer.Create%2A> metody <xref:System.StringComparer> klasy. Pokazano w przykładzie różnych <xref:System.StringComparer> obiektów sortowania trzy wersje Latin litera I.  
  
 [!code-cpp[System.StringComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.StringComparer/cpp/omni.cpp#1)]
 [!code-csharp[System.StringComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer/cs/omni.cs#1)]
 [!code-vb[System.StringComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer/vb/omni.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentCultureIgnoreCase">
      <MemberSignature Language="C#" Value="public static StringComparer CurrentCultureIgnoreCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.StringComparer CurrentCultureIgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.StringComparer.CurrentCultureIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentCultureIgnoreCase As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property StringComparer ^ CurrentCultureIgnoreCase { StringComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.StringComparer" /> obiekt, który wykonuje porównania bez uwzględniania wielkości liter ciągu przy użyciu reguł porównania word bieżącej kultury.</summary>
        <value>Nowy <see cref="T:System.StringComparer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżąca kultura jest <xref:System.Globalization.CultureInfo> obiekt skojarzony z bieżącego wątku.  
  
 <xref:System.StringComparer> Zwrócony przez <xref:System.StringComparer.CurrentCultureIgnoreCase%2A> podczas zależnej istotnych ciągów, ale ich przypadku nie można użyć właściwości. Na przykład jeśli ciągi są wyświetlane dla użytkownika, ale wielkość liter jest bez znaczenia, zależne od kultury, porównania bez uwzględniania wielkości liter ciąg powinien służyć do kolejność danych ciągu.  
  
 <xref:System.StringComparer.CurrentCultureIgnoreCase%2A> Właściwość faktycznie Zwraca wystąpienie klasy anonimowe pochodzące z <xref:System.StringComparer> klasy.  
  
 Każde wywołanie <xref:System.StringComparer.CurrentCultureIgnoreCase%2A> właściwości `get` akcesor zwraca nową <xref:System.StringComparer> obiektu, jak przedstawiono na poniższym kodem.  
  
 [!code-csharp[System.StringComparer.CurrentCulture#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer.CurrentCulture/cs/CompareObjects.cs#2)]
 [!code-vb[System.StringComparer.CurrentCulture#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer.CurrentCulture/vb/CompareObjects.vb#2)]  
  
 Aby zwiększyć wydajność, można przechowywać <xref:System.StringComparer> obiekt w zmiennej lokalnej, a nie pobrać wartość <xref:System.StringComparer.CurrentCultureIgnoreCase%2A> właściwości wiele razy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wskazuje, czy dwa obiekty lub ciągi są takie same.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (object x, object y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object x, object y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (x As Object, y As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ x, System::Object ^ y);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEqualityComparer.Equals(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Object" />
        <Parameter Name="y" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="x">Obiekt do porównania <c>y</c>.</param>
        <param name="y">Obiekt do porównania <c>x</c>.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wskazuje, czy dwa obiekty są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="x" /> i <paramref name="y" /> odwoływać się do tego samego obiektu lub <paramref name="x" /> i <paramref name="y" /> są obie tego samego typu obiektu i te obiekty są takie same, lub obie <paramref name="x" /> i <paramref name="y" /> są <see langword="null" />; w przeciwnym razie <see langword="false" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ środowisko uruchomieniowe nie trzeba unbox — `x` lub `y` typów wartości lub spróbować do przypisanie elementu podrzędnego `x` lub `y` do ciągów, jeśli są one typy referencyjne <xref:System.StringComparer.Equals%28System.String%2CSystem.String%29> metoda może być nieco bardziej efektywne niż <xref:System.StringComparer.Equals%28System.Object%2CSystem.Object%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public abstract bool Equals (string x, string y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string x, string y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Equals (x As String, y As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Equals(System::String ^ x, System::String ^ y);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.String" />
        <Parameter Name="y" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="x">Ciąg do porównania <c>y</c>.</param>
        <param name="y">Ciąg do porównania <c>x</c>.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wskazuje, czy dwa ciągi są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="x" /> i <paramref name="y" /> odwoływać się do tego samego obiektu lub <paramref name="x" /> i <paramref name="y" /> są takie same, lub <paramref name="x" /> i <paramref name="y" /> są <see langword="null" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ środowisko uruchomieniowe nie trzeba unbox — `x` lub `y` typów wartości lub spróbować do przypisanie elementu podrzędnego `x` lub `y` do ciągów, jeśli są one typy referencyjne <xref:System.StringComparer.Equals%28System.String%2CSystem.String%29> metoda może być nieco bardziej efektywne niż <xref:System.StringComparer.Equals%28System.Object%2CSystem.Object%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromComparison">
      <MemberSignature Language="C#" Value="public static StringComparer FromComparison (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.StringComparer FromComparison(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.FromComparison(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromComparison (comparisonType As StringComparison) As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static StringComparer ^ FromComparison(StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetHashCode">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość skrótu dla bieżącego <see cref="T:System.StringComparer" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.GetHashCode(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEqualityComparer.GetHashCode(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość skrótu dla określonego obiektu.</summary>
        <returns>32-bitowej podpisanej skrótu obliczana na podstawie wartości <paramref name="obj" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer.GetHashCode%28System.String%29> Jest bardziej wydajna niż metoda <xref:System.StringComparer.GetHashCode%2A> metody ponieważ `obj` parametru nie musi być rozpakowany do wykonania tej operacji.  
  
 <xref:System.StringComparer.GetHashCode%28System.Object%29> Metody przydziela ilość pamięci, która jest proporcjonalny do rozmiaru `obj` do obliczania skrótu `obj`. W przypadku dużych ciągów próby pobrania skrótu może zgłosić <xref:System.ArgumentException>. Zamiast tego można użyć alternatywnego algorytmu, który przydziela stałej ilości pamięci podczas obliczania skrótu. Aby używać tego algorytmu, Dodaj [< netfx45_cultureawarecomparergethashcode_longstrings — >](~/docs/framework/configure-apps/file-schema/runtime/netfx45-cultureawarecomparergethashcode-longstrings-element.md) elementu [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sekcji pliku konfiguracji aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Dostępne do alokacji buforu, który jest wymagany do Oblicz wartość skrótu jest za mało pamięci.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> jest <see langword="null" />.</exception>
        <exception cref="  &#xA;            T:System.ArgumentException">Dostępne do alokacji buforu, który jest wymagany do Oblicz wartość skrótu jest za mało pamięci.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public abstract int GetHashCode (string obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode(string obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.GetHashCode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetHashCode (obj As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetHashCode(System::String ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Ciąg.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość skrótu dla określonego ciągu.</summary>
        <returns>32-bitowej podpisanej skrótu obliczana na podstawie wartości <paramref name="obj" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer.GetHashCode%28System.String%29> Jest bardziej wydajna niż metoda <xref:System.StringComparer.GetHashCode%28System.Object%29> metody ponieważ `obj` parametru nie musi być rozpakowany do wykonania tej operacji.  
  
 <xref:System.StringComparer.GetHashCode%28System.String%29> Metody przydziela ilość pamięci, która jest proporcjonalny do rozmiaru `obj` do obliczania skrótu `obj`. W przypadku dużych ciągów próby pobrania skrótu może zgłosić <xref:System.ArgumentException>. Zamiast tego można użyć alternatywnego algorytmu, który przydziela stałej ilości pamięci podczas obliczania skrótu. Aby używać tego algorytmu, Dodaj [< netfx45_cultureawarecomparergethashcode_longstrings — >](~/docs/framework/configure-apps/file-schema/runtime/netfx45-cultureawarecomparergethashcode-longstrings-element.md) elementu [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sekcji pliku konfiguracji aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Dostępne do alokacji buforu, który jest wymagany do Oblicz wartość skrótu jest za mało pamięci.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> jest <see langword="null" />.</exception>
        <exception cref="  &#xA;            T:System.ArgumentException">Dostępne do alokacji buforu, który jest wymagany do Oblicz wartość skrótu jest za mało pamięci.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvariantCulture">
      <MemberSignature Language="C#" Value="public static StringComparer InvariantCulture { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.StringComparer InvariantCulture" />
      <MemberSignature Language="DocId" Value="P:System.StringComparer.InvariantCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InvariantCulture As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property StringComparer ^ InvariantCulture { StringComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.StringComparer" /> obiekt, który przeprowadza porównanie ciągu z uwzględnieniem wielkości liter przy użyciu reguł porównania word Niezmienna kultura.</summary>
        <value>Nowy <see cref="T:System.StringComparer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer> Zwrócony przez <xref:System.StringComparer.InvariantCulture%2A> właściwości porównuje ciągi w sposób zależnej istotne, ale nie nadaje się do wyświetlenia w dowolnej określonej kultury. Jego najważniejszych aplikacji jest kolejności ciągów w taki sposób, który musi być taka sama we kultur.  
  
 Niezmienna kultura jest <xref:System.Globalization.CultureInfo> obiektu zwróconego przez <xref:System.Globalization.CultureInfo.InvariantCulture%2A> właściwości.  
  
 <xref:System.StringComparer.InvariantCulture%2A> Właściwość faktycznie Zwraca wystąpienie klasy anonimowe pochodzące z <xref:System.StringComparer> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje właściwości i <xref:System.StringComparer.Create%2A> metody <xref:System.StringComparer> klasy. Pokazano w przykładzie różnych <xref:System.StringComparer> obiektów sortowania trzy wersje Latin litera I.  
  
 [!code-cpp[System.StringComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.StringComparer/cpp/omni.cpp#1)]
 [!code-csharp[System.StringComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer/cs/omni.cs#1)]
 [!code-vb[System.StringComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer/vb/omni.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvariantCultureIgnoreCase">
      <MemberSignature Language="C#" Value="public static StringComparer InvariantCultureIgnoreCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.StringComparer InvariantCultureIgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.StringComparer.InvariantCultureIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InvariantCultureIgnoreCase As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property StringComparer ^ InvariantCultureIgnoreCase { StringComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.StringComparer" /> obiekt, który wykonuje porównania bez uwzględniania wielkości liter ciągów za pomocą zasad porównania word Niezmienna kultura.</summary>
        <value>Nowy <see cref="T:System.StringComparer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer> Zwrócony przez <xref:System.StringComparer.InvariantCultureIgnoreCase%2A> właściwości porównuje ciągi w sposób zależnej odpowiednich ignoruje wielkość liter, ale nie nadaje się do wyświetlenia w dowolnej określonej kultury. Jego najważniejszych aplikacji jest kolejności ciągów w taki sposób, który musi być taka sama we kultur.  
  
 Niezmienna kultura jest <xref:System.Globalization.CultureInfo> obiektu zwróconego przez <xref:System.Globalization.CultureInfo.InvariantCulture%2A> właściwości.  
  
 <xref:System.StringComparer.InvariantCultureIgnoreCase%2A> Właściwość faktycznie Zwraca wystąpienie klasy anonimowe pochodzące z <xref:System.StringComparer> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ordinal">
      <MemberSignature Language="C#" Value="public static StringComparer Ordinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.StringComparer Ordinal" />
      <MemberSignature Language="DocId" Value="P:System.StringComparer.Ordinal" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Ordinal As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property StringComparer ^ Ordinal { StringComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.StringComparer" /> obiekt, który wykonuje porównania ciągów porządkowej z uwzględnieniem wielkości liter.</summary>
        <value>A <see cref="T:System.StringComparer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer> Zwrócony przez <xref:System.StringComparer.Ordinal%2A> właściwości wykonuje porównanie jednobajtowych, która jest niezależna od języka. Jest to najbardziej odpowiednia w przypadku, gdy porównywanie ciągów, które są generowane programistycznie lub gdy porównanie z uwzględnieniem wielkości liter zasoby, takie jak hasła.  
  
 <xref:System.StringComparer.Ordinal%2A> Właściwość faktycznie Zwraca wystąpienie klasy anonimowe pochodzące z <xref:System.StringComparer> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje właściwości i <xref:System.StringComparer.Create%2A> metody <xref:System.StringComparer> klasy. Pokazano w przykładzie różnych <xref:System.StringComparer> obiektów sortowania trzy wersje Latin litera I.  
  
 [!code-cpp[System.StringComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.StringComparer/cpp/omni.cpp#1)]
 [!code-csharp[System.StringComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer/cs/omni.cs#1)]
 [!code-vb[System.StringComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer/vb/omni.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrdinalIgnoreCase">
      <MemberSignature Language="C#" Value="public static StringComparer OrdinalIgnoreCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.StringComparer OrdinalIgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.StringComparer.OrdinalIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OrdinalIgnoreCase As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property StringComparer ^ OrdinalIgnoreCase { StringComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.StringComparer" /> obiektu, który wykonuje porównania ciągów porządkowych bez uwzględniania wielkości liter.</summary>
        <value>A <see cref="T:System.StringComparer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer> Zwrócony przez <xref:System.StringComparer.OrdinalIgnoreCase%2A> właściwości traktuje znaków w ciągach do porównania tak, jakby były one przekonwertowane na wielkie litery przy użyciu konwencji Niezmienna kultura, a następnie wykonuje porównania jednobajtowych, która jest niezależna od język. Jest to najbardziej odpowiednia w przypadku, gdy porównywanie ciągów, które są generowane programistycznie lub gdy porównywanie bez uwzględniania wielkości liter zasobów, takich jak ścieżki i nazwy plików.  
  
 <xref:System.StringComparer.OrdinalIgnoreCase%2A> Właściwość faktycznie Zwraca wystąpienie klasy anonimowe pochodzące z <xref:System.StringComparer> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje właściwości i <xref:System.StringComparer.Create%2A> metody <xref:System.StringComparer> klasy. Pokazano w przykładzie różnych <xref:System.StringComparer> obiektów sortowania trzy wersje Latin litera I.  
  
 [!code-cpp[System.StringComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.StringComparer/cpp/omni.cpp#1)]
 [!code-csharp[System.StringComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer/cs/omni.cs#1)]
 [!code-vb[System.StringComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer/vb/omni.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IComparer.Compare">
      <MemberSignature Language="C#" Value="int IComparer.Compare (object x, object y);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IComparer.Compare(object x, object y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.System#Collections#IComparer#Compare(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Compare (x As Object, y As Object) As Integer Implements IComparer.Compare" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IComparer.Compare(System::Object ^ x, System::Object ^ y) = System::Collections::IComparer::Compare;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IComparer.Compare(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Object" />
        <Parameter Name="y" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="y">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEqualityComparer.Equals">
      <MemberSignature Language="C#" Value="bool IEqualityComparer.Equals (object x, object y);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IEqualityComparer.Equals(object x, object y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.System#Collections#IEqualityComparer#Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (x As Object, y As Object) As Boolean Implements IEqualityComparer.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IEqualityComparer.Equals(System::Object ^ x, System::Object ^ y) = System::Collections::IEqualityComparer::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEqualityComparer.Equals(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Object" />
        <Parameter Name="y" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="y">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEqualityComparer.GetHashCode">
      <MemberSignature Language="C#" Value="int IEqualityComparer.GetHashCode (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IEqualityComparer.GetHashCode(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.System#Collections#IEqualityComparer#GetHashCode(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (obj As Object) As Integer Implements IEqualityComparer.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IEqualityComparer.GetHashCode(System::Object ^ obj) = System::Collections::IEqualityComparer::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEqualityComparer.GetHashCode(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="StringComparer" FullName="System.StringComparer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e03bea22220ecda1db906ead3089421795b2592c" /><Meta Name="ms.sourcegitcommit" Value="9802d4c6745a8ae514b26f144fb3969265b224ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/22/2018" /><Meta Name="ms.locfileid" Value="53750390" /></Metadata><TypeSignature Language="C#" Value="public abstract class StringComparer : System.Collections.Generic.IComparer&lt;string&gt;, System.Collections.Generic.IEqualityComparer&lt;string&gt;, System.Collections.IComparer, System.Collections.IEqualityComparer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit StringComparer extends System.Object implements class System.Collections.Generic.IComparer`1&lt;string&gt;, class System.Collections.Generic.IEqualityComparer`1&lt;string&gt;, class System.Collections.IComparer, class System.Collections.IEqualityComparer" />
  <TypeSignature Language="DocId" Value="T:System.StringComparer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class StringComparer&#xA;Implements IComparer, IComparer(Of String), IEqualityComparer, IEqualityComparer(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringComparer abstract : System::Collections::Generic::IComparer&lt;System::String ^&gt;, System::Collections::Generic::IEqualityComparer&lt;System::String ^&gt;, System::Collections::IComparer, System::Collections::IEqualityComparer" />
  <TypeSignature Language="F#" Value="type StringComparer = class&#xA;    interface IComparer&#xA;    interface IEqualityComparer&#xA;    interface IComparer&lt;string&gt;&#xA;    interface IEqualityComparer&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IComparer&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEqualityComparer&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IComparer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEqualityComparer</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje operacja porównania ciągu, korzystającą z konkretnego przypadku i reguł porównywania kultury lub liczbą porządkową.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt pochodzi od <xref:System.StringComparer> klasy stanowią porównania oparte na ciągach, równości i mieszania kod operacji, które wziąć pod uwagę zarówno reguł porównywania specyficzne dla kultury i wielkości liter. Możesz użyć <xref:System.StringComparer> klasy w celu utworzenia porównania specyficznych dla typu, aby posortować elementy w kolekcji ogólnych. Klasy, takie jak <xref:System.Collections.Hashtable>, <xref:System.Collections.Generic.Dictionary%602>, <xref:System.Collections.SortedList>, i <xref:System.Collections.Generic.SortedList%602> użyj <xref:System.StringComparer> klasy na potrzeby sortowania.  
  
 Operacja porównania, która jest reprezentowana przez <xref:System.StringComparer> klasa jest zdefiniowana, aby być uwzględniana wielkość liter lub bez uwzględniania wielkości liter, a następnie użyć albo programu word (wrażliwe na ustawienia kulturowe) lub reguł porównanie porządkowe (niewrażliwość na ustawienia kulturowe). Aby uzyskać więcej informacji na temat programu word i reguł porównania porządkowego, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  

> [!NOTE]
> Możesz pobrać [tabele wagi sortowania](https://www.microsoft.com/en-us/download/details.aspx?id=10921), zbiór plików tekstowych, które zawierają informacje o wagi znaku w operacjach sortowania i porównywania dla systemów operacyjnych Windows, a [domyślne Unicode Tabela elementów sortowania](https://www.unicode.org/Public/UCA/latest/allkeys.txt), najnowszą wersję tabeli wagi sortowania dla systemów Linux i macOS. Określoną wersję tabeli wagi sortowania w systemie Linux i macOS jest zależna od wersji [składniki międzynarodowego standardu Unicode](http://site.icu-project.org/) biblioteki zainstalowane w systemie. Informacje na temat ICU wersji i wersje Unicode, które implementują, zobacz [pobieranie ICU](http://site.icu-project.org/download).

## <a name="implemented-properties"></a>Zaimplementowane właściwości  

Może być mylone o sposobie używania <xref:System.StringComparer> właściwościami klasy z powodu seeming sprzeczne. <xref:System.StringComparer> Zadeklarowano klasę `abstract` (`MustInherit` w języku Visual Basic), co oznacza jego elementów członkowskich mogą być wywoływane tylko dla obiektu klasy pochodzącej od <xref:System.StringComparer> klasy. Jest sprzeczność to, że każda właściwość <xref:System.StringComparer> zadeklarowano klasę `static` (`Shared` w języku Visual Basic), co oznacza, że właściwość może być wywołana bez tworzenia klasy pochodnej.  
  
 Możesz wywołać <xref:System.StringComparer> właściwości bezpośrednio, ponieważ każda właściwość faktycznie Zwraca wystąpienie klasy anonimowe, która jest pochodną <xref:System.StringComparer> klasy. W związku z tym, typ wartość każdej właściwości jest <xref:System.StringComparer>, który nie jest klasą bazową klasy anonimowe, typ anonimowy samej klasy. Każdy <xref:System.StringComparer> klasy właściwość zwraca <xref:System.StringComparer> obiekt, który obsługuje wstępnie zdefiniowanych reguł wielkość liter i porównywania.  
  
## Examples  

W poniższym przykładzie pokazano właściwości i <xref:System.StringComparer.Create%2A> metody <xref:System.StringComparer> klasy. W przykładzie pokazano jak różne <xref:System.StringComparer> obiektów sortują trzy wersje Łacińskiej litery I.  
  
 [!code-cpp[System.StringComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.StringComparer/cpp/omni.cpp#1)]
 [!code-csharp[System.StringComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer/cs/omni.cs#1)]
 [!code-vb[System.StringComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer/vb/omni.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.String" />
    <altmember cref="T:System.Globalization.CompareOptions" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected StringComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; StringComparer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.StringComparer" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje dwa obiekty lub ciągów i zwraca wskazanie ich względnych sortowania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public int Compare (object x, object y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(object x, object y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.Compare(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compare (x As Object, y As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Compare(System::Object ^ x, System::Object ^ y);" />
      <MemberSignature Language="F#" Value="abstract member Compare : obj * obj -&gt; int&#xA;override this.Compare : obj * obj -&gt; int" Usage="stringComparer.Compare (x, y)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IComparer.Compare(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Object" />
        <Parameter Name="y" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="x">Obiekt do porównania z <paramref name="y" />.</param>
        <param name="y">Obiekt do porównania z <paramref name="x" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, porównuje dwa obiekty i zwraca wskazanie ich względnych sortowania.</summary>
        <returns>Liczba całkowita wskazująca wartości względne <paramref name="x" /> i <paramref name="y" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Znaczenie 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="x" /> poprzedza <paramref name="y" /> w porządku sortowania.  
  
—lub— 
 <paramref name="x" /> jest <see langword="null" /> i <paramref name="y" /> nie <see langword="null" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="x" /> jest równa <paramref name="y" />.  
  
—lub— 
 <paramref name="x" /> i <paramref name="y" /> są <see langword="null" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="x" /> następuje <paramref name="y" /> w porządku sortowania.  
  
—lub— 
 <paramref name="y" /> jest <see langword="null" /> i <paramref name="x" /> nie <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> Metody jest nieco bardziej efektywne niż <xref:System.StringComparer.Compare%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> metody ponieważ konwersja `x` i `y` argumenty są wymagane do wykonania porównania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ani <paramref name="x" /> ani <paramref name="y" /> jest <see cref="T:System.String" /> obiektu i żadna <paramref name="x" /> ani <paramref name="y" /> implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public abstract int Compare (string x, string y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(string x, string y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Compare (x As String, y As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int Compare(System::String ^ x, System::String ^ y);" />
      <MemberSignature Language="F#" Value="abstract member Compare : string * string -&gt; int" Usage="stringComparer.Compare (x, y)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IComparer`1.Compare(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.String" />
        <Parameter Name="y" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="x">Ciąg do porównania z <paramref name="y" />.</param>
        <param name="y">Ciąg do porównania z <paramref name="x" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, porównuje dwa ciągi i zwraca wskazanie ich względnych sortowania.</summary>
        <returns>Liczba całkowita wskazująca wartości względne <paramref name="x" /> i <paramref name="y" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Znaczenie 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="x" /> poprzedza <paramref name="y" /> w porządku sortowania.  
  
—lub— 
 <paramref name="x" /> jest <see langword="null" /> i <paramref name="y" /> nie <see langword="null" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="x" /> jest równa <paramref name="y" />.  
  
—lub— 
 <paramref name="x" /> i <paramref name="y" /> są <see langword="null" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="x" /> następuje <paramref name="y" /> w porządku sortowania.  
  
—lub— 
 <paramref name="y" /> jest <see langword="null" /> i <paramref name="x" /> nie <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> Metody jest nieco bardziej efektywne niż <xref:System.StringComparer.Compare%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> metody ponieważ konwersja `x` i `y` argumenty są wymagane do wykonania porównania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static StringComparer Create (System.Globalization.CultureInfo culture, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.StringComparer Create(class System.Globalization.CultureInfo culture, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.Create(System.Globalization.CultureInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (culture As CultureInfo, ignoreCase As Boolean) As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static StringComparer ^ Create(System::Globalization::CultureInfo ^ culture, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Create : System.Globalization.CultureInfo * bool -&gt; StringComparer" Usage="System.StringComparer.Create (culture, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">Kultura, w których językowej zasady są używane do wykonywania porównania ciągów.</param>
        <param name="ignoreCase"><see langword="true" /> Aby określić operacji porównania bez uwzględniania wielkości liter; <see langword="false" /> Aby określić, że porównanie operacje być uwzględniana wielkość liter.</param>
        <summary>Tworzy <see cref="T:System.StringComparer" /> obiekt, który porównuje ciągi zgodnie z regułami określonej kultury.</summary>
        <returns>Nowy <see cref="T:System.StringComparer" /> obiekt, który wykonuje porównania ciągów, zgodnie z regułami porównania posługują się <paramref name="culture" /> parametr i reguły wielkości liter, określonej przez <paramref name="ignoreCase" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje właściwości i <xref:System.StringComparer.Create%2A> metody <xref:System.StringComparer> klasy. W przykładzie pokazano jak różne <xref:System.StringComparer> obiektów sortują trzy wersje Łacińskiej litery I.  
  
 [!code-cpp[System.StringComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.StringComparer/cpp/omni.cpp#1)]
 [!code-csharp[System.StringComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer/cs/omni.cs#1)]
 [!code-vb[System.StringComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer/vb/omni.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static StringComparer Create (System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.StringComparer Create(class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.Create(System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (culture As CultureInfo, options As CompareOptions) As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static StringComparer ^ Create(System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Create : System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; StringComparer" Usage="System.StringComparer.Create (culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="culture">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static StringComparer CurrentCulture { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.StringComparer CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.StringComparer.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentCulture As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property StringComparer ^ CurrentCulture { StringComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : StringComparer" Usage="System.StringComparer.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.StringComparer" /> obiekt, który wykonuje porównanie ciągu z uwzględnieniem wielkości liter, za pomocą reguł porównywania word bieżącej kultury.</summary>
        <value>Nowy <see cref="T:System.StringComparer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer> Zwrócone przez <xref:System.StringComparer.CurrentCulture%2A> właściwość może być używana w przypadku ciągów lingwistycznie. Na przykład jeśli ciągi są wyświetlane użytkownikowi lub jeśli ciągi są wynikiem interakcji z użytkownikiem, porównania ciągów zależne od kultury powinny służyć do porządkowania danych ciągu.  
  
 Bieżącą kulturą jest <xref:System.Globalization.CultureInfo> obiekt skojarzony z bieżącym wątkiem.  
  
 <xref:System.StringComparer.CurrentCulture%2A> Właściwość faktycznie Zwraca wystąpienie klasy anonimowe pochodną <xref:System.StringComparer> klasy.  
  
 Każde wywołanie <xref:System.StringComparer.CurrentCulture%2A> właściwość `get` akcesor zwraca nowy <xref:System.StringComparer> obiektu, co ilustruje poniższy kod.  
  
 [!code-csharp[System.StringComparer.CurrentCulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer.CurrentCulture/cs/CompareObjects.cs#1)]
 [!code-vb[System.StringComparer.CurrentCulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer.CurrentCulture/vb/CompareObjects.vb#1)]  
  
 Aby zwiększyć wydajność, można przechowywać <xref:System.StringComparer> obiektu w zmiennej lokalnej, zamiast pobierać wartości <xref:System.StringComparer.CurrentCulture%2A> właściwość wiele razy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje właściwości i <xref:System.StringComparer.Create%2A> metody <xref:System.StringComparer> klasy. W przykładzie pokazano jak różne <xref:System.StringComparer> obiektów sortują trzy wersje Łacińskiej litery I.  
  
 [!code-cpp[System.StringComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.StringComparer/cpp/omni.cpp#1)]
 [!code-csharp[System.StringComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer/cs/omni.cs#1)]
 [!code-vb[System.StringComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer/vb/omni.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/best-practices-strings.md">Najlepsze rozwiązania dotyczące używania ciągów w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentCultureIgnoreCase">
      <MemberSignature Language="C#" Value="public static StringComparer CurrentCultureIgnoreCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.StringComparer CurrentCultureIgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.StringComparer.CurrentCultureIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentCultureIgnoreCase As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property StringComparer ^ CurrentCultureIgnoreCase { StringComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCultureIgnoreCase : StringComparer" Usage="System.StringComparer.CurrentCultureIgnoreCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.StringComparer" /> obiekt, który wykonuje porównania bez uwzględniania wielkości liter ciągu za pomocą reguł porównywania word bieżącej kultury.</summary>
        <value>Nowy obiekt do porównania ciągu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżącą kulturą jest <xref:System.Globalization.CultureInfo> obiekt skojarzony z bieżącym wątkiem; jest zwracany przez <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> właściwości.
  
 <xref:System.StringComparer> Zwrócone przez <xref:System.StringComparer.CurrentCultureIgnoreCase%2A> właściwość może być używana, jeśli ciągi są lingwistycznie, ale nie widać ich przypadku. Na przykład jeśli ciągi są wyświetlane użytkownikowi, ale wielkość liter jest ważne, wrażliwość na ustawienia kulturowe, porównanie bez uwzględniania wielkości liter ciągu powinna służyć do porządkowania danych ciągu.  

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]  

 <xref:System.StringComparer.CurrentCultureIgnoreCase%2A> Właściwość faktycznie Zwraca wystąpienie klasy anonimowe pochodną <xref:System.StringComparer> klasy.  
  
 Każde wywołanie <xref:System.StringComparer.CurrentCultureIgnoreCase%2A> właściwość `get` akcesor zwraca nowy <xref:System.StringComparer> obiektu, co ilustruje poniższy kod.  
  
 [!code-csharp[System.StringComparer.CurrentCulture#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer.CurrentCulture/cs/CompareObjects.cs#2)]
 [!code-vb[System.StringComparer.CurrentCulture#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer.CurrentCulture/vb/CompareObjects.vb#2)]  
  
 Aby zwiększyć wydajność, można przechowywać <xref:System.StringComparer> obiektu w zmiennej lokalnej, zamiast pobierać wartości <xref:System.StringComparer.CurrentCultureIgnoreCase%2A> właściwość wiele razy.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/best-practices-strings.md">Najlepsze rozwiązania dotyczące używania ciągów w programie .NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wskazuje, czy dwa obiekty lub ciągi są równe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (object x, object y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object x, object y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (x As Object, y As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ x, System::Object ^ y);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj * obj -&gt; bool" Usage="stringComparer.Equals (x, y)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEqualityComparer.Equals(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Object" />
        <Parameter Name="y" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="x">Obiekt do porównania z <paramref name="y" />.</param>
        <param name="y">Obiekt do porównania z <paramref name="x" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wskazuje, czy dwa obiekty są takie same.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="x" /> i <paramref name="y" /> odnoszą się do tego samego obiektu lub <paramref name="x" /> i <paramref name="y" /> są tego samego typu obiektu i te obiekty są równe, i / lub <paramref name="x" /> i <paramref name="y" /> są <see langword="null" />; w przeciwnym razie <see langword="false" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ środowisko wykonawcze nie będzie musiał rozpakowania `x` lub `y` jeśli są typami wartości lub spróbować do takiej `x` lub `y` na ciągi, jeśli są typami odwołań, <xref:System.StringComparer.Equals%28System.String%2CSystem.String%29> metoda może być nieco bardziej efektywne niż <xref:System.StringComparer.Equals%28System.Object%2CSystem.Object%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public abstract bool Equals (string x, string y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string x, string y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Equals (x As String, y As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Equals(System::String ^ x, System::String ^ y);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * string -&gt; bool" Usage="stringComparer.Equals (x, y)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.String" />
        <Parameter Name="y" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="x">Ciąg do porównania z <paramref name="y" />.</param>
        <param name="y">Ciąg do porównania z <paramref name="x" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wskazuje, czy dwa ciągi są równe.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="x" /> i <paramref name="y" /> odnoszą się do tego samego obiektu lub <paramref name="x" /> i <paramref name="y" /> są takie same lub <paramref name="x" /> i <paramref name="y" /> są <see langword="null" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ środowisko wykonawcze nie będzie musiał rozpakowania `x` lub `y` jeśli są typami wartości lub spróbować do takiej `x` lub `y` na ciągi, jeśli są typami odwołań, <xref:System.StringComparer.Equals%28System.String%2CSystem.String%29> metoda może być nieco bardziej efektywne niż <xref:System.StringComparer.Equals%28System.Object%2CSystem.Object%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromComparison">
      <MemberSignature Language="C#" Value="public static StringComparer FromComparison (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.StringComparer FromComparison(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.FromComparison(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromComparison (comparisonType As StringComparison) As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static StringComparer ^ FromComparison(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member FromComparison : StringComparison -&gt; StringComparer" Usage="System.StringComparer.FromComparison comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetHashCode">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość skrótu dla bieżącego <see cref="T:System.StringComparer" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.GetHashCode(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : obj -&gt; int" Usage="stringComparer.GetHashCode obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEqualityComparer.GetHashCode(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt.</param>
        <summary>Po przesłonięciu w klasie pochodnej pobiera wartość skrótu dla określonego obiektu.</summary>
        <returns>Kod 32-bitowy skrót podpisanego obliczonym na podstawie wartości <paramref name="obj" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer.GetHashCode%28System.String%29> Metody jest bardziej wydajne niż <xref:System.StringComparer.GetHashCode%2A> metody ponieważ `obj` parametr nie ma być rozpakowany do wykonania tej operacji.  
  
 <xref:System.StringComparer.GetHashCode%28System.Object%29> Metoda przydziela ilość pamięci, który jest proporcjonalny do rozmiaru `obj` do obliczania skrótu `obj`. W przypadku dużych ciągów próby pobrania skrótu może zgłosić <xref:System.ArgumentException>. Zamiast tego można użyć alternatywnego algorytmu, który przydziela stałą ilość pamięci podczas obliczania kodów wartości skrótu. Aby użyć tego algorytmu, Dodaj [< NetFx45_CultureAwareComparerGetHashCode_LongStrings >](~/docs/framework/configure-apps/file-schema/runtime/netfx45-cultureawarecomparergethashcode-longstrings-element.md) elementu [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sekcję pliku konfiguracji aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie ma wystarczającej ilości pamięci jest dostępny, można przydzielić bufora, który jest wymagany do Oblicz wartość skrótu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public abstract int GetHashCode (string obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode(string obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.GetHashCode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetHashCode (obj As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetHashCode(System::String ^ obj);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : string -&gt; int" Usage="stringComparer.GetHashCode obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Ciąg.</param>
        <summary>Po przesłonięciu w klasie pochodnej pobiera wartość skrótu dla określonego ciągu.</summary>
        <returns>Kod 32-bitowy skrót podpisanego obliczonym na podstawie wartości <paramref name="obj" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer.GetHashCode%28System.String%29> Metody jest bardziej wydajne niż <xref:System.StringComparer.GetHashCode%28System.Object%29> metody ponieważ `obj` parametr nie ma być rozpakowany do wykonania tej operacji.  
  
 <xref:System.StringComparer.GetHashCode%28System.String%29> Metoda przydziela ilość pamięci, który jest proporcjonalny do rozmiaru `obj` do obliczania skrótu `obj`. W przypadku dużych ciągów próby pobrania skrótu może zgłosić <xref:System.ArgumentException>. Zamiast tego można użyć alternatywnego algorytmu, który przydziela stałą ilość pamięci podczas obliczania kodów wartości skrótu. Aby użyć tego algorytmu, Dodaj [< NetFx45_CultureAwareComparerGetHashCode_LongStrings >](~/docs/framework/configure-apps/file-schema/runtime/netfx45-cultureawarecomparergethashcode-longstrings-element.md) elementu [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sekcję pliku konfiguracji aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie ma wystarczającej ilości pamięci jest dostępny, można przydzielić bufora, który jest wymagany do Oblicz wartość skrótu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvariantCulture">
      <MemberSignature Language="C#" Value="public static StringComparer InvariantCulture { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.StringComparer InvariantCulture" />
      <MemberSignature Language="DocId" Value="P:System.StringComparer.InvariantCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InvariantCulture As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property StringComparer ^ InvariantCulture { StringComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InvariantCulture : StringComparer" Usage="System.StringComparer.InvariantCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.StringComparer" /> obiekt, który wykonuje porównanie ciągu z uwzględnieniem wielkości liter, za pomocą reguł porównywania word niezmiennej kultury.</summary>
        <value>Nowy <see cref="T:System.StringComparer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer> Zwrócone przez <xref:System.StringComparer.InvariantCulture%2A> właściwość porównuje ciągi w sposób lingwistycznie, ale nie nadaje się do wyświetlenia w żadnej określonej kultury. Jego główne aplikacji jest kolejności ciągów w taki sposób, że będą identyczne różnych kultur.  
  
 Niezmienna kultura jest <xref:System.Globalization.CultureInfo> obiektu zwróconego przez <xref:System.Globalization.CultureInfo.InvariantCulture%2A> właściwości.  
  
 <xref:System.StringComparer.InvariantCulture%2A> Właściwość faktycznie Zwraca wystąpienie klasy anonimowe pochodną <xref:System.StringComparer> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje właściwości i <xref:System.StringComparer.Create%2A> metody <xref:System.StringComparer> klasy. W przykładzie pokazano jak różne <xref:System.StringComparer> obiektów sortują trzy wersje Łacińskiej litery I.  
  
 [!code-cpp[System.StringComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.StringComparer/cpp/omni.cpp#1)]
 [!code-csharp[System.StringComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer/cs/omni.cs#1)]
 [!code-vb[System.StringComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer/vb/omni.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/best-practices-strings.md">Najlepsze rozwiązania dotyczące używania ciągów w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="InvariantCultureIgnoreCase">
      <MemberSignature Language="C#" Value="public static StringComparer InvariantCultureIgnoreCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.StringComparer InvariantCultureIgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.StringComparer.InvariantCultureIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InvariantCultureIgnoreCase As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property StringComparer ^ InvariantCultureIgnoreCase { StringComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InvariantCultureIgnoreCase : StringComparer" Usage="System.StringComparer.InvariantCultureIgnoreCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.StringComparer" /> obiekt, który wykonuje porównania bez uwzględniania wielkości liter ciągu za pomocą reguł porównywania word niezmiennej kultury.</summary>
        <value>Nowy <see cref="T:System.StringComparer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer> Zwrócone przez <xref:System.StringComparer.InvariantCultureIgnoreCase%2A> właściwość porównuje ciągi w sposób lingwistycznie, które ignoruje wielkość liter, ale nie nadaje się do wyświetlenia w żadnej określonej kultury. Jego główne aplikacji jest kolejności ciągów w taki sposób, że będą identyczne różnych kultur.  
  
 Niezmienna kultura jest <xref:System.Globalization.CultureInfo> obiektu zwróconego przez <xref:System.Globalization.CultureInfo.InvariantCulture%2A> właściwości.  
  
 <xref:System.StringComparer.InvariantCultureIgnoreCase%2A> Właściwość faktycznie Zwraca wystąpienie klasy anonimowe pochodną <xref:System.StringComparer> klasy.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/best-practices-strings.md">Najlepsze rozwiązania dotyczące używania ciągów w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Ordinal">
      <MemberSignature Language="C#" Value="public static StringComparer Ordinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.StringComparer Ordinal" />
      <MemberSignature Language="DocId" Value="P:System.StringComparer.Ordinal" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Ordinal As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property StringComparer ^ Ordinal { StringComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Ordinal : StringComparer" Usage="System.StringComparer.Ordinal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.StringComparer" /> obiekt, który wykonuje porównanie ciągach porządkowych uwzględniana wielkość liter.</summary>
        <value>Element <see cref="T:System.StringComparer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer> Zwrócone przez <xref:System.StringComparer.Ordinal%2A> właściwość wykonuje porównanie jednobajtowych, który jest niezależny od języka. Jest to najbardziej odpowiednie w przypadku, gdy porównywanie ciągów, które są generowane, programowo, albo podczas porównywania liter zasoby, takie jak hasła.  
  
 <xref:System.StringComparer.Ordinal%2A> Właściwość faktycznie Zwraca wystąpienie klasy anonimowe pochodną <xref:System.StringComparer> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje właściwości i <xref:System.StringComparer.Create%2A> metody <xref:System.StringComparer> klasy. W przykładzie pokazano jak różne <xref:System.StringComparer> obiektów sortują trzy wersje Łacińskiej litery I.  
  
 [!code-cpp[System.StringComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.StringComparer/cpp/omni.cpp#1)]
 [!code-csharp[System.StringComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer/cs/omni.cs#1)]
 [!code-vb[System.StringComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer/vb/omni.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/best-practices-strings.md">Najlepsze rozwiązania dotyczące używania ciągów w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="OrdinalIgnoreCase">
      <MemberSignature Language="C#" Value="public static StringComparer OrdinalIgnoreCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.StringComparer OrdinalIgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.StringComparer.OrdinalIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OrdinalIgnoreCase As StringComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property StringComparer ^ OrdinalIgnoreCase { StringComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OrdinalIgnoreCase : StringComparer" Usage="System.StringComparer.OrdinalIgnoreCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.StringComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.StringComparer" /> obiekt, który wykonuje porównania bez uwzględniania wielkości liter ciągach porządkowych.</summary>
        <value>Element <see cref="T:System.StringComparer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.StringComparer> Zwrócone przez <xref:System.StringComparer.OrdinalIgnoreCase%2A> właściwość traktuje znaków w ciągach znaków, aby porównać tak, jakby one zostały przekonwertowane na wielkie litery za pomocą Konwencji kultury niezmiennej, a następnie wykonuje porównanie jednobajtowych, który jest niezależny od język. Jest to najbardziej odpowiednie w przypadku, gdy porównywanie ciągów, które są generowane programistycznie lub gdy porównanie bez uwzględniania wielkości liter zasobów, takich jak ścieżki i nazwy plików.  
  
 <xref:System.StringComparer.OrdinalIgnoreCase%2A> Właściwość faktycznie Zwraca wystąpienie klasy anonimowe pochodną <xref:System.StringComparer> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje właściwości i <xref:System.StringComparer.Create%2A> metody <xref:System.StringComparer> klasy. W przykładzie pokazano jak różne <xref:System.StringComparer> obiektów sortują trzy wersje Łacińskiej litery I.  
  
 [!code-cpp[System.StringComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.StringComparer/cpp/omni.cpp#1)]
 [!code-csharp[System.StringComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.StringComparer/cs/omni.cs#1)]
 [!code-vb[System.StringComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.StringComparer/vb/omni.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/best-practices-strings.md">Najlepsze rozwiązania dotyczące używania ciągów w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IComparer.Compare">
      <MemberSignature Language="C#" Value="int IComparer.Compare (object x, object y);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IComparer.Compare(object x, object y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.System#Collections#IComparer#Compare(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Compare (x As Object, y As Object) As Integer Implements IComparer.Compare" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IComparer.Compare(System::Object ^ x, System::Object ^ y) = System::Collections::IComparer::Compare;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IComparer.Compare(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Object" />
        <Parameter Name="y" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="y">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEqualityComparer.Equals">
      <MemberSignature Language="C#" Value="bool IEqualityComparer.Equals (object x, object y);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IEqualityComparer.Equals(object x, object y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.System#Collections#IEqualityComparer#Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (x As Object, y As Object) As Boolean Implements IEqualityComparer.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IEqualityComparer.Equals(System::Object ^ x, System::Object ^ y) = System::Collections::IEqualityComparer::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEqualityComparer.Equals(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Object" />
        <Parameter Name="y" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="x">To be added.</param>
        <param name="y">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEqualityComparer.GetHashCode">
      <MemberSignature Language="C#" Value="int IEqualityComparer.GetHashCode (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IEqualityComparer.GetHashCode(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StringComparer.System#Collections#IEqualityComparer#GetHashCode(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (obj As Object) As Integer Implements IEqualityComparer.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IEqualityComparer.GetHashCode(System::Object ^ obj) = System::Collections::IEqualityComparer::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEqualityComparer.GetHashCode(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Environment" FullName="System.Environment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b8f2716206a0d7c4bbbc8310b3ec10e214e0d3af" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30744482" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera informacje na temat i oznacza, że do manipulowania bieżące środowisko i platforma. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Environment> klasę, aby pobrać informacje, takie jak argumenty wiersza polecenia, kod zakończenia, ustawień zmiennych środowiskowych, zawartość stos wywołań, czas od momentu ostatniego uruchomienia systemu i wersji środowiska CLR.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, zostanie wyświetlona lista informacji o bieżącym środowisku.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wiersza polecenia dla tego procesu.</summary>
        <value>Ciąg zawierający argumenty wiersza polecenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia dostęp do nazwy programu i żadnych argumentów określona w wierszu polecenia, Rozpoczęcie bieżącego procesu.  
  
 Nazwa programu mogą obejmować informacje o ścieżce, ale nie jest wymagane, aby to zrobić. Użyj <xref:System.Environment.GetCommandLineArgs%2A> metodę, aby pobrać informacje wiersza polecenia analizy i przechowywane w tablicy ciągów.  
  
 Maksymalny rozmiar buforu wiersza polecenia nie jest równa określonej liczby znaków. może być różna w zależności od systemu operacyjnego, który jest uruchomiony na komputerze.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono w osobnym wierszu polecenia.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do odczytu do zmiennej środowiskowej PATH. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia w pełni kwalifikowaną ścieżkę bieżącego katalogu roboczego.</summary>
        <value>Ciąg zawierający ścieżkę katalogu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgodnie z definicją, jeśli ten proces, który uruchamia się w katalogu lokalnego lub na dysku sieciowym, wartość tej właściwości jest nazwę stacji, a następnie na końcu ukośnik (na przykład "C:\\"). Jeśli ten proces zostanie uruchomiony w podkatalogu, wartość tej właściwości jest dysk i podkatalogu ścieżki, bez ukośnika (na przykład "C:\mySubDirectory").  
  
   
  
## Examples  
 W poniższym przykładzie pokazano ustawienie <xref:System.Environment.CurrentDirectory%2A> właściwości.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Próbowano ustawić pustego ciągu ("").</exception>
        <exception cref="T:System.ArgumentNullException">Próbowano ustawić <see langword="null." /></exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Próbowano ustawić ścieżkę lokalną, której nie można znaleźć.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma odpowiednich uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla zapisu do plików lub katalogów w ramach operacji set. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji w ścieżce w operacji get. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator bieżącego wątku zarządzanego.</summary>
        <value>Liczba całkowita, która reprezentuje unikatowy identyfikator dla tego wątku zarządzanego.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">Kod zakończenia, aby powrócić do systemu operacyjnego. Użyj 0 (zero), aby wskazać, że proces został pomyślnie zakończony.</param>
        <summary>Przerywa ten proces i zwraca kod zakończenia do systemu operacyjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać `exitCode` parametru numer używany z systemem innym niż zero, wystąpił błąd. W aplikacji można definiować własne kody błędów w wyliczeniu i zwracają kod błędu odpowiednie opartą na tym scenariuszu. Na przykład zwróć wartość 1, aby wskazać, że wymagany plik nie jest obecny, a wartości 2, aby wskazać, że plik jest w niewłaściwym formacie. Aby uzyskać listę kodów zakończenia używanych przez system operacyjny Windows, zobacz [kodów błędów systemu](http://msdn.microsoft.com/library/ms681381.aspx) w dokumentacji systemu Windows.  
  
 Wywoływanie <xref:System.Environment.Exit%2A> metoda różni się od przy użyciu języka programowania `return` instrukcji w następujący sposób:  
  
-   <xref:System.Environment.Exit%2A> zawsze kończy aplikacji. Przy użyciu `return` instrukcji może zakończyć aplikację, tylko jeśli jest on używany w punkcie wejścia aplikacji, takich jak w `Main` metody.  
  
-   <xref:System.Environment.Exit%2A> kończy aplikacji natychmiast, nawet jeśli są uruchomione inne wątki. Jeśli `return` instrukcji jest wywoływana w punkcie wejścia aplikacji, powoduje zamknięcie dopiero po zakończeniu wszystkie wątki pierwszoplanowe aplikacji.  
  
-   <xref:System.Environment.Exit%2A> wymaga od wywołującego ma uprawnienia do wywoływania kodu niezarządzanego. `return` Nie obsługuje instrukcji.  
  
-   Jeśli <xref:System.Environment.Exit%2A> jest wywoływana z `try` lub `catch` bloku kodu w żadnym `finally` nie wykonuje bloku. Jeśli `return` używana jest instrukcja, kod w `finally` bloku wykonania.  
  
-   Jeśli <xref:System.Environment.Exit%2A> jest wywoływane, gdy kod w [region ograniczonego wykonania](~/docs/framework/performance/constrained-execution-regions.md) (CER) jest uruchomiona, CER nie zostanie wykonany. Jeśli `return` używana jest instrukcja, CER zakończeniem wykonywania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wystarczających uprawnień do wykonania tej funkcji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływania niezarządzanego kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kod zakończenia procesu.</summary>
        <value>32-bitowe całkowita zawierająca kod wyjścia. Wartość domyślna to 0 (zero), co oznacza, że proces została ukończona pomyślnie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `Main` metoda zwraca `void`, ta właściwość służy do ustawienia kod zakończenia, który zostanie zwrócony do wywoływania środowiska. Jeśli `Main` nie zwraca `void`, ta właściwość jest ignorowana. Początkowa wartość tej właściwości wynosi zero.  
  
> [!WARNING]
>  <xref:System.Environment.ExitCode%2A> Właściwość jest całkowita 32-bitowa. Aby zapobiec właściwość zwróciło kod zakończenia ujemna, nie należy używać wartości większe niż lub równe 0x80000000.  
  
 Wystąpił błąd, należy użyć liczby inną niż zero. W aplikacji można definiować własne kody błędów w wyliczeniu i zwracają kod błędu odpowiednie opartą na tym scenariuszu. Na przykład zwróć wartość 1, aby wskazać, że wymagany plik nie jest obecny, a wartości 2, aby wskazać, że plik jest w niewłaściwym formacie. Aby uzyskać listę kodów zakończenia używanych przez system operacyjny Windows, zobacz [kodów błędów systemu](http://msdn.microsoft.com/library/ms681381\(v=vs.85\)) w dokumentacji systemu Windows.  
  
   
  
## Examples  
 To jest prosta aplikacja o nazwie Double.exe który podwaja całkowitą przekazanego jako argument wiersza polecenia. Kody błędów, aby przypisuje wartość <xref:System.Environment.ExitCode%2A> Właściwość wskazująca warunki błędów. Należy pamiętać, że musisz dodać odwołanie do zestawu System.Numerics.dll pomyślnie skompilować w przykładzie.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 Przykład następnie mogą być wywoływane z pliku wsadowego, takie jak wymienione poniżej, dzięki czemu jego kody błędów dostępny za pomocą `ERRORLEVEL` polecenia.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 Poniżej przedstawiono niektóre przykładowe dane wyjściowe, generowane przez wywoływanie pliku wsadowego.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Należy zwrócić uwagę kodu Double.exe jest identyczne w funkcji do poniższego przykładu z tą różnicą, że pierwsza definiuje punkt wejścia o nazwie `Main` który nie ma zwracanych wartości, w tym przykładzie określa punkt wejścia o nazwie `Main` który zwróci liczbę całkowitą.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwy zero lub więcej zmiennych środowiskowych. Każdej zmiennej środowiskowej jest ujęty w cudzysłów znakiem znaku procentu (%).</param>
        <summary>Zastępuje nazwę każdej zmiennej środowiskowej osadzone w określony ciąg znaków z ciągu odpowiednikiem wartości zmiennej, zwraca wynikowy ciąg.</summary>
        <returns>Ciąg znaków z każdej zmiennej środowiskowej zastępuje jego wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Współdziałanie z COM jest używane do pobierania do zmiennych środowiskowych systemu operacyjnego. Jeśli zmienne środowiskowe nie można pobrać z powodu błędu COM, HRESULT, opisujący przyczynę niepowodzenia służy do generowania jedną z kilkoma wyjątkami możliwe; oznacza to, że wyjątek zależy od HRESULT. Aby uzyskać więcej informacji o przetwarzaniu HRESULT, zobacz sekcję uwag <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> metody.  
  
 Zastąpienie występuje tylko dla zmiennych środowiskowych, które są ustawione. Załóżmy na przykład, `name` jest "MyENV = % MyENV %". Jeśli zmienna środowiskowa, MyENV, jest ustawiona wartość 42, ta metoda zwraca wartość "MyENV = 42". Jeśli nie ustawiono MyENV, występuje bez zmian; Ta metoda zwraca wartość "MyENV = % MyENV %".  
  
 Rozmiar wartości zwracanej wynosi 32 KB.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób uzyskiwania dysku systemowym i zmienne systemu głównego.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">dla możliwość dostępu do zmiennych środowiskowych w <paramref name="name" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Natychmiast kończy proces po zapisaniu komunikat w dzienniku zdarzeń aplikacji systemu Windows, a następnie zawiera komunikat i informacje o opcjonalnych wyjątku raportów o błędach do firmy Microsoft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat, który wyjaśnia, dlaczego proces został przerwany, lub <see langword="null" /> Jeśli jest dostępne żadne wyjaśnienia.</param>
        <summary>Natychmiast kończy proces po zapisaniu komunikat w dzienniku zdarzeń aplikacji systemu Windows, a następnie zawiera komunikat w raportów o błędach do firmy Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kończy proces bez uruchamiania aktywnego `try` / `finally` bloków lub finalizatory.  
  
 <xref:System.Environment.FailFast%2A> Zapisy metody `message` ciąg w dzienniku zdarzeń aplikacji systemu Windows tworzy zrzut aplikacji, a następnie kończy bieżącego procesu. `message` Raportów o błędach do firmy Microsoft dołączony jest również ciągu.  
  
 Użyj <xref:System.Environment.FailFast%2A> zamiast metody <xref:System.Environment.Exit%2A> metodę, aby zakończyć aplikację, jeśli stan aplikacji jest uszkodzony naprawić i wykonywanie aplikacji `try` / `finally` bloków i finalizatory spowoduje uszkodzenie zasobów programu.  
  
 Informacje jest zgłaszane do firmy Microsoft przy użyciu raportowanie błędów systemu Windows. Aby uzyskać więcej informacji, zobacz [raportowanie błędów systemu Windows: wprowadzenie](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  
  
   
  
## Examples  
 W poniższym przykładzie zapisuje wpis dziennika w dzienniku zdarzeń aplikacji systemu Windows i przerywa proces bieżącego.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat, który wyjaśnia, dlaczego proces został przerwany, lub <see langword="null" /> Jeśli jest dostępne żadne wyjaśnienia.</param>
        <param name="exception">Wyjątek, który reprezentuje błąd, który spowodował przerwanie. Zazwyczaj jest to wyjątek w <see langword="catch" /> bloku.</param>
        <summary>Natychmiast kończy proces po zapisaniu komunikat w dzienniku zdarzeń aplikacji systemu Windows, a następnie zawiera informacje na temat wiadomości i wyjątków w raportów o błędach do firmy Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kończy proces bez uruchamiania aktywnego `try` / `finally` bloków lub finalizatory.  
  
 <xref:System.Environment.FailFast%2A> Zapisy metody `message` ciąg w dzienniku zdarzeń aplikacji systemu Windows tworzy zrzut aplikacji, a następnie kończy bieżącego procesu.  
  
 Informacje jest zgłaszane do firmy Microsoft przy użyciu raportowanie błędów systemu Windows. Aby uzyskać więcej informacji, zobacz [raportowanie błędów systemu Windows: wprowadzenie](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Raportów o błędach do firmy Microsoft obejmuje `message` i `exception` informacje, które zawiera szczegółowe informacje, służy do klasyfikowania błędu. Mimo że `exception` jest nieobsługiwany, ponieważ proces jest zakończony, informacje kontekstowe, który spowodował wystąpienie wyjątku jest nadal uzyskany.  
  
 Jeśli `exception` jest `null`, lub jeśli `exception` jest nie zgłoszono, ta metoda działa tak samo jak <xref:System.Environment.FailFast%28System.String%29> przeciążenie metody.  
  
 Użyj <xref:System.Environment.FailFast%2A> zamiast metody <xref:System.Environment.Exit%2A> metodę, aby zakończyć aplikację, jeśli stan aplikacji jest uszkodzony naprawić i wykonywanie aplikacji `try` / `finally` bloków i finalizatory spowoduje uszkodzenie zasobów programu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę ciągów zawierających argumenty wiersza polecenia dla bieżącego procesu.</summary>
        <returns>Tablica ciągów, gdzie każdy element zawiera argument wiersza polecenia. Pierwszy element jest nazwa pliku wykonywalnego i następujących zero lub więcej elementów zawierać pozostałe argumenty wiersza polecenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwszy element w tablicy zawiera nazwę pliku wykonywania programu. Jeśli nazwa pliku nie jest dostępna, pierwszy element jest równa <xref:System.String.Empty?displayProperty=nameWithType>. Pozostałe elementy zawierają wszystkie dodatkowe tokeny wprowadzona w wierszu polecenia.  
  
 Nazwa pliku programu można, ale nie jest wymagane, zawierają informacje o ścieżce.  
  
 Argumenty wiersza polecenia są rozdzielone spacjami. Podwójny cudzysłów (") umożliwia spacji w argumencie. Pojedynczego cudzysłowu ('), jednak nie zapewnia tę funkcję.  
  
 Jeśli co najmniej dwóch parzystą liczbą ukośników odwrotnych podwójny cudzysłów, każda para ukośnik odwrotny postępowania jest zastępowany jeden ukośnik odwrotny, i podwójny cudzysłów została usunięta. Jeśli podwójny cudzysłów nieparzystą liczbę ukośników odwrotnych, łącznie z tylko jednego każda para poprzedniego zastępuje z jednego ukośnik odwrotny, a pozostałe ukośnik odwrotny zostanie usunięta; Jednak w takim przypadku podwójny cudzysłów nie usunięciu.  
  
 W poniższej tabeli pokazano, jak argumenty wiersza polecenia mogą być rozdzielone i zakłada `MyApp` jako bieżącą aplikację wykonującego.  
  
|Wprowadź w wierszu polecenia|Wynikowa argumenty wiersza polecenia|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Aby uzyskać wiersza polecenia w postaci jednego ciągu, użyj <xref:System.Environment.CommandLine%2A> właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono argumenty wiersza polecenia aplikacji.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">System nie obsługuje argumentów wiersza polecenia.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do odczytu do zmiennej środowiskowej PATH. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość zmiennej środowiskowej.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">Nazwa zmiennej środowiskowej.</param>
        <summary>Pobiera wartość zmiennej środowiskowej w bieżącym procesie.</summary>
        <returns>Wartość zmiennej środowiskowej, określony przez <paramref name="variable" />, lub <see langword="null" /> Jeśli zmienna środowiskowa nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.GetEnvironmentVariable%28System.String%29> Metoda pobiera zmienną środowiskową z bloku środowiska bieżącego procesu. Jest to odpowiednik wywołania <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> metody z `target` wartość <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Blok środowiska bieżącego procesu obejmuje następujące zmienne środowiskowe:  
  
-   Wszystkie dla poszczególnych komputerów zmiennych środowiskowych, które są zdefiniowane w czasie procesu jest tworzona wraz z wartościami.  
  
-   Wszystkie zmienne środowiskowe użytkownika zdefiniowane w tym czasie proces został utworzony, wraz z wartościami.  
  
-   Wszelkie zmienne dodać do bloku procesu, gdy proces jest uruchomiony przez wywołanie albo <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metody lub <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metody z `target` wartość <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  
  
 Jeśli zmienne środowiskowe są tworzone po rozpoczęciu procesu, możesz ta metoda służy do pobrania tylko tych zmiennych, które zostały utworzone przez wywołanie metody <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metody lub <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metody z `target` wartość.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  
  
 Aby pobrać wszystkie zmienne środowiskowe wraz z ich wartości, należy wywołać <xref:System.Environment.GetEnvironmentVariables%2A> metody.  
  
 Nazwy zmiennych środowiskowych nie jest rozróżniana.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Environment.GetEnvironmentVariable%2A> metoda pobierania `windir` zmiennej środowiskowej, która zawiera ścieżkę katalogu systemu Windows.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 Poniższy przykład próbuje pobrać wartość zmiennej środowiskowej o nazwie `Test1` z bloku środowiska procesu. Jeśli zmienna nie istnieje, w przykładzie jest tworzony jego i pobiera jego wartość. W przykładzie przedstawiono wartości zmiennej. Jeśli przykładzie utworzona zmiennej, również wywołuje <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> metody z każdy element członkowski <xref:System.EnvironmentVariableTarget> wyliczenie ustalenie, czy zmienna mogą być pobrane tylko z bieżący blok środowiska procesu. Ponadto jeśli przykładzie utworzona zmienna, usuwa go.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">dla możliwości odczytu wartości <paramref name="variable" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">Nazwa zmiennej środowiskowej.</param>
        <param name="target">Jeden z <see cref="T:System.EnvironmentVariableTarget" /> wartości.</param>
        <summary>Pobiera wartość zmiennej środowiskowej z bieżącego procesu lub klucza rejestru systemu operacyjnego Windows dla bieżącego użytkownika lub komputera lokalnego.</summary>
        <returns>Wartość zmiennej środowiskowej, określony przez <paramref name="variable" /> i <paramref name="target" /> parametry, lub <see langword="null" /> Jeśli zmienna środowiskowa nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `target` Parametr określa, czy zmienna środowiskowa są pobierane z bieżącego procesu lub klucza rejestru systemu operacyjnego Windows dla bieżącego użytkownika lub komputera lokalnego. Wszystkie zmienne środowiskowe dla poszczególnych użytkowników i dla poszczególnych komputerów automatycznie są kopiowane do bloku środowiska bieżącego procesu. Jednak dodane tylko do bloku środowiska bieżącego procesu zmiennych środowiskowych utrwalić tylko na czas trwania procesu.  
  
 Aby pobrać wszystkie zmienne środowiskowe wraz z ich wartości, należy wywołać <xref:System.Environment.GetEnvironmentVariables%2A> metody.  
  
 Nazwy zmiennych środowiskowych nie jest rozróżniana.  
  
   
  
## Examples  
 Poniższy przykład tworzy zmienne środowiskowe dla celów Proces, Użytkownik i Komputer, sprawdza, czy rejestr systemu operacyjnego zawiera zmienne środowiskowe Użytkownik i Komputer, a następnie usuwa zmienne środowiskowe.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> nie jest prawidłową <see cref="T:System.EnvironmentVariableTarget" /> wartość.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">dla możliwości odczytu wartości <paramref name="variable" /> Jeśli <paramref name="target" /> jest <see cref="F:System.EnvironmentVariableTarget.Process" /> (skojarzone wyliczenie: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />),  
  
 lub  
  
 Aby uzyskać pełny dostęp do zmiennych środowiskowych Jeśli <paramref name="target" /> jest <see cref="F:System.EnvironmentVariableTarget.User" /> lub <see cref="F:System.EnvironmentVariableTarget.Machine" /> (skojarzone wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wszystkie nazwy zmiennych środowiskowych i ich wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wszystkie nazwy zmiennych środowiskowych i ich wartości z bieżącego procesu.</summary>
        <returns>Słownik zawierający wszystkie nazwy zmiennych środowiskowych i ich wartości. w przeciwnym razie znaleziono pusty słownik, jeśli nie zmiennych środowiskowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwy i wartości zmiennych środowiskowych, które są przechowywane jako pary klucz wartość w zwróconym <xref:System.Collections.IDictionary>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Environment.GetEnvironmentVariables%2A> metody.  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <exception cref="T:System.OutOfMemoryException">Bufor jest za mało pamięci.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">dla możliwości odczytu nazwy i wartości zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="target">Jeden z <see cref="T:System.EnvironmentVariableTarget" /> wartości.</param>
        <summary>Pobiera wszystkie nazwy zmiennych środowiskowych i ich wartości z bieżącego procesu lub klucza rejestru systemu operacyjnego Windows dla bieżącego użytkownika lub komputera lokalnego.</summary>
        <returns>Słownik zawierający wszystkie nazwy zmiennych środowiskowych i ich wartości z określonego przez źródła <paramref name="target" /> parametru; w przeciwnym razie znaleziono pusty słownik, jeśli nie zmiennych środowiskowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `target` Parametr określa, czy źródło jest bieżący proces, klucza rejestru dla bieżącego użytkownika lub klucza rejestru dla komputera lokalnego.  
  
 Nazwy i wartości zmiennych środowiskowych, które są przechowywane jako pary klucz wartość w zwróconym <xref:System.Collections.IDictionary> obiektu.  
  
   
  
## Examples  
 Poniższy przykład tworzy zmienne środowiskowe dla celów Proces, Użytkownik i Komputer, sprawdza, czy rejestr systemu operacyjnego zawiera zmienne środowiskowe Użytkownik i Komputer, a następnie usuwa zmienne środowiskowe.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji dla określonej wartości <paramref name="target" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> zawiera niedozwoloną wartość.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">dla możliwości odczytu nazwy i wartości zmiennych środowiskowych, jeśli <paramref name="target" /> jest <see cref="F:System.EnvironmentVariableTarget.Process" /> (skojarzone wyliczenie: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />),  
  
 lub  
  
 Aby uzyskać pełny dostęp do zmiennych środowiskowych Jeśli <paramref name="target" /> jest <see cref="F:System.EnvironmentVariableTarget.User" /> lub <see cref="F:System.EnvironmentVariableTarget.Machine" /> (skojarzone wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera ścieżkę do folderu specjalnego systemu identyfikowany przez określony wyliczenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
      </Parameters>
      <Docs>
        <param name="folder">Stała wyliczany określający specjalnego folderu systemu.</param>
        <summary>Pobiera ścieżkę do folderu specjalnego systemu identyfikowany przez określony wyliczenia.</summary>
        <returns>Ścieżka do określonego systemu specjalnego folderu, jeśli wybrany folder fizycznie istnieje na komputerze. w przeciwnym razie wartość pustego ciągu ("").  
  
 Folder fizycznie nie istnieje, jeśli system operacyjny nie może utworzyć, usunięto istniejący folder lub folder jest katalogu wirtualnego, takich jak Mój komputer, który nie odpowiada na ścieżkę fizyczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera ścieżkę do folderu specjalnego systemu, takie jak pliki programu, programy, System lub uruchamiania, której można uzyskać dostęp do wspólnych informacji. Foldery specjalne są domyślnie przez system, lub jawnie przez użytkownika, po zainstalowaniu wersji systemu Windows.  
  
 `folder` Parametr wyznacza folderu specjalnego do pobrania i musi być jedną z wartości w <xref:System.Environment.SpecialFolder> wyliczenie; wszelkie inne wartości zgłasza wyjątek.  
  
 Aby uzyskać więcej informacji na temat foldery specjalne, zobacz [zmiennej CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664) temacie wartości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Environment.GetFolderPath%2A> metody, aby wrócić i wyświetlić skojarzona ścieżka `folder` parametru.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> nie jest członkiem <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżąca platforma nie jest obsługiwana.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji w sama ścieżka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" />
      </Parameters>
      <Docs>
        <param name="folder">Stała wyliczany określający specjalnego folderu systemu.</param>
        <param name="option">Określa opcje służące do uzyskiwania dostępu do folderu specjalnego.</param>
        <summary>Pobiera ścieżkę do folderu specjalnego systemu jest identyfikowany przez określony wyliczenie, która używa do uzyskiwania dostępu do folderów specjalnych określoną opcję.</summary>
        <returns>Ścieżka do określonego systemu specjalnego folderu, jeśli wybrany folder fizycznie istnieje na komputerze. w przeciwnym razie wartość pustego ciągu ("").  
  
 Folder fizycznie nie istnieje, jeśli system operacyjny nie może utworzyć, usunięto istniejący folder lub folder jest katalogu wirtualnego, takich jak Mój komputer, który nie odpowiada na ścieżkę fizyczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera ścieżkę do folderu specjalnego systemu, takie jak pliki programu, programy, System lub uruchamiania, której można uzyskać dostęp do wspólnych informacji. Foldery specjalne są domyślnie przez system, lub jawnie przez użytkownika, po zainstalowaniu wersji systemu Windows.  
  
 `folder` Parametr wyznacza folderu specjalnego do pobrania i musi być jedną z wartości w <xref:System.Environment.SpecialFolder> wyliczenie; wszelkie inne wartości zgłasza wyjątek.  
  
 Aby uzyskać więcej informacji na temat foldery specjalne, zobacz [zmiennej CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664) temacie wartości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> nie jest elementem członkowskim <see cref="T:System.Environment.SpecialFolder" /></exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.PlatformNotSupportedException" />
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji w sama ścieżka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg zawierający nazwy dysków logicznych na bieżącym komputerze.</summary>
        <returns>Tablica ciągów, gdzie każdy element zawiera nazwę dysku logicznego. Na przykład, jeśli twardy komputera jest to pierwszy dysk logiczny, pierwszy element zwracane jest "C:\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób wyświetlenia dysków logicznych z bieżącego przy użyciu komputera <xref:System.Environment.GetLogicalDrives%2A> metody.  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do zasobów chronionych przez to uprawnienie. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest zwalniany bieżącej domeny aplikacji lub środowisko uruchomieniowe języka wspólnego (CLR) jest wyłączana.</summary>
        <value>
          <see langword="true" /> Jeśli bieżąca domena aplikacji jest zwalniany lub CLR jest zamykana; w przeciwnym razie wartość <see langword="false." /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy CLR zwalnia domeny aplikacji, uruchamia finalizatory na wszystkie obiekty, które ma finalizator metody w tej domenie aplikacji. Podczas zamykania środowiska CLR, uruchamia wątku finalizatora na wszystkie obiekty, które ma metody finalizatora. <xref:System.Environment.HasShutdownStarted%2A> Zwraca `true` tylko wtedy, gdy wątek finalizatora został uruchomiony. Gdy właściwość zwraca `true`, można określić, czy Zwalnianie domeny aplikacji lub CLR sam jest zamykana, wywołując <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> metody. Ta metoda zwraca `true` Jeśli finalizatory są nazywane, ponieważ jest zwolnienie domeny aplikacji lub `false` Jeśli trwa zamykanie środowiska CLR.  
  
 <xref:System.Environment.HasShutdownStarted%2A> Zwraca `false` Jeśli wątek finalizatora nie został uruchomiony.  
  
 Przy użyciu tej właściwości, można określić, czy dostęp do statycznych zmiennych w kodzie finalizacji. Jeśli środowisko CLR lub domenie aplikacji jest zamykana, nie można niezawodnie uzyskać dostępu do dowolnego obiektu, który ma metodę finalizacji i pola statycznego, do którego odwołuje. Jest to spowodowane te obiekty mogą być już sfinalizowany.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy bieżący system operacyjny jest 64-bitowym systemie operacyjnym.</summary>
        <value>
          <see langword="true" /> Jeśli system operacyjny jest 64-bitowy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy bieżący proces jest proces 64-bitowy.</summary>
        <value>
          <see langword="true" /> Jeśli proces jest 64-bitowy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę NetBIOS tego komputera lokalnego.</summary>
        <value>Ciąg zawierający nazwę tego komputera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa tego komputera jest określana podczas uruchamiania systemu, gdy odczytać z rejestru nazwy. Jeśli ten komputer jest węzłem w klastrze, zwracana jest nazwa węzła.  
  
   
  
## Examples  
 Poniższy przykład przedstawia nazwę komputera, na którym jest uruchamiany przykładowy kod. (Nazwa komputera został pominięty z przykładowe dane wyjściowe ze względów bezpieczeństwa).  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można uzyskać nazwy komputera.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do odczytu do zmiennej środowiskowej COMPUTERNAME. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg znaków nowego wiersza zdefiniowane dla tego środowiska.</summary>
        <value>Ciąg zawierający dla platform Unix z systemem innym niż "\r\n" lub ciąg zawierający "\n" dla platform Unix.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość właściwości <xref:System.Environment.NewLine%2A> jest stałą dostosowane specjalnie dla bieżącej platformy i stosowania programu .NET Framework. Aby uzyskać więcej informacji na temat znaków ucieczki w wartości właściwości, zobacz [znaki specjalne](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 Funkcje zapewniane przez <xref:System.Environment.NewLine%2A> jest często, co oznacza warunki nowego wiersza, wysuwu wiersza, podziału wiersza, znaków powrotu karetki, CRLF i końca wiersza.  
  
 <xref:System.Environment.NewLine%2A> mogą być używane w połączeniu z obsługą nowego wiersza specyficzny dla języka, takie jak znaki ucieczki "\r" i "\n" w języku Microsoft C# i C/C++, lub `vbCrLf` programu Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A> jest automatycznie dołączane do tekstu przetworzone przez <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> i <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono trzy wiersze rozdzielone newlines.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.OperatingSystem" /> obiekt, który zawiera bieżący numer identyfikator i wersja platformy.</summary>
        <value>Obiekt, który znajduje się kod identyfikator i wersja platformy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Począwszy od systemu Windows 8 <xref:System.Environment.OSVersion%2A> właściwość zwraca takie same numery wersji głównej i pomocniczej dla wszystkich platform Windows. W związku z tym nie zaleca się czy pobrać wartość tej właściwości, aby określić wersji systemu operacyjnego.  
  
 Zazwyczaj <xref:System.Environment.OSVersion%2A> właściwość jest używana do zapewnienia, że aplikacja jest uruchomiona na niektórych podstawowej wersji systemu operacyjnego, w którym wprowadzono poszczególnych funkcji. W przypadku, należy wykonać sprawdzanie wersji przez sprawdzenie, czy bieżąca wersja systemu operacyjnego zwracanych przez <xref:System.Environment.OSVersion%2A> właściwości jest taka sama jak, lub nowsza niż wersja podstawowego systemu operacyjnego. Aby uzyskać więcej informacji, zobacz <xref:System.Version> klasy tematu.  
  
 Za pomocą systemu Windows 8 <xref:System.Environment.OSVersion%2A> właściwość zwraca wersji zgłoszony przez system Windows [GetVersionEx](http://msdn.microsoft.com/library/windows/desktop/ms724451\(v=vs.85\).aspx) funkcji. Aby uzyskać listę wersji systemu operacyjnego Windows i ich odpowiednie numery wersji, zobacz [wersji systemu operacyjnego](https://msdn.microsoft.com/library/windows/desktop/ms724832.aspx) w Centrum deweloperów systemu Windows.  
  
> [!NOTE]
>  <xref:System.Environment.OSVersion%2A> Właściwość raportuje ten sam numer wersji (6.2.0.0) dla obu [!INCLUDE[win8](~/includes/win8-md.md)] i [!INCLUDE[win81](~/includes/win81-md.md)] i tego samego numeru wersji głównej i pomocniczej dla systemu Windows 10.  
  
 W niektórych przypadkach <xref:System.Environment.OSVersion%2A> właściwości nie może zwracać wersji systemu operacyjnego, która jest zgodna z wersją określony dla funkcji trybu zgodności programów systemu Windows.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono identyfikator platformy i numer wersji komputera, na którym jest uruchamiany przykładowy kod.  
  
 [!code-cpp[environment.osversion#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.OSVersion/CPP/osversion.cpp#1)]
 [!code-csharp[environment.osversion#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.OSVersion/CS/osversion.cs#1)]
 [!code-vb[environment.osversion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.OSVersion/VB/osversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość nie może uzyskać wersję systemu.  
  
 —lub—  
  
 Identyfikator uzyskany platforma nie jest elementem członkowskim <see cref="T:System.PlatformID" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę procesorów na bieżącym komputerze.</summary>
        <value>32-bitową liczba całkowita określająca liczbę procesorów na bieżącym komputerze. Nie jest domyślnie. Jeśli bieżącego komputera zawiera wielu grup procesorów, ta właściwość zwraca liczbę procesorów logicznych, które są dostępne do użycia przez środowisko uruchomieniowe języka wspólnego (CLR).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat grup procesorów oraz procesorów logicznych, zobacz [grup procesorów](http://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Environment.ProcessorCount%2A> właściwości.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy, modyfikuje lub usuwa zmiennej środowiskowej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">Nazwa zmiennej środowiskowej.</param>
        <param name="value">Wartość do przypisania do <c>zmiennej</c>.</param>
        <summary>Tworzy, modyfikuje lub usuwa zmienną środowiskową przechowywane w bieżącym procesie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest odpowiednikiem wywołania <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> przeciążenia o wartości <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> dla `target` argumentu.  
  
 Jeśli `value` argument nie jest pusty (zobacz opis usuwania w dalszej części tej sekcji definicji pustą wartość zmiennej środowiskowej) i zmienną środowiskową o nazwie `variable` parametr nie istnieje, środowisko Zmienna nie zostanie utworzona i przypisane zawartość `value`. Jeśli istnieje, jej wartość jest modyfikowany. Ponieważ zmiennej środowiskowej jest zdefiniowany w bloku środowiska bieżącego procesu, nie jest trwały po zakończeniu procesu.  
  
 Jeśli `variable` zawiera szesnastkowy-początkowe zero znak znaków przed znakiem zero są traktowane jako nazwa zmiennej środowiskowej i wszystkie kolejne znaki są ignorowane.  
  
 Jeśli `value` zawiera szesnastkowy-początkowe zero znak znaków przed znakiem zero są przypisywane do zmiennej środowiskowej i wszystkie kolejne znaki są ignorowane.  
  
 Jeśli `value` jest pusty, a zmienna środowiskowa o nazwie `variable` istnieje, jest usuwany zmiennej środowiskowej. Jeśli `variable` nie istnieje, nie występują błędy, nawet jeśli nie można wykonać operacji. `value` jest uznawane za pusty we wszystkich następujących warunków:  
  
-   Jest `null`.  
  
-   Jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Składa się z pojedynczym znakiem, którego wartość jest U + 0000.  
  
   
  
## Examples  
 Poniższy przykład sprawdza, czy zmienna środowiskowa o nazwie `APPDOMAIN` istnieje w bieżącym procesie. Jeśli nie, tworzy go i ustawia wartość "True". Jeśli wartość `APPDOMAIN` zmiennej środowiskowej to "True", wywołuje `Message.Display` metody w nowej domenie aplikacji. W przeciwnym razie wykonuje `Message.Display` metody w bieżącej domenie aplikacji.  
  
 [!code-csharp[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/cs/setenvironmentvariable1.cs#1)]
 [!code-vb[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/vb/setenvironmentvariable1.vb#1)]  
  
 Jeśli przykładzie zostanie uruchomiony po raz pierwszy, komunikat "Executing w domenie domeny 2" wyświetlany w konsoli. Jeśli ustawisz zmiennej środowiskowej z wiersza polecenia przy użyciu polecenia:  
  
 `Set AppDomain=False`  
  
 w przykładzie zostanie wyświetlony komunikat "wykonywanie w domenie *Nazwa_pliku_exe*.exe", gdzie *Nazwa_pliku_exe* jest nazwą pliku wykonywalnego.  
  
 Poniższy przykład próbuje pobrać wartość zmiennej środowiskowej o nazwie `Test1` z bloku środowiska procesu. Jeśli zmienna nie istnieje, przykładzie tworzy zmienną i pobiera jego wartość. W przykładzie przedstawiono wartości zmiennej. Jeśli przykładzie utworzona zmiennej, również wywołuje <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> metody z każdy element członkowski <xref:System.EnvironmentVariableTarget> wyliczenie ustalenie, czy zmienna mogą być pobrane tylko z bieżący blok środowiska procesu. Ponadto jeśli przykładzie utworzona zmienna, usuwa go.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> zawiera pusty ciąg szesnastkowy początkowej zero znak (0x00) lub znak równości ("=").  
  
 —lub—  
  
 Długość <paramref name="variable" /> lub <paramref name="value" /> jest większa niż lub równa 32 767 znaków.  
  
 —lub—  
  
 Wystąpił błąd podczas wykonywania tej operacji.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">Nazwa zmiennej środowiskowej.</param>
        <param name="value">Wartość do przypisania do <c>zmiennej</c>.</param>
        <param name="target">Jedna z wartości wyliczenia, które określa lokalizację, w zmiennej środowiskowej.</param>
        <summary>Tworzy, modyfikuje lub usuwa zmienną środowiskową przechowywane w bieżącym procesie lub Windows systemu operacyjnego klucz rejestru zarezerwowane dla bieżącego użytkownika lub komputera lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Metoda pozwala zdefiniować zmienną środowiskową, który jest dostępny dla wszystkich procesów działających w maszynie ( <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> wartość), do wszystkich procesów uruchamiane przez użytkownika ( <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> wartość), lub do bieżącego procesu ( <xref:System.EnvironmentVariableTarget.Process> wartości). Zmienne środowiskowe dla poszczególnych komputerów i użytkowników są kopiowane do bloku środowiska bieżącego procesu. Jednak zmiennych środowiskowych, które są unikatowe, jak bieżący blok środowiska procesu będą się powtarzać, tylko do momentu ukończenia procesu.  
  
 Jeśli `value` argument nie jest pusty (zobacz opis usuwania w dalszej części tej sekcji definicji pustą wartość zmiennej środowiskowej) i zmienną środowiskową o nazwie `variable` parametr nie istnieje, środowisko Zmienna nie zostanie utworzona i przypisane zawartość `value`.  Jeśli istnieje, jej wartość jest modyfikowany.  
  
 Jeśli `variable` zawiera szesnastkowy-początkowe zero znak znaków przed znakiem zero są traktowane jako nazwa zmiennej środowiskowej i wszystkie kolejne znaki są ignorowane.  
  
 Jeśli `value` zawiera szesnastkowy-początkowe zero znak znaków przed znakiem zero są przypisywane do zmiennej środowiskowej i wszystkie kolejne znaki są ignorowane.  
  
 Jeśli `value` jest pusty, a zmienna środowiskowa o nazwie `variable` istnieje, jest usuwany zmiennej środowiskowej. `value` jest uznawane za pusty we wszystkich następujących warunków:  
  
-   Jest `null`.  
  
-   Jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Składa się z pojedynczym znakiem, którego wartość jest U + 0000.  
  
 Jeśli `variable` nie istnieje, nie występują błędy, mimo że nie można wykonać operacji. Należy zachować ostrożność podczas `target` jest <xref:System.EnvironmentVariableTarget.Machine>, ponieważ został przypadkowo usunięty zmiennej środowiskowej, która wpływa na całą komputera lokalnego, nie tylko bieżący proces lub użytkownika.  
  
 Jeśli `target` jest <xref:System.EnvironmentVariableTarget.User>, zmienna środowiskowa jest przechowywana w kluczu HKEY_CURRENT_USER\Environment rejestru na komputerze lokalnym. Jest on również kopiowany do wystąpienia Eksploratora plików, które działają w kontekście bieżącego użytkownika. Zmienna środowiskowa następnie jest dziedziczona przez wszystkie nowe procesy, które użytkownik uruchomi w Eksploratorze plików.  
  
 Podobnie jeśli `target` jest <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, zmienna środowiskowa jest przechowywana w kluczu HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment rejestru na komputerze lokalnym. Jest on również kopiowany do wszystkich wystąpień Eksploratora plików. Zmienna środowiskowa następnie jest dziedziczona przez wszystkie nowe procesy, które będą uruchamiane w Eksploratorze plików.  
  
 Jeśli `target` jest <xref:System.EnvironmentVariableTarget.User> lub <xref:System.EnvironmentVariableTarget.Machine>, inne aplikacje są powiadamiane ustalonej operacji przez system Windows `WM_SETTINGCHANGE` wiadomości.  
  
 Jeśli `target` jest <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> lub <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, zalecana długość `value` mniej niż 2048 znaków.  
  
   
  
## Examples  
 Poniższy przykład tworzy zmiennych środowiskowych dla <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, i <xref:System.EnvironmentVariableTarget.Machine> elementów docelowych, sprawdza, czy rejestr systemu operacyjnego zawiera użytkownika i zmienne środowiskowe, a następnie usuwa środowiska zmienne.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> zawiera pusty ciąg szesnastkowy początkowej zero znak (0x00) lub znak równości ("=").  
  
 —lub—  
  
 Długość <paramref name="variable" /> jest większa niż lub równa 32 767 znaków.  
  
 —lub—  
  
 <paramref name="target" /> nie jest elementem członkowskim <see cref="T:System.EnvironmentVariableTarget" /> wyliczenia.  
  
 —lub—  
  
 <paramref name="target" /> jest <see cref="F:System.EnvironmentVariableTarget.Machine" /> lub <see cref="F:System.EnvironmentVariableTarget.User" />, a długość <paramref name="variable" /> jest większa niż lub równa 255.  
  
 —lub—  
  
 <paramref name="target" /> jest <see cref="F:System.EnvironmentVariableTarget.Process" /> i długość <paramref name="value" /> jest większa niż lub równa 32 767 znaków.  
  
 —lub—  
  
 Wystąpił błąd podczas wykonywania tej operacji.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżące informacje śledzenia stosu.</summary>
        <value>Ciąg zawierający informacje śledzenia stosu. Ta wartość może być <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.StackTrace%2A> Listy właściwości wywołania metody w odwrotnej kolejności chronologicznej, oznacza to, najpierw opisano najnowszych wywołanie metody i znajduje się jeden wiersz informacje śledzenia stosu dla każdego wywołania metody na stosie. Jednak <xref:System.Environment.StackTrace%2A> właściwość może nie raportować dowolną liczbę wywołań metody zgodnie z oczekiwaniami z powodu przekształcenia kodu, jakie występują podczas optymalizacji.  
  
> [!NOTE]
>  Hierarchiczny widok informacje śledzenia stosu przez klasę, można użyć <xref:System.Diagnostics.StackTrace> klasy.  
  
 <xref:System.Environment.StackTrace%2A> Właściwość formatuje informacje śledzenia stosu dla każdego wywołania metody w następujący sposób:  
  
 "w `FullClassName`.`MethodName` (`MethodParams`) w `FileName` : wiersz `LineNumber` "  
  
 Literał "na" jest poprzedzony trzy spacje, a cały podciąg, począwszy od "w" jest pomijana, jeżeli symboli debugowania nie są dostępne. Symbole zastępcze, `FullClassName`, `MethodName`, `MethodParams`, `FileName`, i `LineNumber`, są zastępowane rzeczywistymi wartościami i są zdefiniowane w następujący sposób:  
  
 FullClassName  
 Pełna nazwa klasy, włącznie z przestrzenią nazw.  
  
 `MethodName`  
 Nazwa metody.  
  
 `MethodParams`  
 Lista par nazwa/typu parametru. Każda para jest rozdzielanych przecinkami (","). Te informacje jest pomijana, jeżeli `MethodName` nie przyjmuje żadnych parametrów.  
  
 `FileName`  
 Nazwa źródła pliku where `MethodName` metoda jest zadeklarowana. Informacja ta jest pomijana w razie niedostępności symboli debugowania.  
  
 `LineNumber`  
 Numer wiersza w `FileName` zawierający kodu źródłowego z `MethodName` instrukcji, która znajduje się na stosie wywołań. Informacja ta jest pomijana w razie niedostępności symboli debugowania.  
  
 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Ciąg kończy każdego wiersza ślad stosu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Environment.StackTrace%2A> właściwości.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do zasobów chronionych przez uprawnienia. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pełną ścieżkę katalogu systemowego.</summary>
        <value>Ciąg zawierający ścieżkę katalogu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykładem wartość zwracana jest ciąg "C:\WinNT\System32".  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono katalogu systemowego komputera, który jest uruchamiany przykładowy kod. (Katalog systemowy został pominięty z przykładowe dane wyjściowe ze względów bezpieczeństwa).  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji w sama ścieżka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę bajtów na stronie pamięci systemu operacyjnego.</summary>
        <value>Liczba bajtów na stronie pamięci systemu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Te informacje mogą być przydatne podczas ustalania, czy używać <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> podczas pracy z plików mapowanych na pamięć.  
  
 W systemie Windows, ta wartość jest `dwPageSize` element członkowski w `SYSTEM_INFO` struktury.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do zmiennych środowiskowych systemu i użytkownika. Skojarzony wyjątek:  
  
 <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wyrażony w milisekundach czas, jaki upłynął od uruchomienia systemu.</summary>
        <value>32-bitowe całkowita zawierająca ilość czasu w milisekundach, jaki upłynął od czasu ostatniego uruchomienia komputera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości jest pochodną czasomierza systemu i są przechowywane jako całkowita 32-bitowych. Należy zauważyć, że ponieważ jest pochodną czasomierz systemu rozpoznanie <xref:System.Environment.TickCount%2A> właściwość jest ograniczona do rozdzielczość czasomierza systemu, który zazwyczaj znajduje się w zakresie milisekund 10-16.  
  
> [!IMPORTANT]
>  Ponieważ wartość <xref:System.Environment.TickCount%2A> wartość właściwości jest całkowita 32-bitowy, jeśli system działa w sposób ciągły, <xref:System.Environment.TickCount%2A> powoduje zwiększenie od zera do <xref:System.Int32.MaxValue?displayProperty=nameWithType> 24,9 dni, następnie przejść do <xref:System.Int32.MinValue?displayProperty=nameWithType>, która jest liczbą ujemną następnie przyrostu z powrotem na zero w następnym 24,9 dni. Ten problem można obejść przez wywołanie systemu Windows [GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) funkcji, co spowoduje zresetowanie do zera po około 49.7 dni, przez wywołanie [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) funkcji.  
  
 <xref:System.Environment.TickCount%2A> różni się od <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> właściwość, która jest liczba 100-nanosekundowych interwałów, które upłynęły od 1/1/0001 00:00:00.  
  
 Użyj <xref:System.DateTime.Now%2A?displayProperty=nameWithType> właściwość, aby uzyskać bieżący lokalny Data i godzina na tym komputerze.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak pobrać dodatni zakres wartości zwracanych przez <xref:System.Environment.TickCount%2A> właściwości. <xref:System.Environment.TickCount%2A> Właściwości przełączanie między <xref:System.Int32.MinValue?displayProperty=nameWithType>, która jest liczbą ujemną i <xref:System.Int32.MaxValue?displayProperty=nameWithType> raz 49.8 dni. Ten przykład kodu usuwa bitem umożliwiające uzyskanie nieujemna liczba, która przełączanie między zero a <xref:System.Int32.MaxValue> raz 24,9 dni.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę domeny sieciowej skojarzonych z bieżącego użytkownika.</summary>
        <value>Nazwy domeny sieciowej skojarzonej z bieżącego użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poświadczenia konta domeny dla użytkownika są sformatowane jako nazwa domeny użytkownika, '\\' znaków, a nazwa użytkownika. Użyj <xref:System.Environment.UserDomainName%2A> właściwości można uzyskać nazwy domeny użytkownika bez nazwy użytkownika i <xref:System.Environment.UserName%2A> właściwości można uzyskać nazwy użytkownika bez nazwy domeny.  Na przykład, jeśli nazwa użytkownika i nazwa domeny użytkownika są CORPORATENETWORK\john <xref:System.Environment.UserDomainName%2A> właściwość zwraca "CORPORATENETWORK".  
  
 <xref:System.Environment.UserDomainName%2A> Właściwość najpierw próbuje pobrać składnik nazwy domeny nazwy konta systemu Windows dla bieżącego użytkownika. Jeśli próba który kończy się niepowodzeniem, ta właściwość próbuje pobrać nazwy domeny skojarzonej z o podanej nazwie użytkownika <xref:System.Environment.UserName%2A> właściwości. Jeśli taka próba nie powiedzie się, ponieważ komputer hosta nie jest przyłączony do domeny, zwracana jest nazwa komputera hosta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny nie obsługuje pobierania nazwy domeny w sieci.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można pobrać nazwy domeny sieciowej.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do odczytu do zmiennej środowiskowej USERDOMAIN. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący proces jest uruchomiony w trybie interakcyjnym użytkownika.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący proces jest uruchomiony w trybie interakcyjnym użytkownika; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.UserInteractive%2A> Raportów właściwości `false` dla procesu systemu Windows lub usług, takich jak usługi IIS, który jest uruchamiany bez interfejsu użytkownika. Jeśli ta właściwość jest `false`, nie są wyświetlane modalne okna dialogowe lub pola wiadomości, ponieważ nie istnieje żadne graficznego interfejsu użytkownika dla użytkownika na interakcję z.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, czy bieżący proces jest uruchomiony w trybie interakcyjnym użytkownika.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę użytkownika osoby, która jest aktualnie zalogowany do systemu operacyjnego Windows.</summary>
        <value>Nazwa użytkownika osoby, która jest zalogowany do systemu Windows.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Environment.UserName%2A> właściwość do identyfikacji użytkownika w bieżącym wątku do systemu i aplikacji do celów zabezpieczeń lub dostępu. Również można ją dostosować konkretnej aplikacji dla każdego użytkownika.  
  
 <xref:System.Environment.UserName%2A> Właściwości opakowuje wywołanie systemu Windows [GetUserName](http://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) funkcji. Poświadczenia konta domeny dla użytkownika są sformatowane jako nazwa domeny użytkownika, '\\' znaków, a nazwa użytkownika. Użyj <xref:System.Environment.UserDomainName%2A> właściwości można uzyskać nazwy domeny użytkownika i <xref:System.Environment.UserName%2A> właściwości można uzyskać nazwy użytkownika.  
  
 Jeśli aplikacja ASP.NET działa w środowisku projektowania <xref:System.Environment.UserName%2A> właściwość zwraca nazwę bieżącego użytkownika. W opublikowanej aplikacji ASP.NET ta właściwość zwraca nazwę konta puli aplikacji (na przykład domyślnej puli aplikacji).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono nazwę osoby, która uruchomiła bieżącego wątku.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do odczytu do zmiennej środowiskowej nazwy użytkownika. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Version" /> obiekt, który zawiera opis głównych i pomocniczych, kompilacji i numeru wydania aparatu plików wykonywalnych języka wspólnego.</summary>
        <value>Obiekt, który wyświetla wersję środowiska CLR.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla wersji .NET Framework 4, 4.5.1, 4.5 i 4.5.2 <xref:System.Environment.Version%2A?displayProperty=nameWithType> zwraca <xref:System.Version> obiektu, którego reprezentacji ciągu ma postać `4.0.30319.xxxxx`. .NET Framework 4.6 i nowszymi wersjami, składa się z formularza `4.0.30319.42000`.  
  
> [!WARNING]
>  Dla [!INCLUDE[net_v45](~/includes/net-v45-md.md)] i później, nie zaleca się przy użyciu <xref:System.Environment.Version%2A> właściwość, aby wykryć wersji środowiska uruchomieniowego; zamiast tego można określić wersji środowiska CLR, badając rejestru. Aby uzyskać więcej informacji, zobacz [porady: ustalić, które .NET Framework są zainstalowane wersje](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md).  
  
 Aby uzyskać więcej informacji na temat wersji środowiska CLR zainstalowanego przez poszczególne wersje programu .NET Framework, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wersji środowiska CLR. (Wersja został pominięty z przykładowe dane wyjściowe ze względów bezpieczeństwa).  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci fizycznej mapowane do kontekstu procesu.</summary>
        <value>64-bitowa liczba całkowita zawierającą liczbę bajtów pamięci fizycznej mapowane do kontekstu procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono rozmiar zestawu roboczego tego komputera, na którym jest uruchamiany przykładowy kod.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do zasobów chronionych przez to uprawnienie. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
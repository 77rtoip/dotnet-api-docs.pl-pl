<Type Name="Environment" FullName="System.Environment">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7d07d5b8d5acb5d93066c194be4f73df31196c16" /><Meta Name="ms.sourcegitcommit" Value="8544f14c8194a55eb22d46721b0bbe46f345c063" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/21/2019" /><Meta Name="ms.locfileid" Value="69668132" /></Metadata><TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera informacje o tym, jak i sposobach manipulowania bieżącym środowiskiem i platformą. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment> Użyj klasy, aby pobrać informacje takie jak argumenty wiersza polecenia, kod zakończenia, ustawienia zmiennej środowiskowej, zawartość stosu wywołań, czas od ostatniego rozruchu systemu i wersja środowiska uruchomieniowego języka wspólnego.  
  
   
  
## Examples  
 Poniższy przykład ilustruje Wyświetlanie listy informacji o bieżącym środowisku.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wiersz polecenia dla tego procesu.</summary>
        <value>Ciąg zawierający argumenty wiersza polecenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia dostęp do nazwy programu i wszystkich argumentów określonych w wierszu polecenia, gdy bieżący proces został uruchomiony.  
  
 Nazwa programu może zawierać informacje o ścieżce, ale nie jest to wymagane. <xref:System.Environment.GetCommandLineArgs%2A> Użyj metody, aby pobrać informacje z wiersza polecenia przeanalizowane i zapisane w tablicy ciągów.  
  
 Maksymalny rozmiar buforu wiersza polecenia nie jest ustawiony na określoną liczbę znaków; zależy to od systemu operacyjnego Windows, który jest uruchomiony na komputerze.  
  
   
  
## Examples  
 Poniższy przykład wyświetla własny wiersz polecenia.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">w przypadku dostępu do odczytu do zmiennej środowiskowej PATH. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia w pełni kwalifikowaną ścieżkę bieżącego katalogu roboczego.</summary>
        <value>Ciąg zawierający ścieżkę katalogu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Według definicji, jeśli ten proces jest uruchamiany w katalogu głównym dysku lokalnego lub sieciowego, wartość tej właściwości jest nazwą dysku, po którym następuje końcowy ukośnik (na przykład "C:\\"). Jeśli ten proces rozpocznie się w podkatalogu, wartość tej właściwości jest ścieżką dysku i podkatalogu, bez końcowego ukośnika (na przykład "C:\mySubDirectory").  
  
   
  
## Examples  
 Poniższy przykład demonstruje ustawienie <xref:System.Environment.CurrentDirectory%2A> właściwości.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podjęto próbę ustawienia pustego ciągu ("").</exception>
        <exception cref="T:System.ArgumentNullException">Podjęto próbę ustawienia<see langword="null." /></exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Podjęto próbę ustawienia ścieżki lokalnej, której nie można znaleźć.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma odpowiednich uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do zapisu w plikach lub katalogach w operacji zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji w samej ścieżce w operacji pobierania. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator bieżącego wątku zarządzanego.</summary>
        <value>Liczba całkowita reprezentująca unikatowy identyfikator dla tego wątku zarządzanego.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Diagnostics.CodeAnalysis.DoesNotReturn</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="exitCode">Kod zakończenia, który ma zostać zwrócony do systemu operacyjnego. Użyj 0 (zero), aby wskazać, że proces został ukończony pomyślnie.</param>
        <summary>Kończy ten proces i zwraca kod zakończenia do systemu operacyjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `exitCode` Dla parametru należy użyć niezerowej liczby, aby wskazać błąd. W aplikacji można zdefiniować własne kody błędów w wyliczeniu i zwrócić odpowiedni kod błędu w oparciu o scenariusz. Na przykład Zwróć wartość 1, aby wskazać, że wymagany plik nie istnieje i wartość 2, aby wskazać, że plik ma zły format. Aby zapoznać się z listą kodów zakończenia używanych przez system operacyjny Windows, zobacz [kody błędów systemu](https://msdn.microsoft.com/library/ms681381.aspx) w dokumentacji systemu Windows.  
  
 Wywołanie metody różni się od używania `return` instrukcji języka programowania w następujący sposób: <xref:System.Environment.Exit%2A>  
  
-   <xref:System.Environment.Exit%2A>zawsze kończy działanie aplikacji. Użycie instrukcji może spowodować zakończenie aplikacji tylko wtedy, gdy jest używana w punkcie wejścia aplikacji, na przykład `Main` w metodzie. `return`  
  
-   <xref:System.Environment.Exit%2A>natychmiast kończy działanie aplikacji, nawet jeśli są uruchomione inne wątki. `return` Jeśli instrukcja jest wywoływana w punkcie wejścia aplikacji, powoduje przerwanie działania aplikacji dopiero po zakończeniu wszystkich wątków pierwszego planu.  
  
-   <xref:System.Environment.Exit%2A>wymaga, aby obiekt wywołujący miał uprawnienia do wywoływania kodu niezarządzanego. `return` Instrukcja nie jest.  
  
-   Jeśli <xref:System.Environment.Exit%2A> jest wywoływana `try` z bloku lub `catch` , kod w dowolnym `finally` bloku nie jest wykonywany. Jeśli instrukcja jest używana, kod `finally` w bloku jest wykonywany. `return`  
  
-   Jeśli <xref:System.Environment.Exit%2A> jest wywoływana, gdy jest uruchomiony kod w [ograniczonym regionie wykonywania](~/docs/framework/performance/constrained-execution-regions.md) (CER), CER nie zostanie ukończone. Jeśli zostanie użyta instrukcja, program CER kończy wykonywanie. `return`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wystarczających uprawnień zabezpieczeń do wykonania tej funkcji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływania niezarządzanego kodu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kod zakończenia procesu.</summary>
        <value>32-bitowa liczba całkowita ze znakiem, która zawiera kod zakończenia. Wartość domyślna to 0 (zero), co oznacza, że proces został ukończony pomyślnie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli metoda zwraca `void`metodę, można użyć tej właściwości do ustawienia kodu zakończenia, który będzie zwracany do środowiska wywołującego. `Main` Jeśli `Main` nie zwraca `void`, ta właściwość jest ignorowana. Początkowa wartość tej właściwości jest równa zero.  
  
> [!WARNING]
>  <xref:System.Environment.ExitCode%2A> Właściwość jest podpisaną 32-bitową liczbą całkowitą. Aby zapobiec zwracaniu przez właściwość ujemnego kodu zakończenia, nie należy używać wartości większych ani równych 0x80000000.  
  
 Użyj wartości innej niż zero, aby wskazać błąd. W aplikacji można zdefiniować własne kody błędów w wyliczeniu i zwrócić odpowiedni kod błędu w oparciu o scenariusz. Na przykład Zwróć wartość 1, aby wskazać, że wymagany plik nie istnieje i wartość 2, aby wskazać, że plik jest w niewłaściwym formacie. Aby zapoznać się z listą kodów zakończenia używanych przez system operacyjny Windows, zobacz [kody błędów systemu](https://msdn.microsoft.com/library/ms681381\(v=vs.85\)) w dokumentacji systemu Windows.  
  
   
  
## Examples  
 Poniżej znajduje się prosta aplikacja o nazwie Double. exe, która podwaja wartość całkowitą przekazaną do niej jako argument wiersza polecenia. Wartość przypisuje kody błędów do <xref:System.Environment.ExitCode%2A> właściwości w celu wskazania warunków błędu. Należy pamiętać, że należy dodać odwołanie do zestawu System. Numerics. dll, aby pomyślnie skompilować przykład.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 Przykład można wywołać z pliku wsadowego, takiego jak następujące, co sprawia, że kody błędów są dostępne za pomocą `ERRORLEVEL` polecenia.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 Poniżej przedstawiono niektóre przykładowe dane wyjściowe generowane przez wywołanie pliku wsadowego.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Należy zauważyć, że kod dla programu Double. exe jest identyczny w funkcji w poniższym przykładzie, z tą różnicą, że `Main` dawno definiuje punkt wejścia o nazwie, który nie zwraca wartości, a `Main` w tym przykładzie definiuje punkt wejścia o nazwie, który zwraca liczbę całkowitą.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwy zero lub więcej zmiennych środowiskowych. Każda zmienna środowiskowa jest podawana przy użyciu znaku procentu (%).</param>
        <summary>Zamienia nazwę każdej zmiennej środowiskowej osadzone w określonym ciągu z odpowiednikiem ciągu wartości zmiennej, a następnie zwraca ciąg wynikowy.</summary>
        <returns>Ciąg z każdą zmienną środowiskową zastępowaną przez jej wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Międzyoperacyjność COM służy do pobierania zmiennych środowiskowych z systemu operacyjnego. Jeśli nie można pobrać zmiennych środowiskowych z powodu błędu COM, HRESULT, który wyjaśnia przyczynę niepowodzenia, jest używany do generowania jednego z kilku możliwych wyjątków. oznacza to, że wyjątek zależy od HRESULT. Aby uzyskać więcej informacji na temat sposobu przetwarzania HRESULT, zobacz sekcję <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> uwagi metody.  
  
 Zastąpienie występuje tylko w przypadku zmiennych środowiskowych, które są ustawione. Załóżmy na przykład, że `name` jest to "MyENV =% MyENV%". Jeśli zmienna środowiskowa, MyENV, jest ustawiona na 42, Metoda ta zwraca wartość "MyENV = 42". Jeśli MyENV nie jest ustawiona, zmiany nie są wykonywane; Ta metoda zwraca wartość "MyENV =% MyENV%".  
  
 Rozmiar zwracanej wartości jest ograniczony do 32 KB.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak uzyskać system dyskowy i zmienne główne systemu.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">możliwość uzyskania dostępu do zmiennych środowiskowych w programie <paramref name="name" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Natychmiast kończy proces po zapisaniu komunikatu w dzienniku zdarzeń aplikacji systemu Windows, a następnie zawiera komunikat i opcjonalne informacje o wyjątku w raportowaniu błędów do firmy Microsoft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Diagnostics.CodeAnalysis.DoesNotReturn</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat objaśniający, dlaczego proces został zakończony, lub <see langword="null" /> Jeśli nie podano wyjaśnień.</param>
        <summary>Natychmiast kończy proces po zapisaniu komunikatu w dzienniku zdarzeń aplikacji systemu Windows, a następnie zawiera komunikat w raporcie o błędach do firmy Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przerywa proces bez uruchamiania żadnych aktywnych `try` / `finally` bloków lub finalizatorów.
  
 `Environment.FailFast` Metoda`message` zapisuje ciąg w dzienniku zdarzeń aplikacji systemu Windows, tworzy zrzut aplikacji, a następnie kończy bieżący proces. Ten `message` ciąg jest również uwzględniony w raportowaniu błędów do firmy Microsoft.  
  
 `try` `finally` / Użyj metody zamiast metody, <xref:System.Environment.Exit%2A> aby przerwać swoją aplikację, jeśli stan aplikacji jest uszkodzony niż naprawa i wykonywanie bloków i finalizatorów aplikacji `Environment.FailFast` spowoduje uszkodzenie zasobów programu.  
  
 Informacje są zgłaszane do firmy Microsoft przy użyciu Raportowanie błędów systemu Windows. Aby uzyskać więcej informacji, [zobacz Raportowanie błędów systemu Windows: Wprowadzenie](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  

Wywołanie metody, aby zakończyć wykonywanie aplikacji uruchomionej w debugerze programu Visual Studio, <xref:System.ExecutionEngineException> zgłasza i automatycznie wyzwala [fatalExecutionEngineError Managed Debug Assistant (MDA)](https://github.com/dotnet/docs/blob/master/docs/framework/debug-trace-profile/fatalexecutionengineerror-mda.md). `Environment.FailFast`
  
## Examples  
 Poniższy przykład zapisuje wpis dziennika w dzienniku zdarzeń aplikacji systemu Windows i kończy bieżący proces.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Diagnostics.CodeAnalysis.DoesNotReturn</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exception" Type="System.Exception" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat objaśniający, dlaczego proces został zakończony, lub <see langword="null" /> Jeśli nie podano wyjaśnień.</param>
        <param name="exception">Wyjątek, który reprezentuje błąd, który spowodował zakończenie. Zwykle jest to wyjątek w <see langword="catch" /> bloku.</param>
        <summary>Natychmiast kończy proces po zapisaniu komunikatu w dzienniku zdarzeń aplikacji systemu Windows, a następnie zawiera informacje o komunikatach i wyjątku w raporcie o błędach do firmy Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przerywa proces bez uruchamiania żadnych aktywnych `try` / `finally` bloków lub finalizatorów.  
  
 `Environment.FailFast` Metoda`message` zapisuje ciąg w dzienniku zdarzeń aplikacji systemu Windows, tworzy zrzut aplikacji, a następnie kończy bieżący proces.  
  
 Informacje są zgłaszane do firmy Microsoft przy użyciu Raportowanie błędów systemu Windows. Aby uzyskać więcej informacji, [zobacz Raportowanie błędów systemu Windows: Wprowadzenie](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Raportowanie błędów do firmy Microsoft `message` obejmuje `exception` i informacje, które zawierają szczegółowe informacje służące do klasyfikowania błędu. Chociaż `exception` nie jest obsługiwany, ponieważ proces jest zakończony, informacje kontekstowe, które spowodowały wyjątek, nadal są uzyskiwane.  
  
 Jeśli `exception` `exception` <xref:System.Environment.FailFast%28System.String%29> jest `null`, lub jeśli nie zostanie zgłoszony, ta metoda działa tak samo jak Przeciążenie metody.  
  
 `try` `finally` / Użyj metody zamiast metody, <xref:System.Environment.Exit%2A> aby przerwać swoją aplikację, jeśli stan aplikacji jest uszkodzony niż naprawa i wykonywanie bloków i finalizatorów aplikacji `Environment.FailFast` spowoduje uszkodzenie zasobów programu.  

Wywołanie metody, aby zakończyć wykonywanie aplikacji uruchomionej w debugerze programu Visual Studio, <xref:System.ExecutionEngineException> zgłasza i automatycznie wyzwala [fatalExecutionEngineError Managed Debug Assistant (MDA)](https://github.com/dotnet/docs/blob/master/docs/framework/debug-trace-profile/fatalexecutionengineerror-mda.md). `Environment.FailFast`
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę ciągów zawierającą argumenty wiersza polecenia dla bieżącego procesu.</summary>
        <returns>Tablica ciągu, w którym każdy element zawiera argument wiersza polecenia. Pierwszy element jest nazwą pliku wykonywalnego, a poniższe zero lub więcej elementów zawiera pozostałe argumenty wiersza polecenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwszy element w tablicy zawiera nazwę pliku programu wykonującego. Jeśli nazwa pliku jest niedostępna, pierwszy element jest równa <xref:System.String.Empty?displayProperty=nameWithType>. Pozostałe elementy zawierają dodatkowe tokeny wprowadzone w wierszu polecenia.  
  
 Nazwa pliku programu może, ale nie musi, zawierać informacje o ścieżce.  
  
 Argumenty wiersza polecenia są rozdzielone spacjami. Możesz użyć podwójnego cudzysłowu ("), aby uwzględnić spacje w argumencie. Jednak znak pojedynczego cudzysłowu (') nie zapewnia tej funkcji.  
  
 Jeśli podwójny cudzysłów następuje po dwóch lub parzystej liczbie kresek ułamkowych odwróconych, każda para odwróconych ukośników jest zastępowana przez jeden ukośnik odwrotny, a cudzysłów zostaje usunięty. Jeśli podwójny cudzysłów jest po nieparzystej liczbie ukośników odwrotnych, w tym tylko jeden, każda z poprzednich par jest zastępowana jedną kreską ułamkową odwróconą i pozostały ukośnik odwrotny jest usuwany; Jednak w tym przypadku podwójny cudzysłów nie jest usuwany.  
  
 W poniższej tabeli pokazano, jak argumenty wiersza polecenia mogą być rozdzielane i zakładane `MyApp` jako aktualnie wykonywane aplikacje.  
  
|Dane wejściowe w wierszu polecenia|Wyniki argumentów wiersza polecenia|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Aby uzyskać wiersz polecenia jako pojedynczy ciąg, użyj <xref:System.Environment.CommandLine%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład wyświetla argumenty wiersza polecenia aplikacji.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">System nie obsługuje argumentów wiersza polecenia.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">w przypadku dostępu do odczytu do zmiennej środowiskowej PATH. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość zmiennej środowiskowej.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Nazwa zmiennej środowiskowej.</param>
        <summary>Pobiera wartość zmiennej środowiskowej z bieżącego procesu.</summary>
        <returns>Wartość zmiennej środowiskowej określona przez <paramref name="variable" />, lub <see langword="null" /> Jeśli zmienna środowiskowa nie została znaleziona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Environment.GetEnvironmentVariable%28System.String%29> Metoda pobiera zmienną środowiskową z bloku środowiska tylko dla bieżącego procesu. Jest równoważne wywołaniu <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> metody `target` z wartością <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. 

Aby pobrać wszystkie zmienne środowiskowe wraz z ich wartościami, wywołaj <xref:System.Environment.GetEnvironmentVariables%2A> metodę.  
  
W nazwach zmiennych środowiskowych jest rozróżniana wielkość liter w systemach Linux i macOS, ale nie jest uwzględniana wielkość liter w systemie Windows.  
 
### <a name="on-windows-systems"></a>W systemach Windows

 W systemach Windows, blok środowiska bieżącego procesu obejmuje:
 
- Wszystkie zmienne środowiskowe, które są do niego dostarczane przez proces nadrzędny, który go utworzył. Na przykład aplikacja .NET uruchomiona z okna konsoli dziedziczy wszystkie zmienne środowiskowe okna konsoli. 

  Jeśli nie ma żadnego procesu nadrzędnego, zamiast nich używane są zmienne środowiskowe dla poszczególnych maszyn i użytkowników. Na przykład nowe okno konsoli ma wszystkie zmienne środowiskowe dla poszczególnych maszyn i poszczególnych użytkowników zdefiniowane w momencie uruchomienia.

- Wszelkie zmienne dodawane do bloku procesu, gdy proces jest uruchomiony przez <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> wywołanie metody <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> lub <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>metody z `target` wartością. Te zmienne środowiskowe pozostają do momentu zakończenia działania aplikacji .NET.  
  
Jeśli zmienne środowiskowe są tworzone po rozpoczęciu procesu, można użyć tej metody do pobrania tylko tych zmiennych, które zostały utworzone przez wywołanie <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metody <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> lub metody z `target` wartością.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  

### <a name="on-macos-and-linux-systems"></a>W systemach macOS i Linux

W systemach macOS i Linux blok środowiska bieżącego przetworzyć zawiera następujące zmienne środowiskowe:

- Wszystkie zmienne środowiskowe, które są do niego dostarczane przez proces nadrzędny, który go utworzył. W przypadku aplikacji .NET uruchomionych z poziomu powłoki obejmuje to wszystkie zmienne środowiskowe zdefiniowane w powłoce.

- Wszelkie zmienne dodawane do bloku procesu, gdy proces jest uruchomiony przez <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> wywołanie metody <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> lub <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>metody z `target` wartością. Te zmienne środowiskowe pozostają do momentu zakończenia działania aplikacji .NET.  

Platforma .NET Core w systemach macOS i Linux nie obsługuje zmiennych środowiskowych dla poszczególnych maszyn ani użytkowników.   
  
## Examples  
 Poniższy przykład używa <xref:System.Environment.GetEnvironmentVariable%2A> metody do `windir` pobierania zmiennej środowiskowej, która zawiera ścieżkę katalogu systemu Windows.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 Poniższy przykład próbuje pobrać wartość zmiennej środowiskowej o nazwie `Test1` z bloku środowiska przetwarzania. Jeśli zmienna nie istnieje, przykład tworzy i pobiera jej wartość. Przykład wyświetla wartość zmiennej. Jeśli przykładem została utworzona zmienna, wywołuje <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> również metodę z każdym elementem członkowskim <xref:System.EnvironmentVariableTarget> wyliczenia, aby określić, że zmienna może być pobierana tylko z bieżącego bloku środowiska przetwarzania. Na koniec, jeśli przykład utworzył zmienną, usuwa ją.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby można było odczytać wartość <paramref name="variable" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="variable">Nazwa zmiennej środowiskowej.</param>
        <param name="target">Jedna z <see cref="T:System.EnvironmentVariableTarget" /> wartości. Obsługiwane <see cref="F:System.EnvironmentVariableTarget.Process" /> tylko w programie .NET Core uruchomionym w systemach opartych na systemie UNIX.</param>
        <summary>Pobiera wartość zmiennej środowiskowej z bieżącego procesu lub z klucza rejestru systemu operacyjnego Windows dla bieżącego użytkownika lub komputera lokalnego.</summary>
        <returns>Wartość zmiennej środowiskowej określona przez <paramref name="variable" /> parametry i <paramref name="target" /> lub <see langword="null" /> Jeśli zmienna środowiskowa nie zostanie znaleziona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 

Aby pobrać wszystkie zmienne środowiskowe wraz z ich wartościami, wywołaj <xref:System.Environment.GetEnvironmentVariables%2A> metodę.  
  
W nazwach zmiennych środowiskowych jest rozróżniana wielkość liter w systemach Linux i macOS, ale nie jest uwzględniana wielkość liter w systemie Windows. 

### <a name="on-windows-systems"></a>W systemach Windows

W systemie Windows `target` parametr określa, czy zmienna środowiskowa jest pobierana z bieżącego procesu, czy z klucza rejestru systemu operacyjnego Windows dla bieżącego użytkownika lub komputera lokalnego. Wszystkie zmienne środowiskowe dla poszczególnych użytkowników i poszczególnych maszyn są automatycznie kopiowane do bloku środowiska bieżącego procesu, podobnie jak inne zmienne środowiskowe, które są dostępne dla procesu nadrzędnego, który utworzył proces platformy .NET. Jednak zmienne środowiskowe dodane tylko do bloku <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> środowiska bieżącego procesu przez wywołanie metody <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> lub <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> metody z `target` wartością utrwalania tylko na czas trwania procesu.  
  
### <a name="on-macos-and-linux-systems"></a>W systemach macOS i Linux

W systemach macOS i Linux `GetEnvironmentVariable(String, EnvironmentVariableTarget)` Metoda `target` obsługuje <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> tylko wartość. Wywołania o `target` `null`wartości lub nie<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> są obsługiwane i zwracają. <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> 

Zmienne środowiskowe dla poszczególnych procesów:

- Te dziedziczone z procesu nadrzędnego, zazwyczaj powłoka używana do wywoływania `dotnet.exe` lub uruchamiania aplikacji .NET.

- Te zdefiniowane przez <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> wywołanie metody <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> lub `target` metody z wartością. <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> Te zmienne środowiskowe zachowują się `dotnet` tylko do zakończenia procesu lub aplikacji .NET.   
  
## Examples

Poniższy przykład tworzy zmienne środowiskowe dla <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>i <xref:System.EnvironmentVariableTarget.Machine> obiektów docelowych, sprawdza, czy rejestr systemu operacyjnego zawiera zmienne środowiskowe użytkownika i komputera, a następnie usuwa środowisko modyfikacj. Ponieważ platforma .NET w systemach opartych na systemie UNIX nie obsługuje zmiennych środowiskowych dla poszczególnych użytkowników i poszczególnych maszyn <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> , <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> a wartość <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> pomyślnie przechowuje zmienną środowiskową w bloku środowiska przetwarzania.

[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" />nie jest prawidłową <see cref="T:System.EnvironmentVariableTarget" /> wartością.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby można było odczytać wartość <paramref name="variable" /> parametru if <paramref name="target" /> is <see cref="F:System.EnvironmentVariableTarget.Process" /> (skojarzone Wyliczenie: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), 
lub 
Aby uzyskać pełny dostęp do zmiennych środowiskowych <see cref="F:System.EnvironmentVariableTarget.User" /> , <see cref="F:System.EnvironmentVariableTarget.Machine" /> Jeśli <paramref name="target" /> jest lub ( <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />skojarzone Wyliczenie:).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wszystkie nazwy zmiennych środowiskowych i ich wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wszystkie nazwy zmiennych środowiskowych i ich wartości z bieżącego procesu.</summary>
        <returns>Słownik zawierający wszystkie nazwy zmiennych środowiskowych i ich wartości; w przeciwnym razie, jeśli nie zostaną znalezione żadne zmienne środowiskowe, pusty słownik.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwy i wartości zmiennych środowiskowych są przechowywane jako pary klucz-wartość w zwracanym <xref:System.Collections.IDictionary>elemencie.  
  
### <a name="on-windows-systems"></a>W systemach Windows

W systemach `GetEnvironmentVariables` Windows Metoda zwraca następujące zmienne środowiskowe:
  
- Wszystkie zmienne środowiskowe dla poszczególnych maszyn, które są zdefiniowane w momencie tworzenia procesu, wraz z ich wartościami.  
  
- Wszystkie zmienne środowiskowe użytkownika, które są zdefiniowane w momencie tworzenia procesu, wraz z ich wartościami.  

- Wszystkie zmienne dziedziczone z procesu nadrzędnego, z którego aplikacja .NET została uruchomiona lub dodana do bloku procesu, gdy proces jest uruchomiony. Zmienne środowiskowe są dodawane, gdy proces jest uruchomiony <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> przez wywołanie metody <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> lub <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>metody z `target` wartością.  

### <a name="on-macos-and-linux-systems"></a>W systemach macOS i Linux

W systemach MacOS i Linux `GetEnvironmentVariables` Metoda pobiera nazwę i wartość wszystkich zmiennych środowiskowych, które są dziedziczone z procesu nadrzędnego, który `dotnet` uruchomił proces lub które są zdefiniowane `dotnet` w zakresie samego procesu. Po zakończeniu `dotnet` procesu te ostatnie zmienne środowiskowe przestają istnieć. 

Platforma .NET Core działająca w systemach z systemem UNIX nie obsługuje zmiennych środowiskowych dla poszczególnych maszyn i użytkowników.   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Environment.GetEnvironmentVariables%2A> metodę.  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <exception cref="T:System.OutOfMemoryException">Bufor ma za mało pamięci.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">możliwość odczytywania nazw i wartości zmiennych środowiskowych. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target">Jedna z <see cref="T:System.EnvironmentVariableTarget" /> wartości. Obsługiwane <see cxref="F:System.EnvironmentVariableTarget.Process" /> tylko w programie .NET Core uruchomionym w systemach z systemem UNIX.</param>
        <summary>Pobiera wszystkie nazwy zmiennych środowiskowych i ich wartości z bieżącego procesu lub z klucza rejestru systemu operacyjnego Windows dla bieżącego użytkownika lub komputera lokalnego.</summary>
        <returns>Słownik zawierający wszystkie nazwy zmiennych środowiskowych i ich wartości ze źródła określonego przez <paramref name="target" /> parametr; w przeciwnym razie, pusty słownik, jeśli nie zostaną znalezione żadne zmienne środowiskowe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Nazwy i wartości zmiennych środowiskowych są przechowywane jako pary klucz/wartość w zwracanym <xref:System.Collections.IDictionary> obiekcie.  

### <a name="on-windows-systems"></a>W systemach Windows

W systemach `target` Windows parametr określa, czy źródłem jest bieżący proces, klucz rejestru dla bieżącego użytkownika lub klucz rejestru dla komputera lokalnego.  

### <a name="on-macos-and-linux-systems"></a>W systemach macOS i Linux

W systemach macOS i Linux obsługiwana `target` <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> jest tylko wartość. Zmienne środowiskowe dla procesu są dziedziczone z procesu nadrzędnego (zazwyczaj powłoki) używanego do uruchamiania `dotnet` procesu lub są zdefiniowane w zakresie `dotnet` samego procesu. Po zakończeniu procesu dotnet te ostatnie zmienne środowiskowe przestają istnieć.  

Zmienne środowiskowe dla poszczególnych maszyn i dla użytkownika nie są obsługiwane. `target` Wartość<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> lub zwraca<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> pustą tablicę.
  
## Examples

Poniższy przykład tworzy zmienne środowiskowe dla <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>i <xref:System.EnvironmentVariableTarget.Machine> obiektów docelowych, sprawdza, czy rejestr systemu operacyjnego zawiera zmienne środowiskowe użytkownika i komputera, a następnie usuwa środowisko modyfikacj. Ponieważ platforma .NET w systemach opartych na systemie UNIX nie obsługuje zmiennych środowiskowych dla poszczególnych użytkowników i poszczególnych maszyn <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> , <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> a wartość <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> pomyślnie przechowuje zmienną środowiskową w bloku środowiska przetwarzania.

[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji dla określonej wartości <paramref name="target" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" />zawiera niedozwoloną wartość.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby można było odczytać nazwy i wartości zmiennych środowiskowych, jeśli <paramref name="target" /> jest <see cref="F:System.EnvironmentVariableTarget.Process" /> (skojarzone Wyliczenie: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), 
lub 
Aby uzyskać pełny dostęp do zmiennych środowiskowych <see cref="F:System.EnvironmentVariableTarget.User" /> , <see cref="F:System.EnvironmentVariableTarget.Machine" /> Jeśli <paramref name="target" /> jest lub ( <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />skojarzone Wyliczenie:).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera ścieżkę do specjalnego folderu systemowego, który jest identyfikowany przez określone Wyliczenie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="folder">Jedna z wartości wyliczenia, które identyfikują specjalny folder systemowy.</param>
        <summary>Pobiera ścieżkę do specjalnego folderu systemowego, który jest identyfikowany przez określone Wyliczenie.</summary>
        <returns>Ścieżka do określonego specjalnego folderu systemowego, jeśli znajduje się on na komputerze fizycznym. w przeciwnym razie, pusty ciąg ("").  
  
 Folder nie będzie fizycznie istnieć, jeśli nie został on utworzony przez system operacyjny, istniejący folder został usunięty lub folder jest katalogiem wirtualnym, takim jak mój komputer, który nie odpowiada ścieżce fizycznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera ścieżkę do specjalnego folderu systemowego, na przykład plików programu, programów, systemu lub uruchamiania, które mogą być używane do uzyskiwania dostępu do typowych informacji. Foldery specjalne są ustawiane domyślnie przez system lub jawnie przez użytkownika podczas instalowania wersji systemu Windows.  
  
 Parametr określa folder specjalny do pobrania i musi być jedną z wartości <xref:System.Environment.SpecialFolder> w wyliczeniu; jakakolwiek inna wartość zgłasza wyjątek. `folder`  
  
 Aby uzyskać więcej informacji na temat folderów specjalnych, zobacz temat wartości [identyfikatora CSid](https://go.microsoft.com/fwlink/?LinkId=116664) .  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Environment.GetFolderPath%2A> metody do zwracania i wyświetlania ścieżki skojarzonej `folder` z parametrem.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" />nie jest członkiem <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżąca platforma nie jest obsługiwana.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji w samej ścieżce. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="folder">Jedna z wartości wyliczenia, które identyfikują specjalny folder systemowy.</param>
        <param name="option">Jedna z wartości wyliczenia, która określa opcje, które mają być używane do uzyskiwania dostępu do folderu specjalnego.</param>
        <summary>Pobiera ścieżkę do specjalnego folderu systemowego, który jest identyfikowany przez określone Wyliczenie, i używa określonej opcji dostępu do folderów specjalnych.</summary>
        <returns>Ścieżka do określonego specjalnego folderu systemowego, jeśli znajduje się on na komputerze fizycznym. w przeciwnym razie, pusty ciąg ("").  
  
 Folder nie będzie fizycznie istnieć, jeśli nie został on utworzony przez system operacyjny, istniejący folder został usunięty lub folder jest katalogiem wirtualnym, takim jak mój komputer, który nie odpowiada ścieżce fizycznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera ścieżkę do specjalnego folderu systemowego, na przykład plików programu, programów, systemu lub uruchamiania, które mogą być używane do uzyskiwania dostępu do typowych informacji. Foldery specjalne są ustawiane domyślnie przez system lub jawnie przez użytkownika podczas instalowania wersji systemu Windows.  
  
 Parametr określa folder specjalny do pobrania i musi być jedną z wartości <xref:System.Environment.SpecialFolder> w wyliczeniu; jakakolwiek inna wartość zgłasza wyjątek. `folder`  
  
 Aby uzyskać więcej informacji na temat folderów specjalnych, zobacz temat wartości [identyfikatora CSid](https://go.microsoft.com/fwlink/?LinkId=116664) .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" />nie jest członkiem <see cref="T:System.Environment.SpecialFolder" />.
—lub—

<paramref name="options" />nie jest członkiem <see cref="T:System.Environment.SpecialFolderOption" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżąca platforma nie jest obsługiwana.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji w samej ścieżce. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę zawierającą nazwy dysków logicznych na bieżącym komputerze.</summary>
        <returns>Tablica ciągów, w których każdy element zawiera nazwę dysku logicznego. Na przykład, jeśli dysk twardy komputera jest pierwszym dyskiem logicznym, zwracany pierwszy element to "C:\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak wyświetlić dyski logiczne bieżącego komputera za pomocą <xref:System.Environment.GetLogicalDrives%2A> metody.  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pełny dostęp do zasobu chronionego przez to uprawnienie. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy trwa zwalnianie bieżącej domeny aplikacji lub trwa wyłączanie środowiska uruchomieniowego języka wspólnego (CLR).</summary>
        <value><see langword="true" />Jeśli bieżąca domena aplikacji jest zwalniana lub trwa wyłączanie środowiska CLR; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Tylko .NET Framework**: Gdy środowisko CLR zwalnia domenę aplikacji, uruchamia finalizatory dla wszystkich obiektów, które mają metodę finalizatora w tej domenie aplikacji. Gdy środowisko CLR zostanie zamknięte, uruchamia wątek finalizatora na wszystkich obiektach, które mają metodę finalizatora. Ta <xref:System.Environment.HasShutdownStarted%2A> Właściwość zwraca `true` tylko po rozpoczęciu wątku finalizatora. Po powrocie `true`właściwości można określić, czy domena aplikacji jest usuwana, czy też środowisko CLR jest zamykane przez <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> wywołanie metody. Ta metoda zwraca `true` , jeśli finalizatory są wywoływane, ponieważ domena aplikacji jest wyładowywanie lub `false` Jeśli środowisko CLR jest zamykane.  
  
 Właściwość <xref:System.Environment.HasShutdownStarted%2A> zwraca`false` , jeśli wątek finalizatora nie został uruchomiony.  
  
 Za pomocą tej właściwości można określić, czy mają być dostępne zmienne statyczne w kodzie finalizacji. Jeśli aplikacja lub środowisko CLR jest zamykane, nie można w sposób niezawodny uzyskać dostępu do żadnego obiektu, który ma metodę finalizacji i który jest przywoływany przez pole statyczne. Wynika to z faktu, że te obiekty mogły już zostać sfinalizowane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy bieżący system operacyjny jest 64-bitowym systemem operacyjnym.</summary>
        <value><see langword="true" />Jeśli system operacyjny jest 64-bitowy; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy bieżący proces jest procesem 64-bitowym.</summary>
        <value><see langword="true" />Jeśli proces jest 64-bitowy; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę NetBIOS tego komputera lokalnego.</summary>
        <value>Ciąg zawierający nazwę tego komputera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa tego komputera jest określana podczas uruchamiania systemu, gdy nazwa jest odczytywana z rejestru. Jeśli ten komputer jest węzłem w klastrze, zostanie zwrócona nazwa węzła.  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę komputera, na którym jest uruchomiony przykładowy kod. (Nazwa komputera jest pomijana z przykładowych danych wyjściowych ze względów bezpieczeństwa).  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można uzyskać nazwy tego komputera.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">w przypadku dostępu do odczytu do zmiennej środowiskowej COMPUTERNAME. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg nowego wiersza zdefiniowany dla tego środowiska.</summary>
        <value>Ciąg zawierający "\r\n" dla platform innych niż UNIX lub ciąg zawierający "\n" dla platform UNIX.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Environment.NewLine%2A> właściwości jest stałą dostosowaną specyficzną dla bieżącej platformy i implementacji .NET Framework. Aby uzyskać więcej informacji na temat znaków ucieczki w wartości właściwości, zobacz [znak ucieczki](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 Funkcja udostępniana przez <xref:System.Environment.NewLine%2A> jest często to, czego dotyczy wiersz wiersza warunków, wysuw wiersza, podział wiersza, powrotu karetki, znaku CRLF i końca wiersza.  
  
 <xref:System.Environment.NewLine%2A>może być używany w połączeniu z obsługą nowego wiersza dla określonego języka, takich jak znaki ucieczki "\r" i "\n C# " w firmieC++Microsoft i `vbCrLf` C/lub w programie Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A>jest automatycznie dołączany do tekstu przetworzonego <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> przez <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metody i.  
  
   
  
## Examples  
 Poniższy przykład wyświetla trzy wiersze oddzielone znakami nowego wiersza.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.OperatingSystem" /> Pobiera obiekt, który zawiera bieżący identyfikator platformy i numer wersji.</summary>
        <value>Obiekt, który zawiera identyfikator platformy i numer wersji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`Environment.OSVersion` Właściwość nie zapewnia niezawodnego sposobu zidentyfikowania dokładnego systemu operacyjnego i jego wersji. W związku z tym nie zaleca się korzystania z tej metody. INSTEAD 

- Aby zidentyfikować platformę systemu operacyjnego, użyj <xref:System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform%2A?displayProperty=nameWithType> metody. 

- Należy unikać pisania kodu, który zależy od zgłoszonej wersji systemu operacyjnego. Zamiast tego Sprawdź dostępność funkcji wymaganych przez aplikację.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość nie może uzyskać wersji systemowej.  
  
—lub— 
Otrzymany identyfikator platformy nie jest elementem członkowskim<see cref="T:System.PlatformID" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę procesorów na bieżącym komputerze.</summary>
        <value>32-bitowa liczba całkowita ze znakiem, która określa liczbę procesorów na bieżącym komputerze. Nie jest to ustawienie domyślne. Jeśli bieżąca maszyna zawiera wiele grup procesorów, ta właściwość zwraca liczbę procesorów logicznych, które są dostępne do użycia przez środowisko uruchomieniowe języka wspólnego (CLR).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat grup procesorów i procesorów logicznych, zobacz [grupy procesorów](https://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Environment.ProcessorCount%2A> właściwość.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy, modyfikuje lub usuwa zmienną środowiskową.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Nazwa zmiennej środowiskowej.</param>
        <param name="value">Wartość do przypisania <paramref name="variable" />.</param>
        <summary>Tworzy, modyfikuje lub usuwa zmienną środowiskową przechowywaną w bieżącym procesie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest równoznaczne z wywołaniem <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> przeciążenia z <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> wartością dla `target` argumentu.  
  
 Jeśli argument nie jest pusty (zobacz Omówienie usuwania zmiennej środowiskowej w dalszej części tej sekcji dla definicji pustej wartości) i zmienna środowiskowa o nazwie `variable` parametru nie istnieje, środowisko `value` zmienna została utworzona i przypisana do niej `value`zawartość. Jeśli istnieje, jego wartość jest modyfikowana. Ponieważ zmienna środowiskowa jest zdefiniowana w bloku środowiska bieżącego procesu, nie jest zachowywana po zakończeniu procesu.  
  
 Jeśli `variable` zawiera niepoczątkowy znak zera szesnastkowego, znaki przed znakiem zero są uznawane za nazwę zmiennej środowiskowej i wszystkie kolejne znaki są ignorowane.  
  
 Jeśli `value` zawiera niepoczątkowy znak zera szesnastkowego, znaki przed znakiem zero są przypisywane do zmiennej środowiskowej i wszystkie kolejne znaki są ignorowane.  
  
 Jeśli `value` jest pusty, a zmienna środowiskowa `variable` o nazwie istnieje, zmienna środowiskowa jest usuwana. Jeśli `variable` nie istnieje, żaden błąd nie występuje, mimo że nie można wykonać operacji. `value`jest uznawany za pusty w ramach jednego z następujących warunków:  
  
-   Jest to `null`.  
  
-   Jest to <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Składa się z pojedynczego znaku, którego wartością jest U + 0000.  
  
## Examples

Poniższy przykład próbuje pobrać wartość zmiennej środowiskowej o nazwie `Test1` z bloku środowiska przetwarzania. Jeśli zmienna nie istnieje, przykład tworzy zmienną i pobiera jej wartość. Przykład wyświetla wartość zmiennej. W przypadku implementacji platformy .NET działających w systemach Windows wywołuje <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> ona również metodę z każdym elementem członkowskim <xref:System.EnvironmentVariableTarget> wyliczenia w celu ustalenia, czy zmienna może być pobierana tylko z bieżącego bloku środowiska przetwarzania. (Implementacje .NET w systemach opartych na systemie UNIX obsługują tylko zmienne w bloku środowiska przetwarzania). Na koniec, jeśli przykład utworzył zmienną, usuwa ją.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" />zawiera ciąg o zerowej długości, początkowy szesnastkowy znak zera (0x00) lub znak równości ("=").  
  
—lub— 
Długość <paramref name="variable" /> lub<paramref name="value" /> jest większa lub równa 32 767 znaków.  
  
—lub— 
Wystąpił błąd podczas wykonywania tej operacji.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pełny dostęp do zmiennych środowiskowych. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="variable">Nazwa zmiennej środowiskowej.</param>
        <param name="value">Wartość do przypisania <paramref name="variable" />.</param>
        <param name="target">Jedna z wartości wyliczenia, która określa lokalizację zmiennej środowiskowej.</param>
        <summary>Tworzy, modyfikuje lub usuwa zmienną środowiskową przechowywaną w bieżącym procesie lub w kluczu rejestru systemu operacyjnego Windows zarezerwowanym dla bieżącego użytkownika lub komputera lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Metoda pozwala zdefiniować zmienną środowiskową, która jest dostępna dla bieżącego procesu <xref:System.EnvironmentVariableTarget.Process> (wartość). <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Zmienne środowiskowe, które są unikatowe dla bieżącego bloku środowiska procesu, zachowują się tylko do momentu zakończenia procesu.

Ponadto tylko <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> w systemach Windows Metoda pozwala zdefiniować zmienną środowiskową, która jest dostępna dla wszystkich procesów uruchomionych na komputerze <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> (wartość) i dla wszystkich procesów uruchamianych <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> przez użytkownika (wartość). Zmienne środowiskowe dla poszczególnych maszyn i poszczególnych użytkowników są kopiowane do bloku środowiska bieżącego procesu.  
 
W przypadku platformy .NET Core w systemach macOS i Linux wywołania <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metody z <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> wartością lub <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> są ignorowane. 
  
 Jeśli argument nie jest pusty (zobacz Omówienie usuwania zmiennej środowiskowej w dalszej części tej sekcji dla definicji pustej wartości) i zmienna środowiskowa o nazwie `variable` argument nie istnieje, środowisko `value` zmienna została utworzona i przypisana do niej `value`zawartość.  Jeśli istnieje, jego wartość jest modyfikowana.  
  
 Jeśli `variable` zawiera niepoczątkowy znak zera szesnastkowego, znaki przed znakiem zero są uznawane za nazwę zmiennej środowiskowej i wszystkie kolejne znaki są ignorowane.  
  
 Jeśli `value` zawiera niepoczątkowy znak zera szesnastkowego, znaki przed znakiem zero są przypisywane do zmiennej środowiskowej i wszystkie kolejne znaki są ignorowane.  
  
 Jeśli `value` jest pusty, a zmienna środowiskowa `variable` o nazwie istnieje, zmienna środowiskowa jest usuwana. `value`jest uznawany za pusty w ramach jednego z następujących warunków:  
  
-   Jest to `null`.  
  
-   Jest to <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Składa się z pojedynczego znaku, którego wartością jest U + 0000.  
  
 Jeśli `variable` nie istnieje, błąd nie występuje, chociaż nie można wykonać operacji. Należy zachować `target` ostrożność <xref:System.EnvironmentVariableTarget.Machine>, ponieważ można przypadkowo usunąć zmienną środowiskową, która ma wpływ na całą maszynę lokalną, a nie tylko na bieżący proces lub użytkownika.  

### <a name="environmentvariabletargetmachine-and-environmentvariabletargetuser-on-windows-systems"></a>EnvironmentVariableTarget. Machine i EnvironmentVariableTarget. User w systemach Windows

Jeśli `target` jest<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, zmienna środowiskowa jest przechowywana w kluczu HKEY_CURRENT_USER\Environment rejestru komputera lokalnego. Jest również kopiowany do wystąpień Eksploratora plików, które są uruchomione jako bieżący użytkownik. Zmienna środowiskowa jest następnie dziedziczona przez nowe procesy uruchamiane przez użytkownika z Eksploratora plików.  
  
 Podobnie, jeśli `target` jest <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, zmienna środowiskowa jest przechowywana w kluczu HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment rejestru komputera lokalnego. Jest również kopiowany do wszystkich wystąpień Eksploratora plików. Zmienna środowiskowa jest następnie dziedziczona przez nowe procesy, które są uruchamiane z Eksploratora plików.  
  
 Jeśli `target` jest <xref:System.EnvironmentVariableTarget.User> `WM_SETTINGCHANGE` lub ,inneaplikacjesąpowiadamianeooperacjiustawianiaprzezkomunikatsystemuWindows.<xref:System.EnvironmentVariableTarget.Machine>  
  
 Jeśli `target` jest <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> `value` lub ,<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>zalecamy, aby długość była mniejsza niż 2048 znaków.  
  
## Examples

Poniższy przykład tworzy zmienne środowiskowe dla <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>i <xref:System.EnvironmentVariableTarget.Machine> obiektów docelowych, sprawdza, czy rejestr systemu operacyjnego zawiera zmienne środowiskowe użytkownika i komputera, a następnie usuwa środowisko modyfikacj. Ponieważ platforma .NET w systemach opartych na systemie UNIX nie obsługuje zmiennych środowiskowych dla poszczególnych użytkowników i poszczególnych maszyn <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> , <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> a wartość <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> pomyślnie przechowuje zmienną środowiskową w bloku środowiska przetwarzania.
  
[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" />zawiera ciąg o zerowej długości, początkowy szesnastkowy znak zera (0x00) lub znak równości ("=").  
  
—lub— 
Długość <paramref name="variable" /> nie może przekraczać 32 767 znaków.  
  
—lub— 
 <paramref name="target" />nie jest elementem członkowskim <see cref="T:System.EnvironmentVariableTarget" /> wyliczenia.  
  
—lub— 
 <paramref name="target" />is <see cref="F:System.EnvironmentVariableTarget.Machine" /> lub <see cref="F:System.EnvironmentVariableTarget.User" /> ,adługośćjestwiększalub<paramref name="variable" /> równa 255.  
  
—lub— 
 <paramref name="target" />jest <see cref="F:System.EnvironmentVariableTarget.Process" /> i<paramref name="value" /> długość jest większa lub równa 32 767 znaków.  
  
—lub— 
Wystąpił błąd podczas wykonywania tej operacji.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pełny dostęp do zmiennych środowiskowych. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżące informacje o śledzeniu stosu.</summary>
        <value>Ciąg zawierający informacje o śledzeniu stosu. Ta wartość może być <see cref="F:System.String.Empty" />równa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.StackTrace%2A> Właściwość zawiera listę wywołań metod w odwrotnej kolejności chronologicznej, to znaczy, że ostatnie wywołanie metody jest opisane jako pierwsze, a dla każdego wywołania metody na stosie jest wyświetlana jedna linia informacji o śledzeniu stosu. <xref:System.Environment.StackTrace%2A> Jednak właściwość może nie raportować jako wiele wywołań metod zgodnie z oczekiwaniami, ponieważ przekształcenia kodu występują podczas optymalizacji.  
  
> [!NOTE]
>  Aby uzyskać hierarchiczny widok informacji o śledzeniu stosu według klasy, należy <xref:System.Diagnostics.StackTrace> użyć klasy.  
  
 <xref:System.Environment.StackTrace%2A> Właściwość formatuje informacje o śladach stosu dla każdego wywołania metody w następujący sposób:  
  
 "at `FullClassName`.`MethodName` (`MethodParams`) w `FileName` : wiersz `LineNumber` "  
  
 Literał "at" poprzedza trzy spacje, a cały podciąg rozpoczynający się od "in" jest pomijany, jeśli symbole debugowania są niedostępne. Symbole `FullClassName` `MethodName`zastępcze `MethodParams` `LineNumber`,,,, i, są zamieniane na wartości rzeczywiste i są zdefiniowane w następujący sposób: `FileName`  
  
 FullClassName  
 Pełna nazwa klasy, łącznie z przestrzenią nazw.  
  
 `MethodName`  
 Nazwa metody.  
  
 `MethodParams`  
 Lista par typu parametru/nazwy. Każda para jest oddzielona przecinkiem (","). Te informacje są pomijane, `MethodName` Jeśli nie przyjmuje żadnych parametrów.  
  
 `FileName`  
 Nazwa pliku źródłowego, w `MethodName` którym metoda jest zadeklarowana. Informacja ta jest pomijana w razie niedostępności symboli debugowania.  
  
 `LineNumber`  
 Numer wiersza, w `FileName` którym znajduje się kod źródłowy z `MethodName` dla instrukcji, która znajduje się na stosie wywołań. Informacja ta jest pomijana w razie niedostępności symboli debugowania.  
  
 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Ciąg kończy każdy wiersz śladu stosu.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Environment.StackTrace%2A> właściwość.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pełny dostęp do zasobu chronionego przez to uprawnienie. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera w pełni kwalifikowaną ścieżkę katalogu systemowego.</summary>
        <value>Ciąg zawierający ścieżkę katalogu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykładem zwracanej wartości jest ciąg "C:\WinNT\System32".  
  
   
  
## Examples  
 Poniższy przykład wyświetla katalog systemowy komputera, na którym jest uruchomiony przykładowy kod. (Katalog systemowy jest pomijany z przykładowych danych wyjściowych ze względów bezpieczeństwa).  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji w samej ścieżce. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę bajtów na stronie pamięci systemu operacyjnego.</summary>
        <value>Liczba bajtów na stronie pamięci systemowej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Te informacje mogą być przydatne podczas ustalania, <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> czy należy używać opcji podczas pracy z plikami mapowanymi w pamięci.  
  
 W systemie Windows ta wartość jest `dwPageSize` elementem członkowskim `SYSTEM_INFO` struktury.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">w celu uzyskania dostępu do zmiennych środowiskowych systemu i użytkownika. Skojarzony wyjątek: 
 <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę milisekund, które upłynęły od momentu uruchomienia systemu.</summary>
        <value>32-bitowa liczba całkowita ze znakiem, która zawiera czas (w milisekundach), który upłynął od ostatniego uruchomienia komputera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości pochodzi od czasomierza systemowego i jest przechowywana jako 32-bitowa liczba całkowita ze znakiem. Należy zwrócić uwagę, że ponieważ pochodzi ona od czasomierza systemowego, rozdzielczość <xref:System.Environment.TickCount%2A> właściwości jest ograniczona do rozdzielczości czasomierza systemu, która zazwyczaj należy do zakresu od 10 do 16 milisekund.  
  
> [!IMPORTANT]
>  Ponieważ wartość <xref:System.Environment.TickCount%2A> właściwości jest 32-bitowej podpisanej liczby całkowitej, jeśli system działa w sposób ciągły, <xref:System.Environment.TickCount%2A> zwiększy się od zera do <xref:System.Int32.MaxValue?displayProperty=nameWithType> przez około 24,9 dni, a następnie przeskoczyć do <xref:System.Int32.MinValue?displayProperty=nameWithType>, który jest liczbą ujemną, następnie zwiększ wartość zero w ciągu następnych 24,9 dni. Ten problem można obejść, wywołując funkcję Windows getGetTickCount64, która resetuje do zera po około 49,7 dniach lub przez wywołanie funkcji [](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) . [](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx)  
  
 <xref:System.Environment.TickCount%2A>różni się od <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> właściwości, czyli liczby interwałów 100-nanosekund, które upłynęły od 1/1/0001, 12:10:00.  
  
 Użyj właściwości <xref:System.DateTime.Now%2A?displayProperty=nameWithType> , aby uzyskać bieżącą lokalną datę i godzinę na tym komputerze.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak pobrać dodatni zakres wartości zwracanych przez <xref:System.Environment.TickCount%2A> właściwość. Właściwość jest przełączana między <xref:System.Int32.MinValue?displayProperty=nameWithType>, która jest liczbą ujemną i <xref:System.Int32.MaxValue?displayProperty=nameWithType> co 49,8 dni. <xref:System.Environment.TickCount%2A> Ten przykładowy kod usuwa bit znaku, aby uzyskać nieujemną liczbę, która cykluje od <xref:System.Int32.MaxValue> zera do co 24,9 dni.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TickCount64">
      <MemberSignature Language="C#" Value="public static long TickCount64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TickCount64" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount64" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long TickCount64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount64 : int64" Usage="System.Environment.TickCount64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę milisekund, które upłynęły od momentu uruchomienia systemu.</summary>
        <value>Czas, jaki upłynął od uruchomienia systemu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę domeny sieciowej skojarzoną z bieżącym użytkownikiem.</summary>
        <value>Nazwa domeny sieciowej skojarzona z bieżącym użytkownikiem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poświadczenia konta domeny dla użytkownika są formatowane jako nazwa domeny użytkownika, znak "\\" i nazwa użytkownika. Użyj właściwości, aby uzyskać nazwę domeny użytkownika bez nazwy użytkownika, <xref:System.Environment.UserName%2A> i właściwość, aby uzyskać nazwę użytkownika bez nazwy domeny. <xref:System.Environment.UserDomainName%2A>  Na przykład, jeśli nazwa domeny użytkownika i nazwa użytkownika to CORPORATENETWORK\john, <xref:System.Environment.UserDomainName%2A> Właściwość zwraca wartość "CORPORATENETWORK".  
  
 <xref:System.Environment.UserDomainName%2A> Właściwość najpierw próbuje uzyskać składnik nazwy domeny dla bieżącego użytkownika. Jeśli ta próba nie powiedzie się, ta właściwość podejmie próbę pobrania nazwy domeny skojarzonej z nazwą użytkownika <xref:System.Environment.UserName%2A> podaną przez właściwość. Jeśli próba nie powiedzie się, ponieważ komputer hosta nie jest przyłączony do domeny, zostanie zwrócona nazwa komputera hosta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny nie obsługuje pobierania nazwy domeny sieciowej.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można pobrać nazwy domeny sieciowej.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">w przypadku dostępu do odczytu do zmiennej środowiskowej USERDOMAIN. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący proces jest uruchomiony w trybie interaktywnym użytkownika.</summary>
        <value><see langword="true" />Jeśli bieżący proces jest uruchomiony w trybie interaktywnym użytkownika; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość <xref:System.Environment.UserInteractive%2A> zawiera raporty `false` dotyczące procesów systemu Windows lub usług, takich jak usługi IIS, które są uruchamiane bez interfejsu użytkownika. Jeśli ta właściwość ma `false`wartość, nie wyświetlaj modalnych okien dialogowych ani okien komunikatów, ponieważ nie ma graficznego interfejsu użytkownika, z którym użytkownik może korzystać.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, czy bieżący proces jest uruchomiony w trybie interaktywnym użytkownika.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę użytkownika osoby, która jest aktualnie zalogowana do systemu operacyjnego.</summary>
        <value>Nazwa użytkownika osoby, która jest zalogowana do systemu operacyjnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.UserName%2A> Właściwość służy do identyfikowania użytkownika w bieżącym wątku, do systemu i aplikacji w celu zapewnienia bezpieczeństwa lub dostępu. Można go również użyć do dostosowania konkretnej aplikacji dla każdego użytkownika.  
 
 W systemie Windows <xref:System.Environment.UserName%2A> Właściwość otacza wywołanie funkcji Windows GetUserName [](https://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) . Poświadczenia konta domeny dla użytkownika są formatowane jako nazwa domeny użytkownika, znak "\\" i nazwa użytkownika. Użyj właściwości, aby uzyskać nazwę domeny użytkownika <xref:System.Environment.UserName%2A> i właściwość w celu uzyskania nazwy użytkownika. <xref:System.Environment.UserDomainName%2A>  
 
 Na platformach <xref:System.Environment.UserName%2A> UNIX Właściwość otacza wywołanie `getpwuid_r` funkcji.
 
 Jeśli aplikacja ASP.NET jest uruchamiana w środowisku programistycznym, <xref:System.Environment.UserName%2A> Właściwość zwraca nazwę bieżącego użytkownika. W opublikowanej aplikacji ASP.NET ta właściwość zwraca nazwę konta puli aplikacji (na przykład Default puli aplikacji).  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę użytkownika osoby, która uruchomiła bieżący wątek.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do odczytu do zmiennej środowiskowej USERNAME. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Version" /> Pobiera obiekt opisujący główne, pomocnicze, kompilacje i numery wersji środowiska uruchomieniowego języka wspólnego.</summary>
        <value>Obiekt, który wyświetla wersję środowiska uruchomieniowego języka wspólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla .NET Framework w wersji 4, 4,5, 4.5.1 i 4.5.2 <xref:System.Environment.Version%2A?displayProperty=nameWithType> Właściwość <xref:System.Version> zwraca obiekt, którego reprezentacja ciągu zawiera formularz `4.0.30319.xxxxx`. W przypadku .NET Framework 4,6 i nowszych wersja ma postać `4.0.30319.42000`.  
  
> [!WARNING]
>  W przypadku <xref:System.Environment.Version%2A> i nowszych nie zaleca się używania właściwości w celu wykrycia wersji środowiska uruchomieniowego. zamiast tego można określić wersję środowiska uruchomieniowego języka wspólnego, badając rejestr. [!INCLUDE[net_v45](~/includes/net-v45-md.md)] Aby uzyskać więcej informacji, zobacz [jak: Ustal, które wersje .NET Framework są](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md)zainstalowane.  
  
 Aby uzyskać więcej informacji o wersji środowiska uruchomieniowego języka wspólnego, która jest zainstalowana z każdą wersją .NET Framework, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wersję środowiska uruchomieniowego języka wspólnego. (Wersja jest pomijana z przykładowych danych wyjściowych ze względów bezpieczeństwa).  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci fizycznej mapowanej na kontekst procesu.</summary>
        <value>64-bitowa liczba całkowita ze znakiem, która zawiera liczbę bajtów pamięci fizycznej zamapowanej na kontekst procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla rozmiar zestawu roboczego komputera z uruchomionym przykładem kodu.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pełny dostęp do zasobu chronionego przez to uprawnienie. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>

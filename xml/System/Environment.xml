<Type Name="Environment" FullName="System.Environment">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8f90cd75a7a7c70b077c46759736bd53d521320e" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67250296" /></Metadata><TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera informacje na temat i oznacza, że do manipulowania bieżące środowisko i platforma. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Environment> klasy do pobrania informacje, takie jak argumenty wiersza polecenia, kod zakończenia, ustawień zmiennych środowiskowych, zawartość stosu wywołań, czas od ostatniego rozruchu systemu oraz wersję środowiska uruchomieniowego języka wspólnego.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, wyświetla listę informacji o bieżącym środowisku.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wiersz polecenia dla tego procesu.</summary>
        <value>Ciąg zawierający argumenty wiersza polecenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia dostęp do nazwy programu i argumenty określone w wierszu polecenia, gdy bieżący proces został uruchomiony.  
  
 Nazwa programu mogą obejmować informacje o ścieżce, ale nie jest wymagane, aby to zrobić. Użyj <xref:System.Environment.GetCommandLineArgs%2A> metodę, aby pobrać informacje wiersza polecenia przeanalizować i przechowywane w tablicy ciągów.  
  
 Maksymalny rozmiar buforu wiersza polecenia nie jest równa określonej liczby znaków. ona różna w zależności od systemu operacyjnego Windows, który jest uruchomiony na komputerze.  
  
   
  
## Examples  
 Poniższy przykład wyświetla wiersz polecenia.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do odczytu do zmiennej środowiskowej PATH. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pełną ścieżkę bieżącego katalogu roboczego.</summary>
        <value>Ciąg zawierający ścieżkę katalogu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgodnie z definicją, jeśli ten proces, który rozpoczyna się w katalogu głównym zmiennej lokalnej lub dysku sieciowego, wartość tej właściwości jest nazwę dysku, a następnie na końcu ukośnika (na przykład "C:\\"). Jeśli ten proces zostanie uruchomiony w podkatalogu, wartość tej właściwości jest ścieżka dysku i podkatalogu bez znaku ukośnika na końcu (na przykład "C:\mySubDirectory").  
  
   
  
## Examples  
 W poniższym przykładzie pokazano ustawienie <xref:System.Environment.CurrentDirectory%2A> właściwości.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Próbowano ustawić pustego ciągu ("").</exception>
        <exception cref="T:System.ArgumentNullException">Próbowano ustawić <see langword="null." /></exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Próbowano ustawić ścieżkę lokalną, którego nie można odnaleźć.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma odpowiednich uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do zapisywania plików lub katalogów w operacji zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji w samej ścieżce w ramach operacji get. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator dla bieżącego wątku zarządzanych.</summary>
        <value>Liczba całkowita, która reprezentuje unikatowy identyfikator dla tego wątku zarządzanych.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="exitCode">Kod zakończenia, aby powrócić do systemu operacyjnego. Użyj 0 (zero), aby wskazać, że proces został zakończony pomyślnie.</param>
        <summary>Przerywa ten proces i zwraca kod zakończenia systemowi operacyjnemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać `exitCode` parametru, liczbę Użyj różna od zera, aby wskazać błąd. W aplikacji można zdefiniować własne kody błędów w wyliczeniu i zwrócić kod odpowiedni komunikat o błędzie na podstawie scenariusza. Na przykład zwróć wartość 1, aby wskazać, że wymagany plik nie jest obecny, a wartość 2, aby wskazać, że plik jest w nieprawidłowym formacie. Aby uzyskać listę kodów wyjścia używane przez system operacyjny Windows, zobacz [kodów błędów systemu](https://msdn.microsoft.com/library/ms681381.aspx) w dokumentacji programu Windows.  
  
 Wywoływanie <xref:System.Environment.Exit%2A> metoda różni się od przy użyciu języka programowania `return` instrukcji w następujący sposób:  
  
-   <xref:System.Environment.Exit%2A> zawsze kończy działanie aplikacji. Za pomocą `return` instrukcji może zakończyć aplikację tylko wtedy, gdy jest on w punkcie wejścia aplikacji, takich jak w `Main` metody.  
  
-   <xref:System.Environment.Exit%2A> kończy aplikacji natychmiast, nawet wtedy, gdy są uruchomione inne wątki. Jeśli `return` jest nazwana w punkcie wejścia aplikacji, sprawia, że aplikację można zakończyć tylko wtedy, gdy wszystkie wątki pierwszoplanowe zostać zakończony.  
  
-   <xref:System.Environment.Exit%2A> wymaga obiekt wywołujący, aby mieć uprawnień do wywoływania niezarządzanego kodu. `return` Nie ma instrukcji.  
  
-   Jeśli <xref:System.Environment.Exit%2A> jest wywoływana z `try` lub `catch` zablokować, kod w dowolnym `finally` blok nie jest wykonywane. Jeśli `return` instrukcja jest używane, kod w `finally` wykonanie bloku.  
  
-   Jeśli <xref:System.Environment.Exit%2A> jest wywoływana, gdy kod w [region ograniczonego wykonania](~/docs/framework/performance/constrained-execution-regions.md) (CER) jest uruchomiona, CER nie zostanie wykonany. Jeśli `return` instrukcja jest używane, CER kończy wykonywanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wystarczających uprawnień do wykonywania tej funkcji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływania niezarządzanego kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kod zakończenia procesu.</summary>
        <value>32-bitowych całkowita zawierające kod zakończenia. Wartość domyślna to 0 (zero), co oznacza, że proces zakończony pomyślnie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `Main` metoda zwraca `void`, używasz tej właściwości można ustawić kod zakończenia, który zostanie zwrócony do środowiska wywołującego. Jeśli `Main` nie zwraca `void`, ta właściwość jest ignorowana. Początkowa wartość tej właściwości wynosi zero.  
  
> [!WARNING]
>  <xref:System.Environment.ExitCode%2A> Właściwość jest całkowita 32-bitowa. Aby zapobiec sytuacji, w której właściwość zwraca kod zakończenia ujemna, nie należy używać wartości większe niż lub równa 0x80000000.  
  
 Użyj numeru różna od zera, aby wskazać błąd. W aplikacji można zdefiniować własne kody błędów w wyliczeniu i zwrócić kod odpowiedni komunikat o błędzie na podstawie scenariusza. Na przykład zwróć wartość 1, aby wskazać, że wymagany plik nie jest obecny i wartość 2, aby wskazać, że plik jest w nieprawidłowym formacie. Aby uzyskać listę kodów wyjścia używane przez system operacyjny Windows, zobacz [kodów błędów systemu](https://msdn.microsoft.com/library/ms681381\(v=vs.85\)) w dokumentacji programu Windows.  
  
   
  
## Examples  
 Oto prosta aplikacja o nazwie Double.exe, podwaja się wartością całkowitą z zakresu przekazanego do niej jako argument wiersza polecenia. Wartość przypisuje kody błędów do <xref:System.Environment.ExitCode%2A> właściwości do wskazania warunków błędów. Należy pamiętać, że należy dodać odwołanie do zestawu System.Numerics.dll pomyślnie skompilować w przykładzie.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 Przykład następnie może być wywoływana z pliku wsadowego, podobny do następującego co sprawia, że jego kody błędów dostępne przy użyciu `ERRORLEVEL` polecenia.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 Poniżej przedstawiono niektóre przykładowe dane wyjściowe generowane przez wywołanie pliku wsadowego.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Pamiętaj, ten kod Double.exe jest taka sama w funkcji do poniższego przykładu, z tą różnicą, że pierwsza definiuje punkt wejścia o nazwie `Main` która nie zwraca żadnej wartości w tym przykładzie definiuje punkt wejścia o nazwie `Main` , zwraca liczbę całkowitą.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwy zero lub więcej zmiennych środowiskowych. Każdą zmienną środowiskową jest ujęty w cudzysłów znakiem procentu (%).</param>
        <summary>Zastępuje nazwę każdą zmienną środowiskową osadzone w określony ciąg przy użyciu ciągu wielokrotność wartości zmiennej, następnie zwraca ciąg wynikowy.</summary>
        <returns>Ciąg zawierający każdą zmienną środowiskową zastępuje jego wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa międzyoperacyjna modelu COM jest używany do pobierania do zmiennych środowiskowych systemu operacyjnego. Jeśli nie można pobrać zmienne środowiskowe z powodu błędu modelu COM, HRESULT, wyjaśniający przyczynę błędu jest używany do generowania jednego z kilku możliwych wyjątków; oznacza to, że wyjątek jest zależna od HRESULT. Aby uzyskać więcej informacji o przetwarzaniu HRESULT, zobacz sekcję Uwagi <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> metody.  
  
 Zastępowania wykonywane tylko w zmiennych środowiskowych, które są ustawione. Na przykład, załóżmy, że `name` jest "MyENV = MyENV %". Jeśli zmienna środowiskowa MyENV, jest równa 42, ta metoda zwróci wartość "MyENV = 42". Jeśli nie ustawiono MyENV, odbywa się bez zmian; Ta metoda zwraca wartość "MyENV = MyENV %".  
  
 Rozmiar wartość zwracana wynosi 32 KB.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać dysk systemowy i zmienne główny systemu.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać możliwość dostępu do zmiennych środowiskowych w <paramref name="name" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Natychmiast kończy proces po zapisaniu komunikat w dzienniku zdarzeń aplikacji Windows, a następnie zawiera wiadomości i informacje o wyjątku opcjonalne raportów o błędach do firmy Microsoft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat wyjaśniający, dlaczego proces został zakończony, lub <see langword="null" /> Jeśli podano żadne wyjaśnienia.</param>
        <summary>Natychmiast kończy proces po zapisaniu komunikat w dzienniku zdarzeń aplikacji Windows, a następnie zawiera komunikat w raportów o błędach do firmy Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kończy proces bez konieczności uruchamiania wszystkie aktywne `try` / `finally` bloków lub finalizatorów.  
  
 <xref:System.Environment.FailFast%2A> Zapisów metoda `message` ciąg w dzienniku zdarzeń aplikacji Windows tworzy zrzutu aplikacji, a następnie kończy bieżący proces. `message` Ciągu znajduje się również w raportów o błędach do firmy Microsoft.  
  
 Użyj <xref:System.Environment.FailFast%2A> zamiast metody <xref:System.Environment.Exit%2A> metodę, aby zakończyć aplikację, jeśli stan aplikacji jest uszkodzony naprawienia, a wykonywanie aplikacji `try` / `finally` bloków i finalizatory spowoduje uszkodzenie zasobów programu.  
  
 Informacje są zgłaszane do firmy Microsoft przy użyciu Windows Error Reporting. Aby uzyskać więcej informacji, zobacz [Windows Error Reporting: Wprowadzenie do](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  
  
   
  
## Examples  
 Poniższy przykład zapisuje wpis dziennika w dzienniku zdarzeń aplikacji Windows i kończy bieżący proces.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exception" Type="System.Exception" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat wyjaśniający, dlaczego proces został zakończony, lub <see langword="null" /> Jeśli podano żadne wyjaśnienia.</param>
        <param name="exception">Wyjątek, który reprezentuje błąd, który spowodował przerwanie. Zazwyczaj jest to wyjątek w <see langword="catch" /> bloku.</param>
        <summary>Natychmiast kończy proces po zapisaniu komunikat w dzienniku zdarzeń aplikacji Windows, a następnie zawiera informacje na temat komunikatu i wyjątku w raportów o błędach do firmy Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kończy proces bez konieczności uruchamiania wszystkie aktywne `try` / `finally` bloków lub finalizatorów.  
  
 <xref:System.Environment.FailFast%2A> Zapisów metoda `message` ciąg w dzienniku zdarzeń aplikacji Windows tworzy zrzutu aplikacji, a następnie kończy bieżący proces.  
  
 Informacje są zgłaszane do firmy Microsoft przy użyciu Windows Error Reporting. Aby uzyskać więcej informacji, zobacz [Windows Error Reporting: Wprowadzenie do](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Raportów o błędach do firmy Microsoft zawiera `message` i `exception` informacje, które zawiera szczegółowe informacje, służący do klasyfikowania błędu. Mimo że `exception` jest nie obsługiwane, ponieważ proces zostanie zakończony, informacje kontekstowe, która wywołała wyjątek jest nadal uzyskać.  
  
 Jeśli `exception` jest `null`, lub jeśli `exception` jest nie jest zgłaszany, ta metoda działa tak samo jak <xref:System.Environment.FailFast%28System.String%29> przeciążenie metody.  
  
 Użyj <xref:System.Environment.FailFast%2A> zamiast metody <xref:System.Environment.Exit%2A> metodę, aby zakończyć aplikację, jeśli stan aplikacji jest uszkodzony naprawienia, a wykonywanie aplikacji `try` / `finally` bloków i finalizatory spowoduje uszkodzenie zasobów programu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę ciągów zawierająca argumenty wiersza polecenia dla bieżącego procesu.</summary>
        <returns>Tablica ciągu, gdzie każdy element zawiera argument wiersza polecenia. Pierwszy element jest nazwa pliku wykonywalnego i następujących zero lub więcej elementów zawiera pozostałe argumenty wiersza polecenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwszy element w tablicy zawiera nazwę pliku wykonywania programu. Jeśli nazwa pliku nie jest dostępna, pierwszy element jest równa <xref:System.String.Empty?displayProperty=nameWithType>. Wszystkie pozostałe elementy zawierają wszystkie dodatkowe tokeny wprowadzone w wierszu polecenia.  
  
 Nazwa pliku programu mogą, ale nie jest wymagane, zawierają informacje o ścieżce.  
  
 Argumenty wiersza polecenia są rozdzielone spacjami. Za pomocą podwójnego cudzysłowu (") do uwzględnienia spacje wewnątrz argumentu. Pojedynczy znak cudzysłowu ('), jednak nie zapewnia tę funkcję.  
  
 Jeśli dwie lub parzystą liczbą ukośników odwrotnych podwójny cudzysłów, każda para ukośnik odwrotny postępowania zostaje zastąpiona opcją jednej kreski ułamkowej odwróconej i zostanie usunięta w podwójny cudzysłów. Jeśli podwójny cudzysłów nieparzysta liczba ukośników odwrotnych, w tym tylko jeden parom poprzedniej została zastąpiona jednej kreski ułamkowej odwróconej, a pozostałe ukośnik odwrotny zostanie usunięta; jednak określenia wartości w tym przypadku podwójny cudzysłów nie jest usuwany.  
  
 W poniższej tabeli pokazano, jak może być rozdzielany argumenty wiersza polecenia i zakłada `MyApp` jako bieżące wykonywanie aplikacji.  
  
|Wprowadź w wierszu polecenia|Wynikowy argumenty wiersza polecenia|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Aby uzyskać wiersza polecenia jako pojedynczy ciąg, użyj <xref:System.Environment.CommandLine%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład wyświetla argumenty wiersza polecenia aplikacji.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">System nie obsługuje argumenty wiersza polecenia.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do odczytu do zmiennej środowiskowej PATH. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość zmiennej środowiskowej.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Nazwa zmiennej środowiskowej.</param>
        <summary>Pobiera wartość zmiennej środowiskowej w bieżącym procesie.</summary>
        <returns>Wartość zmiennej środowiskowej określony przez <paramref name="variable" />, lub <see langword="null" /> Jeśli zmienna środowiskowa nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Environment.GetEnvironmentVariable%28System.String%29> Metoda pobiera zmienną środowiskową z bloku środowiska tylko bieżącego procesu. Jest to równoważne z wywoływaniem <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> metody z `target` wartość <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. 

Aby pobrać wszystkie zmienne środowiskowe wraz z wartościami, należy wywołać <xref:System.Environment.GetEnvironmentVariables%2A> metody.  
  
Nazwy zmiennych środowiskowych jest rozróżniana wielkość liter w systemie Linux i macOS, ale nie jest rozróżniana wielkość liter w Windows.  
 
### <a name="on-windows-systems"></a>W systemach Windows

 W systemach Windows zawiera blok środowiska bieżącego procesu:
 
- Wszystkie zmienne środowiskowe, które są dostarczane do niego przez proces nadrzędny, który go utworzył. Na przykład aplikacji platformy .NET, uruchamiany z okna konsoli dziedziczy wszystkie zmienne środowiskowe w oknie konsoli. 

  Jeśli nie ma żadnych procesów nadrzędnego, zmienne środowiskowe dla poszczególnych komputerów i użytkowników są używane zamiast tego. Na przykład nowe okno konsoli ma wszystkich poszczególnych komputerów i użytkowników zmienne środowiskowe zdefiniowane w czasie jej uruchamiania.

- Wszelkie zmienne dodane do bloku procesu, gdy proces jest uruchomiony, wywołując jedną <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metody lub <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metody z `target` wartość <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Te zmienne środowiskowe są zachowywane do momentu zakończenia działania aplikacji .NET.  
  
Jeśli zmienne środowiskowe są tworzone po rozpoczęciu procesu, można użyć tej metody do pobierania tych zmiennych, które zostały utworzone przez wywołanie metody <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metody lub <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metody z `target` wartość.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  

### <a name="on-macos-and-linux-systems"></a>W systemach macOS i Linux systemów

W systemach macOS i Linux blok środowiska bieżącego procesu obejmuje następujące zmienne środowiskowe:

- Wszystkie zmienne środowiskowe, które są dostarczane do niego przez proces nadrzędny, który go utworzył. Aplikacje .NET uruchamiane w powłoce obejmuje to wszystkie zmienne środowiskowe zdefiniowane w powłoce.

- Wszelkie zmienne dodane do bloku procesu, gdy proces jest uruchomiony, wywołując jedną <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metody lub <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metody z `target` wartość <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Te zmienne środowiskowe są zachowywane do momentu zakończenia działania aplikacji .NET.  

.NET core w systemie macOS i Linux nie obsługuje zmiennych środowiskowych dla poszczególnych komputerów lub użytkowników.   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Environment.GetEnvironmentVariable%2A> metodę, która pobierze `windir` zmiennej środowiskowej, która zawiera ścieżkę do katalogu Windows.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 Poniższy przykład podejmie próbę pobrania wartości zmiennej środowiskowej o nazwie `Test1` z procesu blok środowiska. Jeśli zmienna nie istnieje, w przykładzie jest tworzony jego i pobiera jego wartość. W przykładzie pokazano wartość zmiennej. Jeśli przykładzie utworzono zmienną, wzywa także <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> metody z każdego elementu członkowskiego <xref:System.EnvironmentVariableTarget> wyliczenie ustalenie, czy zmienna można pobrać tylko z bieżącego procesu blok środowiska. Ponadto jeśli przykładzie utworzono zmienną, usuwa go.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">możliwość odczytu wartości <paramref name="variable" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="variable">Nazwa zmiennej środowiskowej.</param>
        <param name="target">Jedną z <see cref="T:System.EnvironmentVariableTarget" /> wartości. Tylko <see cref="F:System.EnvironmentVariableTarget.Process" /> jest obsługiwana na platformie .NET Core, działających w systemach Unix podstaw.</param>
        <summary>Pobiera wartość zmiennej środowiskowej, z bieżącego procesu lub klucza rejestru systemu Windows dla bieżącego użytkownika lub komputera lokalnego.</summary>
        <returns>Wartość zmiennej środowiskowej określony przez <paramref name="variable" /> i <paramref name="target" /> parametrów lub <see langword="null" /> Jeśli zmienna środowiskowa nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 

Aby pobrać wszystkie zmienne środowiskowe wraz z wartościami, należy wywołać <xref:System.Environment.GetEnvironmentVariables%2A> metody.  
  
Nazwy zmiennych środowiskowych jest rozróżniana wielkość liter w systemie Linux i macOS, ale nie jest rozróżniana wielkość liter w Windows. 

### <a name="on-windows-systems"></a>W systemach Windows

W Windows `target` parametr określa, czy zmienna środowiskowa jest pobierana z bieżącego procesu lub klucza rejestru systemu Windows dla bieżącego użytkownika lub komputera lokalnego. Wszystkie zmienne środowiskowe na użytkownika i komputera są automatycznie kopiowane do bloku środowiska bieżącego procesu, jak inne zmienne środowiskowe, które są dostępne dla procesu nadrzędnego, który utworzył proces .NET. Jednak zmienne środowiskowe dodawane tylko do bloku środowiska bieżącego procesu, wywołując jedną <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metody lub <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metody z `target` wartość <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> tylko przez czas trwania procesu.  
  
### <a name="on-macos-and-linux-systems"></a>W systemach macOS i Linux systemów

W systemach macOS i Linux `GetEnvironmentVariable(String, EnvironmentVariableTarget)` obsługuje metody `target` wartość <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> tylko. Wywołania z `target` wartość <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> lub <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> nie są obsługiwane i zwracają `null`. 

Dostępne są następujące zmienne środowiskowe na proces:

- Te dziedziczone z procesu nadrzędnego, zazwyczaj używany do wywoływania powłoki `dotnet.exe` lub uruchamianie aplikacji .NET.

- Identyczne ze zdefiniowanymi przez wywołanie metody albo <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metody lub <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metody z `target` wartość <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Utrzymują się tylko do tych zmiennych środowiskowych `dotnet` kończy proces lub aplikacja platformy .NET.   
  
## Examples

Poniższy przykład tworzy zmienne środowiskowe dla optymalizacji <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, i <xref:System.EnvironmentVariableTarget.Machine> jest przeznaczony dla, sprawdza, czy rejestr systemu operacyjnego zawiera zmienne środowiskowe i użytkownika, a następnie usuwa środowisko zmienne. Ponieważ .NET w systemach opartych na systemie Unix nie nie pomocy technicznej na użytkownika i komputera zmienne środowiskowe tylko <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> i <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> o wartości <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> pomyślnie przechowywać w zmiennej środowiskowej, aby blok środowiska procesu.

[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> nie jest prawidłowym <see cref="T:System.EnvironmentVariableTarget" /> wartość.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">możliwość odczytu wartości <paramref name="variable" /> Jeśli <paramref name="target" /> jest <see cref="F:System.EnvironmentVariableTarget.Process" /> (powiązane wyliczenie: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), 
lub 
Aby uzyskać pełny dostęp do zmiennych środowiskowych Jeśli <paramref name="target" /> jest <see cref="F:System.EnvironmentVariableTarget.User" /> lub <see cref="F:System.EnvironmentVariableTarget.Machine" /> (powiązane wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wszystkie nazwy zmiennych środowiskowych i ich wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wszystkie nazwy zmiennych środowiskowych i ich wartości z bieżącego procesu.</summary>
        <returns>Słownik zawierający wszystkie nazwy zmiennych środowiskowych i ich wartości. w przeciwnym razie pusty słownik, jeśli żadne zmienne środowiskowe nie są dostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwy i wartości zmiennych środowiskowych, które są przechowywane jako pary klucz wartość, w zwróconym elemencie <xref:System.Collections.IDictionary>.  
  
### <a name="on-windows-systems"></a>W systemach Windows

W systemach Windows `GetEnvironmentVariables` metoda zwraca następujące zmienne środowiskowe:
  
- Wszystkie maszyny zmienne środowiskowe, które są zdefiniowane w czasie, proces zostanie utworzony, wraz z wartościami.  
  
- Wszystkie zmienne środowiskowe na użytkownika, które są zdefiniowane w czasie procesu jest tworzony wraz z ich wartościami.  

- Wszelkie zmienne dziedziczone z procesu nadrzędnego, z którego aplikacji .NET został uruchomiony lub dodane do bloku procesu, gdy proces jest uruchomiony. Zmienne środowiskowe są dodawane, gdy proces jest uruchomiony, wywołując jedną <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metody lub <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metody z `target` wartość <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  

### <a name="on-macos-and-linux-systems"></a>W systemach macOS i Linux systemów

W systemach MacOS i Linux `GetEnvironmentVariables` metoda pobiera nazwy i wartości wszystkich zmiennych środowiskowych, które są dziedziczone z procesu nadrzędnego, który uruchomił `dotnet` proces lub które są zdefiniowane w zakresie `dotnet` sam przetwarzania. Raz `dotnet` zakończenia procesu, te zmienne środowiskowe ostatnie przestaje istnieć. 

.NET core uruchomionych na komputerach z systemem Unix nie obsługuje zmiennych środowiskowych dla poszczególnych komputerów lub użytkowników.   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Environment.GetEnvironmentVariables%2A> metody.  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <exception cref="T:System.OutOfMemoryException">Bufor jest za mało pamięci.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać możliwość odczytu nazw i wartości zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target">Jedną z <see cref="T:System.EnvironmentVariableTarget" /> wartości. Tylko <see cxref="F:System.EnvironmentVariableTarget.Process" /> jest obsługiwana na platformie .NET Core uruchomionych na komputerach z systemem Unix.</param>
        <summary>Pobiera wszystkie nazwy zmiennych środowiskowych i ich wartości z bieżącego procesu, lub z klucza rejestru systemu Windows dla bieżącego użytkownika lub komputera lokalnego.</summary>
        <returns>Słownik zawierający wszystkie nazwy zmiennych środowiskowych i ich wartości z określoną przez źródło <paramref name="target" /> parametru; w przeciwnym razie pusty słownik, jeśli żadne zmienne środowiskowe nie zostaną znalezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Nazwy i wartości zmiennych środowiskowych, które są przechowywane jako pary klucz/wartość, w zwróconym elemencie <xref:System.Collections.IDictionary> obiektu.  

### <a name="on-windows-systems"></a>W systemach Windows

W systemach Windows `target` parametr określa, czy źródło jest bieżący proces, klucz rejestru dla bieżącego użytkownika lub klucza rejestru dla komputera lokalnego.  

### <a name="on-macos-and-linux-systems"></a>W systemach macOS i Linux systemów

W systemach macOS i Linux, tylko `target` wartość <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> jest obsługiwana. Zmienne środowiskowe dla procesu są dziedziczone z procesu nadrzędnego (zazwyczaj powłoka) używane do uruchomienia `dotnet` przetwarzania lub są zdefiniowane w zakresie `dotnet` sam przetwarzania. Po zakończenia procesu dotnet, tych zmiennych środowiskowych ostatnie przestaje istnieć.  

Zmienne środowiskowe dla poszczególnych komputerów i użytkowników nie są obsługiwane. A `target` wartość <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> lub <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> zwraca pustą tablicę.
  
## Examples

Poniższy przykład tworzy zmienne środowiskowe dla optymalizacji <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, i <xref:System.EnvironmentVariableTarget.Machine> jest przeznaczony dla, sprawdza, czy rejestr systemu operacyjnego zawiera zmienne środowiskowe i użytkownika, a następnie usuwa środowisko zmienne. Ponieważ .NET w systemach opartych na systemie Unix nie nie pomocy technicznej na użytkownika i komputera zmienne środowiskowe tylko <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> i <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> o wartości <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> pomyślnie przechowywać w zmiennej środowiskowej, aby blok środowiska procesu.

[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji dla określonej wartości <paramref name="target" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> zawiera niedozwoloną wartość.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">możliwość odczytu nazw i wartości zmiennych środowiskowych, jeśli <paramref name="target" /> jest <see cref="F:System.EnvironmentVariableTarget.Process" /> (powiązane wyliczenie: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), 
lub 
Aby uzyskać pełny dostęp do zmiennych środowiskowych Jeśli <paramref name="target" /> jest <see cref="F:System.EnvironmentVariableTarget.User" /> lub <see cref="F:System.EnvironmentVariableTarget.Machine" /> (powiązane wyliczenie: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera ścieżkę do folderu specjalne systemu, który jest identyfikowany przez wyliczenie określony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="folder">Jedna z wartości wyliczenia, które identyfikuje specjalne folderem systemowym.</param>
        <summary>Pobiera ścieżkę do folderu specjalne systemu, który jest identyfikowany przez wyliczenie określony.</summary>
        <returns>Ścieżka do określonego systemu specjalnego folderu, jeśli ten folder fizycznie znajduje się na komputerze. w przeciwnym razie pusty ciąg ("").  
  
 Folder fizycznie nie istnieje, jeśli system operacyjny nie utworzył, istniejący folder został usunięty lub folder jest katalogiem wirtualnym, takich jak Mój komputer, który nie odpowiada na ścieżkę fizyczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera ścieżkę do folderu specjalnych systemu, takich jak pliki programu, programy, systemu lub uruchamiania, którego można uzyskać dostępu do wspólnych informacji. Foldery specjalne są domyślnie przez system, lub jawnie przez użytkownika, podczas instalowania wersji systemu Windows.  
  
 `folder` Parametru wyznacza specjalnego folderu do pobrania i musi mieć jedną z wartości w <xref:System.Environment.SpecialFolder> wyliczenie; dowolnej innej wartości zgłasza wyjątek.  
  
 Aby uzyskać więcej informacji na temat folderów specjalnych zobacz [zmiennej CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664) temacie wartości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Environment.GetFolderPath%2A> metodę, aby przywrócić i wyświetlić ścieżkę skojarzoną z `folder` parametru.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> nie jest członkiem <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżąca platforma nie jest obsługiwana.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji w samej ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="folder">Jedna z wartości wyliczenia, które identyfikuje specjalne folderem systemowym.</param>
        <param name="option">Jedna z wartości wyliczenia, które określa opcje służące do uzyskiwania dostępu do folderów specjalnych.</param>
        <summary>Pobiera ścieżkę do folderu specjalnych systemu, jest identyfikowany przez określony wyliczenie, która używa określoną opcję do uzyskiwania dostępu do folderów specjalnych.</summary>
        <returns>Ścieżka do określonego systemu specjalnego folderu, jeśli ten folder fizycznie znajduje się na komputerze. w przeciwnym razie pusty ciąg ("").  
  
 Folder fizycznie nie istnieje, jeśli system operacyjny nie utworzył, istniejący folder został usunięty lub folder jest katalogiem wirtualnym, takich jak Mój komputer, który nie odpowiada na ścieżkę fizyczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera ścieżkę do folderu specjalnych systemu, takich jak pliki programu, programy, systemu lub uruchamiania, którego można uzyskać dostępu do wspólnych informacji. Foldery specjalne są domyślnie przez system, lub jawnie przez użytkownika, podczas instalowania wersji systemu Windows.  
  
 `folder` Parametru wyznacza specjalnego folderu do pobrania i musi mieć jedną z wartości w <xref:System.Environment.SpecialFolder> wyliczenie; dowolnej innej wartości zgłasza wyjątek.  
  
 Aby uzyskać więcej informacji na temat folderów specjalnych zobacz [zmiennej CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664) temacie wartości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> nie jest członkiem <see cref="T:System.Environment.SpecialFolder" />.
—lub—

<paramref name="options" /> nie jest członkiem <see cref="T:System.Environment.SpecialFolderOption" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżąca platforma nie jest obsługiwana.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji w samej ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę ciągów zawierająca nazwy dysków logicznych na bieżącym komputerze.</summary>
        <returns>Tablica ciągów, w której każdy element zawiera nazwę dysku logicznego. Na przykład, jeśli komputer twardym jest pierwszy dysk logiczny, pierwszy element, zwracany jest "C:\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje sposób wyświetlania dysków logicznych z bieżącego komputera przy użyciu <xref:System.Environment.GetLogicalDrives%2A> metody.  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać pełny dostęp do zasobów chronionych przez to uprawnienie. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która wskazuje, czy jest zwalniany bieżącej domeny aplikacji jest zamykana, środowisko uruchomieniowe języka wspólnego (CLR).</summary>
        <value><see langword="true" /> Jeśli bieżąca domena aplikacji jest zwalniany lub środowiska CLR jest zamykana; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Tylko platforma .NET framework**: Gdy środowisko CLR zwalnia domenę aplikacji, jest ono wykonywane finalizatory na wszystkich obiektach, które mają metodzie finalizacji w tej domenie aplikacji. Podczas zamykania środowiska CLR, rozpoczyna się wątek finalizatora na wszystkich obiektach, które mają metodzie finalizacji. <xref:System.Environment.HasShutdownStarted%2A> Właściwość zwraca `true` tylko wtedy, gdy wątek finalizatora został uruchomiony. Gdy właściwość zwraca `true`, można określić, czy Zwalnianie domeny aplikacji lub CLR, sama jest zamykana, wywołując <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> metody. Ta metoda zwraca `true` Jeśli finalizatory są nazywane, ponieważ Trwa zwalnianie domeny aplikacji lub `false` Jeśli środowisko CLR jest zamykany.  
  
 <xref:System.Environment.HasShutdownStarted%2A> Właściwość zwraca `false` Jeśli wątek finalizatora nie został uruchomiony.  
  
 Przy użyciu tej właściwości, można określić, czy chcesz uzyskać dostęp do statycznych zmiennych w kodzie finalizacji jest zakończona. Jeśli domeny aplikacji lub środowiska CLR jest zamykana, nie masz niezawodne dostępu do dowolnego obiektu, który ma metodę finalizacji i która odwołuje się do niej pole statyczne. Jest to spowodowane tych obiektów może mieć już sfinalizowany.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy bieżący system operacyjny jest 64-bitowym systemie operacyjnym.</summary>
        <value><see langword="true" /> Jeśli system operacyjny jest 64-bitowy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy bieżący proces jest proces 64-bitowy.</summary>
        <value><see langword="true" /> Jeśli proces jest 64-bitowy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę NetBIOS tego komputera lokalnego.</summary>
        <value>Ciąg zawierający nazwę tego komputera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa tego komputera jest ustanawiane przy uruchamianiu systemu podczas odczytywania z rejestru nazwy. Jeśli dany komputer jest węzłem w klastrze, zwracana jest nazwa węzła.  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę komputera, na którym jest uruchamiany w przykładzie kodu. (Nazwa komputera jest pominięty z przykładowych danych wyjściowych ze względów bezpieczeństwa).  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można uzyskać nazwę tego komputera.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do odczytu do zmiennej środowiskowej COMPUTERNAME. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg znaków nowego wiersza zdefiniowane dla tego środowiska.</summary>
        <value>Ciąg zawierający "\r\n" dla platform innych niż systemu Unix lub ciąg zawierający "\n" dla platform Unix.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość właściwości <xref:System.Environment.NewLine%2A> jest stałą dostosowane specjalnie dla bieżącej platformy i implementacji .NET Framework. Aby uzyskać więcej informacji na temat znaków ucieczki w wartości właściwości, zobacz [znaki specjalne](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 Funkcje udostępniane przez <xref:System.Environment.NewLine%2A> jest często, jakie jest przeznaczenie warunki znakami nowego wiersza, nowy wiersz, podział wiersza, powrotu karetki, CRLF i końca wiersza.  
  
 <xref:System.Environment.NewLine%2A> mogą być używane w połączeniu z obsługą nowego wiersza specyficzny dla języka, takie jak znaki ucieczki '\r' i '\n' w Microsoft C# i C/C++, lub `vbCrLf` programu Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A> jest automatycznie dołączany do tekstu przetwarzane przez <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> i <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia trzy wiersze rozdzielone tabulacji.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.OperatingSystem" /> obiekt, który zawiera bieżący numer identyfikatora oraz wersji platformy.</summary>
        <value>Obiekt, który zawiera numer identyfikatora oraz wersji platformy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`Environment.OSVersion` Właściwości nie zapewnia niezawodny sposób, aby zidentyfikować dokładną systemu operacyjnego i jego wersji. Dlatego zaleca się użycie tej metody. Zamiast tego: 

- Aby zidentyfikować platformy systemu operacyjnego, należy użyć <xref:System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform%2A?displayProperty=nameWithType> metody. 

- Należy unikać pisanie kodu, który zależy od wersji systemu operacyjnego zgłaszane. Zamiast tego należy sprawdzić dostępność funkcji, które Twoja aplikacja potrzebuje.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość nie może uzyskać wersję systemu.  
  
—lub— 
Identyfikator platformy uzyskanej nie jest członkiem <see cref="T:System.PlatformID" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę procesorów na bieżącym komputerze.</summary>
        <value>32-bitowe podpisane liczby całkowitej, która określa liczbę procesorów na bieżącym komputerze. Nie jest domyślnie. Jeśli bieżąca maszyna zawiera wielu grup procesorów, ta właściwość zwraca liczbę procesorów logicznych, które są dostępne do użycia przez środowisko uruchomieniowe języka wspólnego (CLR).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat grup procesorów oraz procesorów logicznych, zobacz [grup procesorów](https://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Environment.ProcessorCount%2A> właściwości.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy, modyfikuje lub usuwa zmienną środowiskową.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Nazwa zmiennej środowiskowej.</param>
        <param name="value">Wartość do przypisania do <paramref name="variable" />.</param>
        <summary>Tworzy, modyfikuje lub usuwa zmienną środowiskową, przechowywane w bieżącym procesie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest równoważne z wywoływaniem <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> przeciążenia z wartością <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> dla `target` argumentu.  
  
 Jeśli `value` argument nie jest pusty (zobacz opis usuwania zmiennej środowiskowej w dalszej części tej sekcji definicji pustą wartość) i zmienną środowiskową o nazwie określonej przez `variable` parametrów nie istnieje, środowisko zmienna zostanie utworzone i przypisane zawartość `value`. Jeśli istnieje, jego wartość jest modyfikowana. Ponieważ zmienna środowiskowa jest zdefiniowana w blok środowiska tylko bieżącego procesu, nie jest trwały po zakończeniu procesu.  
  
 Jeśli `variable` zawiera szesnastkowe-początkowe zero znaków, znaków przed zero znaków są traktowane jako nazwa zmiennej środowiskowej, a wszystkie kolejne znaki są ignorowane.  
  
 Jeśli `value` zawiera szesnastkowe-początkowe zero znaków, znaków przed zero znaków są przypisane do zmiennej środowiskowej a wszystkie kolejne znaki są ignorowane.  
  
 Jeśli `value` jest pusty, a zmienna środowiskowa o nazwie określonej przez `variable` istnieje, zostanie usunięty w zmiennej środowiskowej. Jeśli `variable` nie istnieje żaden błąd nie wystąpi, nawet jeśli nie można wykonać operacji. `value` jest uznawany za pusty w żadnej z następujących warunków:  
  
-   Jest `null`.  
  
-   Jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Składa się z pojedynczego znaku, którego wartością jest U + 0000.  
  
## Examples

Poniższy przykład podejmie próbę pobrania wartości zmiennej środowiskowej o nazwie `Test1` z procesu blok środowiska. Jeśli zmienna nie istnieje, w przykładzie utworzono zmienną i pobiera jego wartość. W przykładzie pokazano wartość zmiennej. W implementacji .NET działających w systemach Windows, wzywa także <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> metody z każdego elementu członkowskiego <xref:System.EnvironmentVariableTarget> wyliczenie ustalenie, czy zmienna można pobrać tylko z bieżącego procesu blok środowiska. (Implementacje platformy .NET w systemach opartych na systemie Unix obsługują tylko zmienne w bloku środowiska procesu.) Ponadto jeśli przykładzie utworzono zmienną, usuwa go.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> zawiera pusty ciąg szesnastkowy początkowej zero znaków (0x00) lub znak równości ("=").  
  
—lub— 
Długość <paramref name="variable" /> lub <paramref name="value" /> jest większa niż lub równa 32 767 znaków.  
  
—lub— 
Wystąpił błąd podczas wykonywania tej operacji.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać pełny dostęp do zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="variable">Nazwa zmiennej środowiskowej.</param>
        <param name="value">Wartość do przypisania do <paramref name="variable" />.</param>
        <param name="target">Jedna z wartości wyliczenia, które określa lokalizację w zmiennej środowiskowej.</param>
        <summary>Tworzy, modyfikuje lub usuwa zmienną środowiskową, przechowywane w bieżącym procesie lub w Windows systemu operacyjnego klucz rejestru zarezerwowane dla bieżącego użytkownika lub komputera lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Metoda pozwala zdefiniować zmienną środowiskową, która jest dostępna dla bieżącego procesu ( <xref:System.EnvironmentVariableTarget.Process> wartości). Zmienne środowiskowe, które są unikatowe, jak bieżący blok środowiska procesu są zachowywane tylko do momentu zakończenia procesu.

Ponadto tylko w systemach Windows <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metoda pozwala zdefiniować zmienną środowiskową, która jest dostępna dla wszystkich procesów, które są uruchamiane na komputerze ( <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> wartość) i wszystkie procesy uruchomione przez użytkownika ( <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> wartości). Zmienne środowiskowe dla poszczególnych komputerów i użytkowników są kopiowane do bloku środowiska bieżącego procesu.  
 
Na platformie .NET Core w systemach Linux i macOS, wywołania <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metody z wartością <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> lub <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> są ignorowane. 
  
 Jeśli `value` argument nie jest pusty (zobacz opis usuwania zmiennej środowiskowej w dalszej części tej sekcji definicji pustą wartość) i zmienną środowiskową o nazwie określonej przez `variable` argumentu nie istnieje, środowisko zmienna zostanie utworzone i przypisane zawartość `value`.  Jeśli istnieje, jego wartość jest modyfikowana.  
  
 Jeśli `variable` zawiera szesnastkowe-początkowe zero znaków, znaków przed zero znaków są traktowane jako nazwa zmiennej środowiskowej, a wszystkie kolejne znaki są ignorowane.  
  
 Jeśli `value` zawiera szesnastkowe-początkowe zero znaków, znaków przed zero znaków są przypisane do zmiennej środowiskowej a wszystkie kolejne znaki są ignorowane.  
  
 Jeśli `value` jest pusty, a zmienna środowiskowa o nazwie określonej przez `variable` istnieje, zostanie usunięty w zmiennej środowiskowej. `value` jest uznawany za pusty w żadnej z następujących warunków:  
  
-   Jest `null`.  
  
-   Jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Składa się z pojedynczego znaku, którego wartością jest U + 0000.  
  
 Jeśli `variable` nie istnieje żaden błąd nie wystąpi, mimo że nie można wykonać operacji. Należy zachować ostrożność podczas `target` jest <xref:System.EnvironmentVariableTarget.Machine>, ponieważ może przypadkowo usunąć zmienną środowiskową, która wpływa na cały komputer lokalny, nie tylko bieżący proces lub użytkownika.  

### <a name="environmentvariabletargetmachine-and-environmentvariabletargetuser-on-windows-systems"></a>EnvironmentVariableTarget.Machine i EnvironmentVariableTarget.User w systemach Windows

Jeśli `target` jest <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, zmienna środowiskowa jest przechowywana w kluczu HKEY_CURRENT_USER\Environment rejestru na komputerze lokalnym. Jest on również kopiowany do wystąpienia Eksploratora plików, które działają jako bieżącego użytkownika. Zmienna środowiskowa jest następnie dziedziczone przez nowe procesy, które użytkownik uruchamia się w Eksploratorze plików.  
  
 Podobnie jeśli `target` jest <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, zmienna środowiskowa jest przechowywana w kluczu HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment rejestru na komputerze lokalnym. Jest on również kopiowany do wszystkie wystąpienia Eksploratora plików. Zmienna środowiskowa jest następnie dziedziczone przez nowe procesy, które uruchamianych z poziomu Eksploratora plików.  
  
 Jeśli `target` jest <xref:System.EnvironmentVariableTarget.User> lub <xref:System.EnvironmentVariableTarget.Machine>, inne aplikacje są powiadamiane ustalonej operacji przez Windows `WM_SETTINGCHANGE` wiadomości.  
  
 Jeśli `target` jest <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> lub <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, zaleca się długość `value` mieć mniej niż 2048 znaków.  
  
## Examples

Poniższy przykład tworzy zmienne środowiskowe dla optymalizacji <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, i <xref:System.EnvironmentVariableTarget.Machine> jest przeznaczony dla, sprawdza, czy rejestr systemu operacyjnego zawiera zmienne środowiskowe i użytkownika, a następnie usuwa środowisko zmienne. Ponieważ .NET w systemach opartych na systemie Unix nie nie pomocy technicznej na użytkownika i komputera zmienne środowiskowe tylko <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> i <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> o wartości <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> pomyślnie przechowywać w zmiennej środowiskowej, aby blok środowiska procesu.
  
[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> zawiera pusty ciąg szesnastkowy początkowej zero znaków (0x00) lub znak równości ("=").  
  
—lub— 
Długość <paramref name="variable" /> jest większa niż lub równa 32 767 znaków.  
  
—lub— 
 <paramref name="target" /> nie jest członkiem <see cref="T:System.EnvironmentVariableTarget" /> wyliczenia.  
  
—lub— 
 <paramref name="target" /> jest <see cref="F:System.EnvironmentVariableTarget.Machine" /> lub <see cref="F:System.EnvironmentVariableTarget.User" />, a długość <paramref name="variable" /> jest większa niż lub równy 255.  
  
—lub— 
 <paramref name="target" /> jest <see cref="F:System.EnvironmentVariableTarget.Process" /> i długość <paramref name="value" /> jest większa niż lub równa 32 767 znaków.  
  
—lub— 
Wystąpił błąd podczas wykonywania tej operacji.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać pełny dostęp do zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżące informacje o śladzie stosu.</summary>
        <value>Ciąg zawierający informacje o śladzie stosu. Ta wartość może być <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.StackTrace%2A> Listy właściwości — wywołania metod w odwrotnej kolejności chronologicznej, oznacza to, najpierw opisano wywołania metody które najbardziej aktualne i jeden wiersz informacje śledzenia stosu znajduje się na liście dla każdego wywołania metody na stosie. Jednak <xref:System.Environment.StackTrace%2A> właściwość może nie raportować jako wiele wywołań metod, zgodnie z oczekiwaniami z powodu przekształceń kodu, które występują podczas tej optymalizacji.  
  
> [!NOTE]
>  Hierarchiczny widok informacje śledzenia stosu przez klasę, można użyć <xref:System.Diagnostics.StackTrace> klasy.  
  
 <xref:System.Environment.StackTrace%2A> Właściwość formatuje informacje śledzenia stosu dla każdego wywołania metody w następujący sposób:  
  
 "w `FullClassName`.`MethodName` (`MethodParams`) w `FileName` : linia `LineNumber` "  
  
 Literał "at", jest poprzedzony trzech miejsc do magazynowania, a cały podciąg począwszy od "w" jest pomijana, jeżeli symbole debugowania nie są dostępne. Symbole zastępcze `FullClassName`, `MethodName`, `MethodParams`, `FileName`, i `LineNumber`, są zastępowane wartości rzeczywiste i są definiowane w następujący sposób:  
  
 FullClassName  
 Pełna nazwa klasy, włącznie z przestrzenią nazw.  
  
 `MethodName`  
 Nazwa metody.  
  
 `MethodParams`  
 Lista par nazwa/typu parametru. Każda para jest oddzielona przecinkiem (","). Informacja ta jest pomijana, jeżeli `MethodName` nie przyjmuje żadnych parametrów.  
  
 `FileName`  
 Nazwa źródła pliku gdzie `MethodName` metoda jest zadeklarowana. Informacja ta jest pomijana w razie niedostępności symboli debugowania.  
  
 `LineNumber`  
 Numer wiersza w `FileName` zawierający kod źródłowy z `MethodName` dla instrukcji, która znajduje się na stosie wywołań. Informacja ta jest pomijana w razie niedostępności symboli debugowania.  
  
 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Ciąg kończy się każdy wiersz ślad stosu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Environment.StackTrace%2A> właściwości.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać pełny dostęp do zasobów chronionych przez uprawnienia. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pełną ścieżkę dla katalogu systemowego.</summary>
        <value>Ciąg zawierający ścieżkę katalogu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykład wartości zwracanej jest ciąg "C:\WinNT\System32".  
  
   
  
## Examples  
 Poniższy przykład wyświetla dla katalogu systemowego komputera, który jest uruchamiany w przykładzie kodu. (Katalog systemu jest pominięty z przykładowych danych wyjściowych ze względów bezpieczeństwa).  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji w samej ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę bajtów w strony pamięci systemu operacyjnego.</summary>
        <value>Liczba bajtów na stronie pamięci systemu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Te informacje mogą być przydatne podczas ustalania, czy ma być używany <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> podczas pracy z plikami mapowanych na pamięć.  
  
 W Windows, ta wartość jest `dwPageSize` elementu członkowskiego w `SYSTEM_INFO` struktury.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do zmiennych środowiskowych systemu i użytkownika. Skojarzone wyjątek: 
 <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę milisekund, jaki upłynął od uruchomienia systemu.</summary>
        <value>32-bitowych całkowita zawierające ilość czasu w milisekundach, jaki upłynął od czasu ostatniego uruchomienia komputera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości jest tworzony na podstawie czasomierz systemowy i jest przechowywany jako całkowita 32-bitowych. Należy zauważyć, że, ponieważ jest pochodną czasomierz systemowy, rozdzielczość <xref:System.Environment.TickCount%2A> właściwość jest ograniczona do rozwiązania czasomierz systemowy, który zazwyczaj znajduje się w zakresie milisekund 10-16.  
  
> [!IMPORTANT]
>  Ponieważ wartość <xref:System.Environment.TickCount%2A> wartość właściwości jest całkowita 32-bitowego, jeśli system działa w sposób ciągły, <xref:System.Environment.TickCount%2A> powoduje zwiększenie od zera do <xref:System.Int32.MaxValue?displayProperty=nameWithType> 24,9 dni, następnie przejdź do <xref:System.Int32.MinValue?displayProperty=nameWithType>, która jest liczbą ujemną następnie przyrostu z powrotem do zera dalej 24,9 dni. Można obejść ten problem, wywołując Windows [GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) funkcji, co spowoduje zresetowanie do zera po upływie około 49.7 dni lub przez wywołanie [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) funkcji.  
  
 <xref:System.Environment.TickCount%2A> różni się od <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> właściwość, która jest liczbę 100-nanosekundowych interwałów, które upłynęły od 1/1/0001 12:00 am.  
  
 Użyj <xref:System.DateTime.Now%2A?displayProperty=nameWithType> właściwości, aby uzyskać bieżące lokalne daty i czasu na tym komputerze.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać dodatnią zakres wartości zwracanych przez <xref:System.Environment.TickCount%2A> właściwości. <xref:System.Environment.TickCount%2A> Właściwość cykli między <xref:System.Int32.MinValue?displayProperty=nameWithType>, która jest liczbą ujemną, i <xref:System.Int32.MaxValue?displayProperty=nameWithType> raz na 49.8 dni. Ten przykładowy kod powoduje usunięcie z bitem umożliwiające uzyskanie nieujemna liczba, która cykli między zero a <xref:System.Int32.MaxValue> raz na 24,9 dni.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TickCount64">
      <MemberSignature Language="C#" Value="public static long TickCount64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TickCount64" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount64" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long TickCount64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount64 : int64" Usage="System.Environment.TickCount64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę domeny sieciowe skojarzone z bieżącego użytkownika.</summary>
        <value>Nazwa domeny sieciowe skojarzone z bieżącego użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poświadczenia konta domeny dla użytkownika są sformatowane jako nazwy domeny użytkownika, "\\" znak i nazwę użytkownika. Użyj <xref:System.Environment.UserDomainName%2A> właściwość, aby uzyskać nazwy domeny użytkownika bez nazwy użytkownika i <xref:System.Environment.UserName%2A> właściwości, aby uzyskać nazwę użytkownika bez nazwy domeny.  Na przykład, jeśli nazwa użytkownika i nazwy domeny użytkownika są CORPORATENETWORK\john <xref:System.Environment.UserDomainName%2A> "CORPORATENETWORK" zwraca wartość właściwości.  
  
 <xref:System.Environment.UserDomainName%2A> Właściwość najpierw próbuje pobrać składnik nazwy domeny, nazwy konta Windows dla bieżącego użytkownika. Jeśli próba zakończy się niepowodzeniem, ta właściwość próbuje pobrać nazwę domeny skojarzone z nazwą użytkownika, dostarczone przez <xref:System.Environment.UserName%2A> właściwości. Jeśli taka próba nie powiedzie się, ponieważ komputer hosta nie jest przyłączony do domeny, zwracany jest nazwą hosta komputera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny nie obsługuje pobierania nazwy domeny w sieci.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można pobrać nazwy domeny w sieci.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do odczytu do zmiennej środowiskowej USERDOMAIN. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący proces jest uruchomiony w trybie interaktywnym użytkownika.</summary>
        <value><see langword="true" /> Jeśli bieżący proces jest uruchomiony w trybie interaktywnym użytkownika; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.UserInteractive%2A> Raportów właściwości `false` dla procesu, Windows lub usług, takich jak usługi IIS, który jest uruchamiany bez interfejsu użytkownika. Jeśli ta właściwość jest `false`, nie są wyświetlane dialogów modalnych lub pola komunikatu, ponieważ nie istnieje żadne graficzny interfejs użytkownika umożliwiający użytkownikowi interakcję z.  
  
   
  
## Examples  
 Poniższy przykład wyświetla, czy bieżący proces jest uruchomiony w trybie interaktywnym użytkownika.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę użytkownika osoby, która jest aktualnie zalogowany do systemu operacyjnego.</summary>
        <value>Nazwa użytkownika osoby, która jest zalogowany do systemu operacyjnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Environment.UserName%2A> właściwość do identyfikacji użytkownika w bieżącym wątku, do systemu i aplikacji do celów bezpieczeństwa lub dostępu. Może również służyć do dostosowywania konkretnej aplikacji dla każdego użytkownika.  
 
 Na Windows <xref:System.Environment.UserName%2A> właściwość zawija wywołanie do Windows [GetUserName](https://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) funkcji. Poświadczenia konta domeny dla użytkownika są sformatowane jako nazwy domeny użytkownika, "\\" znak i nazwę użytkownika. Użyj <xref:System.Environment.UserDomainName%2A> właściwość, aby uzyskać nazwy domeny użytkownika i <xref:System.Environment.UserName%2A> właściwości, aby uzyskać nazwę użytkownika.  
 
 Na platformach Unix <xref:System.Environment.UserName%2A> właściwość zawija wywołanie do `getpwuid_r` funkcji.
 
 Jeśli aplikacja ASP.NET działa w środowisku deweloperskim <xref:System.Environment.UserName%2A> właściwość zwraca nazwę bieżącego użytkownika. W opublikowanej aplikacji ASP.NET ta właściwość zwraca nazwę konta puli aplikacji (na przykład domyślne puli aplikacji).  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę użytkownika osoby, którzy rozpoczęli bieżącego wątku.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać dostęp do odczytu do zmiennej środowiskowej nazwy użytkownika. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Version" /> obiekt, który zawiera opis głównych i pomocniczych, kompilacji i numery wersji środowiska uruchomieniowego języka wspólnego.</summary>
        <value>Obiekt, który wyświetla wersję środowiska uruchomieniowego języka wspólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla platformy .NET Framework 4, 4.5, 4.5.1 i 4.5.2 <xref:System.Environment.Version%2A?displayProperty=nameWithType> właściwość zwraca <xref:System.Version> obiektu, którego reprezentacja ciągu ma postać `4.0.30319.xxxxx`. Dla platformy .NET Framework 4.6 i nowszymi wersjami, jego ma postać `4.0.30319.42000`.  
  
> [!WARNING]
>  Dla [!INCLUDE[net_v45](~/includes/net-v45-md.md)] i nowszym, nie zaleca się przy użyciu <xref:System.Environment.Version%2A> właściwości do wykrywania wersji środowiska uruchomieniowego; zamiast tego należy określić wersję środowiska uruchomieniowego języka wspólnego, wykonując zapytanie w rejestrze. Aby uzyskać więcej informacji, zobacz [jak: Określanie, które wersje programu .NET Framework są zainstalowane](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md).  
  
 Aby uzyskać więcej informacji o wersji środowiska CLR, który jest instalowany z każdą wersją programu .NET Framework, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Poniższy przykład wyświetla wersję środowiska uruchomieniowego języka wspólnego. (Wersja jest pominięty z przykładowych danych wyjściowych ze względów bezpieczeństwa).  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci fizycznej, mapowany do kontekstu procesu.</summary>
        <value>64-bitowa liczba całkowita zawierającą liczbę bajtów pamięci fizycznej mapowane na procesie kontekst.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla rozmiar zestawu roboczego tego komputera, na którym jest uruchamiany w przykładzie kodu.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać pełny dostęp do zasobów chronionych przez to uprawnienie. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
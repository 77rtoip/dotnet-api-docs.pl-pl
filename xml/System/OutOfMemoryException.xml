<Type Name="OutOfMemoryException" FullName="System.OutOfMemoryException">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a0dd6e3c72f6ed9dea74eaed1b13a4a33e73d0da" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36430864" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class OutOfMemoryException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit OutOfMemoryException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.OutOfMemoryException" />
  <TypeSignature Language="VB.NET" Value="Public Class OutOfMemoryException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class OutOfMemoryException : SystemException" />
  <TypeSignature Language="F#" Value="type OutOfMemoryException = class&#xA;    inherit SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wyjątek zgłaszany, gdy nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.OutOfMemoryException> Wyjątek ma dwa główne przyczyny:  
  
-   Podjęto próbę rozwiń <xref:System.Text.StringBuilder> obiektu powyżej długość zdefiniowaną przez jego <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> właściwości.  
  
-   Środowisko uruchomieniowe języka wspólnego nie może przydzielić wystarczającej ilości pamięci ciągłej do pomyślnego przeprowadzenia operacji. Ten wyjątek może zostać wygenerowany przez wszystkie właściwości przypisania lub wywołanie metody wymagającego alokacji pamięci. Aby uzyskać więcej informacji na temat przyczyny <xref:System.OutOfMemoryException> wyjątek, zobacz ["Brak pamięci" nie odwołuje się do pamięci fizycznej](http://blogs.msdn.com/b/ericlippert/archive/2009/06/08/out-of-memory-does-not-refer-to-physical-memory.aspx).  
  
     Ten typ <xref:System.OutOfMemoryException> wyjątek reprezentuje poważnej awarii. Jeśli wybierzesz do obsługi wyjątku, należy uwzględnić `catch` bloku, który wywołuje <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> metodę, aby zakończyć aplikację i Dodaj wpis w dzienniku zdarzeń systemowych, tak jak w poniższym przykładzie.  
  
     [!code-csharp[System.OutOfMemoryException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/failfast1.cs#2)]
     [!code-vb[System.OutOfMemoryException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/failfast1.vb#2)]  
  
 Niektóre warunki wyjątku i akcje, które należy wykonać w celu usunięcia go są następujące:  
  
 Wywołujesz <xref:System.Text.StringBuilder.Insert%2A?displayProperty=nameWithType> metody.  
 Podjęto próbę zwiększenia długości <xref:System.Text.StringBuilder> obiektu przekracza rozmiar określony przez jego <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> właściwości. Poniższy przykład przedstawia <xref:System.OutOfMemoryException> wyjątek przy wywołaniu <xref:System.Text.StringBuilder.Insert%28System.Int32%2CSystem.String%2CSystem.Int32%29?displayProperty=nameWithType> metody, na przykład próba wstawienia ciąg, który może powodować, że obiekt <xref:System.Text.StringBuilder.Length%2A> właściwości przekroczenie jego maksymalnej pojemności.  
  
 [!code-csharp[System.OutOfMemoryException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/sb_example1.cs#1)]
 [!code-vb[System.OutOfMemoryException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/sb_example1.vb#1)]  
  
 Można wykonać jedną z następujących czynności, aby rozwiązać ten błąd:  
  
-   Zastąp wywołanie <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> konstruktora z wywołaniem innych <xref:System.Text.StringBuilder> przeładowania konstruktora. Maksymalna pojemność sieci <xref:System.Text.StringBuilder> obiektu zostanie ustawiona na wartość domyślną, która jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
-   Wywołanie <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> konstruktora z `maxCapacity` wartość, która jest wystarczająco duża, aby uwzględnić wszystkie rozszerzenia do <xref:System.Text.StringBuilder> obiektu.  
  
 Aplikacja będzie działać jako proces 32-bitowy.  
 procesy 32-bitowe można przydzielić maksymalnie 2GB pamięci wirtualnej trybu użytkownika w systemie 32-bitowym i 4GB pamięci wirtualnej trybu użytkownika w systemie 64-bitowym. To może utrudnić bardziej środowisko uruchomieniowe języka wspólnego przydzielić wystarczającej ilości pamięci ciągłej, gdy jest potrzebna duża alokacji. Z kolei procesów 64-bitowych można przydzielić do 8TB pamięci wirtualnej. Aby usunąć ten wyjątek, skompiluj ponownie aplikację pod kątem platformy 64-bitowych. Aby uzyskać informacje o przeznaczonych dla określonych platform w programie Visual Studio, zobacz [porady: Konfigurowanie projektów do platform docelowych](http://msdn.microsoft.com/library/845302fc-273d-4f81-820a-7296ce91bd76).  
  
 Aplikacji występuje przeciek zasoby niezarządzane  
 Moduł zbierający elementy bezużyteczne ma możliwość Zwolnij pamięć przydzielona programowi typy zarządzane, ale nie zarządza pamięć przydzielona programowi niezarządzane zasoby, takie jak system operacyjny obsługuje (w tym dojść do plików, pliki mapowane w pamięci, potoków, kluczy rejestru i uchwyty oczekiwania) a bloki pamięci, takie jak przydzielone bezpośrednio przez wywołania interfejsu API systemu Windows lub wywołania funkcji alokacji pamięci `malloc`. Typy, które zużywają zasoby niezarządzane implementować <xref:System.IDisposable> interfejsu.  
  
 Jeśli zużywają typu, który wykorzystuje zasoby niezarządzane, należy się upewnić wywołać jej <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metody po zakończeniu korzystania z niego. (Niektóre typy również implementować `Close` metodę, która jest taka sama w funkcji `Dispose` metody.) Aby uzyskać więcej informacji, zobacz [przy użyciu obiektów czy zaimplementować interfejs IDisposable](~/docs/standard/garbage-collection/using-objects.md) tematu.  
  
 Jeśli po utworzeniu typu, który wykorzystuje zasoby niezarządzane, upewnij się, że zaimplementowano wzorzec Dispose i, jeśli to konieczne, należy podać finalizator. Aby uzyskać więcej informacji, zobacz [wzorzec Dispose](~/docs/standard/design-guidelines/dispose-pattern.md), [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md), i <xref:System.Object.Finalize%2A?displayProperty=nameWithType> tematów.  
  
 Próbujesz utworzyć dużą tablicę w procesie 64-bitowych.  
 Domyślnie środowisko uruchomieniowe języka wspólnego pozwala pojedynczych obiektów, których wielkość przekracza 2GB. Aby zastąpić to ustawienie domyślne, ustawienie pliku konfiguracji służy do włączenia tablic, których łączny rozmiar przekracza 2 GB.  
  
 Pracujesz z bardzo dużych zestawów danych (na przykład tablic, kolekcje lub zestawy danych bazy danych) w pamięci.  
 Struktury danych lub zestawów danych, które znajdują się w pamięci stają się tak duża, że środowisko uruchomieniowe języka wspólnego jest nie może przydzielić wystarczającej ilości pamięci ciągłej ich <xref:System.OutOfMemoryException> wyniki wyjątku.  
  
 Aby zapobiec <xref:System.OutOfMemoryException> wyjątki, należy zmodyfikować aplikację tak, aby znajdujących się w pamięci jest mniejsza ilość danych lub danych jest podzielony na segmentów, które wymagają mniejszych alokacji pamięci. Na przykład:  
  
-   Jeśli pobranie wszystkich danych z bazy danych, filtrowania go w aplikacji, aby zminimalizować komunikacji dwustronnej z serwerem, należy zmodyfikować zapytania do zwrócenia tylko podzestaw danych, które Twoja aplikacja powinna. Podczas pracy z dużych tabel, wielu zapytań są prawie zawsze więcej wydajne niż pobierania wszystkich danych w jednej tabeli, a następnie operowanie nimi.  
  
-   Jeśli wykonywanych zapytań, które użytkownicy będą tworzyć dynamicznie, należy upewnić się, że liczbę rekordów zwróconych przez kwerendę jest ograniczona.  
  
-   Jeśli używasz duże tablice lub innych kolekcji obiektów, których wyniki rozmiar w <xref:System.OutOfMemoryException> wyjątek, należy zmodyfikować aplikacji do pracy w formie plików danych, a nie do pracy z nim jednocześnie.  
  
 Poniższy przykład pobiera tablicę, która składa się z wartości zmiennoprzecinkowych 200 milionów, a następnie oblicza średnią ich. Dane wyjściowe w przykładzie pokazano, że, ponieważ przykładzie przechowuje całego tablicy w pamięci przed obliczania średniej, <xref:System.OutOfMemoryException> jest generowany jest.  
  
 [!code-csharp[System.OutOfMemoryException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/data1.cs#3)]
 [!code-vb[System.OutOfMemoryException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/data1.vb#3)]  
  
 Poniższy przykład eliminuje <xref:System.OutOfMemoryException> wyjątku przez przetwarzanie przychodzących danych bez przechowywania cały zestaw danych w pamięci, serializacji danych do pliku, jeśli to konieczne umożliwić dalsze przetwarzanie (te wiersze są oznaczone jako limit w przykładzie ponieważ w takim przypadku wygenerowanie pliku, którego rozmiar jest większy niż 1 GB) i zwracanie obliczona średnia i liczbę przypadków do wywoływania procedury.  
  
 [!code-csharp[System.OutOfMemoryException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/data2.cs#4)]
 [!code-vb[System.OutOfMemoryException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/data2.vb#4)]  
  
 Są często łączenia dużych ciągów.  
 Ponieważ ciągi są niezmienne, każdej operacji łączenia ciągu tworzy nowy ciąg. Wpływ dla małych ciągów lub dla niewielkiej liczby operacji łączenia jest niewielka. Ale dla dużych ciągów lub bardzo dużą liczbę operacji łączenia ciągów może prowadzić do dużej liczby alokacji pamięci i fragmentacja pamięci i pogorszenie wydajności i prawdopodobnie <xref:System.OutOfMemoryException> wyjątków.  
  
 Kiedy łączenie ciągów dużych lub wykonywania dużą liczbę operacji łączenia, należy używać <xref:System.Text.StringBuilder> klasy zamiast <xref:System.String> klasy. Po zakończeniu manipulowanie ciąg przekonwertować <xref:System.Text.StringBuilder> wystąpienia na ciąg przez wywołanie metody <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metody.  
  
 Przypniesz dużą liczbę obiektów w pamięci.  
 Przypinanie dużą liczbę obiektów w pamięci przez dłuższy czas może utrudnić dla modułu zbierającego elementy bezużyteczne przydzielić ciągłych bloków pamięci. Jeśli możesz już przypięty dużą liczbę obiektów w pamięci, na przykład za pomocą `fixed` instrukcji w języku C#, przez wywołanie <xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType> metody z typem dojścia <xref:System.Runtime.InteropServices.GCHandleType.Pinned?displayProperty=nameWithType>, można wykonywać następujące adres <xref:System.OutOfMemoryException> wyjątku.  
  
-   Oceny, czy każdy obiekt naprawdę konieczne przypięty,  
  
-   Upewnij się, że każdy obiekt jest możliwie jak odpiąć.  
  
-   Upewnij się, że każdy wywołanie <xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType> — metoda pamięci numeru pin ma do odpowiedniego wywołania <xref:System.Runtime.InteropServices.GCHandle.Free%2A?displayProperty=nameWithType> metody odpiąć pamięci.  
  
 Firmy Microsoft pośredniego (MSIL) instrukcji throw <xref:System.OutOfMemoryException> wyjątek:  
  
-   [box](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.box.aspx)  
  
-   [newarr](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.newarr.aspx)  
  
-   [newobj](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.newobj.aspx)newobj  
  
 <xref:System.OutOfMemoryException> używa HRESULT `COR_E_OUTOFMEMORY`, który ma wartość 0x8007000E.  
  
 Aby uzyskać listę początkowe wartości właściwości dla wystąpienia <xref:System.OutOfMemoryException>, zobacz <xref:System.OutOfMemoryException.%23ctor%2A> konstruktorów.  
  
> [!NOTE]
>  Wartość dziedziczonego <xref:System.Exception.Data%2A> właściwość jest zawsze `null`.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.OutOfMemoryException" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OutOfMemoryException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OutOfMemoryException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.OutOfMemoryException" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Exception.Message%2A> właściwość nowego wystąpienia dostarczony przez system komunikatu, opisem błędu, takie jak "Brak wystarczającej ilości pamięci, aby kontynuować wykonywanie programu." Ten komunikat uwzględnia bieżącą kulturę systemu.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.OutOfMemoryException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|`null`.|  
|<xref:System.Exception.Message%2A>|Zlokalizowany ciąg komunikatu o błędzie.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OutOfMemoryException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OutOfMemoryException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new OutOfMemoryException : string -&gt; OutOfMemoryException" Usage="new System.OutOfMemoryException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat, który opisuje błąd.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.OutOfMemoryException" /> klasy z powodu określonego błędu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zawartość `message` parametr ma na celu rozumiane przez człowieka. Obiekt wywołujący tego konstruktora jest wymagany w celu zagwarantowania, że ten ciąg został zlokalizowany w bieżącej kulturze systemu.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.OutOfMemoryException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
|<xref:System.Exception.Message%2A>|Ciąg komunikatu o błędzie.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected OutOfMemoryException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; OutOfMemoryException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new OutOfMemoryException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; OutOfMemoryException" Usage="new System.OutOfMemoryException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt zawierający dane serializowanego obiektu.</param>
        <param name="context">Informacje kontekstowe o źródłowego lub miejscu docelowym.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.OutOfMemoryException" /> z zserializowanymi danymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływana podczas deserializacji do odtworzenia obiektu wyjątku przesyłanego za pomocą strumienia. Aby uzyskać więcej informacji, zobacz [XML i serializacji SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OutOfMemoryException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OutOfMemoryException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new OutOfMemoryException : string * Exception -&gt; OutOfMemoryException" Usage="new System.OutOfMemoryException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat o błędzie wyjaśniający przyczynę wyjątku.</param>
        <param name="innerException">Wyjątek, który jest przyczyną bieżącego wyjątku. Jeśli <c>innerException</c> parametr nie jest odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), bieżący wyjątek jest zgłaszany w <see langword="catch" /> bloku, który obsługuje wyjątek wewnętrzny.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.OutOfMemoryException" /> z określonego komunikatu o błędzie i odwołania do wyjątek wewnętrzny będący przyczyną tego wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyjątek zgłaszany bezpośrednio w wyniku poprzedniego wyjątku może zawierać odwołania do poprzedniego wyjątku we <xref:System.Exception.InnerException%2A> właściwości. <xref:System.Exception.InnerException%2A> Właściwość zwraca tę samą wartość, która została przekazana do konstruktora lub odwołanie o wartości null (`Nothing` w języku Visual Basic) Jeśli <xref:System.Exception.InnerException%2A> właściwości nie dostarcza do konstruktora wartości wyjątku wewnętrznego.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.OutOfMemoryException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie do wewnętrznego wyjątku.|  
|<xref:System.Exception.Message%2A>|Ciąg komunikatu o błędzie.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
      </Docs>
    </Member>
  </Members>
</Type>
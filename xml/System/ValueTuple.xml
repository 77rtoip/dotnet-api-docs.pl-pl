<Type Name="ValueTuple" FullName="System.ValueTuple">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="84040a95177ada25a5b3b69f2bc697d7249bedc3" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36427276" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct ValueTuple : IComparable, IComparable&lt;ValueTuple&gt;, IEquatable&lt;ValueTuple&gt;, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ValueTuple extends System.ValueType implements class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.IComparable, class System.IComparable`1&lt;valuetype System.ValueTuple&gt;, class System.IEquatable`1&lt;valuetype System.ValueTuple&gt;" />
  <TypeSignature Language="DocId" Value="T:System.ValueTuple" />
  <TypeSignature Language="VB.NET" Value="Public Structure ValueTuple&#xA;Implements IComparable, IComparable(Of ValueTuple), IEquatable(Of ValueTuple), IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public value class ValueTuple : IComparable, IComparable&lt;ValueTuple&gt;, IEquatable&lt;ValueTuple&gt;, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type ValueTuple = struct" />
  <AssemblyInfo>
    <AssemblyName>System.ValueTuple</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.ValueTuple&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.ValueTuple&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia metody statyczne do tworzenia wartości, spójne kolekcje.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
Krotka to struktura danych, która ma określoną liczbę i sekwencję elementów. Przykładem Krotka jest struktura danych z trzech elementów (zwaną krotki 3 lub triple), która jest używana do przechowywania identyfikatora, takie jak nazwisko osoby w pierwszym elementem, roku w drugi element i przychody osoby w danym roku w trzeci element.  
  
Wartość krotki są wprowadzone w systemie typów spójnej kolekcji [!INCLUDE[net_v463](~/includes/net-v463-md.md)] do implementacji środowiska uruchomieniowego programu [krotek w języku C#](~/docs/csharp/tuples.md) i krotek struktury w języku F #. Są one różne od klasy spójnej kolekcji, takie jak <xref:System.Tuple%601>, <xref:System.Tuple%602>, itd., w następujący sposób:  
  
-   Są one struktur (typy wartości) zamiast klasy (typy referencyjne).  
  
-   Ich użycie jest modyfikowalny, a nie tylko do odczytu. Oznacza to, że można zmienić wartości składników spójnej kolekcji.  
  
-   Ich elementy członkowskie danych, takich jak `Item1`, `Item2`, itd., są pola, a nie właściwości.  
  
<xref:System.ValueTuple> Struktury reprezentuje spójnej kolekcji, która nie ma żadnych elementów. Przydaje się przede wszystkim do jego metod statycznych, które umożliwiają tworzenie i porównywanie wystąpień typów wartości spójnej kolekcji. Jego metody pomocnicze umożliwiają wystąpienia krotek wartość bez konieczności jawnego określania typu każdego składnika spójnej kolekcji wartości. Przez wywołanie jego static <xref:System.ValueTuple.Create%2A> metod, można utworzyć krotek wartość, która ma od 0 do ośmiu składników. Wartość krotki z więcej niż osiem składników, należy wywołać <xref:System.ValueTuple%608.%23ctor%2A> konstruktora.  

### <a name="serialization-and-value-tuples"></a>Serializacja i wartość krotki

<xref:System.ValueTuple> Typ nie jest możliwy do serializacji w .NET Core 1.x lub .NET Framework 4.7 i wcześniejszych wersjach. Ponadto .NET Standard, w tym .NET Standard 2.0 nie wprowadzić serializacji <xref:System.ValueTuple> wystąpienia; czy <xref:System.ValueTuple> wystąpienie jest możliwy do serializacji zależy od poszczególnych implementacji .NET Standard. Aby określić, czy <xref:System.ValueTuple> typ jest możliwy do serializacji w konkretnej implementacji .NET, Pobierz <xref:System.Type> obiekt, który reprezentuje <xref:System.ValueTuple> wpisz i pobrać wartość jego <xref:System.Type.IsSerializable%2A> właściwości. Aby uzyskać listę typów możliwych do serializacji w .NET Core i .NET Framework, zobacz [szeregowanie binarne](~/docs/standard/serialization/binary-serialization.md).

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ValueTuple other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.ValueTuple other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.CompareTo(System.ValueTuple)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ValueTuple) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(ValueTuple other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : ValueTuple -&gt; int&#xA;override this.CompareTo : ValueTuple -&gt; int" Usage="valueTuple.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.ValueTuple" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <summary>Porównuje bieżący <see cref="T:System.ValueTuple" /> wystąpienia określonej <see cref="T:System.ValueTuple" /> wystąpienia.</summary>
        <returns>Ta metoda zawsze zwraca wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
        Because a <xref:System.ValueTuple> instance has no elements, any two <xref:System.ValueTuple> instances are considered to be equivalent.
           ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="other" /> nie jest <see cref="T:System.ValueTuple" /> wystąpienia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie spójnej kolekcji wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static ValueTuple Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ValueTuple" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; ValueTuple" Usage="System.ValueTuple.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe krotki wartość zero składnikom.</summary>
        <returns>Nowe wartości krotka z żadnych składników.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1&gt; Create&lt;T1&gt; (T1 item1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`1&lt;!!T1&gt; Create&lt;T1&gt;(!!T1 item1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1) (item1 As T1) As ValueTuple(Of T1)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1&gt;&#xA; static ValueTuple&lt;T1&gt; Create(T1 item1);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 -&gt; ValueTuple&lt;'T1&gt;" Usage="System.ValueTuple.Create item1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Typ składnika tylko wartości spójnej kolekcji.</typeparam>
        <param name="item1">Wartość krotki wartość jedynym składnikiem.</param>
        <summary>Tworzy nowy krotki wartość ze składnikiem 1 (pojedyncze wystąpienie).</summary>
        <returns>Wartość krotki ze składnikiem 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> jest metodę pomocnika, którą można wywołać w celu utworzenia wystąpienia krotka wartości 1 składnik bez konieczności jawnego określania typu jego części.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1,T2&gt; Create&lt;T1,T2&gt; (T1 item1, T2 item2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;!!T1, !!T2&gt; Create&lt;T1, T2&gt;(!!T1 item1, !!T2 item2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``2(``0,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1, T2) (item1 As T1, item2 As T2) As ValueTuple(Of T1, T2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2&gt;&#xA; static ValueTuple&lt;T1, T2&gt; Create(T1 item1, T2 item2);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 * 'T2 -&gt; ValueTuple&lt;'T1, 'T2&gt;" Usage="System.ValueTuple.Create (item1, item2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1,T2&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Typ krotki wartość pierwszy składnik.</typeparam>
        <typeparam name="T2">Typ krotki wartość drugiego składnika.</typeparam>
        <param name="item1">Wartość krotki wartość pierwszy składnik.</param>
        <param name="item2">Wartość krotki wartość drugiego składnika.</param>
        <summary>Tworzy nowy krotki wartość ze składnikami 2 (parę).</summary>
        <returns>Wartość krotki ze składnikami 2.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> jest to metoda pomocnika, którego możesz użyć do utworzenia wystąpienia krotka wartość składnik 2 bez konieczności jawnego określania typów składników.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1,T2,T3&gt; Create&lt;T1,T2,T3&gt; (T1 item1, T2 item2, T3 item3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;!!T1, !!T2, !!T3&gt; Create&lt;T1, T2, T3&gt;(!!T1 item1, !!T2 item2, !!T3 item3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``3(``0,``1,``2)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1, T2, T3) (item1 As T1, item2 As T2, item3 As T3) As ValueTuple(Of T1, T2, T3)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3&gt;&#xA; static ValueTuple&lt;T1, T2, T3&gt; Create(T1 item1, T2 item2, T3 item3);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 * 'T2 * 'T3 -&gt; ValueTuple&lt;'T1, 'T2, 'T3&gt;" Usage="System.ValueTuple.Create (item1, item2, item3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1,T2,T3&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Typ krotki wartość pierwszy składnik.</typeparam>
        <typeparam name="T2">Typ krotki wartość drugiego składnika.</typeparam>
        <typeparam name="T3">Typ krotki wartość trzecim składnikiem.</typeparam>
        <param name="item1">Wartość krotki wartość pierwszy składnik.</param>
        <param name="item2">Wartość krotki wartość drugiego składnika.</param>
        <param name="item3">Wartość krotki wartość trzecim składnikiem.</param>
        <summary>Tworzy nowy krotki wartość ze składnikami 3 (triple).</summary>
        <returns>Wartość krotki ze składnikami 3.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> jest to metoda pomocnika, którego możesz użyć do utworzenia wystąpienia krotka wartość 3 składnika bez konieczności jawnego określania typów jego składniki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1,T2,T3,T4&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1,T2,T3,T4&gt; Create&lt;T1,T2,T3,T4&gt; (T1 item1, T2 item2, T3 item3, T4 item4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`4&lt;!!T1, !!T2, !!T3, !!T4&gt; Create&lt;T1, T2, T3, T4&gt;(!!T1 item1, !!T2 item2, !!T3 item3, !!T4 item4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``4(``0,``1,``2,``3)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1, T2, T3, T4) (item1 As T1, item2 As T2, item3 As T3, item4 As T4) As ValueTuple(Of T1, T2, T3, T4)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3, typename T4&gt;&#xA; static ValueTuple&lt;T1, T2, T3, T4&gt; Create(T1 item1, T2 item2, T3 item3, T4 item4);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 * 'T2 * 'T3 * 'T4 -&gt; ValueTuple&lt;'T1, 'T2, 'T3, 'T4&gt;" Usage="System.ValueTuple.Create (item1, item2, item3, item4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1,T2,T3,T4&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Typ krotki wartość pierwszy składnik.</typeparam>
        <typeparam name="T2">Typ krotki wartość drugiego składnika.</typeparam>
        <typeparam name="T3">Typ krotki wartość trzecim składnikiem.</typeparam>
        <typeparam name="T4">Typ krotki wartość czwartym składnikiem.</typeparam>
        <param name="item1">Wartość krotki wartość pierwszy składnik.</param>
        <param name="item2">Wartość krotki wartość drugiego składnika.</param>
        <param name="item3">Wartość krotki wartość trzecim składnikiem.</param>
        <param name="item4">Wartość krotki wartość czwartym składnikiem.</param>
        <summary>Tworzy nowy krotki wartość ze składnikami 4 (poczwórnej).</summary>
        <returns>Wartość krotki ze składnikami 4.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> jest to metoda pomocnika, którego możesz użyć do utworzenia wystąpienia składnika 4 wartość krotki bez konieczności jawnego określania typów składników.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1,T2,T3,T4,T5&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1,T2,T3,T4,T5&gt; Create&lt;T1,T2,T3,T4,T5&gt; (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`5&lt;!!T1, !!T2, !!T3, !!T4, !!T5&gt; Create&lt;T1, T2, T3, T4, T5&gt;(!!T1 item1, !!T2 item2, !!T3 item3, !!T4 item4, !!T5 item5) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``5(``0,``1,``2,``3,``4)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1, T2, T3, T4, T5) (item1 As T1, item2 As T2, item3 As T3, item4 As T4, item5 As T5) As ValueTuple(Of T1, T2, T3, T4, T5)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3, typename T4, typename T5&gt;&#xA; static ValueTuple&lt;T1, T2, T3, T4, T5&gt; Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 -&gt; ValueTuple&lt;'T1, 'T2, 'T3, 'T4, 'T5&gt;" Usage="System.ValueTuple.Create (item1, item2, item3, item4, item5)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1,T2,T3,T4,T5&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="T5" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
        <Parameter Name="item5" Type="T5" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Typ krotki wartość pierwszy składnik.</typeparam>
        <typeparam name="T2">Typ krotki wartość drugiego składnika.</typeparam>
        <typeparam name="T3">Typ krotki wartość trzecim składnikiem.</typeparam>
        <typeparam name="T4">Typ krotki wartość czwartym składnikiem.</typeparam>
        <typeparam name="T5">Typ krotki wartość piątym składnikiem.</typeparam>
        <param name="item1">Wartość krotki wartość pierwszy składnik.</param>
        <param name="item2">Wartość krotki wartość drugiego składnika.</param>
        <param name="item3">Wartość krotki wartość trzecim składnikiem.</param>
        <param name="item4">Wartość krotki wartość czwartym składnikiem.</param>
        <param name="item5">Wartość krotki wartość piątym składnikiem.</param>
        <summary>Tworzy nowy krotki wartość ze składnikami 5 (pięciokrotnie).</summary>
        <returns>Wartość krotki ze składnikami 5.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> jest metodę pomocnika, którą można wywołać w celu utworzenia wystąpienia krotka 5-składnik wartość bez konieczności jawnego określania typów składników.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1,T2,T3,T4,T5,T6&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1,T2,T3,T4,T5,T6&gt; Create&lt;T1,T2,T3,T4,T5,T6&gt; (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`6&lt;!!T1, !!T2, !!T3, !!T4, !!T5, !!T6&gt; Create&lt;T1, T2, T3, T4, T5, T6&gt;(!!T1 item1, !!T2 item2, !!T3 item3, !!T4 item4, !!T5 item5, !!T6 item6) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``6(``0,``1,``2,``3,``4,``5)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1, T2, T3, T4, T5, T6) (item1 As T1, item2 As T2, item3 As T3, item4 As T4, item5 As T5, item6 As T6) As ValueTuple(Of T1, T2, T3, T4, T5, T6)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3, typename T4, typename T5, typename T6&gt;&#xA; static ValueTuple&lt;T1, T2, T3, T4, T5, T6&gt; Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 -&gt; ValueTuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6&gt;" Usage="System.ValueTuple.Create (item1, item2, item3, item4, item5, item6)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1,T2,T3,T4,T5,T6&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="T5" />
        <TypeParameter Name="T6" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
        <Parameter Name="item5" Type="T5" />
        <Parameter Name="item6" Type="T6" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Typ krotki wartość pierwszy składnik.</typeparam>
        <typeparam name="T2">Typ krotki wartość drugiego składnika.</typeparam>
        <typeparam name="T3">Typ krotki wartość trzecim składnikiem.</typeparam>
        <typeparam name="T4">Typ krotki wartość czwartym składnikiem.</typeparam>
        <typeparam name="T5">Typ krotki wartość piątym składnikiem.</typeparam>
        <typeparam name="T6">Typ szóstego składnika wartość spójnej kolekcji.</typeparam>
        <param name="item1">Wartość krotki wartość pierwszy składnik.</param>
        <param name="item2">Wartość krotki wartość drugiego składnika.</param>
        <param name="item3">Wartość krotki wartość trzecim składnikiem.</param>
        <param name="item4">Wartość krotki wartość czwartym składnikiem.</param>
        <param name="item5">Wartość krotki wartość piątym składnikiem.</param>
        <param name="item6">Wartość krotki wartość szóstego składnika.</param>
        <summary>Tworzy nowy krotki wartość ze składnikami 6 (sexuple).</summary>
        <returns>Wartość krotki ze składnikami 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> jest to metoda pomocnika, którego możesz użyć do utworzenia wystąpienia krotka wartość 6 składnika bez konieczności jawnego określania typów składników.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1,T2,T3,T4,T5,T6,T7&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1,T2,T3,T4,T5,T6,T7&gt; Create&lt;T1,T2,T3,T4,T5,T6,T7&gt; (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`7&lt;!!T1, !!T2, !!T3, !!T4, !!T5, !!T6, !!T7&gt; Create&lt;T1, T2, T3, T4, T5, T6, T7&gt;(!!T1 item1, !!T2 item2, !!T3 item3, !!T4 item4, !!T5 item5, !!T6 item6, !!T7 item7) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``7(``0,``1,``2,``3,``4,``5,``6)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1, T2, T3, T4, T5, T6, T7) (item1 As T1, item2 As T2, item3 As T3, item4 As T4, item5 As T5, item6 As T6, item7 As T7) As ValueTuple(Of T1, T2, T3, T4, T5, T6, T7)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7&gt;&#xA; static ValueTuple&lt;T1, T2, T3, T4, T5, T6, T7&gt; Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 -&gt; ValueTuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7&gt;" Usage="System.ValueTuple.Create (item1, item2, item3, item4, item5, item6, item7)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1,T2,T3,T4,T5,T6,T7&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="T5" />
        <TypeParameter Name="T6" />
        <TypeParameter Name="T7" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
        <Parameter Name="item5" Type="T5" />
        <Parameter Name="item6" Type="T6" />
        <Parameter Name="item7" Type="T7" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Typ krotki wartość pierwszy składnik.</typeparam>
        <typeparam name="T2">Typ krotki wartość drugiego składnika.</typeparam>
        <typeparam name="T3">Typ krotki wartość trzecim składnikiem.</typeparam>
        <typeparam name="T4">Typ krotki wartość czwartym składnikiem.</typeparam>
        <typeparam name="T5">Typ krotki wartość piątym składnikiem.</typeparam>
        <typeparam name="T6">Typ szóstego składnika wartość spójnej kolekcji.</typeparam>
        <typeparam name="T7">Typ siódmego składnika wartość spójnej kolekcji.</typeparam>
        <param name="item1">Wartość krotki wartość pierwszy składnik.</param>
        <param name="item2">Wartość krotki wartość drugiego składnika.</param>
        <param name="item3">Wartość krotki wartość trzecim składnikiem.</param>
        <param name="item4">Wartość krotki wartość czwartym składnikiem.</param>
        <param name="item5">Wartość krotki wartość piątym składnikiem.</param>
        <param name="item6">Wartość krotki wartość szóstego składnika.</param>
        <param name="item7">Wartość krotki wartość siódmego składnika.</param>
        <summary>Tworzy nowy krotki wartość ze składnikami 7 (septuple).</summary>
        <returns>Wartość krotki ze składnikami 7.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> jest to metoda pomocnika, którego możesz użyć do utworzenia wystąpienia krotka wartości 7 składnika bez konieczności jawnego określania typów jego składniki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;">
      <MemberSignature Language="C#" Value="public static ValueTuple&lt;T1,T2,T3,T4,T5,T6,T7,ValueTuple&lt;T8&gt;&gt; Create&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt; (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`8&lt;!!T1, !!T2, !!T3, !!T4, !!T5, !!T6, !!T7, valuetype System.ValueTuple`1&lt;!!T8&gt;&gt; Create&lt;T1, T2, T3, T4, T5, T6, T7, T8&gt;(!!T1 item1, !!T2 item2, !!T3 item3, !!T4 item4, !!T5 item5, !!T6 item6, !!T7 item7, !!T8 item8) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T1, T2, T3, T4, T5, T6, T7, T8) (item1 As T1, item2 As T2, item3 As T3, item4 As T4, item5 As T5, item6 As T6, item7 As T7, item8 As T8) As ValueTuple(Of T1, T2, T3, T4, T5, T6, T7, ValueTuple(Of T8))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8&gt;&#xA; static ValueTuple&lt;T1, T2, T3, T4, T5, T6, T7, ValueTuple&lt;T8&gt;&gt; Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);" />
      <MemberSignature Language="F#" Value="static member Create : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 -&gt; ValueTuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, ValueTuple&lt;'T8&gt;&gt;" Usage="System.ValueTuple.Create (item1, item2, item3, item4, item5, item6, item7, item8)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T1,T2,T3,T4,T5,T6,T7,System.ValueTuple&lt;T8&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="T5" />
        <TypeParameter Name="T6" />
        <TypeParameter Name="T7" />
        <TypeParameter Name="T8" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
        <Parameter Name="item5" Type="T5" />
        <Parameter Name="item6" Type="T6" />
        <Parameter Name="item7" Type="T7" />
        <Parameter Name="item8" Type="T8" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Typ krotki wartość pierwszy składnik.</typeparam>
        <typeparam name="T2">Typ krotki wartość drugiego składnika.</typeparam>
        <typeparam name="T3">Typ krotki wartość trzecim składnikiem.</typeparam>
        <typeparam name="T4">Typ krotki wartość czwartym składnikiem.</typeparam>
        <typeparam name="T5">Typ krotki wartość piątym składnikiem.</typeparam>
        <typeparam name="T6">Typ szóstego składnika wartość spójnej kolekcji.</typeparam>
        <typeparam name="T7">Typ siódmego składnika wartość spójnej kolekcji.</typeparam>
        <typeparam name="T8">Typ składnika ósmego wartość spójnej kolekcji.</typeparam>
        <param name="item1">Wartość krotki wartość pierwszy składnik.</param>
        <param name="item2">Wartość krotki wartość drugiego składnika.</param>
        <param name="item3">Wartość krotki wartość trzecim składnikiem.</param>
        <param name="item4">Wartość krotki wartość czwartym składnikiem.</param>
        <param name="item5">Wartość krotki wartość piątym składnikiem.</param>
        <param name="item6">Wartość krotki wartość szóstego składnika.</param>
        <param name="item7">Wartość krotki wartość siódmego składnika.</param>
        <param name="item8">Wartość krotki wartość ósmego składnika.</param>
        <summary>Tworzy nowy krotki wartość ze składnikami 8 (octuple).</summary>
        <returns>Wartość krotki ze składnikami 8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ValueTuple.Create%2A> jest metodę pomocnika, którą można wywołać w celu utworzenia wystąpienia krotka wartości 8-składnika bez konieczności jawnego określania typów składników.  
  
> [!NOTE]
>  Należy wywołać <xref:System.ValueTuple%608.%23ctor%2A> konstruktora w celu utworzenia spójnych kolekcji z dziewięciu lub więcej składników, chyba że język udostępnia specjalnej składni, w tym celu. Metod statycznych <xref:System.ValueTuple> struktury nie można użyć do utworzenia spójnych kolekcji z dziewięciu lub więcej składników.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy bieżący <see cref="T:System.ValueTuple" /> wystąpienie jest takie samo jak określony obiekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="valueTuple.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy bieżący <see cref="T:System.ValueTuple" /> wystąpienie jest takie samo jak określony obiekt.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> jest <see cref="T:System.ValueTuple" /> wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ValueTuple other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.ValueTuple other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.Equals(System.ValueTuple)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ValueTuple) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(ValueTuple other);" />
      <MemberSignature Language="F#" Value="override this.Equals : ValueTuple -&gt; bool" Usage="valueTuple.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.ValueTuple" />
      </Parameters>
      <Docs>
        <param name="other">Spójna kolekcja wartość do porównania z bieżącym wystąpieniem.</param>
        <summary>Określa, czy dwa <see cref="T:System.ValueTuple" /> wystąpienia są takie same. Ta metoda zawsze zwraca <see langword="true" />.</summary>
        <returns>Ta metoda zawsze zwraca <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="valueTuple.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego <see cref="T:System.ValueTuple" /> wystąpienia.</summary>
        <returns>Wartość skrótu dla bieżącego <see cref="T:System.ValueTuple" /> wystąpienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <param name="comparer">Obiekt dostarczający niestandardowe reguły na potrzeby porównania. Ten parametr jest ignorowany.</param>
        <summary>Porównuje bieżący <see cref="T:System.ValueTuple" /> wystąpienie określonego obiektu.</summary>
        <returns>Zwraca wartość 0, jeśli <paramref name="other" /> jest <see cref="T:System.ValueTuple" /> wystąpienia i 1, gdy <paramref name="other" /> jest <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="other" /> nie jest <see cref="T:System.ValueTuple" /> wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <param name="comparer">Obiekt definiujący metodę służącą ocenie, czy dwa obiekty są sobie równe.</param>
        <summary>Zwraca wartość wskazującą, czy bieżący <see cref="T:System.ValueTuple" /> wystąpienie jest takie samo jak określony obiekt na podstawie metody porównania określony.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie jest taki sam jak określony obiekt; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element członkowski jest jawną implementacją interfejsu. Może być tylko używane podczas <xref:System.ValueTuple>t > wystąpienia jest rzutowane na <xref:System.Collections.IStructuralEquatable> interfejsu. <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> Implementacji jest wywoływana tylko wtedy, gdy `other` nie jest `null`, i czy można pomyślnie rzutować <xref:System.ValueTuple> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Obiekt których <see cref="M:System.Collections.IEqualityComparer.GetHashCode(System.Object)" /> metoda oblicza wartość skrótu. Ten parametr jest ignorowany.</param>
        <summary>Zwraca wartość skrótu dla tego <see cref="T:System.ValueTuple" /> wystąpienia.</summary>
        <returns>Wartość skrótu dla tego <see cref="T:System.ValueTuple" /> wystąpienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ other) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z bieżącym wystąpieniem</param>
        <summary>Porównuje to <see cref="T:System.ValueTuple" /> wystąpienie określonego obiektu i zwraca dane dotyczące ich względne wartości.</summary>
        <returns>Jeśli 0 <paramref name="other" /> jest <see cref="T:System.ValueTuple" /> wystąpienia; w przeciwnym razie wartość 1, gdy <paramref name="other" /> jest <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="other" /> nie jest <see cref="T:System.ValueTuple" /> wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Item">
      <MemberSignature Language="C#" Value="object System.Runtime.CompilerServices.ITuple.Item[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Runtime.CompilerServices.ITuple.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(index As Integer) As Object Implements ITuple.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Runtime.CompilerServices.ITuple.Item[int] { System::Object ^ get(int index); };" />
      <MemberSignature Language="F#" Usage="System.ValueTuple.System.Runtime.CompilerServices.ITuple.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Nie dopuszczalne wartości dla <c>indeksu</c>.</param>
        <summary>Zwraca <see cref="T:System.IndexOutOfRangeException" />. Brak elementów w <see langword="ValueTuple" />.</summary>
        <value>
          <see cref="T:System.IndexOutOfRangeException" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">Nie dopuszczalne wartości dla <paramref name="index" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Length">
      <MemberSignature Language="C#" Value="int System.Runtime.CompilerServices.ITuple.Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Runtime.CompilerServices.ITuple.Length" />
      <MemberSignature Language="DocId" Value="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Length" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Length As Integer Implements ITuple.Length" />
      <MemberSignature Language="C++ CLI" Value="property int System.Runtime.CompilerServices.ITuple.Length { int get(); };" />
      <MemberSignature Language="F#" Usage="System.ValueTuple.System.Runtime.CompilerServices.ITuple.Length" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Length</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość to <see langword="ValueTuple" /> wystąpienia, która jest zawsze 0. Brak elementów w <see langword="ValueTuple" />.</summary>
        <value>0, liczba elementów w tym <see langword="ValueTuple" /> wystąpienia.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ValueTuple.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="valueTuple.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ValueTuple</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca reprezentację ciągu tego <see cref="T:System.ValueTuple" /> wystąpienia.</summary>
        <returns>Ta metoda zawsze zwraca "()".</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
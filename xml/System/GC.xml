<Type Name="GC" FullName="System.GC">
  <Metadata><Meta Name="ms.openlocfilehash" Value="018082509045fdce79646d99418c54a36c314068" /><Meta Name="ms.sourcegitcommit" Value="74239f3977d28923e5020663db2c4e91601bea79" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/24/2019" /><Meta Name="ms.locfileid" Value="68434633" /></Metadata><TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Kontroluje systemową Moduł wyrzucania elementów bezużytecznych, usługi, która automatycznie odzyskuje nieużywaną pamięć.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł wyrzucania elementów bezużytecznych jest składnikiem środowiska uruchomieniowego języka wspólnego, który kontroluje alokację i wydawanie pamięci zarządzanej. Metody w tej klasie mają wpływ na to, gdy wyrzucanie elementów bezużytecznych jest wykonywane na obiekcie i gdy są wydawane zasoby przydzielone przez obiekt. Właściwości w tej klasie zawierają informacje o łącznej ilości pamięci dostępnej w systemie oraz o kategorii wieku lub generacji pamięci przydzieloną do obiektu.  
  
 Moduł wyrzucania elementów bezużytecznych śledzi i ponownie zgłasza obiekty przydzieloną w pamięci zarządzanej. Okresowo moduł zbierający elementy bezużyteczne wykonuje wyrzucanie elementów bezużytecznych, aby odzyskiwać pamięć przydzieloną do obiektów, dla których nie ma prawidłowych odwołań. Wyrzucanie elementów bezużytecznych odbywa się automatycznie, gdy żądanie dotyczące pamięci nie może zostać spełnione przy użyciu dostępnej wolnej pamięci. Alternatywnie aplikacja może wymusić wyrzucanie elementów <xref:System.GC.Collect%2A> bezużytecznych przy użyciu metody.  
  
 Wyrzucanie elementów bezużytecznych składa się z następujących kroków:  
  
1.  Moduł zbierający elementy bezużyteczne wyszukuje obiekty zarządzane, do których istnieją odwołania w kodzie zarządzanym.  
  
2.  Moduł wyrzucania elementów bezużytecznych próbuje sfinalizować obiekty, do których nie istnieją odwołania.  
  
3.  Moduł wyrzucania elementów bezużytecznych zwalnia obiekty, do których nie odwołuje się i przejmuje ich pamięć.  
  
 Ten temat zawiera następujące sekcje:  
  
 [Moduł wyrzucania elementów bezużytecznych i niezarządzanych zasobów](#unmanaged)   
 [Przedawnianie i generacja obiektów](#generations)   
 [Niezezwalanie na wyrzucanie elementów bezużytecznych](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a>Moduł wyrzucania elementów bezużytecznych i niezarządzanych zasobów  
 Podczas zbierania Moduł wyrzucania elementów bezużytecznych nie zwolni obiektu, jeśli znajdzie co najmniej jedno odwołanie do obiektu w kodzie zarządzanym. Jednak Moduł wyrzucania elementów bezużytecznych nie rozpoznaje odwołań do obiektu z kodu niezarządzanego i może zwolnić obiekty, które są używane wyłącznie w kodzie niezarządzanym, chyba że jawnie nie zostanie to zrobione. <xref:System.GC.KeepAlive%2A> Metoda zapewnia mechanizm, który uniemożliwia modułowi zbierającemu elementy bezużyteczne zbieranie obiektów, które są nadal używane w kodzie niezarządzanym.  
  
 Poza alokacją pamięci zarządzanej, implementacje modułu wyrzucania elementów bezużytecznych nie utrzymują informacji o zasobach przechowywanych przez obiekt, takich jak dojścia do plików lub połączenia z bazami danych. Gdy typ używa niezarządzanych zasobów, które muszą zostać wydane przed odprowadzeniem wystąpień typu, typ może zaimplementować finalizator.  
  
 W większości przypadków <xref:System.Object.Finalize%2A?displayProperty=nameWithType> finalizatory są implementowane przez zastąpienie metody; jednak typy wpisywane C# lub C++ implementujące destruktory, które kompilatory przesłonić <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. W większości przypadków, jeśli obiekt ma finalizator, moduł zbierający elementy bezużyteczne wywołuje go przed zwolnieniem obiektu. Jednak Moduł wyrzucania elementów bezużytecznych nie jest wymagany do wywoływania finalizatorów we wszystkich sytuacjach; na przykład <xref:System.GC.SuppressFinalize%2A> Metoda jawnie uniemożliwia wywoływanie finalizatora obiektu. Ponadto Moduł wyrzucania elementów bezużytecznych nie musi używać określonego wątku do sfinalizowania obiektów lub zagwarantowania kolejności, w której finalizatory są wywoływane dla obiektów, które odwołują się do siebie nawzajem, ale są dostępne do wyrzucania elementów bezużytecznych.  
  
 W scenariuszach, w których zasoby muszą być wydane w określonym czasie, klasy mogą implementować <xref:System.IDisposable> interfejs, który <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> zawiera metodę, która wykonuje zadania zarządzania zasobami i oczyszczania. Klasy implementujące <xref:System.IDisposable.Dispose%2A> muszą określać, jako część ich kontraktu klasy, jeśli i gdy klasy odbiorcy wywołują metodę w celu oczyszczenia obiektu. Moduł wyrzucania elementów bezużytecznych nie jest domyślnie <xref:System.IDisposable.Dispose%2A> wywoływany przez metodę, ale implementacje <xref:System.IDisposable.Dispose%2A> metody mogą wywoływać metody <xref:System.GC> w klasie, aby dostosować sposób finalizowania modułu wyrzucania elementów bezużytecznych.  
  
 Aby uzyskać więcej informacji o finalizowaniu obiektów i wzorcu usuwania, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a>Przedawnianie i generacja obiektów  
 Moduł wyrzucania elementów bezużytecznych w środowisku uruchomieniowym języka wspólnego obsługuje przedawnianie obiektów przy użyciu generacji. Generacja jest jednostką miary względnego wieku obiektów w pamięci. Numer generacji lub wiek obiektu wskazuje generację, do której należy obiekt. Obiekty utworzone niedawno są częścią nowszych generacji i mają niższe numery generacji niż obiekty utworzone wcześniej w cyklu życia aplikacji. Obiekty w najnowszej generacji są w generacji 0. Ta implementacja modułu wyrzucania elementów bezużytecznych obsługuje trzy generacje obiektów, generacji 0, 1 i 2. Możesz pobrać wartość <xref:System.GC.MaxGeneration%2A> właściwości, aby określić maksymalny numer generacji obsługiwany przez system.  
  
 Przedawnianie obiektów umożliwia aplikacjom docelowe wyrzucanie elementów bezużytecznych w określonym zestawie generacji, a nie wymaganie wyrzucania elementów bezużytecznych w celu oszacowania wszystkich generacji. Przeciążenia metody zawierającej `generation` parametr umożliwiają określenie najstarszej generacji do wyrzucania elementów bezużytecznych. <xref:System.GC.Collect%2A>  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a>Niezezwalanie na wyrzucanie elementów bezużytecznych  
 Począwszy od, Moduł wyrzucania elementów bezużytecznych obsługuje tryb opóźnienia w regionie GC, który może być używany podczas wykonywania ścieżek krytycznych, w których wyrzucanie elementów bezużytecznych może mieć negatywny wpływ na wydajność aplikacji. [!INCLUDE[net_v46](~/includes/net-v46-md.md)] Tryb opóźnienia regionu nie wymaga określenia ilości pamięci, którą można przydzielić bez ingerencji z modułu wyrzucania elementów bezużytecznych. Jeśli środowisko uruchomieniowe może przydzielić pamięć, środowisko uruchomieniowe nie wykonuje wyrzucania elementów bezużytecznych podczas wykonywania kodu w ścieżce krytycznej.  
  
 Należy zdefiniować początek ścieżki krytycznej w regionie No GC przez wywołanie jednego z przeciążeń <xref:System.GC.TryStartNoGCRegion%2A>. Należy określić koniec swojej ścieżki krytycznej, wywołując <xref:System.GC.EndNoGCRegion%2A> metodę.  
  
 Nie można zagnieżdżać wywołań do <xref:System.GC.TryStartNoGCRegion%2A> metody i należy <xref:System.GC.EndNoGCRegion%2A> wywołać metodę tylko wtedy, gdy środowisko uruchomieniowe jest obecnie w trybie opóźnień w regionie GC. Innymi słowy, nie należy wywoływać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania zakończą się niepowodzeniem) i nie należy oczekiwać, aby <xref:System.GC.EndNoGCRegion%2A> wywołania kończyły się pomyślnie, <xref:System.GC.TryStartNoGCRegion%2A> ponieważ pierwsze wywołanie zakończyło się pomyślnie.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano kilka metod GC, aby uzyskać informacje o generowaniu i pamięci dla bloku nieużywanych obiektów i wydrukować je w konsoli programu. Wszystkie nieużywane obiekty są gromadzone i wyświetlane są sumy uzyskanej pamięci.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md">Odzyskiwanie pamięci</related>
    <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Podstawy dotyczące wyrzucania elementów bezużytecznych</related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Przyrostowa ilość niezarządzanej pamięci, która została przypisana.</param>
        <summary>Informuje środowisko uruchomieniowe dużej alokacji niezarządzanej pamięci, które należy wziąć pod uwagę podczas planowania wyrzucania elementów bezużytecznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W celu określenia czasu, w którym należy zaplanować wyrzucanie elementów bezużytecznych, środowisko uruchomieniowe uwzględnia ilość przydzielonej pamięci zarządzanej. Jeśli mały zarządzany obiekt przydzieli dużą ilość pamięci niezarządzanej, środowisko uruchomieniowe bierze pod uwagę tylko zarządzaną pamięć i w ten sposób szacuje pilność planowania wyrzucania elementów bezużytecznych. <xref:System.GC.AddMemoryPressure%2A> Metoda informuje środowisko uruchomieniowe tego dodatkowego nacisku w pamięci systemowej.  
  
 W najprostszym wzorcu użycia obiekt zarządzany przydziela niezarządzaną pamięć w konstruktorze i zwalnia go w `Dispose` metodzie lub. `Finalize` Wywołaj <xref:System.GC.RemoveMemoryPressure%2A> metodę po przydzieleniu pamięci niezarządzanej i Wywołaj metodę po jej zwolnieniu. <xref:System.GC.AddMemoryPressure%2A>  
  
 W bardziej skomplikowanych scenariuszach, w których niezarządzana alokacja pamięci ulega znacznemu zmianie w okresie istnienia zarządzanego obiektu, <xref:System.GC.AddMemoryPressure%2A> można <xref:System.GC.RemoveMemoryPressure%2A> wywołać metody i, aby przekazać te przyrostowe zmiany do środowiska uruchomieniowego.  
  
> [!CAUTION]
>  Należy upewnić się, że należy usunąć dokładnie ilość dodawanego nacisku. Niewykonanie tej czynności może niekorzystnie wpłynąć na wydajność systemu w aplikacjach uruchamianych przez długi czas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bytesAllocated" />jest mniejsze lub równe 0.  
  
—lub— 
Na komputerze <paramref name="bytesAllocated" /> 32-bitowym jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">umożliwia wywoływanie kodu niezarządzanego podczas manipulowania priorytetem kolekcji elementów bezużytecznych. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje rejestrację powiadomienia o wyrzucaniu elementów bezużytecznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda anuluje powiadomienie wyrzucania elementów bezużytecznych, które <xref:System.GC.RegisterForFullGCNotification%2A> zostało zarejestrowane za pomocą metody. Nie jest konieczne wywoływanie tej metody przed dopasowaniem wartości parametrów progu w kolejnych wywołaniach <xref:System.GC.RegisterForFullGCNotification%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład anuluje rejestrację wyrzucania elementów bezużytecznych. Ten przykład jest częścią większego przykładu podanego w temacie powiadomienia o wyrzucaniu [elementów](~/docs/standard/garbage-collection/notifications.md) bezużytecznych.  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ten element członkowski nie jest dostępny, gdy włączone jest współbieżne wyrzucanie elementów bezużytecznych. Zobacz ustawienie środowiska uruchomieniowego [ &lt;gcConcurrent&gt; ](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) , aby uzyskać informacje o tym, jak wyłączyć współbieżne odzyskiwanie pamięci.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Powiadomienia dotyczące odzyskiwania pamięci</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wymusza wyrzucanie elementów bezużytecznych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza natychmiastowe wyczyszczenie elementów bezużytecznych wszystkich generacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby spróbować ponownie przejąć całą pamięć, która jest niedostępna. Wykonuje blokowe blokowanie wyrzucania elementów bezużytecznych wszystkich generacji.  
  
 Wszystkie obiekty, niezależnie od tego, jak długo znajdowały się w pamięci, są brane pod uwagę w przypadku zbierania danych. Jednak obiekty, do których odwołuje się kod zarządzany, nie są zbierane. Użyj tej metody, aby wymusić, aby system ponownie odzyskał maksymalną ilość dostępnej pamięci.  
  
 Począwszy od <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> <xref:System.GC.Collect%2A> , można skompaktować stertę dużego obiektu (LOH), ustawiając właściwość na przed wywołaniem metody, jak pokazano w poniższym przykładzie. [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.GC.Collect%2A> metody do wykonania kolekcji na wszystkich generacjach pamięci. Kod generuje kilka nieużywanych obiektów, a następnie wywołuje <xref:System.GC.Collect%2A> metodę, aby oczyścić ją z pamięci.  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Wywołane kolekcje</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">Liczba najstarszych generacji do wyrzucania elementów bezużytecznych.</param>
        <summary>Wymusza natychmiastowe wyrzucanie elementów bezużytecznych z generacji 0 za pośrednictwem określonej generacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby spróbować ponownie przejąć niedostępną pamięć. Jednak użycie tej metody nie gwarantuje, że cała niedostępna pamięć w określonej generacji zostanie ododzyskiwana.  
  
 Jeśli zaimplementowano przedawnianie obiektów, Moduł wyrzucania elementów bezużytecznych nie zbiera obiektów z numerem generacji wyższym niż określona generacja. Jeśli przedawnianie obiektów nie jest zaimplementowane, Moduł wyrzucania elementów bezużytecznych traktuje wszystkie obiekty podczas wyrzucania elementów bezużytecznych.  
  
 Użyj właściwości, aby określić maksymalną prawidłową wartość `generation` parametru. <xref:System.GC.MaxGeneration%2A>  
  
 Aby moduł zbierający elementy bezużyteczne uważał wszystkie obiekty niezależnie od ich generacji, użyj wersji tej metody, która nie przyjmuje żadnych parametrów. Aby moduł zbierający elementy bezużyteczne odzyskał obiekty na <xref:System.GCCollectionMode> podstawie ustawienia, <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> należy użyć przeciążenia metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.GC.Collect%2A> metody do wykonywania kolekcji na poszczególnych warstwach pamięci. Kod generuje kilka nieużywanych obiektów, a następnie wywołuje <xref:System.GC.Collect%2A> metodę, aby oczyścić ją z pamięci.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" />jest nieprawidłowy.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Wywołane kolekcje</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation">Liczba najstarszych generacji do wyrzucania elementów bezużytecznych.</param>
        <param name="mode">Wartość wyliczenia określająca, czy wyrzucanie elementów bezużytecznych <see cref="F:System.GCCollectionMode.Forced" />jest wymuszane (<see cref="F:System.GCCollectionMode.Optimized" /><see cref="F:System.GCCollectionMode.Default" /> lub) czy zoptymalizowane ().</param>
        <summary>Wymusza wyrzucanie elementów bezużytecznych z generacji od 0 do określonej generacji w czasie określonym <see cref="T:System.GCCollectionMode" /> przez wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `mode` , aby określić, czy odzyskiwanie pamięci powinno odbywać się natychmiast, czy tylko wtedy, gdy czas jest optymalny do odzyskiwania obiektów. Użycie tej metody nie gwarantuje, że cała niedostępna pamięć w określonej generacji jest odzyskiwana.  
  
 Aby dostosować nieodpowiednie wyrzucanie elementów bezużytecznych podczas krytycznych okresów w aplikacji <xref:System.Runtime.GCSettings.LatencyMode%2A> , należy ustawić właściwość.  
  
 Moduł wyrzucania elementów bezużytecznych nie zbiera obiektów z numerem generacji wyższym `generation` niż określony przez parametr. Użyj właściwości, aby określić maksymalną prawidłową `generation`wartość. <xref:System.GC.MaxGeneration%2A>  
  
 Aby moduł zbierający elementy bezużyteczne uważał wszystkie obiekty niezależnie od ich generacji, użyj wersji tej metody, która nie przyjmuje żadnych parametrów.  
  
 Aby moduł zbierający elementy bezużyteczne odzyskał obiekty do określonej generacji obiektów, użyj <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> przeciążenia metody. Po określeniu wartości maksymalnej generacji zbierane są wszystkie obiekty.  
  
   
  
## Examples  
 Poniższy przykład wymusza wyrzucanie elementów bezużytecznych dla obiektów generacji <xref:System.GCCollectionMode.Optimized> 2 z ustawieniem.  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" />jest nieprawidłowy.  
  
—lub— 
 <paramref name="mode" />nie jest jedną z <see cref="T:System.GCCollectionMode" /> wartości.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Wywołane kolekcje</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation">Liczba najstarszych generacji do wyrzucania elementów bezużytecznych.</param>
        <param name="mode">Wartość wyliczenia określająca, czy wyrzucanie elementów bezużytecznych <see cref="F:System.GCCollectionMode.Forced" />jest wymuszane (<see cref="F:System.GCCollectionMode.Optimized" /><see cref="F:System.GCCollectionMode.Default" /> lub) czy zoptymalizowane ().</param>
        <param name="blocking"><see langword="true" />Aby wykonać blokowanie wyrzucania elementów bezużytecznych; <see langword="false" /> aby wykonać odzyskiwanie pamięci w tle, tam gdzie jest to możliwe.</param>
        <summary>Wymusza wyrzucanie elementów bezużytecznych z generacji 0 przez określoną generację, w czasie określonym <see cref="T:System.GCCollectionMode" /> przez wartość, o wartości określającej, czy kolekcja powinna blokować.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższa tabela zawiera podsumowanie interakcji `mode` z parametrami i: `blocking`  
  
|`mode`|`blocking`była`true`|`blocking`była`false`|  
|-|-|-|  
|<xref:System.GCCollectionMode.Forced> lub <xref:System.GCCollectionMode.Default>|Kolekcja blokująca jest wykonywana najszybciej, jak to możliwe. Jeśli zbieranie w tle jest w toku i `generation` ma wartość 0 lub 1 <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> , Metoda natychmiast wyzwala kolekcję blokującą i zwraca, gdy kolekcja zostanie zakończona. Jeśli zbieranie w tle jest w toku i `generation` ma wartość 2, metoda czeka, aż kolekcja w tle zostanie zakończona, wyzwala kolekcję blokującą 2, a następnie zwraca wartość.|Kolekcja jest wykonywana najszybciej, jak to możliwe. <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> Metoda żąda kolekcji w tle, ale nie jest to gwarantowane; w zależności od okoliczności nadal może być wykonywana kolekcja blokująca. Jeśli kolekcja w tle jest już w toku, Metoda wraca natychmiast.|  
|<xref:System.GCCollectionMode.Optimized>|Może być wykonywana kolekcja blokująca, w zależności od stanu modułu wyrzucania elementów bezużytecznych i `generation` parametru. Moduł wyrzucania elementów bezużytecznych próbuje zapewnić optymalną wydajność.|Kolekcję można wykonać w zależności od stanu modułu wyrzucania elementów bezużytecznych. <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> Metoda żąda kolekcji w tle, ale nie jest to gwarantowane; w zależności od okoliczności nadal może być wykonywana kolekcja blokująca. Moduł wyrzucania elementów bezużytecznych próbuje zapewnić optymalną wydajność. Jeśli kolekcja w tle jest już w toku, Metoda wraca natychmiast.|  
  
 Jeśli wywołanie <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> metody wykonuje pełne blokowanie wyrzucania elementów bezużytecznych, można również skompaktować stertę dużego obiektu przez <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> ustawienie <xref:System.GC.Collect%2A> właściwości na <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> przed wywołaniem metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" />jest nieprawidłowy.  
  
—lub— 
 <paramref name="mode" />nie jest jedną z <see cref="T:System.GCCollectionMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="compacting" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="generation">Liczba najstarszych generacji do wyrzucania elementów bezużytecznych.</param>
        <param name="mode">Wartość wyliczenia określająca, czy wyrzucanie elementów bezużytecznych <see cref="F:System.GCCollectionMode.Forced" />jest wymuszane (<see cref="F:System.GCCollectionMode.Optimized" /><see cref="F:System.GCCollectionMode.Default" /> lub) czy zoptymalizowane ().</param>
        <param name="blocking"><see langword="true" />Aby wykonać blokowanie wyrzucania elementów bezużytecznych; <see langword="false" /> aby wykonać odzyskiwanie pamięci w tle, tam gdzie jest to możliwe.</param>
        <param name="compacting"><see langword="true" />Aby skompaktować stertę małego obiektu; <see langword="false" /> tylko do wyczyszczenia.</param>
        <summary>Wymusza wyrzucanie elementów bezużytecznych z generacji 0 przez określoną generację, w czasie określonym <see cref="T:System.GCCollectionMode" /> przez wartość, z wartościami, które określają, czy kolekcja powinna blokować i kompaktować.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `blocking` ma`false`wartość, w wykazie globalnym decyduje się, czy ma być wykonywane tło, czy blokujące odzyskiwanie pamięci. Jeśli `compacting` jest`true`, wykonuje blokowanie wyrzucania elementów bezużytecznych.  
  
 Jeśli `compacting` tak`true`, środowisko uruchomieniowe kompaktuje stertę małego obiektu (raport o kondycji). Sterta dużego obiektu (LOH) nie jest kompaktowana, chyba <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> że właściwość jest ustawiona <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>na. Należy zauważyć, że obejmuje to wszystkie blokowanie wyrzucania elementów bezużytecznych, a nie tylko pełne blokowanie odzyskiwania pamięci.  
  
 Można wywołać metodę, <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> aby zredukować zarządzane sterty do możliwie najmniejszego rozmiaru, co ilustruje poniższy fragment kodu.  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 Określenie `true`argumentugwarantujekompaktowanie ,pełneblokowaniewyrzucaniaelementówbezużytecznych.`compacting` Ustawienie właściwości, aby <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> zapewnić kompaktowanie zarówno LOH, jak i raportu o kondycji. <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation">Generowanie obiektów, dla których ma zostać ustalona liczba wyrzucania elementów bezużytecznych.</param>
        <summary>Zwraca liczbę przypadków wyrzucania elementów bezużytecznych dla określonej generacji obiektów.</summary>
        <returns>Liczba przypadków wyrzucania elementów bezużytecznych dla określonej generacji od momentu uruchomienia procesu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku zaimplementowania własnego zarządzania zasobami może zajść potrzeba wymuszenia okresowego wyrzucania <xref:System.GC.Collect%2A> elementów bezużytecznych przez wywołanie metody. Ponieważ jest to kosztowna operacja, można poprawić wydajność, pomijając wywołanie, gdy niedawno wystąpiło wyrzucanie elementów bezużytecznych. Zapisz wartość zwróconą przez <xref:System.GC.CollectionCount%2A> zaraz po wywołaniu <xref:System.GC.Collect%2A>. Przy następnym wywołaniu <xref:System.GC.Collect%2A>należy porównać bieżącą wartość zwracaną przez <xref:System.GC.CollectionCount%2A> wartość zapisanej wartości. Jeśli dwie wartości są równe, żadna kolekcja nie wystąpiła w sposób tymczasowy i jest uzasadnione, aby <xref:System.GC.Collect%2A> ponownie wywołać.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" />jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka tryb opóźnień regionu No.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.EndNoGCRegion%2A> Metoda zgłasza,jeślimodułwyrzucaniaelementówbezużytecznychniejestwtrybie<xref:System.InvalidOperationException> opóźnienia w regionie GC. Dzieje się tak w następujących warunkach:  
  
-   <xref:System.GC.TryStartNoGCRegion%2A> Metoda nie została wcześniej wywołana.  
  
-   Wywołanie <xref:System.GC.TryStartNoGCRegion%2A> metody zostało zwrócone `false`.  
  
-   Wywołanie <xref:System.GC.TryStartNoGCRegion%2A> metody spowodowało wyjątek.  
  
 Wyjątek z jednego z tych powodów można zapobiec za pomocą kodu, takiego jak następujące:  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Moduł wyrzucania elementów bezużytecznych nie jest w trybie opóźnienia w regionie GC.  
  
—lub— 
Tryb opóźnień regionu nie został zakończony wcześniej, ponieważ wywołano wyrzucanie elementów bezużytecznych.  
  
—lub— 
Alokacja pamięci przekroczyła ilość określoną w wywołaniu <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> metody.</exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Tryby opóźnienia</related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera łączną liczbę bajtów przydzieloną do bieżącego wątku od momentu rozpoczęcia jego okresu istnienia.</summary>
        <returns>Całkowita liczba bajtów przydzielono do bieżącego wątku od początku jego okresu istnienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`GetAllocatedBytesForCurrentThread` Metoda zwraca łączną liczbę bajtów przydzieloną na stercie zarządzanym w okresie istnienia wątku, a nie całkowitą liczbę bajtów, które mają przeżyły odzyskiwanie pamięci. Zwracana wartość nie obejmuje również żadnych natywnych przydziałów.

Ta metoda jest najbardziej przydatna w scenariuszach monitorowania w celu mierzenia różnic w alokacji pamięci między przedziałami czasowymi i zdarzeniami.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGCMemoryInfo">
      <MemberSignature Language="C#" Value="public static GCMemoryInfo GetGCMemoryInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCMemoryInfo GetGCMemoryInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGCMemoryInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGCMemoryInfo () As GCMemoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCMemoryInfo GetGCMemoryInfo();" />
      <MemberSignature Language="F#" Value="static member GetGCMemoryInfo : unit -&gt; GCMemoryInfo" Usage="System.GC.GetGCMemoryInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.GCMemoryInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca bieżący numer generacji obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który generuje informacje, jest pobierany dla.</param>
        <summary>Zwraca bieżący numer generacji określonego obiektu.</summary>
        <returns>Bieżąca liczba <paramref name="obj" />generacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby określić wiek obiektu, a następnie użyj tych informacji przy użyciu <xref:System.GC.Collect%2A> metody, aby wymusić zbieranie obiektów przez moduł wyrzucania elementów bezużytecznych w ramach tej samej generacji. Na przykład użyj tej metody, jeśli masz zestaw obiektów, które są tworzone jako Grupa i stają się niedostępne w tym samym czasie.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.GC.GetGeneration%2A> metody w celu określenia wieku obiektu. Przykład następnie wykonuje odzyskiwanie pamięci, aby oczyścić pamięć i porównać całkowite i końcowe ilości pamięci kolekcji w konsoli programu.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="wo">Obiekt <see cref="T:System.WeakReference" /> , który odwołuje się do obiektu docelowego, którego numer generacji ma zostać określony.</param>
        <summary>Zwraca bieżący numer generacji elementu docelowego określonego słabego odwołania.</summary>
        <returns>Bieżąca liczba generacji dla elementu docelowego <paramref name="wo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.GC.GetGeneration%2A> metody do określenia wieku słabego obiektu referencyjnego.  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wyrzucanie elementów bezużytecznych <paramref name="wo" />zostało już wykonane.</exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalAllocatedBytes">
      <MemberSignature Language="C#" Value="public static long GetTotalAllocatedBytes (bool precise = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalAllocatedBytes(bool precise) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalAllocatedBytes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalAllocatedBytes (Optional precise As Boolean = false) As Long" />
      <MemberSignature Language="F#" Value="static member GetTotalAllocatedBytes : bool -&gt; int64" Usage="System.GC.GetTotalAllocatedBytes precise" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precise" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="precise">W <see langword="true" />przypadku zbierania dokładnej liczby; w przeciwnym razie Zbierz przybliżoną liczbę. Gromadzenie dokładnej wartości powoduje znaczącą spadek wydajności.</param>
        <summary>Pobiera liczbę bajtów przydzieloną w okresie istnienia procesu.</summary>
        <returns>Całkowita liczba bajtów przydzielono w okresie istnienia procesu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection"><see langword="true" />Aby wskazać, że ta metoda może oczekiwać na wystąpienie wyrzucania elementów bezużytecznych przed zwróceniem; w przeciwnym razie. <see langword="false" /></param>
        <summary>Pobiera liczbę bajtów, które są aktualnie uważane za przydzieloną. Parametr wskazuje, czy ta metoda może oczekiwać krótkiego interwału przed zwróceniem, aby umożliwić systemowi zbieranie elementów bezużytecznych i finalizowanie obiektów.</summary>
        <returns>Liczba, która jest najlepszym dostępnym przybliżeniem liczby bajtów aktualnie przydzieloną w pamięci zarządzanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli parametr ma `true`wartość, ta metoda czeka krótki interwał przed zwróceniem, podczas gdy system zbiera elementy bezużyteczne i finalizowanie obiektów. `forceFullCollection` Czas trwania interwału to wewnętrznie określony limit określony przez liczbę cykli wyrzucania elementów bezużytecznych i zmiany ilości pamięci, która jest odzyskiwana między cyklami. Moduł wyrzucania elementów bezużytecznych nie gwarantuje, że jest zbierana cała niedostępna pamięć.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak za pomocą <xref:System.GC.GetTotalMemory%2A> metody pobrać i wyświetlić liczbę bajtów aktualnie przydzieloną w pamięci zarządzanej.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do odwołania.</param>
        <summary>Odwołuje się do określonego obiektu, co sprawia, że nie kwalifikuje się do wyrzucania elementów bezużytecznych od początku bieżącej procedury do punktu, w którym ta metoda jest wywoływana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Celem <xref:System.GC.KeepAlive%2A> metody jest upewnienie się, że istnieje odwołanie do obiektu, który jest zagrożony przez moduł wyrzucania elementów bezużytecznych. Typowy scenariusz, w którym może się zdarzyć, ma miejsce, gdy nie ma odwołań do obiektu w kodzie zarządzanym lub danych, ale obiekt jest nadal używany w kodzie niezarządzanym, takim jak interfejsy API systemu Windows, niezarządzane biblioteki DLL lub metody przy użyciu modelu COM.  
  
 Ta metoda odwołuje `obj` się do parametru, dzięki czemu ten obiekt nie kwalifikuje się do wyrzucania elementów bezużytecznych od początku procedury do punktu w kolejności wykonywania, gdzie ta metoda jest wywoływana. Zakodować tę metodę na końcu, a nie na początku, zakresu instrukcji, gdzie `obj` muszą być dostępne.  
  
 <xref:System.GC.KeepAlive%2A> Metoda nie wykonuje operacji i nie generuje żadnych efektów ubocznych innych niż przedłużenie okresu istnienia obiektu przenoszonego jako parametr.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy obiekt na początku jego `Main` metody i nie odwołuje się ponownie do obiektu do momentu zakończenia, <xref:System.GC.KeepAlive%2A> gdy wywoływana jest metoda. Obiekt utrzymuje się na 30-sekundowym czasie trwania `Main` metody, pomimo wywołań <xref:System.GC.Collect%2A> metod i <xref:System.GC.WaitForPendingFinalizers%2A> .  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną liczbę generacji, które obecnie obsługuje system.</summary>
        <value>Wartość z zakresu od zera do maksymalnej liczby obsługiwanych generacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numer generacji lub wiek obiektu jest zdefiniowaną w implementacji miarą względną dla cykl życia obiektu. Ostatnio utworzone obiekty są w generacji 0, a najstarsze obiekty znajdują się w generacji mniejszej lub równej generacji zwróconej przez <xref:System.GC.MaxGeneration%2A> właściwość.  
  
 Moduł wyrzucania elementów bezużytecznych zakłada, że nowsza ilość pamięci jest prawdopodobnie uprawniona do wyrzucania elementów bezużytecznych. W związku z tym moduł wyrzucania elementów bezużytecznych zwiększa wydajność, dopasowując numery generacji przy każdym <xref:System.GC.MaxGeneration%2A> odzyskiwaniu pamięci, a wartość właściwości może się zwiększać wraz z upływem czasu.  
  
 Jeśli zaimplementowano przedawnianie obiektów, <xref:System.GC.MaxGeneration%2A> Właściwość zwraca maksymalny numer generacji używany przez system; w przeciwnym razie ta właściwość zwraca zero.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak użyć właściwości MaxGeneration, aby wyświetlić największy numer generacji, który jest aktualnie używany.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>W przypadku tej implementacji wartość zwrócona przez <see cref="P:System.GC.MaxGeneration" /> właściwość jest gwarantowana na stałą dla okresu istnienia aplikacji, która wykonuje.  
  
Użyj właściwości, aby określić maksymalną wartość, którą można określić podczas <see cref="M:System.GC.Collect(System.Int32)" /> wywoływania metody, która przyjmuje parametr generacji. <see cref="P:System.GC.MaxGeneration" /></para></block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">Liczba z zakresu od 1 do 99 określająca, kiedy powiadomienie powinno być zgłaszane na podstawie obiektów przyznanych w generacji 2.</param>
        <param name="largeObjectHeapThreshold">Liczba z zakresu od 1 do 99 określająca, kiedy powiadomienie powinno być zgłaszane na podstawie obiektów przyznanych w stercie dużego obiektu.</param>
        <summary>Określa, że należy podwyższyć powiadomienie o wyrzucaniu elementów bezużytecznych, gdy warunki preferują pełne odzyskiwanie pamięci i gdy kolekcja została ukończona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla każdej generacji moduł zbierający elementy bezużyteczne ustawia próg alokacji dla tej generacji. Gdy rozmiar alokacji przekracza ten próg, wyrzucanie elementów bezużytecznych jest wyzwalane na tej generacji. Na przykład jeśli wartość progowa generacji 2 to baza (co oznacza, że baza przeżyje 1 kolekcje i zostanie podwyższony do generacji 2), a więcej niż baza przestała 1 i zostanie wyświetlony monit do generacji 2, zostanie podjęta kolejna próba wyrzucania elementów bezużytecznych jako kolekcja generacji 2. Podobnie, jeśli wartość progowa sterty dużego obiektu (LOH) to baza, a aplikacja przydzieliła więcej niż baza dużych obiektów, kolejne odzyskiwanie pamięci zostanie również ponowione jako kolekcja generacji 2 (ponieważ LOH jest zbierana tylko w Gen2 rekolekcji elementów bezużytecznych).  
  
 `maxGenerationThreshold` Progi `largeObjectHeapThreshold` i decydują o tym, jak dużo z wyprzedzeniem otrzymujesz powiadomienie przed wystąpieniem pełnego wyrzucania elementów bezużytecznych. Im większy próg, tym więcej alokacji, które mogą wystąpić między powiadomieniem i następnym pełnym wyrzucaniem elementów bezużytecznych.  
  
 Jeśli masz sytuacje, w których pełne wyrzucanie elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego nie wpłynie negatywnie na wydajność aplikacji, możesz polecić otrzymywanie powiadomień, gdy środowisko uruchomieniowe ma wykonać pełne odzyskiwanie pamięci i obejść tę kolekcję przez Wywoływanie kolekcji (przy użyciu <xref:System.GC.Collect%2A> metody), gdy warunki są nadal preferowane. Oprócz zmieniania harmonogramu wyrzucania elementów bezużytecznych, pełne powiadomienie w ramach programu GC jest przydatne w następujących scenariuszach:  
  
-   Możesz monitorować podejście do pełnego wyrzucania elementów bezużytecznych i, gdy otrzymasz powiadomienie, że jedna z nich zbliża się, zmniejszy się rozmiar danych na żywo (na przykład przez wydanie niektórych wpisów pamięci podręcznej). W związku z tym, gdy następuje wyrzucanie elementów bezużytecznych, jest możliwe odjęcie większej ilości pamięci.  
  
-   Możesz monitorować ukończenie pełnego wyrzucania elementów bezużytecznych, dzięki czemu można zbierać pewne dane statystyczne.  Na przykład może zajść potrzeba mierzenia rozmiaru sterty na zakończenie GC, aby znać rozmiar danych na żywo. (Po pełnym wykazie globalnym sterta ma najmniejszy rozmiar).  
  
 Aby uzyskać więcej informacji o tym, co reprezentuje pełne odzyskiwanie pamięci, zobacz powiadomienia dotyczące wyrzucania [elementów](~/docs/standard/garbage-collection/notifications.md)bezużytecznych.  
  
 Po zarejestrowaniu do powiadomienia o wyrzucaniu elementów bezużytecznych można otrzymywać powiadomienia, gdy zostanie zbliżane pełne odzyskiwanie pamięci. Ten wzorzec przypomina, jak system operacyjny monitoruje w przypadku powiadomień o niskiej ilości pamięci.  
  
 Aby określić `maxGenerationThreshold` parametry i `largeObjectHeapThreshold` należy użyć następujących wytycznych:  
  
-   Im większa wartość progowa, tym większa alokacja będzie odbywać się między powiadomieniem i pełnym wyrzucaniem elementów bezużytecznych.  
  
     Większa wartość progowa daje więcej możliwości dla środowiska uruchomieniowego, aby sprawdzić, czy zbliża się kolekcja. Zwiększa to prawdopodobieństwo, że użytkownik zostanie powiadomiony. Nie należy jednak ustawiać progu zbyt wysoki, ponieważ powoduje to większe alokacje zanim środowisko uruchomieniowe wymusi następną kolekcję.  
  
     Gdy samodzielnie wywołujesz kolekcję po powiadomieniu przy użyciu dużej wartości progowej, mniej obiektów są odzyskiwane, niż byłyby odzyskiwane przez następną kolekcję środowiska uruchomieniowego.  
  
-   Im mniejsza wartość progowa, tym mniejsza ilość alokacji między powiadomieniem a pełnym odzyskiwaniem pamięci.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób rejestrowania powiadomienia o wyrzucaniu elementów bezużytecznych i uruchamiania wątku do monitorowania stanu powiadomienia o wyrzucaniu elementów bezużytecznych. Ten przykład kodu jest częścią większego przykładu dostarczonego w temacie powiadomienia o wyrzucaniu [elementów](~/docs/standard/garbage-collection/notifications.md) bezużytecznych.  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxGenerationThreshold" />lub <paramref name="largeObjectHeapThreshold" /> nie należy do zakresu od 1 do 99.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Powiadomienia dotyczące odzyskiwania pamięci</related>
        <exception cref="T:System.InvalidOperationException">Ten element członkowski nie jest dostępny, gdy włączone jest współbieżne wyrzucanie elementów bezużytecznych. Zobacz ustawienie &lt;środowiska&gt; uruchomieniowego gcConcurrent, aby uzyskać informacje o tym, jak wyłączyć współbieżne odzyskiwanie pamięci.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Ilość pamięci niezarządzanej, która została wydana.</param>
        <summary>Informuje środowisko uruchomieniowe, że niezarządzana pamięć została wydana i nie trzeba już brać pod uwagę podczas planowania wyrzucania elementów bezużytecznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W celu określenia czasu, w którym należy zaplanować wyrzucanie elementów bezużytecznych, środowisko uruchomieniowe uwzględnia ilość przydzielonej pamięci zarządzanej. Jeśli mały zarządzany obiekt przydzieli dużą ilość pamięci niezarządzanej, środowisko uruchomieniowe bierze pod uwagę tylko zarządzaną pamięć i w ten sposób szacuje pilność planowania wyrzucania elementów bezużytecznych. Metoda informuje środowisko uruchomieniowe tego dodatkowego nacisku w pamięci systemowej, <xref:System.GC.RemoveMemoryPressure%2A> a metoda informuje środowisko uruchomieniowe o zwolnieniu dodatkowego nacisku. <xref:System.GC.AddMemoryPressure%2A>  
  
 W najprostszym wzorcu użycia obiekt zarządzany przydziela niezarządzaną pamięć w konstruktorze i zwalnia go w `Dispose` metodzie lub. `Finalize` Wywołaj <xref:System.GC.RemoveMemoryPressure%2A> metodę po przydzieleniu pamięci niezarządzanej i Wywołaj metodę po jej zwolnieniu. <xref:System.GC.AddMemoryPressure%2A>  
  
 W bardziej skomplikowanych scenariuszach, w których niezarządzana alokacja pamięci ulega znacznemu zmianie w okresie istnienia zarządzanego obiektu, <xref:System.GC.AddMemoryPressure%2A> można <xref:System.GC.RemoveMemoryPressure%2A> wywołać metody i, aby przekazać te przyrostowe zmiany do środowiska uruchomieniowego.  
  
> [!CAUTION]
>  Należy upewnić się, że należy usunąć dokładnie ilość dodawanego nacisku. Niewykonanie tej czynności może niekorzystnie wpłynąć na wydajność systemu w aplikacjach uruchamianych przez długi czas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bytesAllocated" />jest mniejsze lub równe 0.  
  
—lub— 
Na komputerze <paramref name="bytesAllocated" /> 32-bitowym jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">umożliwia wywoływanie kodu niezarządzanego podczas manipulowania priorytetem kolekcji elementów bezużytecznych. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, dla którego należy wywołać finalizator.</param>
        <summary>Żąda, aby system wywoływał finalizator dla określonego obiektu, dla którego <see cref="M:System.GC.SuppressFinalize(System.Object)" /> poprzednio został wywołany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.ReRegisterForFinalize%2A> Metoda`obj` dodaje parametr do listy obiektów, które żądają finalizowania, zanim moduł wyrzucania elementów bezużytecznych zwolni obiekt. `obj` Parametr musi być obiektem wywołującym tej metody.  
  
 <xref:System.GC.ReRegisterForFinalize%2A> Wywołanie metody nie gwarantuje, że moduł wyrzucania elementów bezużytecznych wywoła finalizator obiektu.  
  
 Domyślnie wszystkie obiekty implementujące finalizatory są dodawane do listy obiektów, które wymagają finalizacji; Jednak obiekt mógł zostać już sfinalizowany lub mógł wyłączyć finalizowanie, wywołując <xref:System.GC.SuppressFinalize%2A> metodę.  
  
 Finalizator może użyć tej metody do przywracania aktywności samego siebie lub obiektu, do którego się odwołuje.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia metody ReRegisterForFinalize w celu sfinalizowania obiektu po raz drugi po wyrzucaniu elementów bezużytecznych.  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, którego finalizator nie może zostać wykonany.</param>
        <summary>Żąda, aby środowisko uruchomieniowe języka wspólnego nie wywołało finalizatora dla określonego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia bit w nagłówku `obj`obiektu, którego środowisko uruchomieniowe sprawdza podczas wywoływania finalizatorów. Finalizator, który jest reprezentowany przez <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodę, jest używany do zwalniania niezarządzanych zasobów, zanim obiekt zostanie pobrany jako bezużyteczny. Jeśli `obj` nie ma finalizatora, wywołanie <xref:System.GC.SuppressFinalize%2A> metody nie ma wpływu.  
  
 Obiekty implementujące <xref:System.IDisposable> interfejs mogą wywołać tę metodę z <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji obiektu, aby zapobiec wywoływaniu <xref:System.Object.Finalize%2A?displayProperty=nameWithType> przez moduł wyrzucania elementów bezużytecznych na obiekcie, który go nie wymaga. Zwykle jest to spowodowane tym, że nie można zwolnić niezarządzanych zasobów, które zostały już zwolnione przez <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementację.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.GC.SuppressFinalize%2A> metody w klasie zasobów, aby zapobiec wywoływaniu nadmiarowego wyrzucania elementów bezużytecznych. W przykładzie pokazano użycie [wzorca Dispose](~/docs/standard/garbage-collection/implementing-dispose.md) do zwolnienia zasobów zarządzanych (czyli obiektów, które implementują <xref:System.IDisposable>) i niezarządzanych zasobów.  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="https://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb">Usuń wzorzec</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje uniemożliwić wyrzucanie elementów bezużytecznych podczas wykonywania ścieżki krytycznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nie można zagnieżdżać wywołań do <xref:System.GC.TryStartNoGCRegion%2A> metody i należy <xref:System.GC.EndNoGCRegion%2A> wywołać metodę tylko wtedy, gdy środowisko uruchomieniowe jest obecnie w trybie opóźnień w regionie GC. Innymi słowy, nie należy wywoływać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania zakończą się niepowodzeniem) i nie należy oczekiwać, aby <xref:System.GC.EndNoGCRegion%2A> wywołania kończyły się pomyślnie, <xref:System.GC.TryStartNoGCRegion%2A> ponieważ pierwsze wywołanie zakończyło się pomyślnie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize">Ilość pamięci w bajtach do przydzielenia bez wyzwalania wyrzucania elementów bezużytecznych. Musi być mniejszy niż lub równy rozmiarowi segmentu tymczasowych. Informacje o rozmiarze segmentu tymczasowych można znaleźć w sekcji "tymczasowe generacje i segmenty" w artykule [podstawowe informacje o odzyskiwaniu elementów](~/docs/standard/garbage-collection/fundamentals.md) bezużytecznych.</param>
        <summary>Próbuje uniemożliwić wyrzucanie elementów bezużytecznych podczas wykonywania ścieżki krytycznej, jeśli jest dostępna określona ilość pamięci.</summary>
        <returns><see langword="true" />Jeśli środowisko uruchomieniowe mogło zatwierdzić wymaganą ilość pamięci, a Moduł wyrzucania elementów bezużytecznych może wejść w tryb opóźnienia w regionie GC; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> Metoda próbuje umieścić Moduł wyrzucania elementów bezużytecznych w trybie opóźnienia w regionie GC, który uniemożliwia wyrzucanie elementów bezużytecznych, gdy aplikacja wykonuje krytyczny region kodu.  Jeśli środowisko uruchomieniowe nie może początkowo przydzielić żądanej ilości pamięci, Moduł wyrzucania elementów bezużytecznych wykonuje pełne blokowanie wyrzucania elementów bezużytecznych podczas próby zwolnienia dodatkowej pamięci. Moduł wyrzucania elementów bezużytecznych nie przechodzi w tryb opóźnienia regionu GC, jeśli może przydzielić wymaganą ilość pamięci, która w tym przypadku `totalSize` jest w rzeczywistości 2 * bajtów `totalSize` (próbuje przydzielić bajty `totalSize` dla sterty małego obiektu i bajtów dla Sterta dużego obiektu.  
  
 `totalSize`musi być wystarczająco duży, aby obsługiwał wszystkie alokacje pamięci, które występują w ścieżce krytycznej. Obejmuje to alokacje przez aplikację, a także alokacje, które środowisko uruchomieniowe wykonuje w imieniu aplikacji.  
  
> [!IMPORTANT]
>  Nie można zagnieżdżać wywołań do <xref:System.GC.TryStartNoGCRegion%2A> metody i należy <xref:System.GC.EndNoGCRegion%2A> wywołać metodę tylko wtedy, gdy środowisko uruchomieniowe jest obecnie w trybie opóźnień w regionie GC. Innymi słowy, nie należy wywoływać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania zakończą się niepowodzeniem) i nie należy oczekiwać, aby <xref:System.GC.EndNoGCRegion%2A> wywołania kończyły się pomyślnie, <xref:System.GC.TryStartNoGCRegion%2A> ponieważ pierwsze wywołanie zakończyło się pomyślnie.  
  
 Aby wyjść z trybu opóźnień z regionem GC, <xref:System.GC.EndNoGCRegion%2A> należy wywołać metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" />przekracza rozmiar segmentu tymczasowych.</exception>
        <exception cref="T:System.InvalidOperationException">Proces jest już w trybie opóźnień w regionie GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Podstawy dotyczące wyrzucania elementów bezużytecznych</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Tryby opóźnienia</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize">Ilość pamięci w bajtach do przydzielenia bez wyzwalania wyrzucania elementów bezużytecznych. Musi być mniejszy niż lub równy rozmiarowi segmentu tymczasowych. Informacje o rozmiarze segmentu tymczasowych można znaleźć w sekcji "tymczasowe generacje i segmenty" w artykule [podstawowe informacje o odzyskiwaniu elementów](~/docs/standard/garbage-collection/fundamentals.md) bezużytecznych.</param>
        <param name="disallowFullBlockingGC"><see langword="true" />Aby pominąć pełne blokowanie wyrzucania elementów bezużytecznych, <paramref name="totalSize" /> <see langword="false" />Jeśli moduł wyrzucania elementów bezużytecznych nie może początkowo przydzielić bajtów; w przeciwnym razie.</param>
        <summary>Próbuje uniemożliwić wyrzucanie elementów bezużytecznych podczas wykonywania ścieżki krytycznej, jeśli jest dostępna określona ilość pamięci i kontroluje, czy moduł wyrzucania elementów bezużytecznych wykonuje pełne blokowanie wyrzucania elementów bezużytecznych, jeśli nie jest dostępna wystarczająca ilość pamięci.</summary>
        <returns><see langword="true" />Jeśli środowisko uruchomieniowe mogło zatwierdzić wymaganą ilość pamięci, a Moduł wyrzucania elementów bezużytecznych może wejść w tryb opóźnienia w regionie GC; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> Metoda próbuje umieścić Moduł wyrzucania elementów bezużytecznych w trybie opóźnienia w regionie GC, który uniemożliwia wyrzucanie elementów bezużytecznych, gdy aplikacja wykonuje krytyczny region kodu.  Jeśli środowisko uruchomieniowe nie może początkowo przydzielić żądanej ilości pamięci, a `disallowFullBlockingGC` argument to `false`, Moduł wyrzucania elementów bezużytecznych wykonuje pełne blokowanie wyrzucania elementów bezużytecznych w próbie zwolnienia dodatkowej pamięci; w przeciwnym razie alokacja kończy się niepowodzeniem, a `false`Metoda zwraca. Moduł wyrzucania elementów bezużytecznych nie przechodzi w tryb opóźnienia regionu GC, jeśli może przydzielić wymaganą ilość pamięci, która w tym przypadku `totalSize` jest w rzeczywistości 2 * `totalSize` (próbuje przydzielić sterty małego obiektu i `totalSize` dla dużego obiektu Sterta).  
  
 `totalSize`musi być wystarczająco duży, aby obsługiwał wszystkie alokacje pamięci, które występują w ścieżce krytycznej. Obejmuje to alokacje przez aplikację, a także alokacje, które środowisko uruchomieniowe wykonuje w imieniu aplikacji.  
  
 Ustawienie `disallowFullBlockingGC`zapobiegające pełnemu blokowaniu wyrzucania elementów bezużytecznych, jeśli nie jest dostępna wystarczająca ilość pamięci jest najbardziej przydatna w scenariuszach równoważenia obciążenia: jeden system może wywołać tę metodę i zgłosić się jako gotowy do akceptowania żądań, jeśli zwróci wartość `true` i moduł równoważenia obciążenia przekierowuje żądania do innych systemów, jeśli zwróci wartość `false`. `true` Następnie może wykonać pełne blokowanie wyrzucania elementów bezużytecznych, gdy nie obsługuje żądań przez <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> wywołanie metody.  
  
> [!IMPORTANT]
>  Nie można zagnieżdżać wywołań do <xref:System.GC.TryStartNoGCRegion%2A> metody i należy <xref:System.GC.EndNoGCRegion%2A> wywołać metodę tylko wtedy, gdy środowisko uruchomieniowe jest obecnie w trybie opóźnień w regionie GC. Innymi słowy, nie należy wywoływać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania zakończą się niepowodzeniem) i nie należy oczekiwać, aby <xref:System.GC.EndNoGCRegion%2A> wywołania kończyły się pomyślnie, <xref:System.GC.TryStartNoGCRegion%2A> ponieważ pierwsze wywołanie zakończyło się pomyślnie.  
  
 Aby wyjść z trybu opóźnień z regionem GC, <xref:System.GC.EndNoGCRegion%2A> należy wywołać metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" />przekracza rozmiar segmentu tymczasowych.</exception>
        <exception cref="T:System.InvalidOperationException">Proces jest już w trybie opóźnień w regionie GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Podstawy dotyczące wyrzucania elementów bezużytecznych</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Tryby opóźnienia</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize">Ilość pamięci w bajtach do przydzielenia bez wyzwalania wyrzucania elementów bezużytecznych. <paramref name="totalSize" /> -<paramref name="lohSize" />musi być mniejszy niż lub równy rozmiarowi segmentu tymczasowych. Informacje o rozmiarze segmentu tymczasowych można znaleźć w sekcji "tymczasowe generacje i segmenty" w artykule [podstawowe informacje o odzyskiwaniu elementów](~/docs/standard/garbage-collection/fundamentals.md) bezużytecznych.</param>
        <param name="lohSize">Liczba bajtów <paramref name="totalSize" /> , które mają być używane dla przydziałów sterty dużych obiektów (LOH).</param>
        <summary>Próbuje uniemożliwić wyrzucanie elementów bezużytecznych podczas wykonywania ścieżki krytycznej, jeśli określona ilość pamięci jest dostępna dla sterty dużych obiektów i sterty małego obiektu.</summary>
        <returns><see langword="true" />Jeśli środowisko uruchomieniowe mogło zatwierdzić wymaganą ilość pamięci, a Moduł wyrzucania elementów bezużytecznych może wejść w tryb opóźnienia w regionie GC; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> Metoda próbuje umieścić Moduł wyrzucania elementów bezużytecznych w trybie opóźnienia w regionie GC, który uniemożliwia wyrzucanie elementów bezużytecznych, gdy aplikacja wykonuje krytyczny region kodu.  Jeśli środowisko uruchomieniowe nie może początkowo przydzielić żądanej ilości pamięci, Moduł wyrzucania elementów bezużytecznych wykonuje pełne blokowanie wyrzucania elementów bezużytecznych podczas próby zwolnienia dodatkowej pamięci. Moduł wyrzucania elementów bezużytecznych nie przechodzi w tryb opóźnienia regionu GC `lohSize` , jeśli jest w `totalSize` stanie przydzielić LOH oraz  -  `lohSize` dla sterty małego obiektu (raport o kondycji).  
  
 `lohSize`musi być wystarczająco duży, aby obsługiwał wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla LOH, `totalSize` i  -  `lohSize` muszą być wystarczająco duże, aby obsługiwać wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla raportu o kondycji. Obejmuje to alokacje przez aplikację, a także alokacje, które środowisko uruchomieniowe wykonuje w imieniu aplikacji.  
  
> [!IMPORTANT]
>  Nie można zagnieżdżać wywołań do <xref:System.GC.TryStartNoGCRegion%2A> metody i należy <xref:System.GC.EndNoGCRegion%2A> wywołać metodę tylko wtedy, gdy środowisko uruchomieniowe jest obecnie w trybie opóźnień w regionie GC. Innymi słowy, nie należy wywoływać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania zakończą się niepowodzeniem) i nie należy oczekiwać, aby <xref:System.GC.EndNoGCRegion%2A> wywołania kończyły się pomyślnie, <xref:System.GC.TryStartNoGCRegion%2A> ponieważ pierwsze wywołanie zakończyło się pomyślnie.  
  
 Aby wyjść z trybu opóźnień z regionem GC, <xref:System.GC.EndNoGCRegion%2A> należy wywołać metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> - <paramref name="lohSize" />przekracza rozmiar segmentu tymczasowych.</exception>
        <exception cref="T:System.InvalidOperationException">Proces jest już w trybie opóźnień w regionie GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Podstawy dotyczące wyrzucania elementów bezużytecznych</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Tryby opóźnienia</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize">Ilość pamięci w bajtach do przydzielenia bez wyzwalania wyrzucania elementów bezużytecznych. <paramref name="totalSize" /> -<paramref name="lohSize" />musi być mniejszy niż lub równy rozmiarowi segmentu tymczasowych. Informacje o rozmiarze segmentu tymczasowych można znaleźć w sekcji "tymczasowe generacje i segmenty" w artykule [podstawowe informacje o odzyskiwaniu elementów](~/docs/standard/garbage-collection/fundamentals.md) bezużytecznych.</param>
        <param name="lohSize">Liczba bajtów <paramref name="totalSize" /> , które mają być używane dla przydziałów sterty dużych obiektów (LOH).</param>
        <param name="disallowFullBlockingGC"><see langword="true" />Aby pominąć pełne blokowanie wyrzucania elementów bezużytecznych, jeśli moduł wyrzucania elementów bezużytecznych nie może początkowo przydzielić określonej pamięci na stosie małego obiektu (raport o kondycji) i LOH; w przeciwnym razie. <see langword="false" /></param>
        <summary>Próbuje uniemożliwić wyrzucanie elementów bezużytecznych podczas wykonywania ścieżki krytycznej, jeśli określona ilość pamięci jest dostępna dla sterty dużych obiektów i sterty małego obiektu i kontroluje, czy moduł wyrzucania elementów bezużytecznych wykonuje pełne blokowanie wyrzucania elementów bezużytecznych, jeśli nie Początkowo dostępna jest wystarczająca ilość pamięci.</summary>
        <returns><see langword="true" />Jeśli środowisko uruchomieniowe mogło zatwierdzić wymaganą ilość pamięci, a Moduł wyrzucania elementów bezużytecznych może wejść w tryb opóźnienia w regionie GC; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> Metoda próbuje umieścić Moduł wyrzucania elementów bezużytecznych w trybie opóźnienia w regionie GC, który uniemożliwia wyrzucanie elementów bezużytecznych, gdy aplikacja wykonuje krytyczny region kodu.  Jeśli środowisko uruchomieniowe nie może początkowo przydzielić żądanej ilości pamięci, a `disallowFullBlockingGC` argument to `false`, Moduł wyrzucania elementów bezużytecznych wykonuje pełne blokowanie wyrzucania elementów bezużytecznych w próbie zwolnienia dodatkowej pamięci; w przeciwnym razie alokacja kończy się niepowodzeniem, a `false`Metoda zwraca. Moduł wyrzucania elementów bezużytecznych nie przechodzi w tryb opóźnienia regionu GC `lohSize` , jeśli jest w `totalSize` stanie przydzielić LOH oraz  -  `lohSize` dla sterty małego obiektu (raport o kondycji).  
  
 `lohSize`musi być wystarczająco duży, aby obsługiwał wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla LOH, `totalSize` i  -  `lohSize` muszą być wystarczająco duże, aby obsługiwać wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla raportu o kondycji. Obejmuje to alokacje przez aplikację, a także alokacje, które środowisko uruchomieniowe wykonuje w imieniu aplikacji.  
  
 Ustawienie `disallowFullBlockingGC`zapobiegające pełnemu blokowaniu wyrzucania elementów bezużytecznych, jeśli nie jest dostępna wystarczająca ilość pamięci jest najbardziej przydatna w scenariuszach równoważenia obciążenia: jeden system może wywołać tę metodę i zgłosić się jako gotowy do akceptowania żądań, jeśli zwróci wartość `true` i moduł równoważenia obciążenia przekierowuje żądania do innych systemów, jeśli zwróci wartość `false`. `true` Następnie może wykonać pełne blokowanie wyrzucania elementów bezużytecznych, gdy nie obsługuje żądań przez <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> wywołanie metody.  
  
> [!IMPORTANT]
>  Nie można zagnieżdżać wywołań do <xref:System.GC.TryStartNoGCRegion%2A> metody i należy <xref:System.GC.EndNoGCRegion%2A> wywołać metodę tylko wtedy, gdy środowisko uruchomieniowe jest obecnie w trybie opóźnień w regionie GC. Innymi słowy, nie należy wywoływać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania zakończą się niepowodzeniem) i nie należy oczekiwać, aby <xref:System.GC.EndNoGCRegion%2A> wywołania kończyły się pomyślnie, <xref:System.GC.TryStartNoGCRegion%2A> ponieważ pierwsze wywołanie zakończyło się pomyślnie.  
  
 Aby wyjść z trybu opóźnień z regionem GC, <xref:System.GC.EndNoGCRegion%2A> należy wywołać metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> - <paramref name="lohSize" />przekracza rozmiar segmentu tymczasowych.</exception>
        <exception cref="T:System.InvalidOperationException">Proces jest już w trybie opóźnień w regionie GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Podstawy dotyczące wyrzucania elementów bezużytecznych</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Tryby opóźnienia</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca stan zarejestrowanego powiadomienia w celu określenia, czy pełna, blokująca wyrzucanie elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego jest bliska.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca stan zarejestrowanego powiadomienia w celu określenia, czy pełna, blokująca wyrzucanie elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego jest bliska.</summary>
        <returns>Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj wyliczenia zwróconego przez tę metodę, aby określić stan bieżącego powiadomienia o wyrzucaniu elementów bezużytecznych, które <xref:System.GC.RegisterForFullGCNotification%2A> zostało zarejestrowane za pomocą metody. <xref:System.GCNotificationStatus> Można również użyć <xref:System.GC.WaitForFullGCComplete%2A> metody, aby określić, czy pełne odzyskiwanie pamięci zostało zakończone.  
  
 Gdy Wyliczenie zwraca <xref:System.GCNotificationStatus.Succeeded>, można wykonywać zadania, takie jak uniemożliwienie przydzielenia dodatkowych obiektów i wywoływanie kolekcji <xref:System.GC.Collect%2A> przy użyciu metody. Należy pamiętać, że powiadomienie nie gwarantuje, że zostanie wykonane pełne odzyskiwanie pamięci, tylko te warunki osiągnęły próg, który jest preferowany do wykonania pełnego odzyskiwania pamięci.  
  
 Ta metoda czeka na nieokreślony czas na uzyskanie powiadomienia o wyrzucaniu elementów bezużytecznych. Jeśli chcesz określić limit czasu dla metody, która ma zostać zwrócona, jeśli nie można uzyskać powiadomienia, użyj <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> przeciążenia metody. W <xref:System.GC.CancelFullGCNotification%2A> przypadku wywołania tej metody bez określenia limitu czasu można wywołać metodę, jeśli czekasz dłużej niż preferowane.  
  
 Należy wykonać tę metodę z wywołaniem <xref:System.GC.WaitForFullGCComplete%2A> metody, aby upewnić się, że masz pełne odzyskiwanie pamięci. Wywołanie tej metody powoduje jedynie nieokreślony wynik.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać tej metody w celu ustalenia, czy jest zbliżana pełna, blokująca wyrzucanie elementów bezużytecznych. Zawsze, gdy jest <xref:System.GCNotificationStatus.Succeeded>wskazywany stan powiadomienia, Metoda `OnFullGCApproachNotify` użytkownika jest wywoływana w celu wykonywania akcji w odpowiedzi na zbliżające się kolekcje. Ten przykład kodu jest częścią większego przykładu dostarczonego w temacie powiadomienia o wyrzucaniu [elementów](~/docs/standard/garbage-collection/notifications.md) bezużytecznych.  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Powiadomienia dotyczące odzyskiwania pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Czas oczekiwania na uzyskanie stanu powiadomienia. Określ-1, aby czekać w nieskończoność.</param>
        <summary>Zwraca w określonym przedziale czasu stan zarejestrowanego powiadomienia w celu określenia, czy pełna, blokująca wyrzucanie elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego jest bliska.</summary>
        <returns>Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj wyliczenia zwróconego przez tę metodę, aby określić stan bieżącego powiadomienia o wyrzucaniu elementów bezużytecznych, które <xref:System.GC.RegisterForFullGCNotification%2A> zostało zarejestrowane za pomocą metody. <xref:System.GCNotificationStatus> Można również użyć <xref:System.GC.WaitForFullGCComplete%2A> metody, aby określić, czy pełne odzyskiwanie pamięci zostało zakończone.  
  
 Należy zauważyć, że ta metoda zwraca natychmiast za każdym razem, gdy zostanie uzyskany stan powiadomienia o wyrzucaniu `millisecondsTimeout`elementów bezużytecznych, niezależnie od wartości określonej przez. Jeśli stan powiadomienia o wyrzucaniu elementów bezużytecznych nie zostanie uzyskany przed <xref:System.GCNotificationStatus.NotApplicable>upływem `millisecondsTimeout` limitu czasu, ta metoda zwróci wartość.  
  
 Gdy Wyliczenie zwraca <xref:System.GCNotificationStatus.Succeeded>, można wykonywać zadania, takie jak uniemożliwienie przydzielenia dodatkowych obiektów i wywoływanie kolekcji <xref:System.GC.Collect%2A> przy użyciu metody. Należy pamiętać, że powiadomienie nie gwarantuje, że zostanie wykonane pełne odzyskiwanie pamięci, tylko te warunki osiągnęły próg, który jest preferowany do wykonania pełnego odzyskiwania pamięci.  
  
 Metodę można wywołać, <xref:System.GC.CancelFullGCNotification%2A> gdy nie można czekać, aż upłynie limit czasu.  
  
 Należy wykonać tę metodę z wywołaniem <xref:System.GC.WaitForFullGCComplete%2A> metody, aby upewnić się, że masz pełne odzyskiwanie pamięci. Wywołanie tej metody powoduje jedynie nieokreślony wynik.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />musi być wartością nieujemną lub mniejszą lub równą <see cref="F:System.Int32.MaxValue" /> lub-1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Powiadomienia dotyczące odzyskiwania pamięci</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca stan zarejestrowanego powiadomienia w celu określenia, czy pełne, blokujące wyrzucanie elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego zostało zakończone.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca stan zarejestrowanego powiadomienia w celu określenia, czy pełne, blokujące wyrzucanie elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego zostało zakończone.</summary>
        <returns>Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj wyliczenia zwróconego przez tę metodę, aby określić stan bieżącego powiadomienia o wyrzucaniu elementów bezużytecznych, które <xref:System.GC.RegisterForFullGCNotification%2A> zostało zarejestrowane za pomocą metody. <xref:System.GCNotificationStatus> Można również użyć metody, <xref:System.GC.WaitForFullGCApproach%2A> aby określić, czy pełne wyrzucanie elementów bezużytecznych jest nieuchronne.  
  
 Gdy Wyliczenie zwraca <xref:System.GCNotificationStatus.Succeeded>, można wykonywać zadania, takie jak wznawianie pracy i uzyskiwanie liczby kolekcji <xref:System.GC.CollectionCount%2A> z właściwością.  
  
 Ta metoda czeka na nieokreślony czas na uzyskanie powiadomienia o wyrzucaniu elementów bezużytecznych. Jeśli chcesz określić limit czasu dla metody, która ma zostać zwrócona, jeśli nie można uzyskać powiadomienia, użyj <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> przeciążenia metody. W <xref:System.GC.CancelFullGCNotification%2A> przypadku wywołania tej metody bez określenia limitu czasu można wywołać metodę, jeśli czekasz dłużej niż preferowane.  
  
 To wywołanie metody powinno być poprzedzone wywołaniem <xref:System.GC.WaitForFullGCApproach%2A> metody, aby upewnić się, że masz pełne odzyskiwanie pamięci. Wywołanie tej metody może spowodować wygenerowanie nieokreślonych wyników.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób użycia tej metody w celu ustalenia, czy ukończono pełne odzyskiwanie pamięci. Zawsze, gdy jest <xref:System.GCNotificationStatus.Succeeded>wskazywany stan powiadomienia, Metoda `OnFullGCCompletedNotify` użytkownika jest wywoływana w celu wykonania akcji w odpowiedzi na ukończoną kolekcję. Ten przykład kodu jest częścią większego przykładu dostarczonego w temacie powiadomienia o wyrzucaniu [elementów](~/docs/standard/garbage-collection/notifications.md) bezużytecznych.  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Powiadomienia dotyczące odzyskiwania pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Czas oczekiwania na uzyskanie stanu powiadomienia. Określ-1, aby czekać w nieskończoność.</param>
        <summary>Zwraca w określonym przedziale czasu stan zarejestrowanego powiadomienia w celu określenia, czy pełne, blokujące wyrzucanie elementów bezużytecznych w ramach wspólnego języka zostało zakończone.</summary>
        <returns>Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj wyliczenia zwróconego przez tę metodę, aby określić stan bieżącego powiadomienia o wyrzucaniu elementów bezużytecznych, które <xref:System.GC.RegisterForFullGCNotification%2A> zostało zarejestrowane za pomocą metody. <xref:System.GCNotificationStatus> Można również użyć metody, <xref:System.GC.WaitForFullGCApproach%2A> aby określić, czy pełne wyrzucanie elementów bezużytecznych jest nieuchronne.  
  
 Należy zauważyć, że ta metoda zwraca natychmiast za każdym razem, gdy zostanie uzyskany stan powiadomienia o wyrzucaniu `millisecondsTimeout`elementów bezużytecznych, niezależnie od wartości określonej przez. Jeśli stan powiadomienia o wyrzucaniu elementów bezużytecznych nie zostanie uzyskany przed <xref:System.GCNotificationStatus.NotApplicable>upływem `millisecondsTimeout` limitu czasu, ta metoda zwróci wartość.  
  
 Gdy Wyliczenie zwraca <xref:System.GCNotificationStatus.Succeeded>, można wykonywać zadania, takie jak wznawianie pracy i uzyskiwanie liczby kolekcji <xref:System.GC.CollectionCount%2A> z właściwością.  
  
 Metodę można wywołać, <xref:System.GC.CancelFullGCNotification%2A> gdy nie można czekać, aż upłynie limit czasu.  
  
 To wywołanie metody powinno być poprzedzone wywołaniem <xref:System.GC.WaitForFullGCApproach%2A> metody, aby upewnić się, że masz pełne odzyskiwanie pamięci. Wywołanie tej metody może spowodować wygenerowanie nieokreślonych wyników.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="millisecondsTimeout" />musi być wartością nieujemną lub mniejszą lub równą <see cref="F:System.Int32.MaxValue" /> lub-1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Powiadomienia dotyczące odzyskiwania pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstrzymuje bieżący wątek, dopóki wątek, który przetwarza kolejki finalizatorów, opróżnił tę kolejkę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy moduł wyrzucania elementów bezużytecznych odnajdzie obiekty, które mogą być odzyskiwane, sprawdza każdy obiekt, aby określić wymagania finalizacji obiektu. Jeśli obiekt implementuje finalizator i nie wyłączył finalizowania przez wywołanie <xref:System.GC.SuppressFinalize%2A>, obiekt zostanie umieszczony na liście obiektów, które są oznaczone jako gotowe do finalizacji. Moduł zbierający elementy bezużyteczne wywołuje <xref:System.Object.Finalize%2A> metody dla obiektów na tej liście i usuwa wpisy z listy. Ta metoda jest blokowana do momentu zakończenia wszystkich finalizatorów.  
  
 Wątek, w którym są uruchamiane finalizatory, jest nieokreślony, dlatego nie ma gwarancji, że ta metoda zostanie przerwana. Jednak ten wątek może zostać przerwany przez inny wątek, gdy <xref:System.GC.WaitForPendingFinalizers%2A> Metoda jest w toku. Można na przykład uruchomić inny wątek, który czeka przez pewien czas, a następnie przerwać ten wątek, jeśli ten wątek nadal jest wstrzymany.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.GC.WaitForPendingFinalizers%2A> metody do zawieszenia bieżącego wątku do momentu zakończenia wszystkich zebranych obiektów.  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
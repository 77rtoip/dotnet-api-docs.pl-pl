<Type Name="GC" FullName="System.GC">
  <Metadata><Meta Name="ms.openlocfilehash" Value="018082509045fdce79646d99418c54a36c314068" /><Meta Name="ms.sourcegitcommit" Value="74239f3977d28923e5020663db2c4e91601bea79" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/24/2019" /><Meta Name="ms.locfileid" Value="68434633" /></Metadata><TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="49d8a-101">Kontroluje systemową Moduł wyrzucania elementów bezużytecznych, usługi, która automatycznie odzyskuje nieużywaną pamięć.</span><span class="sxs-lookup"><span data-stu-id="49d8a-101">Controls the system garbage collector, a service that automatically reclaims unused memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-102">Moduł wyrzucania elementów bezużytecznych jest składnikiem środowiska uruchomieniowego języka wspólnego, który kontroluje alokację i wydawanie pamięci zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="49d8a-102">The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</span></span> <span data-ttu-id="49d8a-103">Metody w tej klasie mają wpływ na to, gdy wyrzucanie elementów bezużytecznych jest wykonywane na obiekcie i gdy są wydawane zasoby przydzielone przez obiekt.</span><span class="sxs-lookup"><span data-stu-id="49d8a-103">The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</span></span> <span data-ttu-id="49d8a-104">Właściwości w tej klasie zawierają informacje o łącznej ilości pamięci dostępnej w systemie oraz o kategorii wieku lub generacji pamięci przydzieloną do obiektu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-104">Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</span></span>  
  
 <span data-ttu-id="49d8a-105">Moduł wyrzucania elementów bezużytecznych śledzi i ponownie zgłasza obiekty przydzieloną w pamięci zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="49d8a-105">The garbage collector tracks and reclaims objects allocated in managed memory.</span></span> <span data-ttu-id="49d8a-106">Okresowo moduł zbierający elementy bezużyteczne wykonuje wyrzucanie elementów bezużytecznych, aby odzyskiwać pamięć przydzieloną do obiektów, dla których nie ma prawidłowych odwołań.</span><span class="sxs-lookup"><span data-stu-id="49d8a-106">Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</span></span> <span data-ttu-id="49d8a-107">Wyrzucanie elementów bezużytecznych odbywa się automatycznie, gdy żądanie dotyczące pamięci nie może zostać spełnione przy użyciu dostępnej wolnej pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-107">Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</span></span> <span data-ttu-id="49d8a-108">Alternatywnie aplikacja może wymusić wyrzucanie elementów <xref:System.GC.Collect%2A> bezużytecznych przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-108">Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.</span></span>  
  
 <span data-ttu-id="49d8a-109">Wyrzucanie elementów bezużytecznych składa się z następujących kroków:</span><span class="sxs-lookup"><span data-stu-id="49d8a-109">Garbage collection consists of the following steps:</span></span>  
  
1.  <span data-ttu-id="49d8a-110">Moduł zbierający elementy bezużyteczne wyszukuje obiekty zarządzane, do których istnieją odwołania w kodzie zarządzanym.</span><span class="sxs-lookup"><span data-stu-id="49d8a-110">The garbage collector searches for managed objects that are referenced in managed code.</span></span>  
  
2.  <span data-ttu-id="49d8a-111">Moduł wyrzucania elementów bezużytecznych próbuje sfinalizować obiekty, do których nie istnieją odwołania.</span><span class="sxs-lookup"><span data-stu-id="49d8a-111">The garbage collector tries to finalize objects that are not referenced.</span></span>  
  
3.  <span data-ttu-id="49d8a-112">Moduł wyrzucania elementów bezużytecznych zwalnia obiekty, do których nie odwołuje się i przejmuje ich pamięć.</span><span class="sxs-lookup"><span data-stu-id="49d8a-112">The garbage collector frees objects that are not referenced and reclaims their memory.</span></span>  
  
 <span data-ttu-id="49d8a-113">Ten temat zawiera następujące sekcje:</span><span class="sxs-lookup"><span data-stu-id="49d8a-113">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="49d8a-114">[Moduł wyrzucania elementów bezużytecznych i niezarządzanych zasobów](#unmanaged) </span><span class="sxs-lookup"><span data-stu-id="49d8a-114">[The garbage collector and unmanaged resources](#unmanaged) </span></span>  
 <span data-ttu-id="49d8a-115">[Przedawnianie i generacja obiektów](#generations) </span><span class="sxs-lookup"><span data-stu-id="49d8a-115">[Object aging and generations](#generations) </span></span>  
 [<span data-ttu-id="49d8a-116">Niezezwalanie na wyrzucanie elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="49d8a-116">Disallowing garbage collection</span></span>](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a><span data-ttu-id="49d8a-117">Moduł wyrzucania elementów bezużytecznych i niezarządzanych zasobów</span><span class="sxs-lookup"><span data-stu-id="49d8a-117">The garbage collector and unmanaged resources</span></span>  
 <span data-ttu-id="49d8a-118">Podczas zbierania Moduł wyrzucania elementów bezużytecznych nie zwolni obiektu, jeśli znajdzie co najmniej jedno odwołanie do obiektu w kodzie zarządzanym.</span><span class="sxs-lookup"><span data-stu-id="49d8a-118">During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</span></span> <span data-ttu-id="49d8a-119">Jednak Moduł wyrzucania elementów bezużytecznych nie rozpoznaje odwołań do obiektu z kodu niezarządzanego i może zwolnić obiekty, które są używane wyłącznie w kodzie niezarządzanym, chyba że jawnie nie zostanie to zrobione.</span><span class="sxs-lookup"><span data-stu-id="49d8a-119">However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</span></span> <span data-ttu-id="49d8a-120"><xref:System.GC.KeepAlive%2A> Metoda zapewnia mechanizm, który uniemożliwia modułowi zbierającemu elementy bezużyteczne zbieranie obiektów, które są nadal używane w kodzie niezarządzanym.</span><span class="sxs-lookup"><span data-stu-id="49d8a-120">The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</span></span>  
  
 <span data-ttu-id="49d8a-121">Poza alokacją pamięci zarządzanej, implementacje modułu wyrzucania elementów bezużytecznych nie utrzymują informacji o zasobach przechowywanych przez obiekt, takich jak dojścia do plików lub połączenia z bazami danych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-121">Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</span></span> <span data-ttu-id="49d8a-122">Gdy typ używa niezarządzanych zasobów, które muszą zostać wydane przed odprowadzeniem wystąpień typu, typ może zaimplementować finalizator.</span><span class="sxs-lookup"><span data-stu-id="49d8a-122">When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</span></span>  
  
 <span data-ttu-id="49d8a-123">W większości przypadków <xref:System.Object.Finalize%2A?displayProperty=nameWithType> finalizatory są implementowane przez zastąpienie metody; jednak typy wpisywane C# lub C++ implementujące destruktory, które kompilatory przesłonić <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="49d8a-123">In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="49d8a-124">W większości przypadków, jeśli obiekt ma finalizator, moduł zbierający elementy bezużyteczne wywołuje go przed zwolnieniem obiektu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-124">In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</span></span> <span data-ttu-id="49d8a-125">Jednak Moduł wyrzucania elementów bezużytecznych nie jest wymagany do wywoływania finalizatorów we wszystkich sytuacjach; na przykład <xref:System.GC.SuppressFinalize%2A> Metoda jawnie uniemożliwia wywoływanie finalizatora obiektu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-125">However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called.</span></span> <span data-ttu-id="49d8a-126">Ponadto Moduł wyrzucania elementów bezużytecznych nie musi używać określonego wątku do sfinalizowania obiektów lub zagwarantowania kolejności, w której finalizatory są wywoływane dla obiektów, które odwołują się do siebie nawzajem, ale są dostępne do wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-126">Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</span></span>  
  
 <span data-ttu-id="49d8a-127">W scenariuszach, w których zasoby muszą być wydane w określonym czasie, klasy mogą implementować <xref:System.IDisposable> interfejs, który <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> zawiera metodę, która wykonuje zadania zarządzania zasobami i oczyszczania.</span><span class="sxs-lookup"><span data-stu-id="49d8a-127">In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method that performs resource management and cleanup tasks.</span></span> <span data-ttu-id="49d8a-128">Klasy implementujące <xref:System.IDisposable.Dispose%2A> muszą określać, jako część ich kontraktu klasy, jeśli i gdy klasy odbiorcy wywołują metodę w celu oczyszczenia obiektu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-128">Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</span></span> <span data-ttu-id="49d8a-129">Moduł wyrzucania elementów bezużytecznych nie jest domyślnie <xref:System.IDisposable.Dispose%2A> wywoływany przez metodę, ale implementacje <xref:System.IDisposable.Dispose%2A> metody mogą wywoływać metody <xref:System.GC> w klasie, aby dostosować sposób finalizowania modułu wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-129">The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.</span></span>  
  
 <span data-ttu-id="49d8a-130">Aby uzyskać więcej informacji o finalizowaniu obiektów i wzorcu usuwania, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="49d8a-130">For more information on object finalization and the dispose pattern, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a><span data-ttu-id="49d8a-131">Przedawnianie i generacja obiektów</span><span class="sxs-lookup"><span data-stu-id="49d8a-131">Object aging and generations</span></span>  
 <span data-ttu-id="49d8a-132">Moduł wyrzucania elementów bezużytecznych w środowisku uruchomieniowym języka wspólnego obsługuje przedawnianie obiektów przy użyciu generacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-132">The garbage collector in the common language runtime supports object aging using generations.</span></span> <span data-ttu-id="49d8a-133">Generacja jest jednostką miary względnego wieku obiektów w pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-133">A generation is a unit of measure of the relative age of objects in memory.</span></span> <span data-ttu-id="49d8a-134">Numer generacji lub wiek obiektu wskazuje generację, do której należy obiekt.</span><span class="sxs-lookup"><span data-stu-id="49d8a-134">The generation number, or age, of an object indicates the generation to which an object belongs.</span></span> <span data-ttu-id="49d8a-135">Obiekty utworzone niedawno są częścią nowszych generacji i mają niższe numery generacji niż obiekty utworzone wcześniej w cyklu życia aplikacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-135">Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</span></span> <span data-ttu-id="49d8a-136">Obiekty w najnowszej generacji są w generacji 0.</span><span class="sxs-lookup"><span data-stu-id="49d8a-136">Objects in the most recent generation are in generation 0.</span></span> <span data-ttu-id="49d8a-137">Ta implementacja modułu wyrzucania elementów bezużytecznych obsługuje trzy generacje obiektów, generacji 0, 1 i 2.</span><span class="sxs-lookup"><span data-stu-id="49d8a-137">This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</span></span> <span data-ttu-id="49d8a-138">Możesz pobrać wartość <xref:System.GC.MaxGeneration%2A> właściwości, aby określić maksymalny numer generacji obsługiwany przez system.</span><span class="sxs-lookup"><span data-stu-id="49d8a-138">You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.</span></span>  
  
 <span data-ttu-id="49d8a-139">Przedawnianie obiektów umożliwia aplikacjom docelowe wyrzucanie elementów bezużytecznych w określonym zestawie generacji, a nie wymaganie wyrzucania elementów bezużytecznych w celu oszacowania wszystkich generacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-139">Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</span></span> <span data-ttu-id="49d8a-140">Przeciążenia metody zawierającej `generation` parametr umożliwiają określenie najstarszej generacji do wyrzucania elementów bezużytecznych. <xref:System.GC.Collect%2A></span><span class="sxs-lookup"><span data-stu-id="49d8a-140">Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected.</span></span>  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a><span data-ttu-id="49d8a-141">Niezezwalanie na wyrzucanie elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="49d8a-141">Disallowing garbage collection</span></span>  
 <span data-ttu-id="49d8a-142">Począwszy od, Moduł wyrzucania elementów bezużytecznych obsługuje tryb opóźnienia w regionie GC, który może być używany podczas wykonywania ścieżek krytycznych, w których wyrzucanie elementów bezużytecznych może mieć negatywny wpływ na wydajność aplikacji. [!INCLUDE[net_v46](~/includes/net-v46-md.md)]</span><span class="sxs-lookup"><span data-stu-id="49d8a-142">Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</span></span> <span data-ttu-id="49d8a-143">Tryb opóźnienia regionu nie wymaga określenia ilości pamięci, którą można przydzielić bez ingerencji z modułu wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-143">The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</span></span> <span data-ttu-id="49d8a-144">Jeśli środowisko uruchomieniowe może przydzielić pamięć, środowisko uruchomieniowe nie wykonuje wyrzucania elementów bezużytecznych podczas wykonywania kodu w ścieżce krytycznej.</span><span class="sxs-lookup"><span data-stu-id="49d8a-144">If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</span></span>  
  
 <span data-ttu-id="49d8a-145">Należy zdefiniować początek ścieżki krytycznej w regionie No GC przez wywołanie jednego z przeciążeń <xref:System.GC.TryStartNoGCRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="49d8a-145">You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>.</span></span> <span data-ttu-id="49d8a-146">Należy określić koniec swojej ścieżki krytycznej, wywołując <xref:System.GC.EndNoGCRegion%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="49d8a-146">You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 <span data-ttu-id="49d8a-147">Nie można zagnieżdżać wywołań do <xref:System.GC.TryStartNoGCRegion%2A> metody i należy <xref:System.GC.EndNoGCRegion%2A> wywołać metodę tylko wtedy, gdy środowisko uruchomieniowe jest obecnie w trybie opóźnień w regionie GC.</span><span class="sxs-lookup"><span data-stu-id="49d8a-147">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="49d8a-148">Innymi słowy, nie należy wywoływać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania zakończą się niepowodzeniem) i nie należy oczekiwać, aby <xref:System.GC.EndNoGCRegion%2A> wywołania kończyły się pomyślnie, <xref:System.GC.TryStartNoGCRegion%2A> ponieważ pierwsze wywołanie zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="49d8a-148">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-149">W poniższym przykładzie zastosowano kilka metod GC, aby uzyskać informacje o generowaniu i pamięci dla bloku nieużywanych obiektów i wydrukować je w konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-149">The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</span></span> <span data-ttu-id="49d8a-150">Wszystkie nieużywane obiekty są gromadzone i wyświetlane są sumy uzyskanej pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-150">The unused objects are then collected, and the resulting memory totals are displayed.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md"><span data-ttu-id="49d8a-151">Odzyskiwanie pamięci</span><span class="sxs-lookup"><span data-stu-id="49d8a-151">Garbage Collection</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="49d8a-152">Podstawy dotyczące wyrzucania elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="49d8a-152">Fundamentals of Garbage Collection</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated"><span data-ttu-id="49d8a-153">Przyrostowa ilość niezarządzanej pamięci, która została przypisana.</span><span class="sxs-lookup"><span data-stu-id="49d8a-153">The incremental amount of unmanaged memory that has been allocated.</span></span></param>
        <summary><span data-ttu-id="49d8a-154">Informuje środowisko uruchomieniowe dużej alokacji niezarządzanej pamięci, które należy wziąć pod uwagę podczas planowania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-154">Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-155">W celu określenia czasu, w którym należy zaplanować wyrzucanie elementów bezużytecznych, środowisko uruchomieniowe uwzględnia ilość przydzielonej pamięci zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="49d8a-155">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="49d8a-156">Jeśli mały zarządzany obiekt przydzieli dużą ilość pamięci niezarządzanej, środowisko uruchomieniowe bierze pod uwagę tylko zarządzaną pamięć i w ten sposób szacuje pilność planowania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-156">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="49d8a-157"><xref:System.GC.AddMemoryPressure%2A> Metoda informuje środowisko uruchomieniowe tego dodatkowego nacisku w pamięci systemowej.</span><span class="sxs-lookup"><span data-stu-id="49d8a-157">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.</span></span>  
  
 <span data-ttu-id="49d8a-158">W najprostszym wzorcu użycia obiekt zarządzany przydziela niezarządzaną pamięć w konstruktorze i zwalnia go w `Dispose` metodzie lub. `Finalize`</span><span class="sxs-lookup"><span data-stu-id="49d8a-158">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="49d8a-159">Wywołaj <xref:System.GC.RemoveMemoryPressure%2A> metodę po przydzieleniu pamięci niezarządzanej i Wywołaj metodę po jej zwolnieniu. <xref:System.GC.AddMemoryPressure%2A></span><span class="sxs-lookup"><span data-stu-id="49d8a-159">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="49d8a-160">W bardziej skomplikowanych scenariuszach, w których niezarządzana alokacja pamięci ulega znacznemu zmianie w okresie istnienia zarządzanego obiektu, <xref:System.GC.AddMemoryPressure%2A> można <xref:System.GC.RemoveMemoryPressure%2A> wywołać metody i, aby przekazać te przyrostowe zmiany do środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-160">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="49d8a-161">Należy upewnić się, że należy usunąć dokładnie ilość dodawanego nacisku.</span><span class="sxs-lookup"><span data-stu-id="49d8a-161">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="49d8a-162">Niewykonanie tej czynności może niekorzystnie wpłynąć na wydajność systemu w aplikacjach uruchamianych przez długi czas.</span><span class="sxs-lookup"><span data-stu-id="49d8a-162">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="49d8a-163"><paramref name="bytesAllocated" />jest mniejsze lub równe 0.</span><span class="sxs-lookup"><span data-stu-id="49d8a-163"><paramref name="bytesAllocated" /> is less than or equal to 0.</span></span>  
  
<span data-ttu-id="49d8a-164">—lub—</span><span class="sxs-lookup"><span data-stu-id="49d8a-164">-or-</span></span> 
<span data-ttu-id="49d8a-165">Na komputerze <paramref name="bytesAllocated" /> 32-bitowym jest większy niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="49d8a-165">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="49d8a-166">umożliwia wywoływanie kodu niezarządzanego podczas manipulowania priorytetem kolekcji elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-166">for the ability to call unmanaged code when manipulating garbage-collection priority.</span></span> <span data-ttu-id="49d8a-167">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="49d8a-167">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="49d8a-168">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-168">requires full trust for the immediate caller.</span></span> <span data-ttu-id="49d8a-169">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="49d8a-169">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="49d8a-170">Anuluje rejestrację powiadomienia o wyrzucaniu elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-170">Cancels the registration of a garbage collection notification.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-171">Ta metoda anuluje powiadomienie wyrzucania elementów bezużytecznych, które <xref:System.GC.RegisterForFullGCNotification%2A> zostało zarejestrowane za pomocą metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-171">This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="49d8a-172">Nie jest konieczne wywoływanie tej metody przed dopasowaniem wartości parametrów progu w kolejnych wywołaniach <xref:System.GC.RegisterForFullGCNotification%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-172">You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-173">Poniższy przykład anuluje rejestrację wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-173">The following example cancels a garbage collection registration.</span></span> <span data-ttu-id="49d8a-174">Ten przykład jest częścią większego przykładu podanego w temacie powiadomienia o wyrzucaniu [elementów](~/docs/standard/garbage-collection/notifications.md) bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-174">This example is part of a larger example provided for the [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="49d8a-175">Ten element członkowski nie jest dostępny, gdy włączone jest współbieżne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-175">This member is not available when concurrent garbage collection is enabled.</span></span> <span data-ttu-id="49d8a-176">Zobacz ustawienie środowiska uruchomieniowego [ &lt;gcConcurrent&gt; ](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) , aby uzyskać informacje o tym, jak wyłączyć współbieżne odzyskiwanie pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-176">See the [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="49d8a-177">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-177">for full trust for the immediate caller.</span></span> <span data-ttu-id="49d8a-178">Ten element członkowski nie może być używany przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="49d8a-178">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="49d8a-179">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-179">requires full trust for the immediate caller.</span></span> <span data-ttu-id="49d8a-180">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="49d8a-180">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="49d8a-181">Powiadomienia dotyczące odzyskiwania pamięci</span><span class="sxs-lookup"><span data-stu-id="49d8a-181">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="49d8a-182">Wymusza wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-182">Forces garbage collection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="49d8a-183">Wymusza natychmiastowe wyczyszczenie elementów bezużytecznych wszystkich generacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-183">Forces an immediate garbage collection of all generations.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-184">Użyj tej metody, aby spróbować ponownie przejąć całą pamięć, która jest niedostępna.</span><span class="sxs-lookup"><span data-stu-id="49d8a-184">Use this method to try to reclaim all memory that is inaccessible.</span></span> <span data-ttu-id="49d8a-185">Wykonuje blokowe blokowanie wyrzucania elementów bezużytecznych wszystkich generacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-185">It performs a blocking garbage collection of all generations.</span></span>  
  
 <span data-ttu-id="49d8a-186">Wszystkie obiekty, niezależnie od tego, jak długo znajdowały się w pamięci, są brane pod uwagę w przypadku zbierania danych. Jednak obiekty, do których odwołuje się kod zarządzany, nie są zbierane.</span><span class="sxs-lookup"><span data-stu-id="49d8a-186">All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</span></span> <span data-ttu-id="49d8a-187">Użyj tej metody, aby wymusić, aby system ponownie odzyskał maksymalną ilość dostępnej pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-187">Use this method to force the system to try to reclaim the maximum amount of available memory.</span></span>  
  
 <span data-ttu-id="49d8a-188">Począwszy od <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> <xref:System.GC.Collect%2A> , można skompaktować stertę dużego obiektu (LOH), ustawiając właściwość na przed wywołaniem metody, jak pokazano w poniższym przykładzie. [!INCLUDE[net_v451](~/includes/net-v451-md.md)]</span><span class="sxs-lookup"><span data-stu-id="49d8a-188">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], you can compact the large object heap (LOH) by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-189">Poniższy przykład ilustruje sposób użycia <xref:System.GC.Collect%2A> metody do wykonania kolekcji na wszystkich generacjach pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-189">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on all generations of memory.</span></span> <span data-ttu-id="49d8a-190">Kod generuje kilka nieużywanych obiektów, a następnie wywołuje <xref:System.GC.Collect%2A> metodę, aby oczyścić ją z pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-190">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="49d8a-191">Wywołane kolekcje</span><span class="sxs-lookup"><span data-stu-id="49d8a-191">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="49d8a-192">Liczba najstarszych generacji do wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-192">The number of the oldest generation to be garbage collected.</span></span></param>
        <summary><span data-ttu-id="49d8a-193">Wymusza natychmiastowe wyrzucanie elementów bezużytecznych z generacji 0 za pośrednictwem określonej generacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-193">Forces an immediate garbage collection from generation 0 through a specified generation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-194">Użyj tej metody, aby spróbować ponownie przejąć niedostępną pamięć.</span><span class="sxs-lookup"><span data-stu-id="49d8a-194">Use this method to try to reclaim memory that is inaccessible.</span></span> <span data-ttu-id="49d8a-195">Jednak użycie tej metody nie gwarantuje, że cała niedostępna pamięć w określonej generacji zostanie ododzyskiwana.</span><span class="sxs-lookup"><span data-stu-id="49d8a-195">However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="49d8a-196">Jeśli zaimplementowano przedawnianie obiektów, Moduł wyrzucania elementów bezużytecznych nie zbiera obiektów z numerem generacji wyższym niż określona generacja.</span><span class="sxs-lookup"><span data-stu-id="49d8a-196">If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</span></span> <span data-ttu-id="49d8a-197">Jeśli przedawnianie obiektów nie jest zaimplementowane, Moduł wyrzucania elementów bezużytecznych traktuje wszystkie obiekty podczas wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-197">If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</span></span>  
  
 <span data-ttu-id="49d8a-198">Użyj właściwości, aby określić maksymalną prawidłową wartość `generation` parametru. <xref:System.GC.MaxGeneration%2A></span><span class="sxs-lookup"><span data-stu-id="49d8a-198">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of the `generation` parameter.</span></span>  
  
 <span data-ttu-id="49d8a-199">Aby moduł zbierający elementy bezużyteczne uważał wszystkie obiekty niezależnie od ich generacji, użyj wersji tej metody, która nie przyjmuje żadnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="49d8a-199">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span> <span data-ttu-id="49d8a-200">Aby moduł zbierający elementy bezużyteczne odzyskał obiekty na <xref:System.GCCollectionMode> podstawie ustawienia, <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> należy użyć przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-200">To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-201">Poniższy przykład ilustruje sposób użycia <xref:System.GC.Collect%2A> metody do wykonywania kolekcji na poszczególnych warstwach pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-201">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on individual layers of memory.</span></span> <span data-ttu-id="49d8a-202">Kod generuje kilka nieużywanych obiektów, a następnie wywołuje <xref:System.GC.Collect%2A> metodę, aby oczyścić ją z pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-202">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="49d8a-203"><paramref name="generation" />jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="49d8a-203"><paramref name="generation" /> is not valid.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="49d8a-204">Wywołane kolekcje</span><span class="sxs-lookup"><span data-stu-id="49d8a-204">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="49d8a-205">Liczba najstarszych generacji do wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-205">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="49d8a-206">Wartość wyliczenia określająca, czy wyrzucanie elementów bezużytecznych <see cref="F:System.GCCollectionMode.Forced" />jest wymuszane (<see cref="F:System.GCCollectionMode.Optimized" /><see cref="F:System.GCCollectionMode.Default" /> lub) czy zoptymalizowane ().</span><span class="sxs-lookup"><span data-stu-id="49d8a-206">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <summary><span data-ttu-id="49d8a-207">Wymusza wyrzucanie elementów bezużytecznych z generacji od 0 do określonej generacji w czasie określonym <see cref="T:System.GCCollectionMode" /> przez wartość.</span><span class="sxs-lookup"><span data-stu-id="49d8a-207">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-208">Użyj parametru `mode` , aby określić, czy odzyskiwanie pamięci powinno odbywać się natychmiast, czy tylko wtedy, gdy czas jest optymalny do odzyskiwania obiektów.</span><span class="sxs-lookup"><span data-stu-id="49d8a-208">Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</span></span> <span data-ttu-id="49d8a-209">Użycie tej metody nie gwarantuje, że cała niedostępna pamięć w określonej generacji jest odzyskiwana.</span><span class="sxs-lookup"><span data-stu-id="49d8a-209">Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="49d8a-210">Aby dostosować nieodpowiednie wyrzucanie elementów bezużytecznych podczas krytycznych okresów w aplikacji <xref:System.Runtime.GCSettings.LatencyMode%2A> , należy ustawić właściwość.</span><span class="sxs-lookup"><span data-stu-id="49d8a-210">To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property.</span></span>  
  
 <span data-ttu-id="49d8a-211">Moduł wyrzucania elementów bezużytecznych nie zbiera obiektów z numerem generacji wyższym `generation` niż określony przez parametr.</span><span class="sxs-lookup"><span data-stu-id="49d8a-211">The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter.</span></span> <span data-ttu-id="49d8a-212">Użyj właściwości, aby określić maksymalną prawidłową `generation`wartość. <xref:System.GC.MaxGeneration%2A></span><span class="sxs-lookup"><span data-stu-id="49d8a-212">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`.</span></span>  
  
 <span data-ttu-id="49d8a-213">Aby moduł zbierający elementy bezużyteczne uważał wszystkie obiekty niezależnie od ich generacji, użyj wersji tej metody, która nie przyjmuje żadnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="49d8a-213">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span>  
  
 <span data-ttu-id="49d8a-214">Aby moduł zbierający elementy bezużyteczne odzyskał obiekty do określonej generacji obiektów, użyj <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-214">To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="49d8a-215">Po określeniu wartości maksymalnej generacji zbierane są wszystkie obiekty.</span><span class="sxs-lookup"><span data-stu-id="49d8a-215">When you specify the maximum generation, all objects are collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-216">Poniższy przykład wymusza wyrzucanie elementów bezużytecznych dla obiektów generacji <xref:System.GCCollectionMode.Optimized> 2 z ustawieniem.</span><span class="sxs-lookup"><span data-stu-id="49d8a-216">The following example forces a garbage collection for generation 2 objects with the <xref:System.GCCollectionMode.Optimized> setting.</span></span>  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="49d8a-217"><paramref name="generation" />jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="49d8a-217"><paramref name="generation" /> is not valid.</span></span>  
  
<span data-ttu-id="49d8a-218">—lub—</span><span class="sxs-lookup"><span data-stu-id="49d8a-218">-or-</span></span> 
 <span data-ttu-id="49d8a-219"><paramref name="mode" />nie jest jedną z <see cref="T:System.GCCollectionMode" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="49d8a-219"><paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="49d8a-220">Wywołane kolekcje</span><span class="sxs-lookup"><span data-stu-id="49d8a-220">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="49d8a-221">Liczba najstarszych generacji do wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-221">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="49d8a-222">Wartość wyliczenia określająca, czy wyrzucanie elementów bezużytecznych <see cref="F:System.GCCollectionMode.Forced" />jest wymuszane (<see cref="F:System.GCCollectionMode.Optimized" /><see cref="F:System.GCCollectionMode.Default" /> lub) czy zoptymalizowane ().</span><span class="sxs-lookup"><span data-stu-id="49d8a-222">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <param name="blocking"><span data-ttu-id="49d8a-223"><see langword="true" />Aby wykonać blokowanie wyrzucania elementów bezużytecznych; <see langword="false" /> aby wykonać odzyskiwanie pamięci w tle, tam gdzie jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="49d8a-223"><see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span></span></param>
        <summary><span data-ttu-id="49d8a-224">Wymusza wyrzucanie elementów bezużytecznych z generacji 0 przez określoną generację, w czasie określonym <see cref="T:System.GCCollectionMode" /> przez wartość, o wartości określającej, czy kolekcja powinna blokować.</span><span class="sxs-lookup"><span data-stu-id="49d8a-224">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with a value specifying whether the collection should be blocking.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-225">Poniższa tabela zawiera podsumowanie interakcji `mode` z parametrami i: `blocking`</span><span class="sxs-lookup"><span data-stu-id="49d8a-225">The following table summarizes the interaction of the `mode` and `blocking` parameters:</span></span>  
  
|`mode`|<span data-ttu-id="49d8a-226">`blocking`była`true`</span><span class="sxs-lookup"><span data-stu-id="49d8a-226">`blocking` is `true`</span></span>|<span data-ttu-id="49d8a-227">`blocking`była`false`</span><span class="sxs-lookup"><span data-stu-id="49d8a-227">`blocking` is `false`</span></span>|  
|-|-|-|  
|<span data-ttu-id="49d8a-228"><xref:System.GCCollectionMode.Forced> lub <xref:System.GCCollectionMode.Default></span><span class="sxs-lookup"><span data-stu-id="49d8a-228"><xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default></span></span>|<span data-ttu-id="49d8a-229">Kolekcja blokująca jest wykonywana najszybciej, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="49d8a-229">A blocking collection is performed as soon as possible.</span></span> <span data-ttu-id="49d8a-230">Jeśli zbieranie w tle jest w toku i `generation` ma wartość 0 lub 1 <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> , Metoda natychmiast wyzwala kolekcję blokującą i zwraca, gdy kolekcja zostanie zakończona.</span><span class="sxs-lookup"><span data-stu-id="49d8a-230">If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished.</span></span> <span data-ttu-id="49d8a-231">Jeśli zbieranie w tle jest w toku i `generation` ma wartość 2, metoda czeka, aż kolekcja w tle zostanie zakończona, wyzwala kolekcję blokującą 2, a następnie zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="49d8a-231">If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</span></span>|<span data-ttu-id="49d8a-232">Kolekcja jest wykonywana najszybciej, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="49d8a-232">A collection is performed as soon as possible.</span></span> <span data-ttu-id="49d8a-233"><xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> Metoda żąda kolekcji w tle, ale nie jest to gwarantowane; w zależności od okoliczności nadal może być wykonywana kolekcja blokująca.</span><span class="sxs-lookup"><span data-stu-id="49d8a-233">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="49d8a-234">Jeśli kolekcja w tle jest już w toku, Metoda wraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="49d8a-234">If a background collection is already in progress, the method returns immediately.</span></span>|  
|<xref:System.GCCollectionMode.Optimized>|<span data-ttu-id="49d8a-235">Może być wykonywana kolekcja blokująca, w zależności od stanu modułu wyrzucania elementów bezużytecznych i `generation` parametru.</span><span class="sxs-lookup"><span data-stu-id="49d8a-235">A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter.</span></span> <span data-ttu-id="49d8a-236">Moduł wyrzucania elementów bezużytecznych próbuje zapewnić optymalną wydajność.</span><span class="sxs-lookup"><span data-stu-id="49d8a-236">The garbage collector tries to provide optimal performance.</span></span>|<span data-ttu-id="49d8a-237">Kolekcję można wykonać w zależności od stanu modułu wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-237">A collection may be performed, depending on the state of the garbage collector.</span></span> <span data-ttu-id="49d8a-238"><xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> Metoda żąda kolekcji w tle, ale nie jest to gwarantowane; w zależności od okoliczności nadal może być wykonywana kolekcja blokująca.</span><span class="sxs-lookup"><span data-stu-id="49d8a-238">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="49d8a-239">Moduł wyrzucania elementów bezużytecznych próbuje zapewnić optymalną wydajność.</span><span class="sxs-lookup"><span data-stu-id="49d8a-239">The garbage collector tries to provide optimal performance.</span></span> <span data-ttu-id="49d8a-240">Jeśli kolekcja w tle jest już w toku, Metoda wraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="49d8a-240">If a background collection is already in progress, the method returns immediately.</span></span>|  
  
 <span data-ttu-id="49d8a-241">Jeśli wywołanie <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> metody wykonuje pełne blokowanie wyrzucania elementów bezużytecznych, można również skompaktować stertę dużego obiektu przez <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> ustawienie <xref:System.GC.Collect%2A> właściwości na <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> przed wywołaniem metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-241">If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="49d8a-242"><paramref name="generation" />jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="49d8a-242"><paramref name="generation" /> is not valid.</span></span>  
  
<span data-ttu-id="49d8a-243">—lub—</span><span class="sxs-lookup"><span data-stu-id="49d8a-243">-or-</span></span> 
 <span data-ttu-id="49d8a-244"><paramref name="mode" />nie jest jedną z <see cref="T:System.GCCollectionMode" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="49d8a-244"><paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="compacting" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="49d8a-245">Liczba najstarszych generacji do wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-245">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="49d8a-246">Wartość wyliczenia określająca, czy wyrzucanie elementów bezużytecznych <see cref="F:System.GCCollectionMode.Forced" />jest wymuszane (<see cref="F:System.GCCollectionMode.Optimized" /><see cref="F:System.GCCollectionMode.Default" /> lub) czy zoptymalizowane ().</span><span class="sxs-lookup"><span data-stu-id="49d8a-246">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <param name="blocking"><span data-ttu-id="49d8a-247"><see langword="true" />Aby wykonać blokowanie wyrzucania elementów bezużytecznych; <see langword="false" /> aby wykonać odzyskiwanie pamięci w tle, tam gdzie jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="49d8a-247"><see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span></span></param>
        <param name="compacting"><span data-ttu-id="49d8a-248"><see langword="true" />Aby skompaktować stertę małego obiektu; <see langword="false" /> tylko do wyczyszczenia.</span><span class="sxs-lookup"><span data-stu-id="49d8a-248"><see langword="true" /> to compact the small object heap; <see langword="false" /> to sweep only.</span></span></param>
        <summary><span data-ttu-id="49d8a-249">Wymusza wyrzucanie elementów bezużytecznych z generacji 0 przez określoną generację, w czasie określonym <see cref="T:System.GCCollectionMode" /> przez wartość, z wartościami, które określają, czy kolekcja powinna blokować i kompaktować.</span><span class="sxs-lookup"><span data-stu-id="49d8a-249">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with values that specify whether the collection should be blocking and compacting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-250">Jeśli `blocking` ma`false`wartość, w wykazie globalnym decyduje się, czy ma być wykonywane tło, czy blokujące odzyskiwanie pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-250">If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection.</span></span> <span data-ttu-id="49d8a-251">Jeśli `compacting` jest`true`, wykonuje blokowanie wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-251">If `compacting` is `true`, it performs a blocking garbage collection.</span></span>  
  
 <span data-ttu-id="49d8a-252">Jeśli `compacting` tak`true`, środowisko uruchomieniowe kompaktuje stertę małego obiektu (raport o kondycji).</span><span class="sxs-lookup"><span data-stu-id="49d8a-252">If `compacting` is `true`, the runtime compacts the small object heap (SOH).</span></span> <span data-ttu-id="49d8a-253">Sterta dużego obiektu (LOH) nie jest kompaktowana, chyba <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> że właściwość jest ustawiona <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>na.</span><span class="sxs-lookup"><span data-stu-id="49d8a-253">The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span></span> <span data-ttu-id="49d8a-254">Należy zauważyć, że obejmuje to wszystkie blokowanie wyrzucania elementów bezużytecznych, a nie tylko pełne blokowanie odzyskiwania pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-254">Note that this includes all blocking garbage collections, not just full blocking garbage collections.</span></span>  
  
 <span data-ttu-id="49d8a-255">Można wywołać metodę, <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> aby zredukować zarządzane sterty do możliwie najmniejszego rozmiaru, co ilustruje poniższy fragment kodu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-255">You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</span></span>  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 <span data-ttu-id="49d8a-256">Określenie `true`argumentugwarantujekompaktowanie ,pełneblokowaniewyrzucaniaelementówbezużytecznych.`compacting`</span><span class="sxs-lookup"><span data-stu-id="49d8a-256">Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection.</span></span> <span data-ttu-id="49d8a-257">Ustawienie właściwości, aby <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> zapewnić kompaktowanie zarówno LOH, jak i raportu o kondycji. <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="49d8a-257">Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> ensures that both the LOH and SOH are compacted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="49d8a-258">Generowanie obiektów, dla których ma zostać ustalona liczba wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-258">The generation of objects for which the garbage collection count is to be determined.</span></span></param>
        <summary><span data-ttu-id="49d8a-259">Zwraca liczbę przypadków wyrzucania elementów bezużytecznych dla określonej generacji obiektów.</span><span class="sxs-lookup"><span data-stu-id="49d8a-259">Returns the number of times garbage collection has occurred for the specified generation of objects.</span></span></summary>
        <returns><span data-ttu-id="49d8a-260">Liczba przypadków wyrzucania elementów bezużytecznych dla określonej generacji od momentu uruchomienia procesu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-260">The number of times garbage collection has occurred for the specified generation since the process was started.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-261">W przypadku zaimplementowania własnego zarządzania zasobami może zajść potrzeba wymuszenia okresowego wyrzucania <xref:System.GC.Collect%2A> elementów bezużytecznych przez wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-261">If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="49d8a-262">Ponieważ jest to kosztowna operacja, można poprawić wydajność, pomijając wywołanie, gdy niedawno wystąpiło wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-262">Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</span></span> <span data-ttu-id="49d8a-263">Zapisz wartość zwróconą przez <xref:System.GC.CollectionCount%2A> zaraz po wywołaniu <xref:System.GC.Collect%2A>.</span><span class="sxs-lookup"><span data-stu-id="49d8a-263">Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>.</span></span> <span data-ttu-id="49d8a-264">Przy następnym wywołaniu <xref:System.GC.Collect%2A>należy porównać bieżącą wartość zwracaną przez <xref:System.GC.CollectionCount%2A> wartość zapisanej wartości.</span><span class="sxs-lookup"><span data-stu-id="49d8a-264">The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value.</span></span> <span data-ttu-id="49d8a-265">Jeśli dwie wartości są równe, żadna kolekcja nie wystąpiła w sposób tymczasowy i jest uzasadnione, aby <xref:System.GC.Collect%2A> ponownie wywołać.</span><span class="sxs-lookup"><span data-stu-id="49d8a-265">If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="49d8a-266"><paramref name="generation" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="49d8a-266"><paramref name="generation" /> is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="49d8a-267">Zamyka tryb opóźnień regionu No.</span><span class="sxs-lookup"><span data-stu-id="49d8a-267">Ends the no GC region latency mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-268"><xref:System.GC.EndNoGCRegion%2A> Metoda zgłasza,jeślimodułwyrzucaniaelementówbezużytecznychniejestwtrybie<xref:System.InvalidOperationException> opóźnienia w regionie GC.</span><span class="sxs-lookup"><span data-stu-id="49d8a-268">The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode.</span></span> <span data-ttu-id="49d8a-269">Dzieje się tak w następujących warunkach:</span><span class="sxs-lookup"><span data-stu-id="49d8a-269">This occurs under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="49d8a-270"><xref:System.GC.TryStartNoGCRegion%2A> Metoda nie została wcześniej wywołana.</span><span class="sxs-lookup"><span data-stu-id="49d8a-270">The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously.</span></span>  
  
-   <span data-ttu-id="49d8a-271">Wywołanie <xref:System.GC.TryStartNoGCRegion%2A> metody zostało zwrócone `false`.</span><span class="sxs-lookup"><span data-stu-id="49d8a-271">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method returned `false`.</span></span>  
  
-   <span data-ttu-id="49d8a-272">Wywołanie <xref:System.GC.TryStartNoGCRegion%2A> metody spowodowało wyjątek.</span><span class="sxs-lookup"><span data-stu-id="49d8a-272">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception.</span></span>  
  
 <span data-ttu-id="49d8a-273">Wyjątek z jednego z tych powodów można zapobiec za pomocą kodu, takiego jak następujące:</span><span class="sxs-lookup"><span data-stu-id="49d8a-273">You can prevent an exception for any of these reasons by using code such as the following:</span></span>  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="49d8a-274">Moduł wyrzucania elementów bezużytecznych nie jest w trybie opóźnienia w regionie GC.</span><span class="sxs-lookup"><span data-stu-id="49d8a-274">The garbage collector is not in no GC region latency mode.</span></span>  
  
<span data-ttu-id="49d8a-275">—lub—</span><span class="sxs-lookup"><span data-stu-id="49d8a-275">-or-</span></span> 
<span data-ttu-id="49d8a-276">Tryb opóźnień regionu nie został zakończony wcześniej, ponieważ wywołano wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-276">The no GC region latency mode was ended previously because a garbage collection was induced.</span></span>  
  
<span data-ttu-id="49d8a-277">—lub—</span><span class="sxs-lookup"><span data-stu-id="49d8a-277">-or-</span></span> 
<span data-ttu-id="49d8a-278">Alokacja pamięci przekroczyła ilość określoną w wywołaniu <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-278">A memory allocation exceeded the amount specified in the call to the <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> method.</span></span></exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="49d8a-279">Tryby opóźnienia</span><span class="sxs-lookup"><span data-stu-id="49d8a-279">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="49d8a-280">Pobiera łączną liczbę bajtów przydzieloną do bieżącego wątku od momentu rozpoczęcia jego okresu istnienia.</span><span class="sxs-lookup"><span data-stu-id="49d8a-280">Gets the total number of bytes allocated to the current thread since the beginning of its lifetime.</span></span></summary>
        <returns><span data-ttu-id="49d8a-281">Całkowita liczba bajtów przydzielono do bieżącego wątku od początku jego okresu istnienia.</span><span class="sxs-lookup"><span data-stu-id="49d8a-281">The total number of bytes allocated to the current thread since the beginning of its lifetime.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="49d8a-282">`GetAllocatedBytesForCurrentThread` Metoda zwraca łączną liczbę bajtów przydzieloną na stercie zarządzanym w okresie istnienia wątku, a nie całkowitą liczbę bajtów, które mają przeżyły odzyskiwanie pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-282">The `GetAllocatedBytesForCurrentThread` method returns the total number of bytes allocated on the managed heap during the lifetime of a thread, not the total number of bytes that have survived garbage collection.</span></span> <span data-ttu-id="49d8a-283">Zwracana wartość nie obejmuje również żadnych natywnych przydziałów.</span><span class="sxs-lookup"><span data-stu-id="49d8a-283">The returned value also does not include any native allocations.</span></span>

<span data-ttu-id="49d8a-284">Ta metoda jest najbardziej przydatna w scenariuszach monitorowania w celu mierzenia różnic w alokacji pamięci między przedziałami czasowymi i zdarzeniami.</span><span class="sxs-lookup"><span data-stu-id="49d8a-284">This method is most useful in monitoring scenarios for measuring the difference in memory allocation between time intervals or events.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGCMemoryInfo">
      <MemberSignature Language="C#" Value="public static GCMemoryInfo GetGCMemoryInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCMemoryInfo GetGCMemoryInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGCMemoryInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGCMemoryInfo () As GCMemoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCMemoryInfo GetGCMemoryInfo();" />
      <MemberSignature Language="F#" Value="static member GetGCMemoryInfo : unit -&gt; GCMemoryInfo" Usage="System.GC.GetGCMemoryInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.GCMemoryInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="49d8a-285">Zwraca bieżący numer generacji obiektu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-285">Returns the current generation number of an object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="49d8a-286">Obiekt, który generuje informacje, jest pobierany dla.</span><span class="sxs-lookup"><span data-stu-id="49d8a-286">The object that generation information is retrieved for.</span></span></param>
        <summary><span data-ttu-id="49d8a-287">Zwraca bieżący numer generacji określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-287">Returns the current generation number of the specified object.</span></span></summary>
        <returns><span data-ttu-id="49d8a-288">Bieżąca liczba <paramref name="obj" />generacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-288">The current generation number of <paramref name="obj" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-289">Użyj tej metody, aby określić wiek obiektu, a następnie użyj tych informacji przy użyciu <xref:System.GC.Collect%2A> metody, aby wymusić zbieranie obiektów przez moduł wyrzucania elementów bezużytecznych w ramach tej samej generacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-289">Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation.</span></span> <span data-ttu-id="49d8a-290">Na przykład użyj tej metody, jeśli masz zestaw obiektów, które są tworzone jako Grupa i stają się niedostępne w tym samym czasie.</span><span class="sxs-lookup"><span data-stu-id="49d8a-290">For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-291">Poniższy przykład ilustruje sposób użycia <xref:System.GC.GetGeneration%2A> metody w celu określenia wieku obiektu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-291">The following example demonstrates how to use the <xref:System.GC.GetGeneration%2A> method to determine the age of an object.</span></span> <span data-ttu-id="49d8a-292">Przykład następnie wykonuje odzyskiwanie pamięci, aby oczyścić pamięć i porównać całkowite i końcowe ilości pamięci kolekcji w konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-292">The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="wo"><span data-ttu-id="49d8a-293">Obiekt <see cref="T:System.WeakReference" /> , który odwołuje się do obiektu docelowego, którego numer generacji ma zostać określony.</span><span class="sxs-lookup"><span data-stu-id="49d8a-293">A <see cref="T:System.WeakReference" /> that refers to the target object whose generation number is to be determined.</span></span></param>
        <summary><span data-ttu-id="49d8a-294">Zwraca bieżący numer generacji elementu docelowego określonego słabego odwołania.</span><span class="sxs-lookup"><span data-stu-id="49d8a-294">Returns the current generation number of the target of a specified weak reference.</span></span></summary>
        <returns><span data-ttu-id="49d8a-295">Bieżąca liczba generacji dla elementu docelowego <paramref name="wo" />.</span><span class="sxs-lookup"><span data-stu-id="49d8a-295">The current generation number of the target of <paramref name="wo" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="49d8a-296">Poniższy przykład ilustruje użycie <xref:System.GC.GetGeneration%2A> metody do określenia wieku słabego obiektu referencyjnego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-296">The following example demonstrates the use of the <xref:System.GC.GetGeneration%2A> method to determine the age of a weak reference object.</span></span>  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="49d8a-297">Wyrzucanie elementów bezużytecznych <paramref name="wo" />zostało już wykonane.</span><span class="sxs-lookup"><span data-stu-id="49d8a-297">Garbage collection has already been performed on <paramref name="wo" />.</span></span></exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalAllocatedBytes">
      <MemberSignature Language="C#" Value="public static long GetTotalAllocatedBytes (bool precise = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalAllocatedBytes(bool precise) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalAllocatedBytes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalAllocatedBytes (Optional precise As Boolean = false) As Long" />
      <MemberSignature Language="F#" Value="static member GetTotalAllocatedBytes : bool -&gt; int64" Usage="System.GC.GetTotalAllocatedBytes precise" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precise" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="precise"><span data-ttu-id="49d8a-298">W <see langword="true" />przypadku zbierania dokładnej liczby; w przeciwnym razie Zbierz przybliżoną liczbę.</span><span class="sxs-lookup"><span data-stu-id="49d8a-298">If <see langword="true" />, gather a precise number; otherwise, gather an approximate count.</span></span> <span data-ttu-id="49d8a-299">Gromadzenie dokładnej wartości powoduje znaczącą spadek wydajności.</span><span class="sxs-lookup"><span data-stu-id="49d8a-299">Gathering a precise value entails a significant performance penalty.</span></span></param>
        <summary><span data-ttu-id="49d8a-300">Pobiera liczbę bajtów przydzieloną w okresie istnienia procesu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-300">Gets a count of the bytes allocated over the lifetime of the process.</span></span></summary>
        <returns><span data-ttu-id="49d8a-301">Całkowita liczba bajtów przydzielono w okresie istnienia procesu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-301">The total number of bytes allocated over the lifetime of the process.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection"><span data-ttu-id="49d8a-302"><see langword="true" />Aby wskazać, że ta metoda może oczekiwać na wystąpienie wyrzucania elementów bezużytecznych przed zwróceniem; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="49d8a-302"><see langword="true" /> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="49d8a-303">Pobiera liczbę bajtów, które są aktualnie uważane za przydzieloną.</span><span class="sxs-lookup"><span data-stu-id="49d8a-303">Retrieves the number of bytes currently thought to be allocated.</span></span> <span data-ttu-id="49d8a-304">Parametr wskazuje, czy ta metoda może oczekiwać krótkiego interwału przed zwróceniem, aby umożliwić systemowi zbieranie elementów bezużytecznych i finalizowanie obiektów.</span><span class="sxs-lookup"><span data-stu-id="49d8a-304">A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</span></span></summary>
        <returns><span data-ttu-id="49d8a-305">Liczba, która jest najlepszym dostępnym przybliżeniem liczby bajtów aktualnie przydzieloną w pamięci zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="49d8a-305">A number that is the best available approximation of the number of bytes currently allocated in managed memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-306">Jeśli parametr ma `true`wartość, ta metoda czeka krótki interwał przed zwróceniem, podczas gdy system zbiera elementy bezużyteczne i finalizowanie obiektów. `forceFullCollection`</span><span class="sxs-lookup"><span data-stu-id="49d8a-306">If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects.</span></span> <span data-ttu-id="49d8a-307">Czas trwania interwału to wewnętrznie określony limit określony przez liczbę cykli wyrzucania elementów bezużytecznych i zmiany ilości pamięci, która jest odzyskiwana między cyklami.</span><span class="sxs-lookup"><span data-stu-id="49d8a-307">The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</span></span> <span data-ttu-id="49d8a-308">Moduł wyrzucania elementów bezużytecznych nie gwarantuje, że jest zbierana cała niedostępna pamięć.</span><span class="sxs-lookup"><span data-stu-id="49d8a-308">The garbage collector does not guarantee that all inaccessible memory is collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-309">W poniższym przykładzie pokazano, jak za pomocą <xref:System.GC.GetTotalMemory%2A> metody pobrać i wyświetlić liczbę bajtów aktualnie przydzieloną w pamięci zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="49d8a-309">The following example demonstrates how to use the <xref:System.GC.GetTotalMemory%2A> method to get and display the number of bytes currently allocated in managed memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="49d8a-310">Obiekt do odwołania.</span><span class="sxs-lookup"><span data-stu-id="49d8a-310">The object to reference.</span></span></param>
        <summary><span data-ttu-id="49d8a-311">Odwołuje się do określonego obiektu, co sprawia, że nie kwalifikuje się do wyrzucania elementów bezużytecznych od początku bieżącej procedury do punktu, w którym ta metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="49d8a-311">References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-312">Celem <xref:System.GC.KeepAlive%2A> metody jest upewnienie się, że istnieje odwołanie do obiektu, który jest zagrożony przez moduł wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-312">The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</span></span> <span data-ttu-id="49d8a-313">Typowy scenariusz, w którym może się zdarzyć, ma miejsce, gdy nie ma odwołań do obiektu w kodzie zarządzanym lub danych, ale obiekt jest nadal używany w kodzie niezarządzanym, takim jak interfejsy API systemu Windows, niezarządzane biblioteki DLL lub metody przy użyciu modelu COM.</span><span class="sxs-lookup"><span data-stu-id="49d8a-313">A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Windows APIs, unmanaged DLLs, or methods using COM.</span></span>  
  
 <span data-ttu-id="49d8a-314">Ta metoda odwołuje `obj` się do parametru, dzięki czemu ten obiekt nie kwalifikuje się do wyrzucania elementów bezużytecznych od początku procedury do punktu w kolejności wykonywania, gdzie ta metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="49d8a-314">This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</span></span> <span data-ttu-id="49d8a-315">Zakodować tę metodę na końcu, a nie na początku, zakresu instrukcji, gdzie `obj` muszą być dostępne.</span><span class="sxs-lookup"><span data-stu-id="49d8a-315">Code this method at the end, not the beginning, of the range of instructions where `obj` must be available.</span></span>  
  
 <span data-ttu-id="49d8a-316"><xref:System.GC.KeepAlive%2A> Metoda nie wykonuje operacji i nie generuje żadnych efektów ubocznych innych niż przedłużenie okresu istnienia obiektu przenoszonego jako parametr.</span><span class="sxs-lookup"><span data-stu-id="49d8a-316">The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-317">Poniższy przykład kodu tworzy obiekt na początku jego `Main` metody i nie odwołuje się ponownie do obiektu do momentu zakończenia, <xref:System.GC.KeepAlive%2A> gdy wywoływana jest metoda.</span><span class="sxs-lookup"><span data-stu-id="49d8a-317">The following code example creates an object at the beginning of its `Main` method and does not refer to the object again until the end, when the <xref:System.GC.KeepAlive%2A> method is called.</span></span> <span data-ttu-id="49d8a-318">Obiekt utrzymuje się na 30-sekundowym czasie trwania `Main` metody, pomimo wywołań <xref:System.GC.Collect%2A> metod i <xref:System.GC.WaitForPendingFinalizers%2A> .</span><span class="sxs-lookup"><span data-stu-id="49d8a-318">The object persists for the 30-second duration of the `Main` method, despite calls to the <xref:System.GC.Collect%2A> and <xref:System.GC.WaitForPendingFinalizers%2A> methods.</span></span>  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="49d8a-319">Pobiera maksymalną liczbę generacji, które obecnie obsługuje system.</span><span class="sxs-lookup"><span data-stu-id="49d8a-319">Gets the maximum number of generations that the system currently supports.</span></span></summary>
        <value><span data-ttu-id="49d8a-320">Wartość z zakresu od zera do maksymalnej liczby obsługiwanych generacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-320">A value that ranges from zero to the maximum number of supported generations.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-321">Numer generacji lub wiek obiektu jest zdefiniowaną w implementacji miarą względną dla cykl życia obiektu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-321">The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</span></span> <span data-ttu-id="49d8a-322">Ostatnio utworzone obiekty są w generacji 0, a najstarsze obiekty znajdują się w generacji mniejszej lub równej generacji zwróconej przez <xref:System.GC.MaxGeneration%2A> właściwość.</span><span class="sxs-lookup"><span data-stu-id="49d8a-322">The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.</span></span>  
  
 <span data-ttu-id="49d8a-323">Moduł wyrzucania elementów bezużytecznych zakłada, że nowsza ilość pamięci jest prawdopodobnie uprawniona do wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-323">The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</span></span> <span data-ttu-id="49d8a-324">W związku z tym moduł wyrzucania elementów bezużytecznych zwiększa wydajność, dopasowując numery generacji przy każdym <xref:System.GC.MaxGeneration%2A> odzyskiwaniu pamięci, a wartość właściwości może się zwiększać wraz z upływem czasu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-324">Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.</span></span>  
  
 <span data-ttu-id="49d8a-325">Jeśli zaimplementowano przedawnianie obiektów, <xref:System.GC.MaxGeneration%2A> Właściwość zwraca maksymalny numer generacji używany przez system; w przeciwnym razie ta właściwość zwraca zero.</span><span class="sxs-lookup"><span data-stu-id="49d8a-325">If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-326">W poniższym przykładzie pokazano, jak użyć właściwości MaxGeneration, aby wyświetlić największy numer generacji, który jest aktualnie używany.</span><span class="sxs-lookup"><span data-stu-id="49d8a-326">The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="49d8a-327">W przypadku tej implementacji wartość zwrócona przez <see cref="P:System.GC.MaxGeneration" /> właściwość jest gwarantowana na stałą dla okresu istnienia aplikacji, która wykonuje.</span><span class="sxs-lookup"><span data-stu-id="49d8a-327">For this implementation, the value returned by the <see cref="P:System.GC.MaxGeneration" /> property is guaranteed to remain constant for the lifetime of an executing application.</span></span>  
  
<span data-ttu-id="49d8a-328">Użyj właściwości, aby określić maksymalną wartość, którą można określić podczas <see cref="M:System.GC.Collect(System.Int32)" /> wywoływania metody, która przyjmuje parametr generacji. <see cref="P:System.GC.MaxGeneration" /></span><span class="sxs-lookup"><span data-stu-id="49d8a-328">Use the <see cref="P:System.GC.MaxGeneration" /> property to determine the maximum value you can specify when calling the <see cref="M:System.GC.Collect(System.Int32)" /> method that takes a generation parameter.</span></span></para></block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold"><span data-ttu-id="49d8a-329">Liczba z zakresu od 1 do 99 określająca, kiedy powiadomienie powinno być zgłaszane na podstawie obiektów przyznanych w generacji 2.</span><span class="sxs-lookup"><span data-stu-id="49d8a-329">A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</span></span></param>
        <param name="largeObjectHeapThreshold"><span data-ttu-id="49d8a-330">Liczba z zakresu od 1 do 99 określająca, kiedy powiadomienie powinno być zgłaszane na podstawie obiektów przyznanych w stercie dużego obiektu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-330">A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</span></span></param>
        <summary><span data-ttu-id="49d8a-331">Określa, że należy podwyższyć powiadomienie o wyrzucaniu elementów bezużytecznych, gdy warunki preferują pełne odzyskiwanie pamięci i gdy kolekcja została ukończona.</span><span class="sxs-lookup"><span data-stu-id="49d8a-331">Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-332">Dla każdej generacji moduł zbierający elementy bezużyteczne ustawia próg alokacji dla tej generacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-332">For each generation, the garbage collector sets a threshold for allocations into that generation.</span></span> <span data-ttu-id="49d8a-333">Gdy rozmiar alokacji przekracza ten próg, wyrzucanie elementów bezużytecznych jest wyzwalane na tej generacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-333">When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</span></span> <span data-ttu-id="49d8a-334">Na przykład jeśli wartość progowa generacji 2 to baza (co oznacza, że baza przeżyje 1 kolekcje i zostanie podwyższony do generacji 2), a więcej niż baza przestała 1 i zostanie wyświetlony monit do generacji 2, zostanie podjęta kolejna próba wyrzucania elementów bezużytecznych jako kolekcja generacji 2.</span><span class="sxs-lookup"><span data-stu-id="49d8a-334">For example, if generation 2's threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</span></span> <span data-ttu-id="49d8a-335">Podobnie, jeśli wartość progowa sterty dużego obiektu (LOH) to baza, a aplikacja przydzieliła więcej niż baza dużych obiektów, kolejne odzyskiwanie pamięci zostanie również ponowione jako kolekcja generacji 2 (ponieważ LOH jest zbierana tylko w Gen2 rekolekcji elementów bezużytecznych).</span><span class="sxs-lookup"><span data-stu-id="49d8a-335">Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</span></span>  
  
 <span data-ttu-id="49d8a-336">`maxGenerationThreshold` Progi `largeObjectHeapThreshold` i decydują o tym, jak dużo z wyprzedzeniem otrzymujesz powiadomienie przed wystąpieniem pełnego wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-336">The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs.</span></span> <span data-ttu-id="49d8a-337">Im większy próg, tym więcej alokacji, które mogą wystąpić między powiadomieniem i następnym pełnym wyrzucaniem elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-337">The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</span></span>  
  
 <span data-ttu-id="49d8a-338">Jeśli masz sytuacje, w których pełne wyrzucanie elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego nie wpłynie negatywnie na wydajność aplikacji, możesz polecić otrzymywanie powiadomień, gdy środowisko uruchomieniowe ma wykonać pełne odzyskiwanie pamięci i obejść tę kolekcję przez Wywoływanie kolekcji (przy użyciu <xref:System.GC.Collect%2A> metody), gdy warunki są nadal preferowane.</span><span class="sxs-lookup"><span data-stu-id="49d8a-338">If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable.</span></span> <span data-ttu-id="49d8a-339">Oprócz zmieniania harmonogramu wyrzucania elementów bezużytecznych, pełne powiadomienie w ramach programu GC jest przydatne w następujących scenariuszach:</span><span class="sxs-lookup"><span data-stu-id="49d8a-339">In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</span></span>  
  
-   <span data-ttu-id="49d8a-340">Możesz monitorować podejście do pełnego wyrzucania elementów bezużytecznych i, gdy otrzymasz powiadomienie, że jedna z nich zbliża się, zmniejszy się rozmiar danych na żywo (na przykład przez wydanie niektórych wpisów pamięci podręcznej).</span><span class="sxs-lookup"><span data-stu-id="49d8a-340">You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</span></span> <span data-ttu-id="49d8a-341">W związku z tym, gdy następuje wyrzucanie elementów bezużytecznych, jest możliwe odjęcie większej ilości pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-341">As a result, when the garbage collection occurs, it is able to reclaim more memory.</span></span>  
  
-   <span data-ttu-id="49d8a-342">Możesz monitorować ukończenie pełnego wyrzucania elementów bezużytecznych, dzięki czemu można zbierać pewne dane statystyczne.</span><span class="sxs-lookup"><span data-stu-id="49d8a-342">You monitor for the completion of a full garbage collection so that you can collect some statistics.</span></span>  <span data-ttu-id="49d8a-343">Na przykład może zajść potrzeba mierzenia rozmiaru sterty na zakończenie GC, aby znać rozmiar danych na żywo.</span><span class="sxs-lookup"><span data-stu-id="49d8a-343">For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</span></span> <span data-ttu-id="49d8a-344">(Po pełnym wykazie globalnym sterta ma najmniejszy rozmiar).</span><span class="sxs-lookup"><span data-stu-id="49d8a-344">(After a full GC, the heap is at its smallest size.)</span></span>  
  
 <span data-ttu-id="49d8a-345">Aby uzyskać więcej informacji o tym, co reprezentuje pełne odzyskiwanie pamięci, zobacz powiadomienia dotyczące wyrzucania [elementów](~/docs/standard/garbage-collection/notifications.md)bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-345">For more information about what represents a full garbage collection, see [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md).</span></span>  
  
 <span data-ttu-id="49d8a-346">Po zarejestrowaniu do powiadomienia o wyrzucaniu elementów bezużytecznych można otrzymywać powiadomienia, gdy zostanie zbliżane pełne odzyskiwanie pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-346">When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</span></span> <span data-ttu-id="49d8a-347">Ten wzorzec przypomina, jak system operacyjny monitoruje w przypadku powiadomień o niskiej ilości pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-347">This pattern resembles how the operating system monitors for low memory notifications.</span></span>  
  
 <span data-ttu-id="49d8a-348">Aby określić `maxGenerationThreshold` parametry i `largeObjectHeapThreshold` należy użyć następujących wytycznych:</span><span class="sxs-lookup"><span data-stu-id="49d8a-348">Use the following guidelines for specifying the `maxGenerationThreshold` and `largeObjectHeapThreshold` parameters:</span></span>  
  
-   <span data-ttu-id="49d8a-349">Im większa wartość progowa, tym większa alokacja będzie odbywać się między powiadomieniem i pełnym wyrzucaniem elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-349">The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</span></span>  
  
     <span data-ttu-id="49d8a-350">Większa wartość progowa daje więcej możliwości dla środowiska uruchomieniowego, aby sprawdzić, czy zbliża się kolekcja.</span><span class="sxs-lookup"><span data-stu-id="49d8a-350">A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</span></span> <span data-ttu-id="49d8a-351">Zwiększa to prawdopodobieństwo, że użytkownik zostanie powiadomiony.</span><span class="sxs-lookup"><span data-stu-id="49d8a-351">This increases the likelihood that you will be notified.</span></span> <span data-ttu-id="49d8a-352">Nie należy jednak ustawiać progu zbyt wysoki, ponieważ powoduje to większe alokacje zanim środowisko uruchomieniowe wymusi następną kolekcję.</span><span class="sxs-lookup"><span data-stu-id="49d8a-352">However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</span></span>  
  
     <span data-ttu-id="49d8a-353">Gdy samodzielnie wywołujesz kolekcję po powiadomieniu przy użyciu dużej wartości progowej, mniej obiektów są odzyskiwane, niż byłyby odzyskiwane przez następną kolekcję środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-353">When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</span></span>  
  
-   <span data-ttu-id="49d8a-354">Im mniejsza wartość progowa, tym mniejsza ilość alokacji między powiadomieniem a pełnym odzyskiwaniem pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-354">The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-355">Poniższy przykład przedstawia sposób rejestrowania powiadomienia o wyrzucaniu elementów bezużytecznych i uruchamiania wątku do monitorowania stanu powiadomienia o wyrzucaniu elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-355">The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</span></span> <span data-ttu-id="49d8a-356">Ten przykład kodu jest częścią większego przykładu dostarczonego w temacie powiadomienia o wyrzucaniu [elementów](~/docs/standard/garbage-collection/notifications.md) bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-356">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="49d8a-357"><paramref name="maxGenerationThreshold" />lub <paramref name="largeObjectHeapThreshold" /> nie należy do zakresu od 1 do 99.</span><span class="sxs-lookup"><span data-stu-id="49d8a-357"><paramref name="maxGenerationThreshold" /> or <paramref name="largeObjectHeapThreshold" /> is not between 1 and 99.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="49d8a-358">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-358">for full trust for the immediate caller.</span></span> <span data-ttu-id="49d8a-359">Ten element członkowski nie może być używany przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="49d8a-359">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="49d8a-360">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-360">requires full trust for the immediate caller.</span></span> <span data-ttu-id="49d8a-361">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="49d8a-361">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="49d8a-362">Powiadomienia dotyczące odzyskiwania pamięci</span><span class="sxs-lookup"><span data-stu-id="49d8a-362">Garbage Collection Notifications</span></span></related>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="49d8a-363">Ten element członkowski nie jest dostępny, gdy włączone jest współbieżne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-363">This member is not available when concurrent garbage collection is enabled.</span></span> <span data-ttu-id="49d8a-364">Zobacz ustawienie &lt;środowiska&gt; uruchomieniowego gcConcurrent, aby uzyskać informacje o tym, jak wyłączyć współbieżne odzyskiwanie pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-364">See the &lt;gcConcurrent&gt; runtime setting for information about how to disable concurrent garbage collection.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated"><span data-ttu-id="49d8a-365">Ilość pamięci niezarządzanej, która została wydana.</span><span class="sxs-lookup"><span data-stu-id="49d8a-365">The amount of unmanaged memory that has been released.</span></span></param>
        <summary><span data-ttu-id="49d8a-366">Informuje środowisko uruchomieniowe, że niezarządzana pamięć została wydana i nie trzeba już brać pod uwagę podczas planowania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-366">Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-367">W celu określenia czasu, w którym należy zaplanować wyrzucanie elementów bezużytecznych, środowisko uruchomieniowe uwzględnia ilość przydzielonej pamięci zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="49d8a-367">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="49d8a-368">Jeśli mały zarządzany obiekt przydzieli dużą ilość pamięci niezarządzanej, środowisko uruchomieniowe bierze pod uwagę tylko zarządzaną pamięć i w ten sposób szacuje pilność planowania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-368">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="49d8a-369">Metoda informuje środowisko uruchomieniowe tego dodatkowego nacisku w pamięci systemowej, <xref:System.GC.RemoveMemoryPressure%2A> a metoda informuje środowisko uruchomieniowe o zwolnieniu dodatkowego nacisku. <xref:System.GC.AddMemoryPressure%2A></span><span class="sxs-lookup"><span data-stu-id="49d8a-369">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.</span></span>  
  
 <span data-ttu-id="49d8a-370">W najprostszym wzorcu użycia obiekt zarządzany przydziela niezarządzaną pamięć w konstruktorze i zwalnia go w `Dispose` metodzie lub. `Finalize`</span><span class="sxs-lookup"><span data-stu-id="49d8a-370">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="49d8a-371">Wywołaj <xref:System.GC.RemoveMemoryPressure%2A> metodę po przydzieleniu pamięci niezarządzanej i Wywołaj metodę po jej zwolnieniu. <xref:System.GC.AddMemoryPressure%2A></span><span class="sxs-lookup"><span data-stu-id="49d8a-371">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="49d8a-372">W bardziej skomplikowanych scenariuszach, w których niezarządzana alokacja pamięci ulega znacznemu zmianie w okresie istnienia zarządzanego obiektu, <xref:System.GC.AddMemoryPressure%2A> można <xref:System.GC.RemoveMemoryPressure%2A> wywołać metody i, aby przekazać te przyrostowe zmiany do środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-372">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="49d8a-373">Należy upewnić się, że należy usunąć dokładnie ilość dodawanego nacisku.</span><span class="sxs-lookup"><span data-stu-id="49d8a-373">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="49d8a-374">Niewykonanie tej czynności może niekorzystnie wpłynąć na wydajność systemu w aplikacjach uruchamianych przez długi czas.</span><span class="sxs-lookup"><span data-stu-id="49d8a-374">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="49d8a-375"><paramref name="bytesAllocated" />jest mniejsze lub równe 0.</span><span class="sxs-lookup"><span data-stu-id="49d8a-375"><paramref name="bytesAllocated" /> is less than or equal to 0.</span></span>  
  
<span data-ttu-id="49d8a-376">—lub—</span><span class="sxs-lookup"><span data-stu-id="49d8a-376">-or-</span></span> 
<span data-ttu-id="49d8a-377">Na komputerze <paramref name="bytesAllocated" /> 32-bitowym jest większy niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="49d8a-377">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="49d8a-378">umożliwia wywoływanie kodu niezarządzanego podczas manipulowania priorytetem kolekcji elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-378">for the ability to call unmanaged code when manipulating garbage-collection priority.</span></span> <span data-ttu-id="49d8a-379">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="49d8a-379">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="49d8a-380">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-380">requires full trust for the immediate caller.</span></span> <span data-ttu-id="49d8a-381">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="49d8a-381">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="49d8a-382">Obiekt, dla którego należy wywołać finalizator.</span><span class="sxs-lookup"><span data-stu-id="49d8a-382">The object that a finalizer must be called for.</span></span></param>
        <summary><span data-ttu-id="49d8a-383">Żąda, aby system wywoływał finalizator dla określonego obiektu, dla którego <see cref="M:System.GC.SuppressFinalize(System.Object)" /> poprzednio został wywołany.</span><span class="sxs-lookup"><span data-stu-id="49d8a-383">Requests that the system call the finalizer for the specified object for which <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has previously been called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-384"><xref:System.GC.ReRegisterForFinalize%2A> Metoda`obj` dodaje parametr do listy obiektów, które żądają finalizowania, zanim moduł wyrzucania elementów bezużytecznych zwolni obiekt.</span><span class="sxs-lookup"><span data-stu-id="49d8a-384">The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object.</span></span> <span data-ttu-id="49d8a-385">`obj` Parametr musi być obiektem wywołującym tej metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-385">The `obj` parameter must be the caller of this method.</span></span>  
  
 <span data-ttu-id="49d8a-386"><xref:System.GC.ReRegisterForFinalize%2A> Wywołanie metody nie gwarantuje, że moduł wyrzucania elementów bezużytecznych wywoła finalizator obiektu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-386">Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer.</span></span>  
  
 <span data-ttu-id="49d8a-387">Domyślnie wszystkie obiekty implementujące finalizatory są dodawane do listy obiektów, które wymagają finalizacji; Jednak obiekt mógł zostać już sfinalizowany lub mógł wyłączyć finalizowanie, wywołując <xref:System.GC.SuppressFinalize%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="49d8a-387">By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method.</span></span>  
  
 <span data-ttu-id="49d8a-388">Finalizator może użyć tej metody do przywracania aktywności samego siebie lub obiektu, do którego się odwołuje.</span><span class="sxs-lookup"><span data-stu-id="49d8a-388">A finalizer can use this method to resurrect itself or an object that it references.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-389">Poniższy przykład ilustruje sposób użycia metody ReRegisterForFinalize w celu sfinalizowania obiektu po raz drugi po wyrzucaniu elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-389">The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</span></span>  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="49d8a-390"><paramref name="obj" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="49d8a-390"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="49d8a-391">Obiekt, którego finalizator nie może zostać wykonany.</span><span class="sxs-lookup"><span data-stu-id="49d8a-391">The object whose finalizer must not be executed.</span></span></param>
        <summary><span data-ttu-id="49d8a-392">Żąda, aby środowisko uruchomieniowe języka wspólnego nie wywołało finalizatora dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-392">Requests that the common language runtime not call the finalizer for the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-393">Ta metoda ustawia bit w nagłówku `obj`obiektu, którego środowisko uruchomieniowe sprawdza podczas wywoływania finalizatorów.</span><span class="sxs-lookup"><span data-stu-id="49d8a-393">This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers.</span></span> <span data-ttu-id="49d8a-394">Finalizator, który jest reprezentowany przez <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodę, jest używany do zwalniania niezarządzanych zasobów, zanim obiekt zostanie pobrany jako bezużyteczny.</span><span class="sxs-lookup"><span data-stu-id="49d8a-394">A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method, is used to release unmanaged resources before an object is garbage-collected.</span></span> <span data-ttu-id="49d8a-395">Jeśli `obj` nie ma finalizatora, wywołanie <xref:System.GC.SuppressFinalize%2A> metody nie ma wpływu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-395">If `obj` does not have a finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect.</span></span>  
  
 <span data-ttu-id="49d8a-396">Obiekty implementujące <xref:System.IDisposable> interfejs mogą wywołać tę metodę z <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji obiektu, aby zapobiec wywoływaniu <xref:System.Object.Finalize%2A?displayProperty=nameWithType> przez moduł wyrzucania elementów bezużytecznych na obiekcie, który go nie wymaga.</span><span class="sxs-lookup"><span data-stu-id="49d8a-396">Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=nameWithType> on an object that does not require it.</span></span> <span data-ttu-id="49d8a-397">Zwykle jest to spowodowane tym, że nie można zwolnić niezarządzanych zasobów, które zostały już zwolnione przez <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementację.</span><span class="sxs-lookup"><span data-stu-id="49d8a-397">Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-398">Poniższy przykład ilustruje sposób użycia <xref:System.GC.SuppressFinalize%2A> metody w klasie zasobów, aby zapobiec wywoływaniu nadmiarowego wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-398">The following example demonstrates how to use the <xref:System.GC.SuppressFinalize%2A> method in a resource class to prevent a redundant garbage collection from being called.</span></span> <span data-ttu-id="49d8a-399">W przykładzie pokazano użycie [wzorca Dispose](~/docs/standard/garbage-collection/implementing-dispose.md) do zwolnienia zasobów zarządzanych (czyli obiektów, które implementują <xref:System.IDisposable>) i niezarządzanych zasobów.</span><span class="sxs-lookup"><span data-stu-id="49d8a-399">The example uses the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) to free both managed resources (that is, objects that implement <xref:System.IDisposable>) and unmanaged resources.</span></span>  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="49d8a-400"><paramref name="obj" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="49d8a-400"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="https://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb"><span data-ttu-id="49d8a-401">Usuń wzorzec</span><span class="sxs-lookup"><span data-stu-id="49d8a-401">Dispose Pattern</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="49d8a-402">Próbuje uniemożliwić wyrzucanie elementów bezużytecznych podczas wykonywania ścieżki krytycznej.</span><span class="sxs-lookup"><span data-stu-id="49d8a-402">Attempts to disallow garbage collection during the execution of a critical path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="49d8a-403">Nie można zagnieżdżać wywołań do <xref:System.GC.TryStartNoGCRegion%2A> metody i należy <xref:System.GC.EndNoGCRegion%2A> wywołać metodę tylko wtedy, gdy środowisko uruchomieniowe jest obecnie w trybie opóźnień w regionie GC.</span><span class="sxs-lookup"><span data-stu-id="49d8a-403">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="49d8a-404">Innymi słowy, nie należy wywoływać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania zakończą się niepowodzeniem) i nie należy oczekiwać, aby <xref:System.GC.EndNoGCRegion%2A> wywołania kończyły się pomyślnie, <xref:System.GC.TryStartNoGCRegion%2A> ponieważ pierwsze wywołanie zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="49d8a-404">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="49d8a-405">Ilość pamięci w bajtach do przydzielenia bez wyzwalania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-405">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="49d8a-406">Musi być mniejszy niż lub równy rozmiarowi segmentu tymczasowych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-406">It must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="49d8a-407">Informacje o rozmiarze segmentu tymczasowych można znaleźć w sekcji "tymczasowe generacje i segmenty" w artykule [podstawowe informacje o odzyskiwaniu elementów](~/docs/standard/garbage-collection/fundamentals.md) bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-407">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <summary><span data-ttu-id="49d8a-408">Próbuje uniemożliwić wyrzucanie elementów bezużytecznych podczas wykonywania ścieżki krytycznej, jeśli jest dostępna określona ilość pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-408">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</span></span></summary>
        <returns><span data-ttu-id="49d8a-409"><see langword="true" />Jeśli środowisko uruchomieniowe mogło zatwierdzić wymaganą ilość pamięci, a Moduł wyrzucania elementów bezużytecznych może wejść w tryb opóźnienia w regionie GC; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="49d8a-409"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-410"><xref:System.GC.TryStartNoGCRegion%28System.Int64%29> Metoda próbuje umieścić Moduł wyrzucania elementów bezużytecznych w trybie opóźnienia w regionie GC, który uniemożliwia wyrzucanie elementów bezużytecznych, gdy aplikacja wykonuje krytyczny region kodu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-410">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="49d8a-411">Jeśli środowisko uruchomieniowe nie może początkowo przydzielić żądanej ilości pamięci, Moduł wyrzucania elementów bezużytecznych wykonuje pełne blokowanie wyrzucania elementów bezużytecznych podczas próby zwolnienia dodatkowej pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-411">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="49d8a-412">Moduł wyrzucania elementów bezużytecznych nie przechodzi w tryb opóźnienia regionu GC, jeśli może przydzielić wymaganą ilość pamięci, która w tym przypadku `totalSize` jest w rzeczywistości 2 \* bajtów `totalSize` (próbuje przydzielić bajty `totalSize` dla sterty małego obiektu i bajtów dla Sterta dużego obiektu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-412">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap).</span></span>  
  
 <span data-ttu-id="49d8a-413">`totalSize`musi być wystarczająco duży, aby obsługiwał wszystkie alokacje pamięci, które występują w ścieżce krytycznej.</span><span class="sxs-lookup"><span data-stu-id="49d8a-413">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="49d8a-414">Obejmuje to alokacje przez aplikację, a także alokacje, które środowisko uruchomieniowe wykonuje w imieniu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-414">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="49d8a-415">Nie można zagnieżdżać wywołań do <xref:System.GC.TryStartNoGCRegion%2A> metody i należy <xref:System.GC.EndNoGCRegion%2A> wywołać metodę tylko wtedy, gdy środowisko uruchomieniowe jest obecnie w trybie opóźnień w regionie GC.</span><span class="sxs-lookup"><span data-stu-id="49d8a-415">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="49d8a-416">Innymi słowy, nie należy wywoływać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania zakończą się niepowodzeniem) i nie należy oczekiwać, aby <xref:System.GC.EndNoGCRegion%2A> wywołania kończyły się pomyślnie, <xref:System.GC.TryStartNoGCRegion%2A> ponieważ pierwsze wywołanie zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="49d8a-416">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="49d8a-417">Aby wyjść z trybu opóźnień z regionem GC, <xref:System.GC.EndNoGCRegion%2A> należy wywołać metodę.</span><span class="sxs-lookup"><span data-stu-id="49d8a-417">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="49d8a-418"><paramref name="totalSize" />przekracza rozmiar segmentu tymczasowych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-418"><paramref name="totalSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="49d8a-419">Proces jest już w trybie opóźnień w regionie GC.</span><span class="sxs-lookup"><span data-stu-id="49d8a-419">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="49d8a-420">Podstawy dotyczące wyrzucania elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="49d8a-420">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="49d8a-421">Tryby opóźnienia</span><span class="sxs-lookup"><span data-stu-id="49d8a-421">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="49d8a-422">Ilość pamięci w bajtach do przydzielenia bez wyzwalania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-422">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="49d8a-423">Musi być mniejszy niż lub równy rozmiarowi segmentu tymczasowych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-423">It must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="49d8a-424">Informacje o rozmiarze segmentu tymczasowych można znaleźć w sekcji "tymczasowe generacje i segmenty" w artykule [podstawowe informacje o odzyskiwaniu elementów](~/docs/standard/garbage-collection/fundamentals.md) bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-424">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="disallowFullBlockingGC"><span data-ttu-id="49d8a-425"><see langword="true" />Aby pominąć pełne blokowanie wyrzucania elementów bezużytecznych, <paramref name="totalSize" /> <see langword="false" />Jeśli moduł wyrzucania elementów bezużytecznych nie może początkowo przydzielić bajtów; w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="49d8a-425"><see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <paramref name="totalSize" /> bytes; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="49d8a-426">Próbuje uniemożliwić wyrzucanie elementów bezużytecznych podczas wykonywania ścieżki krytycznej, jeśli jest dostępna określona ilość pamięci i kontroluje, czy moduł wyrzucania elementów bezużytecznych wykonuje pełne blokowanie wyrzucania elementów bezużytecznych, jeśli nie jest dostępna wystarczająca ilość pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-426">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span></span></summary>
        <returns><span data-ttu-id="49d8a-427"><see langword="true" />Jeśli środowisko uruchomieniowe mogło zatwierdzić wymaganą ilość pamięci, a Moduł wyrzucania elementów bezużytecznych może wejść w tryb opóźnienia w regionie GC; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="49d8a-427"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-428"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> Metoda próbuje umieścić Moduł wyrzucania elementów bezużytecznych w trybie opóźnienia w regionie GC, który uniemożliwia wyrzucanie elementów bezużytecznych, gdy aplikacja wykonuje krytyczny region kodu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-428">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="49d8a-429">Jeśli środowisko uruchomieniowe nie może początkowo przydzielić żądanej ilości pamięci, a `disallowFullBlockingGC` argument to `false`, Moduł wyrzucania elementów bezużytecznych wykonuje pełne blokowanie wyrzucania elementów bezużytecznych w próbie zwolnienia dodatkowej pamięci; w przeciwnym razie alokacja kończy się niepowodzeniem, a `false`Metoda zwraca.</span><span class="sxs-lookup"><span data-stu-id="49d8a-429">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="49d8a-430">Moduł wyrzucania elementów bezużytecznych nie przechodzi w tryb opóźnienia regionu GC, jeśli może przydzielić wymaganą ilość pamięci, która w tym przypadku `totalSize` jest w rzeczywistości 2 \* `totalSize` (próbuje przydzielić sterty małego obiektu i `totalSize` dla dużego obiektu Sterta).</span><span class="sxs-lookup"><span data-stu-id="49d8a-430">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap).</span></span>  
  
 <span data-ttu-id="49d8a-431">`totalSize`musi być wystarczająco duży, aby obsługiwał wszystkie alokacje pamięci, które występują w ścieżce krytycznej.</span><span class="sxs-lookup"><span data-stu-id="49d8a-431">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="49d8a-432">Obejmuje to alokacje przez aplikację, a także alokacje, które środowisko uruchomieniowe wykonuje w imieniu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-432">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="49d8a-433">Ustawienie `disallowFullBlockingGC`zapobiegające pełnemu blokowaniu wyrzucania elementów bezużytecznych, jeśli nie jest dostępna wystarczająca ilość pamięci jest najbardziej przydatna w scenariuszach równoważenia obciążenia: jeden system może wywołać tę metodę i zgłosić się jako gotowy do akceptowania żądań, jeśli zwróci wartość `true` i moduł równoważenia obciążenia przekierowuje żądania do innych systemów, jeśli zwróci wartość `false`. `true`</span><span class="sxs-lookup"><span data-stu-id="49d8a-433">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="49d8a-434">Następnie może wykonać pełne blokowanie wyrzucania elementów bezużytecznych, gdy nie obsługuje żądań przez <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-434">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="49d8a-435">Nie można zagnieżdżać wywołań do <xref:System.GC.TryStartNoGCRegion%2A> metody i należy <xref:System.GC.EndNoGCRegion%2A> wywołać metodę tylko wtedy, gdy środowisko uruchomieniowe jest obecnie w trybie opóźnień w regionie GC.</span><span class="sxs-lookup"><span data-stu-id="49d8a-435">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="49d8a-436">Innymi słowy, nie należy wywoływać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania zakończą się niepowodzeniem) i nie należy oczekiwać, aby <xref:System.GC.EndNoGCRegion%2A> wywołania kończyły się pomyślnie, <xref:System.GC.TryStartNoGCRegion%2A> ponieważ pierwsze wywołanie zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="49d8a-436">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="49d8a-437">Aby wyjść z trybu opóźnień z regionem GC, <xref:System.GC.EndNoGCRegion%2A> należy wywołać metodę.</span><span class="sxs-lookup"><span data-stu-id="49d8a-437">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="49d8a-438"><paramref name="totalSize" />przekracza rozmiar segmentu tymczasowych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-438"><paramref name="totalSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="49d8a-439">Proces jest już w trybie opóźnień w regionie GC.</span><span class="sxs-lookup"><span data-stu-id="49d8a-439">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="49d8a-440">Podstawy dotyczące wyrzucania elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="49d8a-440">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="49d8a-441">Tryby opóźnienia</span><span class="sxs-lookup"><span data-stu-id="49d8a-441">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="49d8a-442">Ilość pamięci w bajtach do przydzielenia bez wyzwalania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-442">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="49d8a-443"><paramref name="totalSize" /> -<paramref name="lohSize" />musi być mniejszy niż lub równy rozmiarowi segmentu tymczasowych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-443"><paramref name="totalSize" /> -<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="49d8a-444">Informacje o rozmiarze segmentu tymczasowych można znaleźć w sekcji "tymczasowe generacje i segmenty" w artykule [podstawowe informacje o odzyskiwaniu elementów](~/docs/standard/garbage-collection/fundamentals.md) bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-444">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="lohSize"><span data-ttu-id="49d8a-445">Liczba bajtów <paramref name="totalSize" /> , które mają być używane dla przydziałów sterty dużych obiektów (LOH).</span><span class="sxs-lookup"><span data-stu-id="49d8a-445">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span></span></param>
        <summary><span data-ttu-id="49d8a-446">Próbuje uniemożliwić wyrzucanie elementów bezużytecznych podczas wykonywania ścieżki krytycznej, jeśli określona ilość pamięci jest dostępna dla sterty dużych obiektów i sterty małego obiektu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-446">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</span></span></summary>
        <returns><span data-ttu-id="49d8a-447"><see langword="true" />Jeśli środowisko uruchomieniowe mogło zatwierdzić wymaganą ilość pamięci, a Moduł wyrzucania elementów bezużytecznych może wejść w tryb opóźnienia w regionie GC; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="49d8a-447"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-448"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> Metoda próbuje umieścić Moduł wyrzucania elementów bezużytecznych w trybie opóźnienia w regionie GC, który uniemożliwia wyrzucanie elementów bezużytecznych, gdy aplikacja wykonuje krytyczny region kodu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-448">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="49d8a-449">Jeśli środowisko uruchomieniowe nie może początkowo przydzielić żądanej ilości pamięci, Moduł wyrzucania elementów bezużytecznych wykonuje pełne blokowanie wyrzucania elementów bezużytecznych podczas próby zwolnienia dodatkowej pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-449">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="49d8a-450">Moduł wyrzucania elementów bezużytecznych nie przechodzi w tryb opóźnienia regionu GC `lohSize` , jeśli jest w `totalSize` stanie przydzielić LOH oraz  -  `lohSize` dla sterty małego obiektu (raport o kondycji).</span><span class="sxs-lookup"><span data-stu-id="49d8a-450">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` - `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="49d8a-451">`lohSize`musi być wystarczająco duży, aby obsługiwał wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla LOH, `totalSize` i  -  `lohSize` muszą być wystarczająco duże, aby obsługiwać wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla raportu o kondycji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-451">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` - `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="49d8a-452">Obejmuje to alokacje przez aplikację, a także alokacje, które środowisko uruchomieniowe wykonuje w imieniu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-452">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="49d8a-453">Nie można zagnieżdżać wywołań do <xref:System.GC.TryStartNoGCRegion%2A> metody i należy <xref:System.GC.EndNoGCRegion%2A> wywołać metodę tylko wtedy, gdy środowisko uruchomieniowe jest obecnie w trybie opóźnień w regionie GC.</span><span class="sxs-lookup"><span data-stu-id="49d8a-453">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="49d8a-454">Innymi słowy, nie należy wywoływać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania zakończą się niepowodzeniem) i nie należy oczekiwać, aby <xref:System.GC.EndNoGCRegion%2A> wywołania kończyły się pomyślnie, <xref:System.GC.TryStartNoGCRegion%2A> ponieważ pierwsze wywołanie zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="49d8a-454">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="49d8a-455">Aby wyjść z trybu opóźnień z regionem GC, <xref:System.GC.EndNoGCRegion%2A> należy wywołać metodę.</span><span class="sxs-lookup"><span data-stu-id="49d8a-455">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="49d8a-456"><paramref name="totalSize" /> - <paramref name="lohSize" />przekracza rozmiar segmentu tymczasowych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-456"><paramref name="totalSize" /> - <paramref name="lohSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="49d8a-457">Proces jest już w trybie opóźnień w regionie GC.</span><span class="sxs-lookup"><span data-stu-id="49d8a-457">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="49d8a-458">Podstawy dotyczące wyrzucania elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="49d8a-458">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="49d8a-459">Tryby opóźnienia</span><span class="sxs-lookup"><span data-stu-id="49d8a-459">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="49d8a-460">Ilość pamięci w bajtach do przydzielenia bez wyzwalania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-460">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="49d8a-461"><paramref name="totalSize" /> -<paramref name="lohSize" />musi być mniejszy niż lub równy rozmiarowi segmentu tymczasowych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-461"><paramref name="totalSize" /> -<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="49d8a-462">Informacje o rozmiarze segmentu tymczasowych można znaleźć w sekcji "tymczasowe generacje i segmenty" w artykule [podstawowe informacje o odzyskiwaniu elementów](~/docs/standard/garbage-collection/fundamentals.md) bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-462">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="lohSize"><span data-ttu-id="49d8a-463">Liczba bajtów <paramref name="totalSize" /> , które mają być używane dla przydziałów sterty dużych obiektów (LOH).</span><span class="sxs-lookup"><span data-stu-id="49d8a-463">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span></span></param>
        <param name="disallowFullBlockingGC"><span data-ttu-id="49d8a-464"><see langword="true" />Aby pominąć pełne blokowanie wyrzucania elementów bezużytecznych, jeśli moduł wyrzucania elementów bezużytecznych nie może początkowo przydzielić określonej pamięci na stosie małego obiektu (raport o kondycji) i LOH; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="49d8a-464"><see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="49d8a-465">Próbuje uniemożliwić wyrzucanie elementów bezużytecznych podczas wykonywania ścieżki krytycznej, jeśli określona ilość pamięci jest dostępna dla sterty dużych obiektów i sterty małego obiektu i kontroluje, czy moduł wyrzucania elementów bezużytecznych wykonuje pełne blokowanie wyrzucania elementów bezużytecznych, jeśli nie Początkowo dostępna jest wystarczająca ilość pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-465">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span></span></summary>
        <returns><span data-ttu-id="49d8a-466"><see langword="true" />Jeśli środowisko uruchomieniowe mogło zatwierdzić wymaganą ilość pamięci, a Moduł wyrzucania elementów bezużytecznych może wejść w tryb opóźnienia w regionie GC; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="49d8a-466"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-467"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> Metoda próbuje umieścić Moduł wyrzucania elementów bezużytecznych w trybie opóźnienia w regionie GC, który uniemożliwia wyrzucanie elementów bezużytecznych, gdy aplikacja wykonuje krytyczny region kodu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-467">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="49d8a-468">Jeśli środowisko uruchomieniowe nie może początkowo przydzielić żądanej ilości pamięci, a `disallowFullBlockingGC` argument to `false`, Moduł wyrzucania elementów bezużytecznych wykonuje pełne blokowanie wyrzucania elementów bezużytecznych w próbie zwolnienia dodatkowej pamięci; w przeciwnym razie alokacja kończy się niepowodzeniem, a `false`Metoda zwraca.</span><span class="sxs-lookup"><span data-stu-id="49d8a-468">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="49d8a-469">Moduł wyrzucania elementów bezużytecznych nie przechodzi w tryb opóźnienia regionu GC `lohSize` , jeśli jest w `totalSize` stanie przydzielić LOH oraz  -  `lohSize` dla sterty małego obiektu (raport o kondycji).</span><span class="sxs-lookup"><span data-stu-id="49d8a-469">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` - `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="49d8a-470">`lohSize`musi być wystarczająco duży, aby obsługiwał wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla LOH, `totalSize` i  -  `lohSize` muszą być wystarczająco duże, aby obsługiwać wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla raportu o kondycji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-470">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` - `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="49d8a-471">Obejmuje to alokacje przez aplikację, a także alokacje, które środowisko uruchomieniowe wykonuje w imieniu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-471">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="49d8a-472">Ustawienie `disallowFullBlockingGC`zapobiegające pełnemu blokowaniu wyrzucania elementów bezużytecznych, jeśli nie jest dostępna wystarczająca ilość pamięci jest najbardziej przydatna w scenariuszach równoważenia obciążenia: jeden system może wywołać tę metodę i zgłosić się jako gotowy do akceptowania żądań, jeśli zwróci wartość `true` i moduł równoważenia obciążenia przekierowuje żądania do innych systemów, jeśli zwróci wartość `false`. `true`</span><span class="sxs-lookup"><span data-stu-id="49d8a-472">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="49d8a-473">Następnie może wykonać pełne blokowanie wyrzucania elementów bezużytecznych, gdy nie obsługuje żądań przez <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-473">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="49d8a-474">Nie można zagnieżdżać wywołań do <xref:System.GC.TryStartNoGCRegion%2A> metody i należy <xref:System.GC.EndNoGCRegion%2A> wywołać metodę tylko wtedy, gdy środowisko uruchomieniowe jest obecnie w trybie opóźnień w regionie GC.</span><span class="sxs-lookup"><span data-stu-id="49d8a-474">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="49d8a-475">Innymi słowy, nie należy wywoływać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania zakończą się niepowodzeniem) i nie należy oczekiwać, aby <xref:System.GC.EndNoGCRegion%2A> wywołania kończyły się pomyślnie, <xref:System.GC.TryStartNoGCRegion%2A> ponieważ pierwsze wywołanie zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="49d8a-475">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="49d8a-476">Aby wyjść z trybu opóźnień z regionem GC, <xref:System.GC.EndNoGCRegion%2A> należy wywołać metodę.</span><span class="sxs-lookup"><span data-stu-id="49d8a-476">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="49d8a-477"><paramref name="totalSize" /> - <paramref name="lohSize" />przekracza rozmiar segmentu tymczasowych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-477"><paramref name="totalSize" /> - <paramref name="lohSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="49d8a-478">Proces jest już w trybie opóźnień w regionie GC.</span><span class="sxs-lookup"><span data-stu-id="49d8a-478">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="49d8a-479">Podstawy dotyczące wyrzucania elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="49d8a-479">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="49d8a-480">Tryby opóźnienia</span><span class="sxs-lookup"><span data-stu-id="49d8a-480">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="49d8a-481">Zwraca stan zarejestrowanego powiadomienia w celu określenia, czy pełna, blokująca wyrzucanie elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego jest bliska.</span><span class="sxs-lookup"><span data-stu-id="49d8a-481">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="49d8a-482">Zwraca stan zarejestrowanego powiadomienia w celu określenia, czy pełna, blokująca wyrzucanie elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego jest bliska.</span><span class="sxs-lookup"><span data-stu-id="49d8a-482">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
        <returns><span data-ttu-id="49d8a-483">Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-483">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-484">Użyj wyliczenia zwróconego przez tę metodę, aby określić stan bieżącego powiadomienia o wyrzucaniu elementów bezużytecznych, które <xref:System.GC.RegisterForFullGCNotification%2A> zostało zarejestrowane za pomocą metody. <xref:System.GCNotificationStatus></span><span class="sxs-lookup"><span data-stu-id="49d8a-484">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="49d8a-485">Można również użyć <xref:System.GC.WaitForFullGCComplete%2A> metody, aby określić, czy pełne odzyskiwanie pamięci zostało zakończone.</span><span class="sxs-lookup"><span data-stu-id="49d8a-485">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="49d8a-486">Gdy Wyliczenie zwraca <xref:System.GCNotificationStatus.Succeeded>, można wykonywać zadania, takie jak uniemożliwienie przydzielenia dodatkowych obiektów i wywoływanie kolekcji <xref:System.GC.Collect%2A> przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-486">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="49d8a-487">Należy pamiętać, że powiadomienie nie gwarantuje, że zostanie wykonane pełne odzyskiwanie pamięci, tylko te warunki osiągnęły próg, który jest preferowany do wykonania pełnego odzyskiwania pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-487">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="49d8a-488">Ta metoda czeka na nieokreślony czas na uzyskanie powiadomienia o wyrzucaniu elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-488">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="49d8a-489">Jeśli chcesz określić limit czasu dla metody, która ma zostać zwrócona, jeśli nie można uzyskać powiadomienia, użyj <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-489">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="49d8a-490">W <xref:System.GC.CancelFullGCNotification%2A> przypadku wywołania tej metody bez określenia limitu czasu można wywołać metodę, jeśli czekasz dłużej niż preferowane.</span><span class="sxs-lookup"><span data-stu-id="49d8a-490">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="49d8a-491">Należy wykonać tę metodę z wywołaniem <xref:System.GC.WaitForFullGCComplete%2A> metody, aby upewnić się, że masz pełne odzyskiwanie pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-491">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="49d8a-492">Wywołanie tej metody powoduje jedynie nieokreślony wynik.</span><span class="sxs-lookup"><span data-stu-id="49d8a-492">Calling this method alone causes indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-493">Poniższy przykład pokazuje, jak używać tej metody w celu ustalenia, czy jest zbliżana pełna, blokująca wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-493">The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</span></span> <span data-ttu-id="49d8a-494">Zawsze, gdy jest <xref:System.GCNotificationStatus.Succeeded>wskazywany stan powiadomienia, Metoda `OnFullGCApproachNotify` użytkownika jest wywoływana w celu wykonywania akcji w odpowiedzi na zbliżające się kolekcje.</span><span class="sxs-lookup"><span data-stu-id="49d8a-494">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCApproachNotify` is called to perform actions in response to the approaching collection.</span></span> <span data-ttu-id="49d8a-495">Ten przykład kodu jest częścią większego przykładu dostarczonego w temacie powiadomienia o wyrzucaniu [elementów](~/docs/standard/garbage-collection/notifications.md) bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-495">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="49d8a-496">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-496">for full trust for the immediate caller.</span></span> <span data-ttu-id="49d8a-497">Ten element członkowski nie może być używany przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="49d8a-497">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="49d8a-498">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-498">requires full trust for the immediate caller.</span></span> <span data-ttu-id="49d8a-499">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="49d8a-499">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="49d8a-500">Powiadomienia dotyczące odzyskiwania pamięci</span><span class="sxs-lookup"><span data-stu-id="49d8a-500">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="49d8a-501">Czas oczekiwania na uzyskanie stanu powiadomienia.</span><span class="sxs-lookup"><span data-stu-id="49d8a-501">The length of time to wait before a notification status can be obtained.</span></span> <span data-ttu-id="49d8a-502">Określ-1, aby czekać w nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="49d8a-502">Specify -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="49d8a-503">Zwraca w określonym przedziale czasu stan zarejestrowanego powiadomienia w celu określenia, czy pełna, blokująca wyrzucanie elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego jest bliska.</span><span class="sxs-lookup"><span data-stu-id="49d8a-503">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
        <returns><span data-ttu-id="49d8a-504">Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-504">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-505">Użyj wyliczenia zwróconego przez tę metodę, aby określić stan bieżącego powiadomienia o wyrzucaniu elementów bezużytecznych, które <xref:System.GC.RegisterForFullGCNotification%2A> zostało zarejestrowane za pomocą metody. <xref:System.GCNotificationStatus></span><span class="sxs-lookup"><span data-stu-id="49d8a-505">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="49d8a-506">Można również użyć <xref:System.GC.WaitForFullGCComplete%2A> metody, aby określić, czy pełne odzyskiwanie pamięci zostało zakończone.</span><span class="sxs-lookup"><span data-stu-id="49d8a-506">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="49d8a-507">Należy zauważyć, że ta metoda zwraca natychmiast za każdym razem, gdy zostanie uzyskany stan powiadomienia o wyrzucaniu `millisecondsTimeout`elementów bezużytecznych, niezależnie od wartości określonej przez.</span><span class="sxs-lookup"><span data-stu-id="49d8a-507">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="49d8a-508">Jeśli stan powiadomienia o wyrzucaniu elementów bezużytecznych nie zostanie uzyskany przed <xref:System.GCNotificationStatus.NotApplicable>upływem `millisecondsTimeout` limitu czasu, ta metoda zwróci wartość.</span><span class="sxs-lookup"><span data-stu-id="49d8a-508">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="49d8a-509">Gdy Wyliczenie zwraca <xref:System.GCNotificationStatus.Succeeded>, można wykonywać zadania, takie jak uniemożliwienie przydzielenia dodatkowych obiektów i wywoływanie kolekcji <xref:System.GC.Collect%2A> przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-509">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="49d8a-510">Należy pamiętać, że powiadomienie nie gwarantuje, że zostanie wykonane pełne odzyskiwanie pamięci, tylko te warunki osiągnęły próg, który jest preferowany do wykonania pełnego odzyskiwania pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-510">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="49d8a-511">Metodę można wywołać, <xref:System.GC.CancelFullGCNotification%2A> gdy nie można czekać, aż upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-511">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="49d8a-512">Należy wykonać tę metodę z wywołaniem <xref:System.GC.WaitForFullGCComplete%2A> metody, aby upewnić się, że masz pełne odzyskiwanie pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-512">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="49d8a-513">Wywołanie tej metody powoduje jedynie nieokreślony wynik.</span><span class="sxs-lookup"><span data-stu-id="49d8a-513">Calling this method alone causes indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="49d8a-514"><paramref name="millisecondsTimeout" />musi być wartością nieujemną lub mniejszą lub równą <see cref="F:System.Int32.MaxValue" /> lub-1.</span><span class="sxs-lookup"><span data-stu-id="49d8a-514"><paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="49d8a-515">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-515">for full trust for the immediate caller.</span></span> <span data-ttu-id="49d8a-516">Ten element członkowski nie może być używany przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="49d8a-516">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="49d8a-517">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-517">requires full trust for the immediate caller.</span></span> <span data-ttu-id="49d8a-518">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="49d8a-518">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="49d8a-519">Powiadomienia dotyczące odzyskiwania pamięci</span><span class="sxs-lookup"><span data-stu-id="49d8a-519">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="49d8a-520">Zwraca stan zarejestrowanego powiadomienia w celu określenia, czy pełne, blokujące wyrzucanie elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego zostało zakończone.</span><span class="sxs-lookup"><span data-stu-id="49d8a-520">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="49d8a-521">Zwraca stan zarejestrowanego powiadomienia w celu określenia, czy pełne, blokujące wyrzucanie elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego zostało zakończone.</span><span class="sxs-lookup"><span data-stu-id="49d8a-521">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span></span></summary>
        <returns><span data-ttu-id="49d8a-522">Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-522">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-523">Użyj wyliczenia zwróconego przez tę metodę, aby określić stan bieżącego powiadomienia o wyrzucaniu elementów bezużytecznych, które <xref:System.GC.RegisterForFullGCNotification%2A> zostało zarejestrowane za pomocą metody. <xref:System.GCNotificationStatus></span><span class="sxs-lookup"><span data-stu-id="49d8a-523">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="49d8a-524">Można również użyć metody, <xref:System.GC.WaitForFullGCApproach%2A> aby określić, czy pełne wyrzucanie elementów bezużytecznych jest nieuchronne.</span><span class="sxs-lookup"><span data-stu-id="49d8a-524">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="49d8a-525">Gdy Wyliczenie zwraca <xref:System.GCNotificationStatus.Succeeded>, można wykonywać zadania, takie jak wznawianie pracy i uzyskiwanie liczby kolekcji <xref:System.GC.CollectionCount%2A> z właściwością.</span><span class="sxs-lookup"><span data-stu-id="49d8a-525">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="49d8a-526">Ta metoda czeka na nieokreślony czas na uzyskanie powiadomienia o wyrzucaniu elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-526">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="49d8a-527">Jeśli chcesz określić limit czasu dla metody, która ma zostać zwrócona, jeśli nie można uzyskać powiadomienia, użyj <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="49d8a-527">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="49d8a-528">W <xref:System.GC.CancelFullGCNotification%2A> przypadku wywołania tej metody bez określenia limitu czasu można wywołać metodę, jeśli czekasz dłużej niż preferowane.</span><span class="sxs-lookup"><span data-stu-id="49d8a-528">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="49d8a-529">To wywołanie metody powinno być poprzedzone wywołaniem <xref:System.GC.WaitForFullGCApproach%2A> metody, aby upewnić się, że masz pełne odzyskiwanie pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-529">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="49d8a-530">Wywołanie tej metody może spowodować wygenerowanie nieokreślonych wyników.</span><span class="sxs-lookup"><span data-stu-id="49d8a-530">Calling this method alone can produce indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-531">Poniższy przykład przedstawia sposób użycia tej metody w celu ustalenia, czy ukończono pełne odzyskiwanie pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-531">The following example shows how to use this method to determine whether a full garbage collection has completed.</span></span> <span data-ttu-id="49d8a-532">Zawsze, gdy jest <xref:System.GCNotificationStatus.Succeeded>wskazywany stan powiadomienia, Metoda `OnFullGCCompletedNotify` użytkownika jest wywoływana w celu wykonania akcji w odpowiedzi na ukończoną kolekcję.</span><span class="sxs-lookup"><span data-stu-id="49d8a-532">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCCompletedNotify` is called to perform actions in response to the completed collection.</span></span> <span data-ttu-id="49d8a-533">Ten przykład kodu jest częścią większego przykładu dostarczonego w temacie powiadomienia o wyrzucaniu [elementów](~/docs/standard/garbage-collection/notifications.md) bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-533">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="49d8a-534">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-534">for full trust for the immediate caller.</span></span> <span data-ttu-id="49d8a-535">Ten element członkowski nie może być używany przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="49d8a-535">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="49d8a-536">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-536">requires full trust for the immediate caller.</span></span> <span data-ttu-id="49d8a-537">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="49d8a-537">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="49d8a-538">Powiadomienia dotyczące odzyskiwania pamięci</span><span class="sxs-lookup"><span data-stu-id="49d8a-538">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="49d8a-539">Czas oczekiwania na uzyskanie stanu powiadomienia.</span><span class="sxs-lookup"><span data-stu-id="49d8a-539">The length of time to wait before a notification status can be obtained.</span></span> <span data-ttu-id="49d8a-540">Określ-1, aby czekać w nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="49d8a-540">Specify -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="49d8a-541">Zwraca w określonym przedziale czasu stan zarejestrowanego powiadomienia w celu określenia, czy pełne, blokujące wyrzucanie elementów bezużytecznych w ramach wspólnego języka zostało zakończone.</span><span class="sxs-lookup"><span data-stu-id="49d8a-541">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</span></span></summary>
        <returns><span data-ttu-id="49d8a-542">Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="49d8a-542">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-543">Użyj wyliczenia zwróconego przez tę metodę, aby określić stan bieżącego powiadomienia o wyrzucaniu elementów bezużytecznych, które <xref:System.GC.RegisterForFullGCNotification%2A> zostało zarejestrowane za pomocą metody. <xref:System.GCNotificationStatus></span><span class="sxs-lookup"><span data-stu-id="49d8a-543">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="49d8a-544">Można również użyć metody, <xref:System.GC.WaitForFullGCApproach%2A> aby określić, czy pełne wyrzucanie elementów bezużytecznych jest nieuchronne.</span><span class="sxs-lookup"><span data-stu-id="49d8a-544">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="49d8a-545">Należy zauważyć, że ta metoda zwraca natychmiast za każdym razem, gdy zostanie uzyskany stan powiadomienia o wyrzucaniu `millisecondsTimeout`elementów bezużytecznych, niezależnie od wartości określonej przez.</span><span class="sxs-lookup"><span data-stu-id="49d8a-545">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="49d8a-546">Jeśli stan powiadomienia o wyrzucaniu elementów bezużytecznych nie zostanie uzyskany przed <xref:System.GCNotificationStatus.NotApplicable>upływem `millisecondsTimeout` limitu czasu, ta metoda zwróci wartość.</span><span class="sxs-lookup"><span data-stu-id="49d8a-546">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="49d8a-547">Gdy Wyliczenie zwraca <xref:System.GCNotificationStatus.Succeeded>, można wykonywać zadania, takie jak wznawianie pracy i uzyskiwanie liczby kolekcji <xref:System.GC.CollectionCount%2A> z właściwością.</span><span class="sxs-lookup"><span data-stu-id="49d8a-547">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="49d8a-548">Metodę można wywołać, <xref:System.GC.CancelFullGCNotification%2A> gdy nie można czekać, aż upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-548">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="49d8a-549">To wywołanie metody powinno być poprzedzone wywołaniem <xref:System.GC.WaitForFullGCApproach%2A> metody, aby upewnić się, że masz pełne odzyskiwanie pamięci.</span><span class="sxs-lookup"><span data-stu-id="49d8a-549">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="49d8a-550">Wywołanie tej metody może spowodować wygenerowanie nieokreślonych wyników.</span><span class="sxs-lookup"><span data-stu-id="49d8a-550">Calling this method alone can produce indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="49d8a-551"><paramref name="millisecondsTimeout" />musi być wartością nieujemną lub mniejszą lub równą <see cref="F:System.Int32.MaxValue" /> lub-1.</span><span class="sxs-lookup"><span data-stu-id="49d8a-551"><paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="49d8a-552">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-552">for full trust for the immediate caller.</span></span> <span data-ttu-id="49d8a-553">Ten element członkowski nie może być używany przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="49d8a-553">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="49d8a-554">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="49d8a-554">requires full trust for the immediate caller.</span></span> <span data-ttu-id="49d8a-555">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="49d8a-555">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="49d8a-556">Powiadomienia dotyczące odzyskiwania pamięci</span><span class="sxs-lookup"><span data-stu-id="49d8a-556">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="49d8a-557">Wstrzymuje bieżący wątek, dopóki wątek, który przetwarza kolejki finalizatorów, opróżnił tę kolejkę.</span><span class="sxs-lookup"><span data-stu-id="49d8a-557">Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="49d8a-558">Gdy moduł wyrzucania elementów bezużytecznych odnajdzie obiekty, które mogą być odzyskiwane, sprawdza każdy obiekt, aby określić wymagania finalizacji obiektu.</span><span class="sxs-lookup"><span data-stu-id="49d8a-558">When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</span></span> <span data-ttu-id="49d8a-559">Jeśli obiekt implementuje finalizator i nie wyłączył finalizowania przez wywołanie <xref:System.GC.SuppressFinalize%2A>, obiekt zostanie umieszczony na liście obiektów, które są oznaczone jako gotowe do finalizacji.</span><span class="sxs-lookup"><span data-stu-id="49d8a-559">If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization.</span></span> <span data-ttu-id="49d8a-560">Moduł zbierający elementy bezużyteczne wywołuje <xref:System.Object.Finalize%2A> metody dla obiektów na tej liście i usuwa wpisy z listy.</span><span class="sxs-lookup"><span data-stu-id="49d8a-560">The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list.</span></span> <span data-ttu-id="49d8a-561">Ta metoda jest blokowana do momentu zakończenia wszystkich finalizatorów.</span><span class="sxs-lookup"><span data-stu-id="49d8a-561">This method blocks until all finalizers have run to completion.</span></span>  
  
 <span data-ttu-id="49d8a-562">Wątek, w którym są uruchamiane finalizatory, jest nieokreślony, dlatego nie ma gwarancji, że ta metoda zostanie przerwana.</span><span class="sxs-lookup"><span data-stu-id="49d8a-562">The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</span></span> <span data-ttu-id="49d8a-563">Jednak ten wątek może zostać przerwany przez inny wątek, gdy <xref:System.GC.WaitForPendingFinalizers%2A> Metoda jest w toku.</span><span class="sxs-lookup"><span data-stu-id="49d8a-563">However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress.</span></span> <span data-ttu-id="49d8a-564">Można na przykład uruchomić inny wątek, który czeka przez pewien czas, a następnie przerwać ten wątek, jeśli ten wątek nadal jest wstrzymany.</span><span class="sxs-lookup"><span data-stu-id="49d8a-564">For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="49d8a-565">Poniższy przykład ilustruje sposób użycia <xref:System.GC.WaitForPendingFinalizers%2A> metody do zawieszenia bieżącego wątku do momentu zakończenia wszystkich zebranych obiektów.</span><span class="sxs-lookup"><span data-stu-id="49d8a-565">The following example demonstrates how to use the <xref:System.GC.WaitForPendingFinalizers%2A> method to suspend the current thread until finalization of all the collected objects is complete.</span></span>  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
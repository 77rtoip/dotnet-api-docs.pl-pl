<Type Name="GC" FullName="System.GC">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="11996d97bef6121bce982a8368bef5e8197c8a44" />
    <Meta Name="ms.sourcegitcommit" Value="1465f1a9bce3970cd9e95769eaa641b92a0a22d5" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/18/2018" />
    <Meta Name="ms.locfileid" Value="31469402" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Określa moduł zbierający elementy bezużyteczne systemu to usługa, która automatycznie zwraca nieużywanej pamięci.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł zbierający elementy bezużyteczne to typowe składnika środowiska uruchomieniowego języka, który kontroluje alokacji i wersji pamięci zarządzanej. Metody tej klasy wpływ, gdy obiektu i po udostępnieniu zasoby przydzielone przez obiekt odbywa się wyrzucanie elementów bezużytecznych. Właściwości tej klasy zawierają informacje o całkowitej ilości pamięci w systemie i wiek kategorii lub generowania pamięci przydzielonej do obiektu.  
  
 Moduł zbierający elementy bezużyteczne śledzi i zwraca obiekty przydzielone w pamięci zarządzanej. Moduł garbage collector wykonuje okresowo, wyrzucanie elementów bezużytecznych w celu odzyskania pamięci przydzielonej do obiektów, dla których nie ma żadnych prawidłowe odwołania. Wyrzucanie elementów bezużytecznych odbywa się automatycznie, gdy żądanie pamięci nie mogą być spełnione przy użyciu dostępnej wolnej pamięci. Alternatywnie aplikacji można wymusić przy użyciu kolekcji garbage <xref:System.GC.Collect%2A> metody.  
  
 Wyrzucanie elementów bezużytecznych obejmuje następujące kroki:  
  
1.  Moduł zbierający elementy bezużyteczne wyszukiwanie obiektów zarządzanych, do których istnieją odwołania w kodzie zarządzanym.  
  
2.  Moduł zbierający elementy bezużyteczne próbuje zakończyć obiektów, które nie są używane.  
  
3.  Moduł zbierający elementy bezużyteczne zwalnia obiektów, które nie są używane i zwraca ich pamięci.  
  
 Ten temat zawiera następujące sekcje:  
  
 [Moduł zbierający elementy bezużyteczne i zasoby niezarządzane](#unmanaged)   
 [Obiekt przedawnienia i generacji](#generations)   
 [Brak zezwolenia wyrzucanie elementów bezużytecznych](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a>Moduł zbierający elementy bezużyteczne i zasoby niezarządzane  
 Podczas zbierania moduł zbierający elementy bezużyteczne nie spowoduje zwolnienie obiektu, w przypadku odnalezienia co najmniej jednego odwołania do obiektu w kodzie zarządzanym. Jednak moduł garbage collector nie może rozpoznać odwołania do obiektu z kodem niezarządzanym i może zwolnić obiekty, które są używane wyłącznie za pomocą kodu niezarządzanego, chyba że jawnie uniemożliwił w ten sposób. <xref:System.GC.KeepAlive%2A> Metoda zapewnia mechanizm, który uniemożliwia zbierania obiektów, które są nadal używane za pomocą kodu niezarządzanego przez moduł garbage collector.  
  
 Jako uzupełnienie alokacje pamięci zarządzanej implementacje moduł garbage collector nie obsługują informacji o zasoby zajmowane przez obiekt, np. dojścia do plików lub połączenia z bazą danych. Typem wykorzystującym niezarządzane zasoby, które muszą zostać zwolnione odzyskane wystąpienia typu Typ można zaimplementować finalizator.  
  
 W większości przypadków finalizatory są implementowane przez zastąpienie <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody; jednak typy napisany w języku C# lub języka C++ zaimplementować destruktory, które kompilatory przekształcić zastępująca <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. W większości przypadków Jeśli obiekt ma finalizator, moduł zbierający elementy bezużyteczne wywołuje ona przed zwalniania obiektu. Jednak nie jest wymagane wywoływać finalizatory w sytuacji wszystkie; moduł zbierający elementy bezużyteczne na przykład <xref:System.GC.SuppressFinalize%2A> metoda jawnie uniemożliwia finalizatora obiektu wywoływane. Ponadto moduł garbage collector jest nie trzeba używać z konkretnym wątkiem finalize obiektów lub gwarantuje kolejności, w którym finalizatory są nazywane dla obiektów, które zależą od siebie, ale w przeciwnym razie są dostępne dla wyrzucanie elementów bezużytecznych.  
  
 W scenariuszach, w którym zasoby muszą zostać zwolnione w określonym czasie, można zaimplementować klasy <xref:System.IDisposable> interfejsu, który zawiera <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodę, która wykonuje zadania zarządzania i czyszczenie zasobów. Klasy, które implementują <xref:System.IDisposable.Dispose%2A> konieczne jest określenie, w ramach umowy klasy, jeśli klasy konsumentów wywołać metodę, aby wyczyścić obiektu. Moduł zbierający elementy bezużyteczne, domyślnie wymagają <xref:System.IDisposable.Dispose%2A> — metoda, jednak implementacje <xref:System.IDisposable.Dispose%2A> metodę można wywoływać metod <xref:System.GC> klasę, aby dostosować zachowanie finalizacji moduł garbage collector.  
  
 Aby uzyskać więcej informacji o finalizacji obiektu i wzorzec dispose zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a>Obiekt przedawnienia i generacji  
 Moduł zbierający elementy bezużyteczne w środowisku uruchomieniowym języka obsługuje przedawnienia obiektu przy użyciu generacji. Generacji jest jednostką miary względną życia obiektów w pamięci. Generowanie liczby lub wieku obiektu wskazuje generacji, do którego należy obiekt. Obiekty utworzone więcej ostatnio są częścią generacje nowszej i mają niższych numerach generowania niż cykl obiektów utworzonych wcześniej w cyklu życia aplikacji. Obiekty w ostatniej generacji mają podczas generowania 0. Ta implementacja modułu zbierającego elementy bezużyteczne obsługuje trzy generacje obiektów, pokolenia 0, 1 i 2. Można pobrać wartość <xref:System.GC.MaxGeneration%2A> właściwości w celu określenia numer generowania Maksymalna obsługiwana przez system.  
  
 Przedawnienia obiektu umożliwia aplikacji docelowej wyrzucanie elementów bezużytecznych w określonych generacje nie wymagają modułu zbierającego elementy bezużyteczne do oceny wszystkich generacji. Overloads z <xref:System.GC.Collect%2A> — metoda, która zawiera `generation` parametru umożliwiają określenie najstarsze generowania być bezużytecznych.  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a>Brak zezwolenia wyrzucanie elementów bezużytecznych  
 Począwszy od [!INCLUDE[net_v46](~/includes/net-v46-md.md)], moduł zbierający elementy bezużyteczne obsługuje nie GC region opóźnienia tryb używany podczas wykonywania ścieżek krytycznych, w których pamięci kolekcji może niekorzystnie wpłynąć na wydajność aplikacji. Nie GC region opóźnienia tryb wymaga określenia ilości pamięci, która może być przydzielona bez zakłóceń z modułu zbierającego elementy bezużyteczne. Jeśli środowisko uruchomieniowe można przydzielić pamięci, środowisko uruchomieniowe nie będzie wykonywać wyrzucania elementów bezużytecznych podczas wykonuje kod w ścieżce krytyczne.  
  
 Zdefiniuj początek krytyczne ścieżka obszaru nie GC, wywołując jedną z przeciążeń <xref:System.GC.TryStartNoGCRegion%2A>. Określ koniec jego ścieżkę krytyczną przez wywołanie metody <xref:System.GC.EndNoGCRegion%2A> metody.  
  
 Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, a powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko uruchomieniowe jest w trybie opóźnienia region nie GC. Innymi słowy, nie powinien wywołania <xref:System.GC.TryStartNoGCRegion%2A> wielokrotnie (po pierwszym wywołaniu metody kolejnych wywołań nie powiedzie się), i nie należy oczekiwać wywołań <xref:System.GC.EndNoGCRegion%2A> do pomyślnego wyłącznie z powodu pierwsze wywołanie <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.  
  
   
  
## Examples  
 W poniższym przykładzie użyto kilka metod GC do generowania i informacji o pamięci o bloku nieużywane obiekty i wydrukować go do konsoli. Nieużywane obiekty są następnie zbierane i sumy pamięci wynikowe są wyświetlane.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Przyrostowe ilość niezarządzanej pamięci, która została przydzielona.</param>
        <summary>Informuje o środowiska wykonawczego o dużych alokacji niezarządzanej pamięci, które powinny być brane pod uwagę podczas planowania wyrzucanie elementów bezużytecznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy określaniu, kiedy należy zaplanować wyrzucanie elementów bezużytecznych, środowisko uruchomieniowe bierze pod uwagę ilość pamięci zarządzanej został przydzielony. Małego obiektu zarządzanego przydziela dużej ilości pamięci niezarządzane, środowisko uruchomieniowe uwzględnia pamięci zarządzanej, a w związku z tym szacuje zbyt nisko pilność planowania wyrzucanie elementów bezużytecznych. <xref:System.GC.AddMemoryPressure%2A> Metody informuje środowiska uruchomieniowego tej dodatkowe wykorzystania pamięci systemu.  
  
 We wzorcu najprostszy sposób użycia obiektu zarządzanego przydziela pamięć niezarządzanych w Konstruktorze i zwolnieniem w `Dispose` lub `Finalize` metody. Wywołanie <xref:System.GC.AddMemoryPressure%2A> metody po przydzieleniu niezarządzanej pamięci i Wywołaj <xref:System.GC.RemoveMemoryPressure%2A> metody po jego zwolnienia.  
  
 W bardziej złożonych zadań, w których alokacji pamięci niezarządzanej znacznie zmieni się przez cały okres istnienia obiektu zarządzanego, można wywołać <xref:System.GC.AddMemoryPressure%2A> i <xref:System.GC.RemoveMemoryPressure%2A> metody do komunikowania się te zmiany przyrostowe do środowiska wykonawczego.  
  
> [!CAUTION]
>  Należy się upewnić, usunięcie dokładnie ilość wykorzystania dodane. Niepowodzenie w tym przypadku może niekorzystnie wpłynąć na wydajność systemu w aplikacjach wykonywanych przez dłuższy czas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> jest mniejsze niż lub równa 0.  
  
 —lub—  
  
 Na komputerze 32-bitowym <paramref name="bytesAllocated" /> jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływanie kodu niezarządzanego podczas manipulacji priorytet wyrzucanie elementów bezużytecznych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia anulowanie rejestracji powiadomień kolekcji pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia anulowanie powiadomień kolekcji pamięci, który został zarejestrowany za pomocą <xref:System.GC.RegisterForFullGCNotification%2A> metody. Nie trzeba tę metodę należy wywołać przed dostosowaniem progu wartości parametrów w kolejnych wywołaniach <xref:System.GC.RegisterForFullGCNotification%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład umożliwia anulowanie rejestracji kolekcji pamięci. Ten przykład jest częścią większego przykładu udostępnionego dla [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md) tematu.  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ten element członkowski jest niedostępna, gdy jest włączona współbieżne odzyskiwanie pamięci. Zobacz [ &lt;gcconcurrent —&gt; ](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) ustawienie środowiska uruchomieniowego dla informacji o sposobie wyłączyć współbieżne odzyskiwanie pamięci.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wymusza wyrzucanie elementów bezużytecznych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymuszenie natychmiastowego wyrzucanie elementów bezużytecznych wszystkich generacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby spróbować odzyskać wszystkie pamięci, który jest niedostępny. Wykonuje blokowania wyrzucania elementów bezużytecznych wszystkich generacji.  
  
 Wszystkie obiekty, niezależnie od tego, jak długo znajdowały się w pamięci, są traktowane jako kolekcji; obiekty, które są używane w kodzie zarządzanym nie są zbierane. Użyj tej metody, aby wymusić próby odzyskania maksymalną ilość dostępnej pamięci systemu.  
  
 Począwszy od [!INCLUDE[net_v451](~/includes/net-v451-md.md)], skompaktowaniu sterty dużego obiektu (LOH) przez ustawienie <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> właściwości <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> przed wywołaniem <xref:System.GC.Collect%2A> metody, jak w poniższym przykładzie przedstawiono.  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.GC.Collect%2A> metodę w celu kolekcji na wszystkich generacji pamięci. Kod generuje wiele nieużywanych obiektów, a następnie wywołuje <xref:System.GC.Collect%2A> metody do usunięcia ich z pamięci.  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">Liczba najstarsze generowania być bezużytecznych.</param>
        <summary>Wymuszenie natychmiastowego wyrzucanie elementów bezużytecznych z generacji 0 za pomocą określonej generacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby spróbować odzyskać pamięć, która jest niedostępna. Jednak za pomocą tej metody nie gwarantuje, że jest odzyskać wszystkie pamięci niedostępne w określonej generacji.  
  
 Jeśli zaimplementowano przedawnienia obiektu, moduł zbierający elementy bezużyteczne nie zbiera obiektów o numerze generacji jest wyższy niż określonej generacji. Jeśli obiekt przedawnienia nie jest zaimplementowana, moduł zbierający elementy bezużyteczne uwzględnia wszystkie obiekty podczas wyrzucania elementów bezużytecznych.  
  
 Użyj <xref:System.GC.MaxGeneration%2A> właściwości, aby określić maksymalną wartość prawidłowy `generation` parametru.  
  
 Aby moduł zbierający elementy bezużyteczne należy wziąć pod uwagę wszystkie obiekty niezależnie od ich generowania, użyj wersji tej metody, która nie przyjmuje żadnych parametrów. Aby moduł zbierający elementy bezużyteczne odzyskać obiektów na podstawie <xref:System.GCCollectionMode> ustawienie, użyj <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> przeciążenie metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.GC.Collect%2A> metodę w celu kolekcji na poszczególnych warstw pamięci. Kod generuje wiele nieużywanych obiektów, a następnie wywołuje <xref:System.GC.Collect%2A> metody do usunięcia ich z pamięci.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> nie jest prawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">Liczba najstarsze generowania być bezużytecznych.</param>
        <param name="mode">Wartość wyliczenia, który określa, czy będzie zmuszony wyrzucanie elementów bezużytecznych (<see cref="F:System.GCCollectionMode.Default" /> lub <see cref="F:System.GCCollectionMode.Forced" />) lub zoptymalizowany (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <summary>Wyrzucanie elementów bezużytecznych z generacji 0 za pomocą określonej generacji w czasie określonym przez wymusza <see cref="T:System.GCCollectionMode" /> wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `mode` parametr, aby określić, czy wyrzucanie elementów bezużytecznych powinna występować natychmiast lub tylko jeśli czas jest optymalna odzyskiwanie obiektów. Za pomocą tej metody nie gwarantuje, że jest odzyskać wszystkie pamięci niedostępne w określonej generacji.  
  
 Aby dostosować intrusiveness operacji wyrzucania elementów bezużytecznych w krytycznych okresach w aplikacji, ustaw <xref:System.Runtime.GCSettings.LatencyMode%2A> właściwości.  
  
 Moduł zbierający elementy bezużyteczne nie gromadzi obiekty z liczbą generowania wyższe niż określona w `generation` parametru. Użyj <xref:System.GC.MaxGeneration%2A> właściwości, aby określić maksymalną wartość prawidłowy `generation`.  
  
 Aby moduł zbierający elementy bezużyteczne należy wziąć pod uwagę wszystkie obiekty niezależnie od ich generowania, użyj wersji tej metody, która nie przyjmuje żadnych parametrów.  
  
 Aby moduł zbierający elementy bezużyteczne odzyskać obiektów do określonej generacji obiektów, użyj <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> przeciążenie metody. Po określeniu generacji maksymalną wszystkie obiekty są zbierane.  
  
   
  
## Examples  
 Poniższy przykład wymusza wyrzucania obiektów generacji 2 z <xref:System.GCCollectionMode.Optimized> ustawienie.  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> nie jest prawidłowy.  
  
 —lub—  
  
 <paramref name="mode" /> nie jest jednym z <see cref="T:System.GCCollectionMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">Liczba najstarsze generowania być bezużytecznych.</param>
        <param name="mode">Wartość wyliczenia, który określa, czy będzie zmuszony wyrzucanie elementów bezużytecznych (<see cref="F:System.GCCollectionMode.Default" /> lub <see cref="F:System.GCCollectionMode.Forced" />) lub zoptymalizowany (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          <see langword="true" /> Aby wykonać blokowania wyrzucanie elementów bezużytecznych; <see langword="false" /> można wykonać odzyskiwanie pamięci w tle, gdy jest to możliwe.</param>
        <summary>Wyrzucanie elementów bezużytecznych z generacji 0 za pomocą określonej generacji w czasie określonym przez wymusza <see cref="T:System.GCCollectionMode" /> wartość określająca, czy należy blokować kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono interakcje z `mode` i `blocking` parametry:  
  
|`mode`|`blocking` jest `true`|`blocking` jest `false`|  
|-|-|-|  
|<xref:System.GCCollectionMode.Forced> lub <xref:System.GCCollectionMode.Default>|Blokowanie kolekcji jest wykonywane tak szybko, jak to możliwe. Jeśli pamięci w tle jest w toku i `generation` jest równa 0 lub 1, <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> metoda natychmiast wyzwala blokowania kolekcji i zwraca po zakończeniu kolekcji. Jeśli pamięci w tle jest w toku i `generation` 2, czeka metody do momentu pamięci w tle została zakończona, wyzwala blokowania kolekcji generacji 2, a następnie zwraca.|Kolekcja jest wykonywane tak szybko, jak to możliwe. <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> Metoda żąda pamięci w tle, ale nie gwarantuje; w pewnych okolicznościach blokowania kolekcji nadal może być wykonana. Jeśli pamięci w tle jest już w toku, metoda zwraca natychmiast.|  
|<xref:System.GCCollectionMode.Optimized>|Blokowanie kolekcji może być wykonana, w zależności od stanu modułu zbierającego elementy bezużyteczne i `generation` parametru. Moduł zbierający elementy bezużyteczne próbuje zapewnić optymalną wydajność.|Kolekcja może być wykonana, w zależności od stanu moduł garbage collector. <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> Metoda żąda pamięci w tle, ale nie gwarantuje; w pewnych okolicznościach blokowania kolekcji nadal może być wykonana. Moduł zbierający elementy bezużyteczne próbuje zapewnić optymalną wydajność. Jeśli pamięci w tle jest już w toku, metoda zwraca natychmiast.|  
  
 Jeśli wywołanie <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> metoda przeprowadza pełne blokowania wyrzucanie elementów bezużytecznych, można również compact sterty dużego obiektu przez ustawienie <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> właściwości <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> przed wywołaniem <xref:System.GC.Collect%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> nie jest prawidłowy.  
  
 —lub—  
  
 <paramref name="mode" /> nie jest jednym z <see cref="T:System.GCCollectionMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">Liczba najstarsze generowania być bezużytecznych.</param>
        <param name="mode">Wartość wyliczenia, który określa, czy będzie zmuszony wyrzucanie elementów bezużytecznych (<see cref="F:System.GCCollectionMode.Default" /> lub <see cref="F:System.GCCollectionMode.Forced" />) lub zoptymalizowany (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          <see langword="true" /> Aby wykonać blokowania wyrzucanie elementów bezużytecznych; <see langword="false" /> można wykonać odzyskiwanie pamięci w tle, gdy jest to możliwe.</param>
        <param name="compacting">
          <see langword="true" /> Aby skompaktować sterty małego obiektu; <see langword="false" /> do odchylenia tylko.</param>
        <summary>Wyrzucanie elementów bezużytecznych z generacji 0 za pomocą określonej generacji w czasie określonym przez wymusza <see cref="T:System.GCCollectionMode" /> wartość z wartościami, które określają, czy blokowanie i kompaktowanie kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `blocking` jest `false`, wykaz Globalny decyduje o tym, czy ma być przeprowadzane tło lub blokowania wyrzucania elementów bezużytecznych. Jeśli `compacting` jest `true`, wykonuje blokowania wyrzucania elementów bezużytecznych.  
  
 Jeśli `compacting` jest `true`, środowisko uruchomieniowe kompaktuje sterty małego obiektu (raportu o kondycji). Sterty dużego obiektu (LOH) nie jest kompaktowanie, chyba że <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> właściwość jest ustawiona na <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>. Należy pamiętać, że obejmuje wszystkie blokujące wyrzucania, nie tylko pełna blokuje wyrzucania.  
  
 Możesz wywołać <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> metodę, aby zmniejszyć sterty zarządzanej najmniejszą możliwą rozmiar, jak pokazano w poniższy fragment kodu.  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 Określanie `true` dla `compacting` argument gwarantuje kompaktowanie, pełną blokowania wyrzucania elementów bezużytecznych. Ustawienie <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> właściwości <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> zapewnia kompaktowanie LOH i raportu o kondycji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">Generowanie obiektów, dla których ma można określić liczbę kolekcji pamięci.</param>
        <summary>Zwraca liczbę razy wystąpienia dla określonej generacji obiektów wyrzucanie elementów bezużytecznych.</summary>
        <returns>Ile razy wyrzucanie elementów bezużytecznych wystąpił dla określonej generacji od momentu uruchomienia procesu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku zastosowania zarządzania własnych zasobów, konieczne może być okresowo wymusić wyrzucanie elementów bezużytecznych przez wywołanie metody <xref:System.GC.Collect%2A> metody. Ponieważ jest to kosztowna operacja, może poprawić wydajność przez pominięcie wywołania, gdy wystąpił ostatnio wyrzucania elementów bezużytecznych. Zapisz wartość zwrócona przez <xref:System.GC.CollectionCount%2A> natychmiast po wywołaniu <xref:System.GC.Collect%2A>. Przy następnym należy wywołać <xref:System.GC.Collect%2A>, porównanie bieżącej wartości zwracane przez <xref:System.GC.CollectionCount%2A> zapisanych wartości. Jeśli dwie wartości są równe, żadna kolekcja nie wystąpił w tymczasowych i można wywołać <xref:System.GC.Collect%2A> ponownie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się nie GC region opóźnienia tryb.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.EndNoGCRegion%2A> Metoda zgłasza <xref:System.InvalidOperationException> Jeśli moduł zbierający elementy bezużyteczne nie jest w trybie opóźnienia region nie GC. Dzieje się tak w dowolnej z następujących warunków:  
  
-   <xref:System.GC.TryStartNoGCRegion%2A> Nie wywołano metody wcześniej.  
  
-   Wywołanie <xref:System.GC.TryStartNoGCRegion%2A> metoda zwróciła `false`.  
  
-   Wywołanie <xref:System.GC.TryStartNoGCRegion%2A> metody zwrócił wyjątek.  
  
 Wyjątek dla żadnej z następujących powodów można zapobiec za pomocą kodu, takie jak następujące:  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Moduł zbierający elementy bezużyteczne nie jest w trybie opóźnienia region nie GC.  
  
 —lub—  
  
 Nie GC region opóźnienia trybu została zakończona wcześniej, ponieważ zostało wywołane wyrzucania elementów bezużytecznych.  
  
 —lub—  
  
 Alokacja pamięci przekracza wartość określoną w wywołaniu <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> metody.</exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca liczbę generacji bieżącego obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Generowanie informacje są pobierane dla obiekt.</param>
        <summary>Zwraca liczbę obecnej generacji określonego obiektu.</summary>
        <returns>Numer bieżącej generacji <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do określenia wieku obiektu, a następnie użyć tych informacji z <xref:System.GC.Collect%2A> metodę wymuszania moduł zbierający elementy bezużyteczne w celu zbierania obiektów w tej samej generacji. Na przykład użyć tej metody, jeśli masz zestaw obiektów, które są tworzone jako grupę i która stać się niedostępne w tym samym czasie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.GC.GetGeneration%2A> metodę, aby ustalić okres ważności obiektu. Przykład wykonuje następnie wyrzucania wyczyszczenia pamięci i porównać wstępnie i post kolekcji sumy pamięci w konsoli.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo">A <see cref="T:System.WeakReference" /> odwołujący się do obiektu docelowego, którego numer generacja zostanie określony.</param>
        <summary>Zwraca liczbę obecnej generacji docelowej określonej słabe odwołanie.</summary>
        <returns>Numer bieżącej generacji element docelowy <paramref name="wo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.GC.GetGeneration%2A> metodę, aby określić wiek obiektu słabe odwołanie.  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wyrzucanie elementów bezużytecznych została już wykonana na <paramref name="wo" />.</exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">
          <see langword="true" /> Aby wskazać, że ta metoda może oczekiwać na wyrzucanie elementów bezużytecznych występuje przed zwróceniem; w przeciwnym razie <see langword="false" />.</param>
        <summary>Pobiera liczbę bajtów obecnie traktować do przydzielenia. Parametr wskazuje, czy ta metoda może czekać przez krótki czas przed zwróceniem, aby zezwolić na zbieranie pamięci i finalize obiektów przez system.</summary>
        <returns>Liczba, która jest dostępna najlepiej zbliżenie liczba bajtów przydzielonych aktualnie w pamięci zarządzanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `forceFullCollection` parametr jest `true`, ta metoda oczekuje przez krótki czas przed zwróceniem systemu zbiera pamięci i kończenie obiektów znajdujących się w. Czas trwania interwału jest wewnętrznie określonego limitu ustaleniami liczby cykli kolekcji garbage ukończone i zmiany ilości pamięci odzyskana między cykle. Moduł zbierający elementy bezużyteczne nie gwarantuje zbieranych całej pamięci niedostępny.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.GC.GetTotalMemory%2A> metody get i wyświetlić liczbę bajtów przydzielone aktualnie w pamięci zarządzanej.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt ma dotyczyć odwołanie.</param>
        <summary>Odwołuje się do określonego obiektu, dzięki czemu jej wyrzucanie elementów bezużytecznych od początku bieżącego procedury do punktu, w którym ta metoda jest wywoływana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Celem <xref:System.GC.KeepAlive%2A> metodą jest zapewnienie istnienie odwołania do obiektu, który zagraża przedwcześnie zostanie odzyskana przez moduł garbage collector. Jest typowy scenariusz, w którym może się to zdarzyć, gdy istnieją żadnych odwołań do obiektu kodu zarządzanego lub dane, ale obiekt jest nadal używane za pomocą kodu niezarządzanego, takich jak interfejsów API Win32, niezarządzanych bibliotek DLL, lub metody za pomocą modelu COM.  
  
 Odwołuje się do tej metody `obj` parametru wprowadzania tego obiektu za wyrzucanie elementów bezużytecznych od początku procedury do punktu, w kolejności wykonania, gdy ta metoda jest wywoływana. Kod tej metody na końcu nie początek zakresu instrukcji gdzie `obj` muszą być dostępne.  
  
 <xref:System.GC.KeepAlive%2A> Metoda wykonuje żadnych operacji i daje żadnych efektów ubocznych innego niż rozszerzenia okresu istnienia obiektu przekazany jako parametr.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy obiekt na początku jego `Main` metody i nie odwołuje się do obiektu ponownie aż do zakończenia, gdy <xref:System.GC.KeepAlive%2A> metoda jest wywoływana. Obiekt będzie się powtarzać, czas trwania 30 sekund `Main` metody, niezależnie od wywołania <xref:System.GC.Collect%2A> i <xref:System.GC.WaitForPendingFinalizers%2A> metody.  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną liczbę generacji, które obecnie obsługuje system.</summary>
        <value>Wartość w zakresie od zera do maksymalnej liczby obsługiwanych pokoleń.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generowanie liczby lub wieku obiektu jest zdefiniowane w implementacji względną miarę cykl życia obiektów. Niedawno przez obiekty są podczas generowania 0 i obiektów najstarsze w generacji mniejsze niż generowanie zwróconych przez <xref:System.GC.MaxGeneration%2A> właściwości.  
  
 Moduł zbierający elementy bezużyteczne zakłada, że częściej na kwalifikować się do pamięci niż pamięci starsze nowszej pamięci. W związku z tym moduł garbage collector zwiększa jego wydajność, dostosowując numery generowania zawsze zwraca go pamięci, i <xref:System.GC.MaxGeneration%2A> wartości właściwości mogą rosnąć wraz z upływem czasu.  
  
 Jeśli zaimplementowano przedawnienia obiektu, <xref:System.GC.MaxGeneration%2A> właściwość zwraca liczbę maksymalną generowania używaną przez system; w przeciwnym razie ta właściwość zwraca zero.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia właściwości MaxGeneration do wyświetlenia generowania największego aktualnie w użyciu.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Dla tej implementacji wartość zwracana przez <see cref="P:System.GC.MaxGeneration" /> właściwości jest gwarantowana pozostaje stała aplikację wykonującego przez czas ich istnienia.  
  
 Użyj <see cref="P:System.GC.MaxGeneration" /> właściwości, aby określić maksymalną wartość można określić podczas wywoływania metody <see cref="M:System.GC.Collect(System.Int32)" /> metody pobierającej parametr generacji.</para>
        </block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">Liczbą z zakresu od 1 do 99 określająca, kiedy powiadomienie zostanie zgłoszony oparte na obiekty przydzielone w generacji 2.</param>
        <param name="largeObjectHeapThreshold">Liczbą z zakresu od 1 do 99 określająca, kiedy powiadomienie zostanie zgłoszony oparte na obiekty przydzielone na stercie dużego obiektu.</param>
        <summary>Określa, czy powiadomienie kolekcji odzyskiwanie powinien być wywoływany, gdy warunki Preferuj pełnego wyrzucania elementów bezużytecznych i po zakończeniu zbierania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla każdej generacji modułu zbierającego elementy bezużyteczne ustawia próg alokacji w tej generacji. Jeśli rozmiar alokacji przekracza wartość progu, wyrzucanie elementów bezużytecznych jest wyzwalane na tej generacji. Na przykład, jeśli próg generacji 2 jest 20MB (co oznacza, że 20MB przeżyje generacji 1 i jest podwyższany do generacji 2) i ponad 20MB ma udało przetrwać generacji 1 i jest monitowany w generacji 2, zostanie podjęta próba dalej wyrzucanie elementów bezużytecznych jako kolekcja generacji 2. Podobnie jeśli sterty dużego obiektu (LOH) próg wynosi 20MB i aplikacji została przydzielona więcej niż 20MB pamięci dużych obiektów, dalej wyrzucanie elementów bezużytecznych zostanie również podjęta jako kolekcja generacji 2 (ponieważ LOH są zbierane w gen2 wyrzucania).  
  
 `maxGenerationThreshold` i `largeObjectHeapThreshold` progi sterowania ile wcześniej otrzymasz powiadomienie, zanim nastąpi jego pełnego wyrzucania elementów bezużytecznych. Im większa wartość progową, więcej przydziałów, które mogą wystąpić między powiadomień i dalej pełnego wyrzucania elementów bezużytecznych.  
  
 Jeśli masz sytuacje, w których pełnego wyrzucania elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego wpłynie niekorzystnie wydajności aplikacji, poproś powiadomienie, gdy środowisko wykonawcze ma pełne wyrzucania elementów bezużytecznych i obejście tej kolekcji przez wywołania kolekcji samodzielnie (przy użyciu <xref:System.GC.Collect%2A> metody) Jeśli warunki są nadal pozytywnych. Oprócz zmiana harmonogramu kolekcji garbage samodzielnie, pełną powiadomień GC jest przydatne w następujących scenariuszach:  
  
-   Monitor wykrywający podejście pełnego wyrzucania elementów bezużytecznych i po wyświetleniu powiadomienia, że jeden zbliża się do, Zmniejsz rozmiar danych na żywo (na przykład przez wydanie niektóre wpisy w pamięci podręcznej). W związku z tym gdy wyrzucania, jest w stanie odzyskać więcej pamięci.  
  
-   Monitorowanie zakończenia pełnego wyrzucania elementów bezużytecznych i tak, aby zebrać statystykami.  Na przykład można mierzyć rozmiar sterty po zakończeniu operacji GC, aby poinformować rozmiar danych na żywo. (Po pełną operacją GC sterty jest na najmniejszy).  
  
 Aby uzyskać więcej informacji na temat co reprezentuje pełnego wyrzucania elementów bezużytecznych, zobacz [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md).  
  
 Podczas rejestrowania dla powiadomień kolekcji pamięci można powiadamianych gdy zbliża się do pełnego wyrzucania elementów bezużytecznych i po jego ukończeniu. Ten wzorzec jest podobny jak monitoruje systemu operacyjnego dla powiadomień o małej ilości pamięci.  
  
 Skorzystaj z poniższych wskazówek dotyczących określania `maxGenerationThreshold` i `largeObjectHeapThreshold` parametry:  
  
-   Im większa wartość progowa, nastąpi więcej alokacji między powiadomienia i pełnego wyrzucania elementów bezużytecznych.  
  
     Wyższa wartość progowa zapewnia dodatkowe możliwości środowiska uruchomieniowego wyszukać o kolekcji. Zwiększa prawdopodobieństwo, że użytkownik zostanie powiadomiony. Nie należy jednak ustawić zbyt wysoki próg, ponieważ powoduje w alokacjach więcej przed środowiska uruchomieniowego wywołuje dalej kolekcji.  
  
     Jeśli należy wywołać kolekcji samodzielnie na powiadomienia za pomocą wartość progowa, mniejszą liczbę obiektów odzyskane nie będzie można odzyskać przy następnej kolekcji środowiska uruchomieniowego.  
  
-   Niższa wartość progowa, mniejszej liczby przydziałów między powiadomień i pełnego wyrzucania elementów bezużytecznych.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak do rejestracji powiadomień kolekcji pamięci i rozpocząć wątku do monitorowania stanu powiadomienia kolekcji pamięci. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md) tematu.  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxGenerationThreshold" /> lub <paramref name="largeObjectHeapThreshold" /> nie jest od 1 do 99.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Ilość niezarządzanej pamięci, który został zwolniony.</param>
        <summary>Informuje o środowiska uruchomieniowego zwolnienie niezarządzanych pamięci i nie musi już być brana pod uwagę podczas planowania wyrzucanie elementów bezużytecznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy określaniu, kiedy należy zaplanować wyrzucanie elementów bezużytecznych, środowisko uruchomieniowe bierze pod uwagę ilość pamięci zarządzanej został przydzielony. Małego obiektu zarządzanego przydziela dużej ilości pamięci niezarządzane, środowisko uruchomieniowe uwzględnia pamięci zarządzanej, a w związku z tym szacuje zbyt nisko pilność planowania wyrzucanie elementów bezużytecznych. <xref:System.GC.AddMemoryPressure%2A> Metody informuje środowiska uruchomieniowego tej dodatkowe wykorzystania pamięci systemu i <xref:System.GC.RemoveMemoryPressure%2A> metody informuje środowiska uruchomieniowego wykorzystania dodatkowe opublikowane.  
  
 We wzorcu najprostszy sposób użycia obiektu zarządzanego przydziela pamięć niezarządzanych w Konstruktorze i zwolnieniem w `Dispose` lub `Finalize` metody. Wywołanie <xref:System.GC.AddMemoryPressure%2A> metody po przydzieleniu niezarządzanej pamięci i Wywołaj <xref:System.GC.RemoveMemoryPressure%2A> metody po jego zwolnienia.  
  
 W bardziej złożonych zadań, w których alokacji pamięci niezarządzanej znacznie zmieni się przez cały okres istnienia obiektu zarządzanego, można wywołać <xref:System.GC.AddMemoryPressure%2A> i <xref:System.GC.RemoveMemoryPressure%2A> metody do komunikowania się te zmiany przyrostowe do środowiska wykonawczego.  
  
> [!CAUTION]
>  Należy się upewnić, usunięcie dokładnie ilość wykorzystania dodane. Niepowodzenie w tym przypadku może niekorzystnie wpłynąć na wydajność systemu w aplikacjach wykonywanych przez dłuższy czas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> jest mniejsze niż lub równa 0.  
  
 —lub—  
  
 Na komputerze 32-bitowym <paramref name="bytesAllocated" /> jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływanie kodu niezarządzanego podczas manipulacji priorytet wyrzucanie elementów bezużytecznych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Finalizator musi zostać wywołana dla obiekt.</param>
        <summary>Żąda system wywołać finalizatora dla określonego obiektu, dla którego <see cref="M:System.GC.SuppressFinalize(System.Object)" /> wcześniej została wywołana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.ReRegisterForFinalize%2A> Dodaje metody `obj` parametru do listy obiektów żądających finalizacji przed moduł garbage collector zwolnienia obiektu. `obj` Parametr musi być wywołujący tę metodę.  
  
 Wywoływanie <xref:System.GC.ReRegisterForFinalize%2A> — metoda nie gwarantuje, że moduł zbierający elementy bezużyteczne wywoła finalizatora obiektu.  
  
 Domyślnie wszystkie obiekty, które implementują finalizatory są dodawane do listy obiektów, które wymagają finalizacji; Jednak obiekt może mieć już sfinalizowany lub mógł wyłączyć finalizacji przez wywołanie metody <xref:System.GC.SuppressFinalize%2A> metody.  
  
 Finalizator ta metoda służy do przywracania aktywności siebie lub obiektu, do której się odwołuje.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia metody ReRegisterForFinalize w celu sfinalizowania obiektu drugi czasu po wyrzucanie elementów bezużytecznych.  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, którego finalizatora nie musi zostać wykonana.</param>
        <summary>Żądania, że środowisko uruchomieniowe języka wspólnego nie wywołać finalizatora dla określonego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nieco ustawia w nagłówku obiektu `obj`, która sprawdza środowiska uruchomieniowego podczas wywoływania metody finalizatory. Finalizator, która jest reprezentowana przez <xref:System.Object.Finalize%2A?displayProperty=nameWithType> służy metody, aby zwolnić zasoby niezarządzane przed zbierane pamięci jest obiekt. Jeśli `obj` nie ma finalizator, wywołanie <xref:System.GC.SuppressFinalize%2A> — metoda nie ma wpływu.  
  
 Obiekty, które implementują <xref:System.IDisposable> interfejsu można wywołać tej metody z obiektu <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji zapobiegające moduł garbage collector wywołania <xref:System.Object.Finalize%2A?displayProperty=nameWithType> na obiekcie, który nie jest wymagane. Zwykle odbywa finalizator uniemożliwić zwalniania niezarządzanych zasobów, które już została zwolniona przez <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.GC.SuppressFinalize%2A> metodę w klasie zasobu, aby zapobiec nadmiarowe wyrzucania elementów bezużytecznych z wywoływane. W przykładzie użyto [wzorzec dispose](~/docs/standard/design-guidelines/dispose-pattern.md) zarówno zwolnienia zarządzanych zasobów (czyli obiekty, które implementują <xref:System.IDisposable>) i niezarządzanych zasobów.  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżkę krytyczną prób.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, a powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko uruchomieniowe jest w trybie opóźnienia region nie GC. Innymi słowy, nie powinien wywołania <xref:System.GC.TryStartNoGCRegion%2A> wielokrotnie (po pierwszym wywołaniu metody kolejnych wywołań nie powiedzie się), i nie należy oczekiwać wywołań <xref:System.GC.EndNoGCRegion%2A> do pomyślnego wyłącznie z powodu pierwsze wywołanie <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">Ilość pamięci w bajtach przydzielić bez wyzwalania wyrzucania elementów bezużytecznych. Musi być mniejsze lub równe rozmiarowi segmentu tymczasowych. Uzyskać informacji o rozmiar segmentu tymczasowych, zobacz sekcję "generacje tymczasowych i segmentów" w [podstawowe informacje dotyczące wyrzucania elementów bezużytecznych](~/docs/standard/garbage-collection/fundamentals.md) artykułu.</param>
        <summary>Próby nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżkę krytyczną, jeśli określona ilość pamięci jest dostępna.</summary>
        <returns>
          <see langword="true" /> Jeśli środowisko uruchomieniowe był w stanie przekazać wymagana ilość pamięci oraz moduł zbierający elementy bezużyteczne jest w stanie trybu nie GC region opóźnienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> Metoda próbuje umieścić modułu zbierającego elementy bezużyteczne w nie GC region opóźnienia tryb, który uniemożliwia wyrzucanie elementów bezużytecznych, gdy aplikacja wykonuje krytyczne region kodu.  Jeśli środowisko uruchomieniowe nie można wstępnie przydzielić żądanej ilości pamięci, moduł garbage collector wykonuje pełne blokowania wyrzucanie elementów bezużytecznych w celu zwolnienia dodatkowej pamięci. Moduł zbierający elementy bezużyteczne przechodzi nie GC regionu w trybie opóźnienia, jeśli jest w stanie przydzielić wymagana ilość pamięci, co w tym przypadku jest rzeczywiście 2 * `totalSize` bajtów (próbuje przydzielić `totalSize` bajtów dla sterty małego obiektu i `totalSize` bajtów dla sterty dużego obiektu).  
  
 `totalSize` musi być wystarczająco duży, aby obsłużyć wszystkie przydziału pamięci, które występują w ścieżce krytycznej. W tym przydziały przez aplikację, a także alokacje środowiska uruchomieniowego sprawia, że w imieniu aplikacji.  
  
> [!IMPORTANT]
>  Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, a powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko uruchomieniowe jest w trybie opóźnienia region nie GC. Innymi słowy, nie powinien wywołania <xref:System.GC.TryStartNoGCRegion%2A> wielokrotnie (po pierwszym wywołaniu metody kolejnych wywołań nie powiedzie się), i nie należy oczekiwać wywołań <xref:System.GC.EndNoGCRegion%2A> do pomyślnego wyłącznie z powodu pierwsze wywołanie <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.  
  
 Zakończ nie GC region opóźnienia tryb przez wywołanie metody <xref:System.GC.EndNoGCRegion%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> przekracza rozmiar segmentu tymczasowych.</exception>
        <exception cref="T:System.InvalidOperationException">Proces jest już w trybie opóźnienia region nie GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">Ilość pamięci w bajtach przydzielić bez wyzwalania wyrzucania elementów bezużytecznych. Musi być mniejsze lub równe rozmiarowi segmentu tymczasowych. Uzyskać informacji o rozmiar segmentu tymczasowych, zobacz sekcję "generacje tymczasowych i segmentów" w [podstawowe informacje dotyczące wyrzucania elementów bezużytecznych](~/docs/standard/garbage-collection/fundamentals.md) artykułu.</param>
        <param name="disallowFullBlockingGC">
          <see langword="true" /> Aby pominąć pełnego blokowania wyrzucanie elementów bezużytecznych, jeśli moduł zbierający elementy bezużyteczne jest początkowo nie można przydzielić <c>totalSize</c> bajtów; w przeciwnym razie <see langword="false" />.</param>
        <summary>Próbuje nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżkę krytyczną, jeśli określona ilość pamięci jest dostępny i kontrolek, czy moduł zbierający elementy bezużyteczne jest pełna blokowania wyrzucanie elementów bezużytecznych, jeśli nie wystarczającej ilości pamięci jest początkowo dostępna.</summary>
        <returns>
          <see langword="true" /> Jeśli środowisko uruchomieniowe był w stanie przekazać wymagana ilość pamięci oraz moduł zbierający elementy bezużyteczne jest w stanie trybu nie GC region opóźnienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> Metoda próbuje umieścić modułu zbierającego elementy bezużyteczne w nie GC region opóźnienia tryb, który uniemożliwia wyrzucanie elementów bezużytecznych, gdy aplikacja wykonuje krytyczne region kodu.  Jeśli nie można wstępnie przydzielić żądanej ilości pamięci jest środowisko uruchomieniowe i `disallowFullBlockingGC` argument jest `false`, moduł garbage collector wykonuje pełne blokowania wyrzucanie elementów bezużytecznych w celu zwolnienia dodatkowej pamięci; w przeciwnym przypadku alokacja nie powiedzie się i metoda zwraca `false`. Moduł zbierający elementy bezużyteczne przechodzi nie GC regionu w trybie opóźnienia, jeśli jest w stanie przydzielić wymagana ilość pamięci, co w tym przypadku jest rzeczywiście 2 * `totalSize` (próbuje przydzielić `totalSize` dla sterty małego obiektu i `totalSize` dla sterty dużego obiektu).  
  
 `totalSize` musi być wystarczająco duży, aby obsłużyć wszystkie przydziału pamięci, które występują w ścieżce krytycznej. W tym przydziały przez aplikację, a także alokacje środowiska uruchomieniowego sprawia, że w imieniu aplikacji.  
  
 Ustawienie `disallowFullBlockingGC` do `true` zapobiegające pełne odzyskiwanie blokowania kolekcji, jeśli nie ma wystarczającej ilości pamięci jest początkowo dostępna jest najbardziej przydatne w scenariuszach równoważenia obciążenia: jeden system można wywołać tę metodę i przedstawia się jako gotowy do akceptowania żądań, jeśli zwróci ona `true`, i mieć usługi równoważenia obciążenia, które przekierowują żądania do innych systemów, jeśli zwróci ona `false`. Go następnie wykonaj pełny blokowania wyrzucanie elementów bezużytecznych gdy go nie obsługuje żądań przez wywołanie metody <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> metody.  
  
> [!IMPORTANT]
>  Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, a powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko uruchomieniowe jest w trybie opóźnienia region nie GC. Innymi słowy, nie powinien wywołania <xref:System.GC.TryStartNoGCRegion%2A> wielokrotnie (po pierwszym wywołaniu metody kolejnych wywołań nie powiedzie się), i nie należy oczekiwać wywołań <xref:System.GC.EndNoGCRegion%2A> do pomyślnego wyłącznie z powodu pierwsze wywołanie <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.  
  
 Zakończ nie GC region opóźnienia tryb przez wywołanie metody <xref:System.GC.EndNoGCRegion%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> przekracza rozmiar segmentu tymczasowych.</exception>
        <exception cref="T:System.InvalidOperationException">Proces jest już w trybie opóźnienia region nie GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">Ilość pamięci w bajtach przydzielić bez wyzwalania wyrzucania elementów bezużytecznych. <c>totalSize</c> —<c>lohSize</c> musi być mniejszy niż rozmiar segmentu tymczasowych. Uzyskać informacji o rozmiar segmentu tymczasowych, zobacz sekcję "generacje tymczasowych i segmentów" w [podstawowe informacje dotyczące wyrzucania elementów bezużytecznych](~/docs/standard/garbage-collection/fundamentals.md) artykułu.</param>
        <param name="lohSize">Liczba bajtów w <c>totalSize</c> dla dużego obiektu Alokacje sterty (LOH).</param>
        <summary>Próby nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżkę krytyczną, jeśli określona ilość pamięci dostępnej dla sterty dużego obiektu i sterty małego obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli środowisko uruchomieniowe był w stanie przekazać wymagana ilość pamięci oraz moduł zbierający elementy bezużyteczne jest w stanie trybu nie GC region opóźnienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> Metoda próbuje umieścić modułu zbierającego elementy bezużyteczne w nie GC region opóźnienia tryb, który uniemożliwia wyrzucanie elementów bezużytecznych, gdy aplikacja wykonuje krytyczne region kodu.  Jeśli środowisko uruchomieniowe nie można wstępnie przydzielić żądanej ilości pamięci, moduł garbage collector wykonuje pełne blokowania wyrzucanie elementów bezużytecznych w celu zwolnienia dodatkowej pamięci. Moduł zbierający elementy bezużyteczne przechodzi nie GC regionu w trybie opóźnienia, jeśli jest w stanie przydzielić `lohSize` dla LOH i `totalSize` — `lohSize` dla sterty małego obiektu (raportu o kondycji).  
  
 `lohSize` musi być wystarczająco duży, aby obsłużyć wszystkie przydziału pamięci, które występują w ścieżkę krytyczną dla LOH, i `totalSize` — `lohSize` musi być wystarczająco duży, aby obsłużyć wszystkie przydziału pamięci, które występują w ścieżkę krytyczną dla raportu o kondycji. W tym przydziały przez aplikację, a także alokacje środowiska uruchomieniowego sprawia, że w imieniu aplikacji.  
  
> [!IMPORTANT]
>  Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, a powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko uruchomieniowe jest w trybie opóźnienia region nie GC. Innymi słowy, nie powinien wywołania <xref:System.GC.TryStartNoGCRegion%2A> wielokrotnie (po pierwszym wywołaniu metody kolejnych wywołań nie powiedzie się), i nie należy oczekiwać wywołań <xref:System.GC.EndNoGCRegion%2A> do pomyślnego wyłącznie z powodu pierwsze wywołanie <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.  
  
 Zakończ nie GC region opóźnienia tryb przez wywołanie metody <xref:System.GC.EndNoGCRegion%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> — <paramref name="lohSize" /> przekracza rozmiar segmentu tymczasowych.</exception>
        <exception cref="T:System.InvalidOperationException">Proces jest już w trybie opóźnienia region nie GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">Ilość pamięci w bajtach przydzielić bez wyzwalania wyrzucania elementów bezużytecznych. <c>totalSize</c> —<c>lohSize</c> musi być mniejszy niż rozmiar segmentu tymczasowych. Uzyskać informacji o rozmiar segmentu tymczasowych, zobacz sekcję "generacje tymczasowych i segmentów" w [podstawowe informacje dotyczące wyrzucania elementów bezużytecznych](~/docs/standard/garbage-collection/fundamentals.md) artykułu.</param>
        <param name="lohSize">Liczba bajtów w <c>totalSize</c> dla dużego obiektu Alokacje sterty (LOH).</param>
        <param name="disallowFullBlockingGC">
          <see langword="true" /> Aby pominąć pełnego blokowania wyrzucanie elementów bezużytecznych, jeśli moduł zbierający elementy bezużyteczne jest początkowo nie można przydzielić pamięci określony w sterty małego obiektu (raportu o kondycji) i LOH; w przeciwnym razie <see langword="false" />.</param>
        <summary>Próbuje nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżkę krytyczną, jeśli określoną ilość pamięci dostępnej dla sterty dużego obiektu i sterty małego obiektu i kontrolek, czy moduł zbierający elementy bezużyteczne jest pełna blokowania wyrzucanie elementów bezużytecznych, jeśli nie wystarczającej ilości pamięci jest początkowo dostępna.</summary>
        <returns>
          <see langword="true" /> Jeśli środowisko uruchomieniowe był w stanie przekazać wymagana ilość pamięci oraz moduł zbierający elementy bezużyteczne jest w stanie trybu nie GC region opóźnienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> Metoda próbuje umieścić modułu zbierającego elementy bezużyteczne w nie GC region opóźnienia tryb, który uniemożliwia wyrzucanie elementów bezużytecznych, gdy aplikacja wykonuje krytyczne region kodu.  Jeśli nie można wstępnie przydzielić żądanej ilości pamięci jest środowisko uruchomieniowe i `disallowFullBlockingGC` argument jest `false`, moduł garbage collector wykonuje pełne blokowania wyrzucanie elementów bezużytecznych w celu zwolnienia dodatkowej pamięci; w przeciwnym przypadku alokacja nie powiedzie się i metoda zwraca `false`. Moduł zbierający elementy bezużyteczne przechodzi nie GC regionu w trybie opóźnienia, jeśli jest w stanie przydzielić `lohSize` dla LOH i `totalSize` — `lohSize` dla sterty małego obiektu (raportu o kondycji).  
  
 `lohSize` musi być wystarczająco duży, aby obsłużyć wszystkie przydziału pamięci, które występują w ścieżkę krytyczną dla LOH, i `totalSize` — `lohSize` musi być wystarczająco duży, aby obsłużyć wszystkie przydziału pamięci, które występują w ścieżkę krytyczną dla raportu o kondycji. W tym przydziały przez aplikację, a także alokacje środowiska uruchomieniowego sprawia, że w imieniu aplikacji.  
  
 Ustawienie `disallowFullBlockingGC` do `true` zapobiegające pełne odzyskiwanie blokowania kolekcji, jeśli nie ma wystarczającej ilości pamięci jest początkowo dostępna jest najbardziej przydatne w scenariuszach równoważenia obciążenia: jeden system można wywołać tę metodę i przedstawia się jako gotowy do akceptowania żądań, jeśli zwróci ona `true`, i mieć usługi równoważenia obciążenia, które przekierowują żądania do innych systemów, jeśli zwróci ona `false`. Go następnie wykonaj pełny blokowania wyrzucanie elementów bezużytecznych gdy go nie obsługuje żądań przez wywołanie metody <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> metody.  
  
> [!IMPORTANT]
>  Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, a powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko uruchomieniowe jest w trybie opóźnienia region nie GC. Innymi słowy, nie powinien wywołania <xref:System.GC.TryStartNoGCRegion%2A> wielokrotnie (po pierwszym wywołaniu metody kolejnych wywołań nie powiedzie się), i nie należy oczekiwać wywołań <xref:System.GC.EndNoGCRegion%2A> do pomyślnego wyłącznie z powodu pierwsze wywołanie <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.  
  
 Zakończ nie GC region opóźnienia tryb przez wywołanie metody <xref:System.GC.EndNoGCRegion%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> — <paramref name="lohSize" /> przekracza rozmiar segmentu tymczasowych.</exception>
        <exception cref="T:System.InvalidOperationException">Proces jest już w trybie opóźnienia region nie GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca informacje o stanie zarejestrowanych powiadomień do określania, czy bezpośrednie jest pełny, blokowanie odzyskiwania pamięci przez środowisko uruchomieniowe języka wspólnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca informacje o stanie zarejestrowanych powiadomień do określania, czy bezpośrednie jest pełny, blokowanie odzyskiwania pamięci przez środowisko uruchomieniowe języka wspólnego.</summary>
        <returns>Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.GCNotificationStatus> wyliczenie zwrócona przez tę metodę, aby określić stan bieżący powiadomienia kolekcji pamięci, który został zarejestrowany za pomocą <xref:System.GC.RegisterForFullGCNotification%2A> metody. Można również użyć <xref:System.GC.WaitForFullGCComplete%2A> metodę, aby określić, czy pełnego wyrzucania elementów bezużytecznych została ukończona.  
  
 Podczas wyliczania zwraca <xref:System.GCNotificationStatus.Succeeded>, mogą wykonywać zadania, takie jak uniemożliwia dodatkowe obiekty przydzielane i wywołania samodzielnie kolekcji z <xref:System.GC.Collect%2A> metody. Należy pamiętać, że powiadomienia nie gwarantuje, że pełnego wyrzucania elementów bezużytecznych nastąpi, tylko że warunków Osiągnięto próg są korzystna dla pełnego wyrzucania elementów bezużytecznych występuje.  
  
 Ta metoda oczekuje nieskończoność powiadomienia kolekcji pamięci można uzyskać. Jeśli chcesz określić limit czasu dla metody do zwrócenia, jeśli nie można uzyskać powiadomienia, użyj <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> przeciążenie metody. Jeśli ta metoda jest wywoływana bez określania limit czasu, można wywołać <xref:System.GC.CancelFullGCNotification%2A> metodę, jeśli oczekujesz dłużej niż preferowany.  
  
 Należy stosować tej metody za pomocą wywołania <xref:System.GC.WaitForFullGCComplete%2A> metody, aby upewnić się, że wystąpiły pełnego wyrzucania elementów bezużytecznych. Wywołanie tej metody tylko powoduje, że wyniki nieokreślony.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać tej metody w celu określenia, czy zbliża się do pełnego, blokowanie odzyskiwania pamięci. Zawsze, gdy jest w stanie powiadomienia <xref:System.GCNotificationStatus.Succeeded>, metoda użytkownika `OnFullGCApproachNotify` jest wywoływana w celu wykonania akcji w odpowiedzi na o kolekcji. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md) tematu.  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Długość czasu oczekiwania można uzyskać stanu powiadomienia. Określ wartość -1 będzie czekać w nieskończoność.</param>
        <summary>Zwraca określony przekroczył limit czasu, stan zarejestrowanych powiadomień do określania, czy bezpośrednie jest pełny, blokowanie odzyskiwania pamięci przez środowisko uruchomieniowe języka wspólnego.</summary>
        <returns>Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.GCNotificationStatus> wyliczenie zwrócona przez tę metodę, aby określić stan bieżący powiadomienia kolekcji pamięci, który został zarejestrowany za pomocą <xref:System.GC.RegisterForFullGCNotification%2A> metody. Można również użyć <xref:System.GC.WaitForFullGCComplete%2A> metodę, aby określić, czy pełnego wyrzucania elementów bezużytecznych została ukończona.  
  
 Należy pamiętać, że ta metoda zwraca natychmiast po każdej zmianie uzyskany stan powiadomień kolekcji pamięci, niezależnie od wartości określonej przez `millisecondsTimeout`. Jeśli stan powiadomień kolekcji pamięci nie są uzyskiwane przed `millisecondsTimeout` razy, ta metoda zwraca <xref:System.GCNotificationStatus.NotApplicable>.  
  
 Podczas wyliczania zwraca <xref:System.GCNotificationStatus.Succeeded>, mogą wykonywać zadania, takie jak uniemożliwia dodatkowe obiekty przydzielane i wywołania samodzielnie kolekcji z <xref:System.GC.Collect%2A> metody. Należy pamiętać, że powiadomienia nie gwarantuje, że pełnego wyrzucania elementów bezużytecznych nastąpi, tylko że warunków Osiągnięto próg są korzystna dla pełnego wyrzucania elementów bezużytecznych występuje.  
  
 Możesz wywołać <xref:System.GC.CancelFullGCNotification%2A> metody, gdy nie może czekać na limit czasu oczekiwania.  
  
 Należy stosować tej metody za pomocą wywołania <xref:System.GC.WaitForFullGCComplete%2A> metody, aby upewnić się, że wystąpiły pełnego wyrzucania elementów bezużytecznych. Wywołanie tej metody tylko powoduje, że wyniki nieokreślony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> musi być nieujemna albo mniejsza lub równa <see cref="F:System.Int32.MaxValue" /> lub wartość -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca informacje o stanie zarejestrowanych powiadomień do określania, czy pełne, blokowanie odzyskiwania pamięci przez środowisko uruchomieniowe języka wspólnego została ukończona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca informacje o stanie zarejestrowanych powiadomień do określania, czy pełne, blokowanie odzyskiwania pamięci przez środowisko uruchomieniowe języka wspólnego została ukończona.</summary>
        <returns>Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.GCNotificationStatus> wyliczenie zwrócona przez tę metodę, aby określić stan bieżący powiadomienia kolekcji pamięci, który został zarejestrowany za pomocą <xref:System.GC.RegisterForFullGCNotification%2A> metody. Można również użyć <xref:System.GC.WaitForFullGCApproach%2A> metodę, aby określić, czy pełnego wyrzucania elementów bezużytecznych jest bezpośrednie.  
  
 Podczas wyliczania zwraca <xref:System.GCNotificationStatus.Succeeded>, mogą wykonywać zadania, takie jak wznawiania pracy oraz uzyskania liczbę kolekcji, za pomocą <xref:System.GC.CollectionCount%2A> właściwości.  
  
 Ta metoda oczekuje nieskończoność powiadomienia kolekcji pamięci można uzyskać. Jeśli chcesz określić limit czasu dla metody do zwrócenia, jeśli nie można uzyskać powiadomienia, użyj <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> przeciążenie metody. Jeśli ta metoda jest wywoływana bez określania limit czasu, można wywołać <xref:System.GC.CancelFullGCNotification%2A> metodę, jeśli oczekujesz dłużej niż preferowany.  
  
 Wywołanie tej metody powinien zostać poprzedzony literą wywołanie <xref:System.GC.WaitForFullGCApproach%2A> metody, aby upewnić się, że wystąpiły pełnego wyrzucania elementów bezużytecznych. Wywołanie tej metody tylko może wygenerować wyniki nieokreślony.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać tej metody w celu określenia, czy pełnego wyrzucania elementów bezużytecznych została ukończona. Zawsze, gdy jest w stanie powiadomienia <xref:System.GCNotificationStatus.Succeeded>, metoda użytkownika `OnFullGCCompletedNotify` jest wywoływana w celu wykonania akcji w odpowiedzi na kolekcji ukończone. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md) tematu.  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Długość czasu oczekiwania można uzyskać stanu powiadomienia. Określ wartość -1 będzie czekać w nieskończoność.</param>
        <summary>Zwraca określony przekroczył limit czasu, stan zarejestrowanych powiadomień do określania, czy jest pełne blokowanie odzyskiwania pamięci przez środowisko uruchomieniowe języka wspólnego została ukończona.</summary>
        <returns>Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.GCNotificationStatus> wyliczenie zwrócona przez tę metodę, aby określić stan bieżący powiadomienia kolekcji pamięci, który został zarejestrowany za pomocą <xref:System.GC.RegisterForFullGCNotification%2A> metody. Można również użyć <xref:System.GC.WaitForFullGCApproach%2A> metodę, aby określić, czy pełnego wyrzucania elementów bezużytecznych jest bezpośrednie.  
  
 Należy pamiętać, że ta metoda zwraca natychmiast po każdej zmianie uzyskany stan powiadomień kolekcji pamięci, niezależnie od wartości określonej przez `millisecondsTimeout`. Jeśli stan powiadomień kolekcji pamięci nie są uzyskiwane przed `millisecondsTimeout` razy, ta metoda zwraca <xref:System.GCNotificationStatus.NotApplicable>.  
  
 Podczas wyliczania zwraca <xref:System.GCNotificationStatus.Succeeded>, mogą wykonywać zadania, takie jak wznawiania pracy oraz uzyskania liczbę kolekcji, za pomocą <xref:System.GC.CollectionCount%2A> właściwości.  
  
 Możesz wywołać <xref:System.GC.CancelFullGCNotification%2A> metody, gdy nie może czekać na limit czasu oczekiwania.  
  
 Wywołanie tej metody powinien zostać poprzedzony literą wywołanie <xref:System.GC.WaitForFullGCApproach%2A> metody, aby upewnić się, że wystąpiły pełnego wyrzucania elementów bezużytecznych. Wywołanie tej metody tylko może wygenerować wyniki nieokreślony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="millisecondsTimeout" /> musi być nieujemna albo mniejsza lub równa <see cref="F:System.Int32.MaxValue" /> lub wartość -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstrzymuje bieżącego wątku, aż do chwili wątku, który przetwarza kolejki finalizatory ma opróżnienia tej kolejki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli moduł zbierający elementy bezużyteczne znajdzie obiektów, które można odzyskać, sprawdza każdy obiekt, aby ustalić wymagania finalizacji obiektu. Jeśli obiekt implementuje finalizator i finalizacji nie została wyłączona przez wywołanie metody <xref:System.GC.SuppressFinalize%2A>, obiekt znajduje się na liście obiektów, które są oznaczone jako gotowe do finalizacji. Wywołania modułu zbierającego elementy bezużyteczne <xref:System.Object.Finalize%2A> metod dla obiektów w tym listy i usuwa wpisy z listy. Ten bloki metody do wszystkich finalizatory uruchomiono do zakończenia.  
  
 Wątek, na którym są uruchamiane finalizatory jest nieokreślony, więc nie ma gwarancji, że ta metoda zostanie zakończona. Jednak ten wątek może przerwane przez inny wątek podczas <xref:System.GC.WaitForPendingFinalizers%2A> metody jest w toku. Na przykład można uruchomić inny wątek oczekuje na pewien czas, który następnie przerwań tego wątku, jeśli ten wątek nadal jest wstrzymana.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.GC.WaitForPendingFinalizers%2A> metody wstrzymania bieżący wątek, do czasu ukończenia finalizacji zebranych obiektów.  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
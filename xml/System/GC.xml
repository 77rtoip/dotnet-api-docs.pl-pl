<Type Name="GC" FullName="System.GC">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="df6c8515f979bac3eb8e948b4bb6025a6577640e" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37481429" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Określa moduł zbierający elementy bezużyteczne systemu to usługa, która automatycznie odzyskuje nieużywanej pamięci.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł odśmiecania pamięci jest wspólnego składnika środowiska uruchomieniowego języka, który kontroluje przydzielaniem i zwalnianiem pamięci zarządzanej. Metody tej klasy wpływ podczas wyrzucania elementów bezużytecznych jest wykonywane na obiekcie i są wydawane zasoby przydzielone przez obiekt. Właściwości tej klasy zawierają informacje o całkowitej ilości dostępnej pamięci w systemie i wiek, kategorii lub generowania ilość pamięci przydzielona do obiektu.  
  
 Wyrzucanie elementów bezużytecznych śledzi i ponownie wzywa obiekty przydzielone w pamięci zarządzanej. Okresowo moduł zbierający elementy bezużyteczne wykonuje wyrzucanie elementów bezużytecznych w celu odzyskania pamięci przydzielonej do obiektów, dla których nie istnieją żadne prawidłowe odwołania. Wyrzucanie elementów bezużytecznych odbywa się automatycznie, gdy żądanie pamięci nie mogą być spełnione przy użyciu dostępnej wolnej pamięci. Alternatywnie, aplikację można wymusić przy użyciu kolekcji wyrzucania elementów <xref:System.GC.Collect%2A> metody.  
  
 Wyrzucanie elementów bezużytecznych składa się z następujących czynności:  
  
1.  Moduł zbierający elementy bezużyteczne wyszukuje zarządzanych obiektów, do których istnieją odwołania w kodzie zarządzanym.  
  
2.  Moduł zbierający elementy bezużyteczne próbuje zakończyć obiektów, które nie są wywoływane.  
  
3.  Moduł zbierający elementy bezużyteczne zwalnia obiektów, które nie są wywoływane i odzyskuje ich pamięci.  
  
 Ten temat zawiera następujące sekcje:  
  
 [Moduł odśmiecania pamięci i zasobów niezarządzanych](#unmanaged)   
 [Obiekt przedawnienia i generacji](#generations)   
 [Nie można przydzielać wyrzucania elementów bezużytecznych](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a>Moduł odśmiecania pamięci i zasobów niezarządzanych  
 Podczas wyrzucania moduł odśmiecania pamięci nie zwolni obiektu, jeśli znajdzie jedno lub więcej odwołań do obiektu w kodzie zarządzanym. Jednak moduł odśmiecania pamięci nie może rozpoznać odwołania do obiektu z niezarządzanego kodu i mogą zwalniać obiekty, które są używane wyłącznie w przypadku kodu niezarządzanego, chyba że jawnie zabronione w myśl. <xref:System.GC.KeepAlive%2A> Metoda zapewnia mechanizm, który uniemożliwia zbieranie obiektów, które są nadal używane w niezarządzanym kodzie moduł odśmiecania pamięci.  
  
 Oprócz alokacje pamięci zarządzanej implementacji modułu odśmiecania pamięci nie zachowują informacje o zasobach w posiadaniu obiektu, takie jak dojścia do plików lub połączenia z bazą danych. Gdy typ używa niezarządzane zasoby, które muszą zostać zwolnione wystąpienia tego typu są odzyskiwane, typ może implementować finalizatora.  
  
 W większości przypadków finalizatory są implementowane przez zastąpienie <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody; jednak typów napisane w języku C# lub C++ implementuje destruktory, w których kompilatory przekształcić w zastąpieniu obiektu <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. W większości przypadków Jeśli obiekt ma finalizatora, moduł odśmiecania pamięci wywołuje on przed zwalnianie obiektu. Jednak moduł odśmiecania pamięci nie jest wymagane do wywołania finalizatory we wszystkich sytuacjach; na przykład <xref:System.GC.SuppressFinalize%2A> metoda jawnie zapobiega finalizatora obiektu wywoływana. Ponadto moduł odśmiecania pamięci nie jest wymagany na potrzeby określonego wątku finalize obiektów lub gwarantuje kolejności, w którym finalizatory są nazywane dla obiektów, które zależą od siebie, ale w przeciwnym razie są dostępne do wyrzucania elementów bezużytecznych.  
  
 W scenariuszach, w którym zasoby muszą zostać zwolnione w taki sposób, w określonym czasie, można zaimplementować klasy <xref:System.IDisposable> interfejs, który zawiera <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodę, która wykonuje zadania zarządzania i czyszczenie zasobów. Klasy, które implementują <xref:System.IDisposable.Dispose%2A> należy określić, w ramach umowy klasy, jeśli klasa konsumentów wywołania metody w celu oczyszczenia obiektu. Moduł zbierający elementy bezużyteczne, domyślnie niewywołujący <xref:System.IDisposable.Dispose%2A> metoda; jednak implementacje <xref:System.IDisposable.Dispose%2A> metodę można wywołać metody w <xref:System.GC> klasy, aby dostosować zachowanie finalizacji modułu odśmiecania pamięci.  
  
 Aby uzyskać więcej informacji na wzorzec dispose i finalizacja obiektu, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a>Obiekt przedawnienia i generacji  
 Moduł zbierający elementy bezużyteczne w środowisko uruchomieniowe języka wspólnego obsługuje przestarzałej obiektu przy użyciu generacji. Generowanie jest jednostką miary względnej wiek obiektów w pamięci. Generowanie liczby lub wieku obiektu wskazuje generacji, do której należy dany obiekt. Obiekty utworzone więcej ostatnio są częścią nowszej generacji i mieć niższych numerach generowania niż cykl obiekty utworzone wcześniej w cyklu życia aplikacji. Obiekty w najnowszej generacji znajdują się w generacji 0. Ta implementacja modułu odśmiecania pamięci obsługuje trzy generacje obiektów, generacji 0, 1 i 2. Można pobrać wartość <xref:System.GC.MaxGeneration%2A> właściwości w celu określenia liczby generacji maksymalny obsługiwany przez system.  
  
 Przedawnianie obiekt umożliwia aplikacjom docelowej wyrzucania elementów bezużytecznych na określony zbiór generacje zamiast konieczności moduł odśmiecania pamięci ocenić wszystkie generacje. Przeciążenia <xref:System.GC.Collect%2A> metody, które obejmują `generation` parametru pozwalają na określenie najstarsze generowania się bezużyteczne.  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a>Nie można przydzielać wyrzucania elementów bezużytecznych  
 Począwszy od [!INCLUDE[net_v46](~/includes/net-v46-md.md)], moduł odśmiecania pamięci obsługuje nie GC region opóźnienie trybie który może być używana podczas wykonywania ścieżek krytycznych, w których wyrzucania elementów kolekcji może niekorzystnie wpłynąć na wydajność aplikacji. Nie GC region opóźnienie tryb wymaga, określ ilość pamięci, która może być przydzielona bez zakłóceń z modułu odśmiecania pamięci. Jeśli środowisko uruchomieniowe można przydzielić pamięci, środowisko wykonawcze nie wykonuje wyrzucania elementów bezużytecznych, podczas wykonywania kodu w ścieżce krytycznej.  
  
 Zdefiniuj początku ścieżki krytycznej, nie regionu GC, wywołując jedną z przeciążeń <xref:System.GC.TryStartNoGCRegion%2A>. Określ koniec jego ścieżki krytycznej, wywołując <xref:System.GC.EndNoGCRegion%2A> metody.  
  
 Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, na które powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko wykonawcze jest w trybie opóźnienia w regionie nie GC. Innymi słowy, nie należy wywołać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania nie powiedzie się), a nie powinni oczekiwać od wywołania <xref:System.GC.EndNoGCRegion%2A> zakończyło się sukcesem, po prostu, ponieważ jest to pierwsze wywołanie do <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.  
  
   
  
## Examples  
 W poniższym przykładzie użyto kilka metod odzyskiwania pamięci generacji i informacje o pamięci o bloku nieużywanych obiektów i drukować do konsoli. Następnie zbieranymi nieużywanych obiektów, a uzyskane sumy pamięci są wyświetlane.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Przyrostowe ilość niezarządzanej pamięci, która została przydzielona.</param>
        <summary>Informuje środowisko uruchomieniowe dużych alokacji niezarządzanej pamięci, która powinna być brana pod uwagę podczas planowania wyrzucania elementów bezużytecznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określenie, kiedy należy zaplanować wyrzucania elementów bezużytecznych, środowisko uruchomieniowe bierze pod uwagę ilość pamięci zarządzanej jest przydzielony. Dużą ilość niezarządzanej pamięci są przydzielane w małych obiektów zarządzanych, środowisko uruchomieniowe uwzględnia pamięci zarządzanej, a zatem szacuje zbyt nisko pilność planowania wyrzucania elementów bezużytecznych. <xref:System.GC.AddMemoryPressure%2A> Metoda informuje środowisko uruchomieniowe to dodatkowe wykorzystanie pamięci systemu.  
  
 We wzorcu najprostszy sposób użycia obiektu zarządzanego niezarządzanej pamięci w Konstruktorze przydziela i zwalnia go w `Dispose` lub `Finalize` metody. Wywołaj <xref:System.GC.AddMemoryPressure%2A> metoda po przydzieleniu niezarządzanej pamięci i wywoływać <xref:System.GC.RemoveMemoryPressure%2A> metody po jego.  
  
 W bardziej skomplikowane sytuacje, w którym niezarządzane przydzielanie pamięci znacznie zmienia się w okresie istnienia obiektu zarządzanego, można wywołać <xref:System.GC.AddMemoryPressure%2A> i <xref:System.GC.RemoveMemoryPressure%2A> metody do komunikowania się przyrostowe zmiany środowiska uruchomieniowego.  
  
> [!CAUTION]
>  Należy zadbać o usunięcie dokładnie ilość wykorzystanie, które można dodać. Niepowodzenie w tym może niekorzystnie wpłynąć na wydajność systemu w aplikacjach wykonywanych przez długi czas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> jest mniejsza niż lub równa 0.  - lub - na 32-bitowym komputerze <paramref name="bytesAllocated" /> jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływać kod niezarządzany, podczas manipulacji priorytet wyrzucania elementów bezużytecznych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anulowanie rejestracji powiadomienia wyrzucania elementów kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda anuluje powiadomienie kolekcji wyrzucania elementów, które zostało zarejestrowane przy użyciu <xref:System.GC.RegisterForFullGCNotification%2A> metody. Nie trzeba wywołać tę metodę przed dostosowaniem progu wartości parametrów w kolejnych wywołaniach <xref:System.GC.RegisterForFullGCNotification%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład anuluje rejestracji kolekcji wyrzucania elementów. W tym przykładzie jest częścią większego przykładu przewidzianego dla [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md) tematu.  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ten element członkowski nie jest dostępna, gdy jest włączona współbieżne wyrzucanie elementów bezużytecznych. Zobacz temat [&lt;gcconcurrent —&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) ustawienia środowiska wykonawczego, aby uzyskać informacje o tym, jak wyłączyć współbieżne wyrzucanie elementów bezużytecznych.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wymusza wyrzucanie elementów bezużytecznych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza natychmiastowe wyrzucanie elementów bezużytecznych dla wszystkich generacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda próbuje odzyskać wszystkie pamięci, który jest niedostępny. Wykonuje blokowania wyrzucania elementów bezużytecznych dla wszystkich generacji.  
  
 Wszystkie obiekty, niezależnie od tego, ile znajdowały się w pamięci, są traktowane jako kolekcji; obiekty, do których istnieją odwołania w kodzie zarządzanym nie są zbierane. Ta metoda umożliwia wymuszanie próby odzyskania maksymalną ilość dostępnej pamięci w systemie.  
  
 Począwszy od [!INCLUDE[net_v451](~/includes/net-v451-md.md)], można kompaktowania sterty dużych obiektów (LOH), ustawiając <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> właściwości <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> przed wywołaniem <xref:System.GC.Collect%2A> metody, w poniższym przykładzie pokazano.  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.GC.Collect%2A> metodę, aby przeprowadzić wyrzucanie bezużytecznych na wszystkie generacje pamięci. Kod, który generuje liczby nieużywanych obiektów, a następnie wywołuje <xref:System.GC.Collect%2A> metodę, aby oczyścić je z pamięci.  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">Liczba najstarsze generowania się bezużyteczne.</param>
        <summary>Wymusza natychmiastowe wyrzucanie elementów bezużytecznych z generacji 0 za pomocą określonej generacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta jest przydatna w celu odzyskania pamięci, który jest niedostępny. Jednak przy użyciu tej metody nie gwarantuje, że wszystkie pamięci niedostępne w określonej generacji jest odzyskiwane.  
  
 Jeśli zaimplementowano przestarzałej obiektu, moduł odśmiecania pamięci nie są zbierane obiektów z liczbą generacji jest wyższa niż określonej generacji. Jeśli przestarzałej obiektu nie jest zaimplementowana, moduł odśmiecania pamięci uznaje wszystkich obiektów podczas wyrzucania elementów bezużytecznych.  
  
 Użyj <xref:System.GC.MaxGeneration%2A> własność, aby określić prawidłową wartość maksymalna `generation` parametru.  
  
 Aby uzyskać moduł odśmiecania pamięci, należy wziąć pod uwagę wszystkie obiekty, niezależnie od ich generowania, należy użyć wersji tej metody, która nie przyjmuje żadnych parametrów. Aby moduł zbierający elementy bezużyteczne odzyskać obiektów na podstawie <xref:System.GCCollectionMode> ustawienia, użyj <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> przeciążenie metody.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.GC.Collect%2A> metodę, aby przeprowadzić wyrzucanie bezużytecznych na poszczególnych warstw pamięci. Kod, który generuje liczby nieużywanych obiektów, a następnie wywołuje <xref:System.GC.Collect%2A> metodę, aby oczyścić je z pamięci.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> nie jest prawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">Liczba najstarsze generowania się bezużyteczne.</param>
        <param name="mode">Wartość wyliczenia, który określa, czy wyrzucanie elementów bezużytecznych jest wymuszone (<see cref="F:System.GCCollectionMode.Default" /> lub <see cref="F:System.GCCollectionMode.Forced" />) lub zoptymalizowane pod kątem (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <summary>Wymusza wyrzucania elementów bezużytecznych z generacji 0 za pomocą określonej generacji w czasie określonym przez <see cref="T:System.GCCollectionMode" /> wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `mode` parametru do określenia, czy wyrzucanie elementów bezużytecznych powinna występować bezpośrednio lub tylko jeśli godzina jest optymalna do odzyskania obiektów. Przy użyciu tej metody nie gwarantuje, że wszystkie pamięci niedostępne w określonej generacji jest odzyskiwane.  
  
 Aby dostosować ingerencję operacji wyrzucania elementów bezużytecznych w krytycznych okresach w aplikacji, należy ustawić <xref:System.Runtime.GCSettings.LatencyMode%2A> właściwości.  
  
 Moduł odśmiecania pamięci nie są zbierane w obiekty z liczbą generowania nowszej niż określona w `generation` parametru. Użyj <xref:System.GC.MaxGeneration%2A> własność, aby określić prawidłową wartość maksymalna `generation`.  
  
 Aby uzyskać moduł odśmiecania pamięci, należy wziąć pod uwagę wszystkie obiekty, niezależnie od ich generowania, należy użyć wersji tej metody, która nie przyjmuje żadnych parametrów.  
  
 Aby moduł zbierający elementy bezużyteczne odzyskać obiekty do określonej generacji obiektów, należy użyć <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> przeciążenie metody. Po określeniu generacji maksymalny, wszystkie obiekty są zbierane.  
  
   
  
## Examples  
 Poniższy przykład wymusza wyrzucania elementów bezużytecznych generacji 2 obiektów za pomocą <xref:System.GCCollectionMode.Optimized> ustawienie.  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> nie jest prawidłowy.  - lub - <paramref name="mode" /> nie jest jednym z <see cref="T:System.GCCollectionMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">Liczba najstarsze generowania się bezużyteczne.</param>
        <param name="mode">Wartość wyliczenia, który określa, czy wyrzucanie elementów bezużytecznych jest wymuszone (<see cref="F:System.GCCollectionMode.Default" /> lub <see cref="F:System.GCCollectionMode.Forced" />) lub zoptymalizowane pod kątem (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          <see langword="true" /> do blokowania wyrzucania elementów bezużytecznych; <see langword="false" /> przeprowadzić tle wyrzucania elementów bezużytecznych, jeśli jest to możliwe.</param>
        <summary>Wymusza wyrzucania elementów bezużytecznych z generacji 0 za pomocą określonej generacji w czasie określonym przez <see cref="T:System.GCCollectionMode" /> wartością wartość określającą, czy kolekcja powinny blokować.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższa tabela podsumowuje interakcje `mode` i `blocking` parametry:  
  
|`mode`|`blocking` jest `true`|`blocking` jest `false`|  
|-|-|-|  
|<xref:System.GCCollectionMode.Forced> lub <xref:System.GCCollectionMode.Default>|Blokowanie kolekcji jest wykonywane tak szybko, jak to możliwe. Jeśli zbieranie w tle jest w toku i `generation` jest równa 0 lub 1, <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> metoda natychmiast wyzwala zbieranie blokujące i zwraca po zakończeniu zbierania. Jeśli zbieranie w tle jest w toku i `generation` 2, metoda czeka, dopóki nie zakończy bezużytecznych w tle, wyzwala zbieranie blokujące 2. generacji, a następnie zwraca.|Kolekcja jest wykonywana tak szybko, jak to możliwe. <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> Metoda żąda kolekcja tła, ale nie jest to gwarantowane; w zależności od okoliczności nadal może być wykonywana kolekcja blokowania. Jeśli zbieranie w tle jest już w toku, metoda zwraca natychmiast.|  
|<xref:System.GCCollectionMode.Optimized>|Blokowanie kolekcji mogą być wykonywane w zależności od stanu modułu odśmiecania pamięci i `generation` parametru. Wyrzucanie elementów bezużytecznych stara się zapewnić optymalną wydajność.|Kolekcja może być wykonywana w zależności od stanu modułu odśmiecania pamięci. <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> Metoda żąda kolekcja tła, ale nie jest to gwarantowane; w zależności od okoliczności nadal może być wykonywana kolekcja blokowania. Wyrzucanie elementów bezużytecznych stara się zapewnić optymalną wydajność. Jeśli zbieranie w tle jest już w toku, metoda zwraca natychmiast.|  
  
 Jeśli wywołanie <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> metoda wykonuje pełne blokowanie wyrzucania elementów bezużytecznych, możesz również skompaktować stertę dużego obiektu przez ustawienie <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> właściwości <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> przed wywołaniem <xref:System.GC.Collect%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> nie jest prawidłowy.  - lub - <paramref name="mode" /> nie jest jednym z <see cref="T:System.GCCollectionMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">Liczba najstarsze generowania się bezużyteczne.</param>
        <param name="mode">Wartość wyliczenia, który określa, czy wyrzucanie elementów bezużytecznych jest wymuszone (<see cref="F:System.GCCollectionMode.Default" /> lub <see cref="F:System.GCCollectionMode.Forced" />) lub zoptymalizowane pod kątem (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          <see langword="true" /> do blokowania wyrzucania elementów bezużytecznych; <see langword="false" /> przeprowadzić tle wyrzucania elementów bezużytecznych, jeśli jest to możliwe.</param>
        <param name="compacting">
          <see langword="true" /> kompaktowanie stosu małych obiektów; <see langword="false" /> do tylko odchylenia.</param>
        <summary>Wymusza wyrzucania elementów bezużytecznych z generacji 0 za pomocą określonej generacji w czasie określonym przez <see cref="T:System.GCCollectionMode" /> wartość z wartościami, które określają, czy blokowanie i kompaktowanie kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `blocking` jest `false`, GC decyduje, czy ma być przeprowadzane w tle lub blokowanie wyrzucania elementów bezużytecznych. Jeśli `compacting` jest `true`, wykonuje blokowania wyrzucania elementów bezużytecznych.  
  
 Jeśli `compacting` jest `true`, środowisko uruchomieniowe kompaktuje stos małych obiektów (raportu o kondycji). Stos dużych obiektów (LOH) nie jest kompaktowana, chyba że <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> właściwość jest ustawiona na <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>. Należy pamiętać, że w tym wszystkie blokowania wyrzucania elementów bezużytecznych, nie tylko pełne blokowanie wyrzucania elementów bezużytecznych.  
  
 Możesz wywołać <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> metodę, aby zmniejszyć sterty zarządzanej na najmniejszą możliwą rozmiar, tak jak pokazano w poniższy fragment kodu.  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 Określanie `true` dla `compacting` argument gwarantuje kompaktowania, pełny blokowania wyrzucania elementów bezużytecznych. Ustawienie <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> właściwość <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> zapewnia skompaktować LOH i raportu o kondycji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">Generowanie obiektów, dla których ma być oznaczona liczba kolekcji wyrzucania elementów.</param>
        <summary>Zwraca liczbę przypadków, gdy wystąpiło wyrzucania elementów bezużytecznych dla określonej generacji obiektów.</summary>
        <returns>Liczba przypadków, gdy wystąpił wyrzucania elementów bezużytecznych dla określonej generacji, ponieważ proces został uruchomiony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku zastosowania zarządzania zasobów, konieczne może być okresowo wymuszenia wyrzucania elementów bezużytecznych przez wywołanie metody <xref:System.GC.Collect%2A> metody. Ponieważ jest kosztowną operacją, może poprawić wydajność, pomijając wywołania, jeśli ostatnio nastąpiła wyrzucania elementów bezużytecznych. Zapisz wartość zwrócona przez obiekt <xref:System.GC.CollectionCount%2A> natychmiast po wywołaniu <xref:System.GC.Collect%2A>. Następnym razem, należy wywołać <xref:System.GC.Collect%2A>, porównanie bieżącej wartości zwracanej przez <xref:System.GC.CollectionCount%2A> zapisane wartości. Jeśli dwie wartości są równe, w międzyczasie wystąpił nie kolekcji i można wywołać <xref:System.GC.Collect%2A> ponownie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się nie GC region opóźnienia w trybie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.EndNoGCRegion%2A> Metoda zgłasza wyjątek <xref:System.InvalidOperationException> Jeśli moduł odśmiecania pamięci nie jest w trybie opóźnienia w regionie nie GC. Dzieje się w żadnej z następujących warunków:  
  
-   <xref:System.GC.TryStartNoGCRegion%2A> Nie wywołano metody wcześniej.  
  
-   Wywołanie <xref:System.GC.TryStartNoGCRegion%2A> zwróconej metody `false`.  
  
-   Wywołanie <xref:System.GC.TryStartNoGCRegion%2A> metoda wywołała wyjątek.  
  
 Aby zapobiec wyjątkowi dla każdego z tych powodów, przy użyciu kodu, takie jak następujące:  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Moduł odśmiecania pamięci nie jest w trybie opóźnienia w regionie nie GC.  - lub - GC region opóźnienie tryb bez zostało zakończone wcześniej, ponieważ wyrzucania elementów bezużytecznych zostało wywołane.  - lub - alokacja pamięci przekracza wartość określoną w wywołaniu <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> metody.</exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca numer bieżącej generacji obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który generowania informacje są pobierane dla.</param>
        <summary>Zwraca numer bieżącej generacji określonego obiektu.</summary>
        <returns>Numer bieżącej generacji <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do określenia wieku obiektu, a następnie użyć tych informacji z <xref:System.GC.Collect%2A> metodę wymuszania moduł odśmiecania pamięci, aby zebrać obiektów w tej samej generacji. Na przykład użyć tej metody, gdy masz zestaw obiektów, które są tworzone jako grupą i które stały się niedostępne w tym samym czasie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.GC.GetGeneration%2A> metodę pozwala ustalić okres ważności obiektu. Przykład następnie wykonuje wyrzucania elementów bezużytecznych do wyczyszczenia pamięci sortujące i porównujące wstępnie — Opublikuj kolekcję sum pamięci w konsoli.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo">A <see cref="T:System.WeakReference" /> odwołujący się do obiektu docelowego, którego numer generacja zostanie określony.</param>
        <summary>Zwraca numer bieżącej generacji celem określone odwołanie słabe.</summary>
        <returns>Numer bieżącej generacji celem <paramref name="wo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.GC.GetGeneration%2A> metodę pozwala ustalić okres ważności obiektu słabe odwołanie.  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wyrzucanie elementów bezużytecznych została już wykonana na <paramref name="wo" />.</exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">
          <see langword="true" /> Aby wskazać, że ta metoda może oczekiwać wyrzucanie elementów bezużytecznych przed zwróceniem; w przeciwnym razie <see langword="false" />.</param>
        <summary>Pobiera liczbę bajtów, które obecnie traktować do przydzielenia. Parametr wskazuje, czy ta metoda może czekać przez krótki czas przed zwróceniem, aby zezwolić na zbieranie pamięci i zakończyć obiektów systemu.</summary>
        <returns>Liczba, która jest dostępna najlepiej zbliżenia liczbę aktualnie przydzielonych bajtów w pamięci zarządzanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `forceFullCollection` parametr jest `true`, ta metoda czeka przez krótki czas przed zwróceniem systemu umożliwia zbieranie informacji o pamięci i kończenie znajdujących się w obiektach. Długość interwału jest wewnętrznie określony limit określana przez liczbę cykli kolekcji wyrzucania elementów ukończone i zmiana ilości pamięci odzyskana między cykle. Moduł odśmiecania pamięci nie gwarantuje zbierane wszystkie pamięci niedostępne.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.GC.GetTotalMemory%2A> metodę, aby pobrać i wyświetlić liczbę aktualnie przydzielonych bajtów w pamięci zarządzanej.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do odwołania.</param>
        <summary>Odwołuje się do określonego obiektu, dzięki czemu nie kwalifikuje się do wyrzucania elementów bezużytecznych od początku bieżącego procedury do punktu, w którym ta metoda jest wywoływana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Celem <xref:System.GC.KeepAlive%2A> metodą jest zapewnić istnienie odwołania do obiektu, który jest zagrożona przez przedwcześnie są odzyskiwane przez moduł odśmiecania pamięci. Jest to typowy scenariusz, w którym może się to zdarzyć, istnieją żadnych odwołań do obiektu w kodzie zarządzanym lub danych, kiedy obiekt jest nadal używany w niezarządzanym kodzie, takich jak interfejsy API systemu Win32, niezarządzanych bibliotek DLL, lub metody za pomocą modelu COM.  
  
 Odwołuje się ta metoda `obj` parametru, dzięki czemu ten obiekt nie kwalifikuje się do wyrzucania elementów bezużytecznych od samego początku procedury do punktu, w kolejności wykonywania której ta metoda jest wywoływana. Kod tej metody, na końcu, a nie początku zakresu instrukcje gdzie `obj` muszą być dostępne.  
  
 <xref:System.GC.KeepAlive%2A> Metoda nie wykonuje żadnej operacji i tworzy żadnych efektów ubocznych niż rozszerzanie okresu istnienia obiektu przekazany jako parametr.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy obiekt na początku jego `Main` metody i nie odwołuje się do obiektu ponownie do czasu zakończenia, gdy <xref:System.GC.KeepAlive%2A> metoda jest wywoływana. Obiekt będzie nadal występować po 30 sekund czasu trwania `Main` metody, niezależnie od wywołania <xref:System.GC.Collect%2A> i <xref:System.GC.WaitForPendingFinalizers%2A> metody.  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną liczbę generacje, które obsługuje obecnie system.</summary>
        <value>Wartość z zakresu od 0 do maksymalną liczbę obsługiwanych generacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generowanie liczby lub wieku obiektu jest zdefiniowane w implementacji Względna miara obiektu życia. Ostatnio utworzone obiekty są w generacji 0 i najstarsze obiekty w generacji mniejsze niż lub równe Generowanie zwróconych przez <xref:System.GC.MaxGeneration%2A> właściwości.  
  
 Moduł zbierający elementy bezużyteczne przyjęto założenie, czy nowszej pamięci jest bardziej prawdopodobne zakwalifikować się do wyrzucania elementów bezużytecznych niż starsze pamięci. W związku z tym, moduł odśmiecania pamięci zwiększa jego wydajność, dostosowując generowania liczb każdorazowo odzyskuje pamięć, a <xref:System.GC.MaxGeneration%2A> wartość właściwości może rosnąć wraz z upływem czasu.  
  
 Jeśli obiekt przestarzałej jest zaimplementowana, <xref:System.GC.MaxGeneration%2A> właściwość zwraca liczbę maksymalną generowania używaną przez system; w przeciwnym razie ta właściwość zwraca wartość zero.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak użyć właściwości MaxGeneration, aby wyświetlić największa liczba generacji obecnie w użyciu.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Dla tej implementacji wartość zwracana przez <see cref="P:System.GC.MaxGeneration" /> właściwość jest gwarantowane, pozostaje niezmienna przez okres istnienia realizowanej aplikacji.  Użyj <see cref="P:System.GC.MaxGeneration" /> właściwość, aby określić maksymalną wartość można określić podczas wywoływania <see cref="M:System.GC.Collect(System.Int32)" /> metody, która przyjmuje parametr generacji.</para>
        </block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">Liczbą z zakresu od 1 do 99 określający, kiedy powinien być wywoływany powiadomienia na podstawie obiekty przydzielone w generacji 2.</param>
        <param name="largeObjectHeapThreshold">Liczbą z zakresu od 1 do 99 określający, kiedy powinien być wywoływany powiadomienia na podstawie obiekty przydzielone w stosie dużego obiektu.</param>
        <summary>Określa, że powiadomienie kolekcji wyrzucania elementów powinien być wywoływany w przypadku, gdy warunki Preferuj pełne wyrzucanie elementów bezużytecznych i kiedy kolekcji zostały ukończone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla każdej generacji moduł zbierający elementy bezużyteczne ustawia próg alokacji w tej generacji. Gdy rozmiar alokacji przekracza wartość progowa, wyrzucanie elementów bezużytecznych jest wyzwalana dla tej generacji. Aby uzyskać przykład, jeśli próg generacji 2 jest o rozmiarze 20MB (co oznacza, że o rozmiarze 20MB przeżyje kolekcji generacji 1 i są promowane do generacji 2) i więcej niż 20MB ma przetrwały generacji 1 i zostanie poproszony w generacji 2, zostanie podjęta próba następnego wyrzucania elementów bezużytecznych jako kolekcji generacji 2. Podobnie jeśli sterty dużych obiektów (LOH) próg wynosi 20MB i aplikację przydzieliła więcej niż 20MB pamięci dużych obiektów, następnego wyrzucania elementów bezużytecznych zostanie również podjęta jako kolekcji generacji 2 (ponieważ LOH są zbierane w gen2 wyrzucania elementów bezużytecznych).  
  
 `maxGenerationThreshold` i `largeObjectHeapThreshold` progi kontrolować, ile wcześniej otrzymasz powiadomienie, zanim wystąpi pełne wyrzucanie elementów bezużytecznych. Wyższa wartość progową, więcej przydziały, które mogą wystąpić między powiadomienia i dalej pełne wyrzucanie elementów bezużytecznych.  
  
 W przypadku sytuacji, w których pełne wyrzucanie elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego może niekorzystnie wpłynąć na wydajność aplikacji, możesz poprosić otrzymywać powiadomienia, gdy środowisko uruchomieniowe ma pełną wyrzucania elementów bezużytecznych i obejście tej kolekcji przez wykonuje kolekcję, samodzielnie (przy użyciu <xref:System.GC.Collect%2A> metoda) Jeśli warunki są nadal pozytywnych. Validated harmonogramy zbierania śmieci samodzielnie, pełne powiadomienie GC przydaje się w poniższych scenariuszach:  
  
-   Możesz monitorować podejście pełne odśmiecanie, i po wyświetleniu powiadomienia, że zbliża się jeden, zmniejszyć rozmiar danych na żywo (na przykład dzięki niektóre wpisy w pamięci podręcznej). W rezultacie po wystąpieniu wyrzucania elementów bezużytecznych jest w stanie odzyskać większej ilości pamięci.  
  
-   Możesz monitorować zakończenia pełne odśmiecanie, tak, aby zbierać statystykami.  Na przykład można mierzyć rozmiar sterty po ukończeniu odzyskiwania pamięci, dzięki czemu będzie wiadomo, rozmiar danych na żywo. (Po pełną operacją GC sterty jest na najmniejszy).  
  
 Aby uzyskać więcej informacji na temat co reprezentuje pełne odśmiecanie, zobacz [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md).  
  
 Po zarejestrowaniu powiadomienia kolekcji wyrzucania elementów, możesz otrzymać, gdy zbliża się pełne wyrzucanie elementów bezużytecznych, a po jego zakończeniu. Ten wzorzec jest podobny, jak system operacyjny monitoruje dla powiadomień o małej ilości pamięci.  
  
 Skorzystaj z poniższych wskazówek w celu określania `maxGenerationThreshold` i `largeObjectHeapThreshold` parametry:  
  
-   Im większa wartość progowa, wystąpi więcej alokacje między powiadomienia i pełne wyrzucanie elementów bezużytecznych.  
  
     Wyższa wartość progowa zapewnia dodatkowe możliwości dla środowiska uruchomieniowego pod kątem bliskim kolekcji. Zwiększa prawdopodobieństwo, że użytkownik będzie powiadamiany. Nie należy jednak ustawić zbyt wysoki próg, ponieważ wyniki w alokacjach więcej przed środowisko uruchomieniowe wywołuje kolejnego zbierania.  
  
     Gdy możesz wywołać kolekcję samodzielnie na powiadomienia za pomocą wartość progowa, mniejszą liczbę obiektów są odzyskiwane nie będzie można odzyskać przy następnej kolekcji w środowisku uruchomieniowym.  
  
-   Niższa wartość progowa, mniej alokacje między powiadomienia i pełne wyrzucanie elementów bezużytecznych.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak do rejestracji powiadomień kolekcji wyrzucania elementów i uruchomić wątku do monitorowania stanu powiadomień kolekcji wyrzucania elementów. Ten przykład kodu jest częścią większego przykładu przewidzianego dla [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md) tematu.  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxGenerationThreshold" /> lub <paramref name="largeObjectHeapThreshold" /> nie jest w zakresie od 1 do 99.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Ilość niezarządzanej pamięci, która została zwolniona.</param>
        <summary>Informuje środowisko uruchomieniowe wydano niezarządzanej pamięci, a nie musi już być brana pod uwagę podczas planowania wyrzucania elementów bezużytecznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określenie, kiedy należy zaplanować wyrzucania elementów bezużytecznych, środowisko uruchomieniowe bierze pod uwagę ilość pamięci zarządzanej jest przydzielony. Dużą ilość niezarządzanej pamięci są przydzielane w małych obiektów zarządzanych, środowisko uruchomieniowe uwzględnia pamięci zarządzanej, a zatem szacuje zbyt nisko pilność planowania wyrzucania elementów bezużytecznych. <xref:System.GC.AddMemoryPressure%2A> Metoda informuje środowiska wykonawczego o ten dodatkowy nacisk na pamięci systemowej i <xref:System.GC.RemoveMemoryPressure%2A> metoda informuje środowisko uruchomieniowe po udostępnieniu dodatkowych ciśnienia.  
  
 We wzorcu najprostszy sposób użycia obiektu zarządzanego niezarządzanej pamięci w Konstruktorze przydziela i zwalnia go w `Dispose` lub `Finalize` metody. Wywołaj <xref:System.GC.AddMemoryPressure%2A> metoda po przydzieleniu niezarządzanej pamięci i wywoływać <xref:System.GC.RemoveMemoryPressure%2A> metody po jego.  
  
 W bardziej skomplikowane sytuacje, w którym niezarządzane przydzielanie pamięci znacznie zmienia się w okresie istnienia obiektu zarządzanego, można wywołać <xref:System.GC.AddMemoryPressure%2A> i <xref:System.GC.RemoveMemoryPressure%2A> metody do komunikowania się przyrostowe zmiany środowiska uruchomieniowego.  
  
> [!CAUTION]
>  Należy zadbać o usunięcie dokładnie ilość wykorzystanie, które można dodać. Niepowodzenie w tym może niekorzystnie wpłynąć na wydajność systemu w aplikacjach wykonywanych przez długi czas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> jest mniejsza niż lub równa 0.  - lub - na 32-bitowym komputerze <paramref name="bytesAllocated" /> jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływać kod niezarządzany, podczas manipulacji priorytet wyrzucania elementów bezużytecznych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który należy wywołać finalizatora dla.</param>
        <summary>Żąda system wywołać finalizatora dla określonego obiektu, dla którego <see cref="M:System.GC.SuppressFinalize(System.Object)" /> wcześniej została wywołana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.ReRegisterForFinalize%2A> Metoda dodaje `obj` parametru do listy obiektów żądających finalizacji, zanim moduł odśmiecania pamięci zwalnia obiektu. `obj` Parametr musi być wywołujący tę metodę.  
  
 Wywoływanie <xref:System.GC.ReRegisterForFinalize%2A> metody nie gwarantuje, że moduł odśmiecania pamięci będzie wywołać finalizatora obiektu.  
  
 Domyślnie wszystkie obiekty, które implementują finalizatory są dodawane do listy obiektów, które wymagają finalizacji; jednak może mieć już sfinalizowany lub może być wyłączone finalizacja przez wywołanie obiektu <xref:System.GC.SuppressFinalize%2A> metody.  
  
 Finalizator umożliwia operacji przywracania aktywności siebie lub obiekt, który odwołuje się do tej metody.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zakończyć obiektu na sekundę przy użyciu metody ReRegisterForFinalize czas po wyrzucania elementów bezużytecznych.  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, którego finalizatora nie musi zostać wykonana.</param>
        <summary>Żądania, że środowisko uruchomieniowe języka wspólnego nie wywołać finalizatora dla określonego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia bit w nagłówku obiektu `obj`, której środowisko uruchomieniowe sprawdza podczas wywoływania finalizatorów. Finalizator, który jest reprezentowany przez <xref:System.Object.Finalize%2A?displayProperty=nameWithType> służy metody, aby zwolnić niezarządzane zasoby, zanim obiekt będzie jesdnostką zbierającą śmieci. Jeśli `obj` nie ma finalizatora, wywołanie <xref:System.GC.SuppressFinalize%2A> metoda nie ma wpływu.  
  
 Obiekty, które implementują <xref:System.IDisposable> interfejsu można wywołać tej metody z obiektu <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji, aby uniemożliwić moduł zbierający elementy bezużyteczne wywoływania <xref:System.Object.Finalize%2A?displayProperty=nameWithType> na obiekt, który nie jest wymagane. Zazwyczaj w ten sposób zapobiec finalizator zwalniania niezarządzanych zasobów, które już mają zostać zwolniony przez <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.GC.SuppressFinalize%2A> metody w klasie zasobów, aby zapobiec nadmiarowe wyrzucanie elementów bezużytecznych z wywołanego. W przykładzie użyto [wzorca usuwania](~/docs/standard/design-guidelines/dispose-pattern.md) zwolnienie zarówno zasoby zarządzane (czyli obiekty, które implementują <xref:System.IDisposable>) i niezarządzanych zasobów.  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżkę krytyczną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, na które powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko wykonawcze jest w trybie opóźnienia w regionie nie GC. Innymi słowy, nie należy wywołać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania nie powiedzie się), a nie powinni oczekiwać od wywołania <xref:System.GC.EndNoGCRegion%2A> zakończyło się sukcesem, po prostu, ponieważ jest to pierwsze wywołanie do <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">Ilość pamięci w bajtach, można przydzielić bez powodowania wyrzucania elementów bezużytecznych. Może być mniejsza niż lub równy rozmiarowi segment efemeryczny. Aby uzyskać informacje dotyczące rozmiaru segment efemeryczny zawiera sekcja "generacje i segmenty Efemeryczne" w [artykuł Collection](~/docs/standard/garbage-collection/fundamentals.md) podstawowe informacje dotyczące odzyskiwania pamięci.</param>
        <summary>Próby nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżki krytycznej, jeśli określona ilość pamięci jest dostępny.</summary>
        <returns>
          <see langword="true" /> Jeśli środowisko uruchomieniowe można było zatwierdzić wymagana ilość pamięci i odśmiecania pamięci jest w stanie nie tryb opóźnienie region GC; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> Metoda próbuje umieścić moduł zbierający elementy bezużyteczne w nie GC region opóźnienie trybie, który nie zezwala wyrzucania elementów bezużytecznych, gdy aplikacja wykonuje krytyczne obszar kodu.  Jeśli środowisko wykonawcze nie może przydzielić pierwotnie żądanej ilości pamięci, moduł zbierający elementy bezużyteczne wykonuje pełne blokowanie wyrzucania elementów bezużytecznych zwolnić więcej pamięci. Moduł zbierający elementy bezużyteczne przechodzi tryb bez GC region opóźnienia, jeśli jest w stanie przydzielić wymagana ilość pamięci, w tym przypadku jest faktycznie 2 * `totalSize` bajtów (próbuje przydzielić `totalSize` bajtów dla sterty małego obiektu i `totalSize` bajtów sterty dużego obiektu).  
  
 `totalSize` musi być wystarczająco duży, aby obsłużyć wszystkie alokacje pamięci, które występują w ścieżce krytycznej. Obejmuje to alokacje przez aplikację, a także alokacji, który sprawia, że środowisko wykonawcze w imieniu aplikacji.  
  
> [!IMPORTANT]
>  Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, na które powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko wykonawcze jest w trybie opóźnienia w regionie nie GC. Innymi słowy, nie należy wywołać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania nie powiedzie się), a nie powinni oczekiwać od wywołania <xref:System.GC.EndNoGCRegion%2A> zakończyło się sukcesem, po prostu, ponieważ jest to pierwsze wywołanie do <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.  
  
 Możesz wyjść z nie GC region opóźnienie trybu przez wywołanie metody <xref:System.GC.EndNoGCRegion%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> przekracza rozmiar segment efemeryczny.</exception>
        <exception cref="T:System.InvalidOperationException">Proces jest już w trybie opóźnienia w regionie nie GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">Ilość pamięci w bajtach, można przydzielić bez powodowania wyrzucania elementów bezużytecznych. Może być mniejsza niż lub równy rozmiarowi segment efemeryczny. Aby uzyskać informacje dotyczące rozmiaru segment efemeryczny zawiera sekcja "generacje i segmenty Efemeryczne" w [artykuł Collection](~/docs/standard/garbage-collection/fundamentals.md) podstawowe informacje dotyczące odzyskiwania pamięci.</param>
        <param name="disallowFullBlockingGC">
          <see langword="true" /> Aby pominąć pełną blokowania wyrzucania elementów bezużytecznych, jeśli moduł odśmiecania pamięci jest początkowo nie można przydzielić <c>totalSize</c> bajtów; w przeciwnym razie <see langword="false" />.</param>
        <summary>Próbuje nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżki krytycznej, jeśli określona ilość pamięci jest dostępny i formantów, czy moduł odśmiecania pamięci jest pełna blokowania wyrzucania elementów bezużytecznych, jeśli nie wystarczającej ilości pamięci jest początkowo dostępna.</summary>
        <returns>
          <see langword="true" /> Jeśli środowisko uruchomieniowe można było zatwierdzić wymagana ilość pamięci i odśmiecania pamięci jest w stanie nie tryb opóźnienie region GC; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> Metoda próbuje umieścić moduł zbierający elementy bezużyteczne w nie GC region opóźnienie trybie, który nie zezwala wyrzucania elementów bezużytecznych, gdy aplikacja wykonuje krytyczne obszar kodu.  Jeśli środowisko uruchomieniowe jest nie można wstępnie przydzielić żądanej ilości pamięci i `disallowFullBlockingGC` argument jest `false`, moduł zbierający elementy bezużyteczne wykonuje pełne blokowanie wyrzucania elementów bezużytecznych zwolnić więcej pamięci; w przeciwnym razie alokacji kończy się niepowodzeniem i metoda zwraca `false`. Moduł zbierający elementy bezużyteczne przechodzi tryb bez GC region opóźnienia, jeśli jest w stanie przydzielić wymagana ilość pamięci, w tym przypadku jest faktycznie 2 * `totalSize` (próbuje przydzielić `totalSize` dla sterty małego obiektu i `totalSize` dla dużego obiektu Sterta).  
  
 `totalSize` musi być wystarczająco duży, aby obsłużyć wszystkie alokacje pamięci, które występują w ścieżce krytycznej. Obejmuje to alokacje przez aplikację, a także alokacji, który sprawia, że środowisko wykonawcze w imieniu aplikacji.  
  
 Ustawienie `disallowFullBlockingGC` do `true` zapobiegające pełnego blokowania wyrzucania elementów kolekcji, jeśli nie ma wystarczającej ilości pamięci jest początkowo dostępna jest najbardziej przydatna w scenariusze równoważenia obciążenia: jeden system może wywołać tę metodę i przedstawia się jako gotowy do akceptowania żądań, jeśli zostanie zwrócona `true`, i modułu równoważenia obciążenia, Przekieruj żądania do innych systemów, jeśli zwróci ona `false`. Go następnie wykonaj pełną blokowania wyrzucania elementów bezużytecznych, gdy go nie obsługuje żądania przez wywołanie metody <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> metody.  
  
> [!IMPORTANT]
>  Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, na które powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko wykonawcze jest w trybie opóźnienia w regionie nie GC. Innymi słowy, nie należy wywołać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania nie powiedzie się), a nie powinni oczekiwać od wywołania <xref:System.GC.EndNoGCRegion%2A> zakończyło się sukcesem, po prostu, ponieważ jest to pierwsze wywołanie do <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.  
  
 Możesz wyjść z nie GC region opóźnienie trybu przez wywołanie metody <xref:System.GC.EndNoGCRegion%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> przekracza rozmiar segment efemeryczny.</exception>
        <exception cref="T:System.InvalidOperationException">Proces jest już w trybie opóźnienia w regionie nie GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">Ilość pamięci w bajtach, można przydzielić bez powodowania wyrzucania elementów bezużytecznych. <c>totalSize</c> —<c>lohSize</c> musi być mniejsza niż rozmiar segment efemeryczny. Aby uzyskać informacje dotyczące rozmiaru segment efemeryczny zawiera sekcja "generacje i segmenty Efemeryczne" w [artykuł Collection](~/docs/standard/garbage-collection/fundamentals.md) podstawowe informacje dotyczące odzyskiwania pamięci.</param>
        <param name="lohSize">Liczba bajtów w <c>totalSize</c> na potrzeby alokacji sterty (LOH) dużego obiektu.</param>
        <summary>Próby nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżki krytycznej, jeśli określona ilość pamięci jest dostępna dla stosu dużych obiektów i stosu małych obiektów.</summary>
        <returns>
          <see langword="true" /> Jeśli środowisko uruchomieniowe można było zatwierdzić wymagana ilość pamięci i odśmiecania pamięci jest w stanie nie tryb opóźnienie region GC; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> Metoda próbuje umieścić moduł zbierający elementy bezużyteczne w nie GC region opóźnienie trybie, który nie zezwala wyrzucania elementów bezużytecznych, gdy aplikacja wykonuje krytyczne obszar kodu.  Jeśli środowisko wykonawcze nie może przydzielić pierwotnie żądanej ilości pamięci, moduł zbierający elementy bezużyteczne wykonuje pełne blokowanie wyrzucania elementów bezużytecznych zwolnić więcej pamięci. Moduł zbierający elementy bezużyteczne przechodzi nie w trybie opóźnienia region GC, jeśli jest w stanie przydzielić `lohSize` dla LOH i `totalSize` — `lohSize` dla sterty małego obiektu (raportu o kondycji).  
  
 `lohSize` musi być wystarczająco duży, aby obsłużyć wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla LOH, i `totalSize` — `lohSize` musi być wystarczająco duży, aby obsłużyć wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla raportu o kondycji. Obejmuje to alokacje przez aplikację, a także alokacji, który sprawia, że środowisko wykonawcze w imieniu aplikacji.  
  
> [!IMPORTANT]
>  Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, na które powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko wykonawcze jest w trybie opóźnienia w regionie nie GC. Innymi słowy, nie należy wywołać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania nie powiedzie się), a nie powinni oczekiwać od wywołania <xref:System.GC.EndNoGCRegion%2A> zakończyło się sukcesem, po prostu, ponieważ jest to pierwsze wywołanie do <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.  
  
 Możesz wyjść z nie GC region opóźnienie trybu przez wywołanie metody <xref:System.GC.EndNoGCRegion%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> — <paramref name="lohSize" /> przekracza rozmiar segment efemeryczny.</exception>
        <exception cref="T:System.InvalidOperationException">Proces jest już w trybie opóźnienia w regionie nie GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">Ilość pamięci w bajtach, można przydzielić bez powodowania wyrzucania elementów bezużytecznych. <c>totalSize</c> —<c>lohSize</c> musi być mniejsza niż rozmiar segment efemeryczny. Aby uzyskać informacje dotyczące rozmiaru segment efemeryczny zawiera sekcja "generacje i segmenty Efemeryczne" w [artykuł Collection](~/docs/standard/garbage-collection/fundamentals.md) podstawowe informacje dotyczące odzyskiwania pamięci.</param>
        <param name="lohSize">Liczba bajtów w <c>totalSize</c> na potrzeby alokacji sterty (LOH) dużego obiektu.</param>
        <param name="disallowFullBlockingGC">
          <see langword="true" /> Aby pominąć pełną blokowania wyrzucania elementów bezużytecznych, jeśli moduł odśmiecania pamięci jest początkowo nie można przydzielić określonym pamięci sterty małego obiektu (raportu o kondycji) i LOH; w przeciwnym razie <see langword="false" />.</param>
        <summary>Nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżki krytycznej, jeśli określonej ilości pamięci jest dostępny dla sterty dużych obiektów i stos małych obiektów i kontrolek, czy moduł odśmiecania pamięci jest pełna blokowania wyrzucania elementów bezużytecznych, jeśli nie prób początkowo dostępna jest wystarczająca ilość pamięci.</summary>
        <returns>
          <see langword="true" /> Jeśli środowisko uruchomieniowe można było zatwierdzić wymagana ilość pamięci i odśmiecania pamięci jest w stanie nie tryb opóźnienie region GC; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> Metoda próbuje umieścić moduł zbierający elementy bezużyteczne w nie GC region opóźnienie trybie, który nie zezwala wyrzucania elementów bezużytecznych, gdy aplikacja wykonuje krytyczne obszar kodu.  Jeśli środowisko uruchomieniowe jest nie można wstępnie przydzielić żądanej ilości pamięci i `disallowFullBlockingGC` argument jest `false`, moduł zbierający elementy bezużyteczne wykonuje pełne blokowanie wyrzucania elementów bezużytecznych zwolnić więcej pamięci; w przeciwnym razie alokacji kończy się niepowodzeniem i metoda zwraca `false`. Moduł zbierający elementy bezużyteczne przechodzi nie w trybie opóźnienia region GC, jeśli jest w stanie przydzielić `lohSize` dla LOH i `totalSize` — `lohSize` dla sterty małego obiektu (raportu o kondycji).  
  
 `lohSize` musi być wystarczająco duży, aby obsłużyć wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla LOH, i `totalSize` — `lohSize` musi być wystarczająco duży, aby obsłużyć wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla raportu o kondycji. Obejmuje to alokacje przez aplikację, a także alokacji, który sprawia, że środowisko wykonawcze w imieniu aplikacji.  
  
 Ustawienie `disallowFullBlockingGC` do `true` zapobiegające pełnego blokowania wyrzucania elementów kolekcji, jeśli nie ma wystarczającej ilości pamięci jest początkowo dostępna jest najbardziej przydatna w scenariusze równoważenia obciążenia: jeden system może wywołać tę metodę i przedstawia się jako gotowy do akceptowania żądań, jeśli zostanie zwrócona `true`, i modułu równoważenia obciążenia, Przekieruj żądania do innych systemów, jeśli zwróci ona `false`. Go następnie wykonaj pełną blokowania wyrzucania elementów bezużytecznych, gdy go nie obsługuje żądania przez wywołanie metody <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> metody.  
  
> [!IMPORTANT]
>  Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, na które powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko wykonawcze jest w trybie opóźnienia w regionie nie GC. Innymi słowy, nie należy wywołać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania nie powiedzie się), a nie powinni oczekiwać od wywołania <xref:System.GC.EndNoGCRegion%2A> zakończyło się sukcesem, po prostu, ponieważ jest to pierwsze wywołanie do <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.  
  
 Możesz wyjść z nie GC region opóźnienie trybu przez wywołanie metody <xref:System.GC.EndNoGCRegion%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> — <paramref name="lohSize" /> przekracza rozmiar segment efemeryczny.</exception>
        <exception cref="T:System.InvalidOperationException">Proces jest już w trybie opóźnienia w regionie nie GC.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca stan zarejestrowanego powiadomienia do określenia, czy pełny blokowanie wyrzucania elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego jest bliska.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca stan zarejestrowanego powiadomienia do określenia, czy pełny blokowanie wyrzucania elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego jest bliska.</summary>
        <returns>Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.GCNotificationStatus> zwracane przez tę metodę pozwala ustalić stan bieżącego powiadomienia kolekcji wyrzucania elementów, który został zarejestrowany przy użyciu wyliczenia <xref:System.GC.RegisterForFullGCNotification%2A> metody. Można również użyć <xref:System.GC.WaitForFullGCComplete%2A> metodę pozwala ustalić, czy pełne wyrzucanie elementów bezużytecznych zostało zakończone.  
  
 Gdy zwraca wyliczenie <xref:System.GCNotificationStatus.Succeeded>, mogą wykonywać zadania, takie jak uniemożliwia dodatkowe obiekty są przydzielane i wykonuje kolekcję, samodzielnie za pomocą <xref:System.GC.Collect%2A> metody. Należy pamiętać, że powiadomienia nie gwarantuje, że pełne wyrzucanie elementów bezużytecznych nastąpi, tylko, że warunki Osiągnięto próg jest preferowana dla pełne wyrzucanie elementów bezużytecznych.  
  
 Ta metoda przez czas nieokreślony oczekuje można uzyskać powiadomienia wyrzucania elementów kolekcji. Aby określić limit czasu dla metody do zwrócenia, jeśli nie można uzyskać powiadomienia, należy użyć <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> przeciążenie metody. Jeśli ta metoda jest wywoływana bez określania upływu limitu czasu, można wywołać <xref:System.GC.CancelFullGCNotification%2A> metodę, jeśli oczekujesz dłużej niż preferowany.  
  
 Należy przestrzegać tej metody za pomocą wywołania <xref:System.GC.WaitForFullGCComplete%2A> metody, aby upewnić się, mieli pełne wyrzucanie elementów bezużytecznych. Wywołanie tej metody tylko powoduje, że wyniki nieokreślony.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ta metoda służy do określenia, czy zbliża się pełne, blokowanie wyrzucania elementów bezużytecznych. Zawsze, gdy jest w stanie powiadomienia <xref:System.GCNotificationStatus.Succeeded>, metoda użytkownika `OnFullGCApproachNotify` jest wywoływana w celu wykonania akcji w odpowiedzi na Bliskim kolekcji. Ten przykład kodu jest częścią większego przykładu przewidzianego dla [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md) tematu.  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Długość czasu oczekiwania, można uzyskać stanu powiadomień. Określ wartość -1, aby czekać w nieskończoność.</param>
        <summary>Zwraca określony przekroczył limit czasu, stan zarejestrowanego powiadomienia do określenia, czy pełny blokowanie wyrzucania elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego jest bliska.</summary>
        <returns>Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.GCNotificationStatus> zwracane przez tę metodę pozwala ustalić stan bieżącego powiadomienia kolekcji wyrzucania elementów, który został zarejestrowany przy użyciu wyliczenia <xref:System.GC.RegisterForFullGCNotification%2A> metody. Można również użyć <xref:System.GC.WaitForFullGCComplete%2A> metodę pozwala ustalić, czy pełne wyrzucanie elementów bezużytecznych zostało zakończone.  
  
 Należy zauważyć, że ta metoda zwraca natychmiast zawsze, gdy uzyskany stanu powiadomień kolekcji wyrzucania elementów, bez względu na wartość określoną przez `millisecondsTimeout`. Jeśli stan powiadomień kolekcji wyrzucania elementów nie zostanie osiągnięta przed `millisecondsTimeout` razy, Metoda ta zwraca <xref:System.GCNotificationStatus.NotApplicable>.  
  
 Gdy zwraca wyliczenie <xref:System.GCNotificationStatus.Succeeded>, mogą wykonywać zadania, takie jak uniemożliwia dodatkowe obiekty są przydzielane i wykonuje kolekcję, samodzielnie za pomocą <xref:System.GC.Collect%2A> metody. Należy pamiętać, że powiadomienia nie gwarantuje, że pełne wyrzucanie elementów bezużytecznych nastąpi, tylko, że warunki Osiągnięto próg jest preferowana dla pełne wyrzucanie elementów bezużytecznych.  
  
 Możesz wywołać <xref:System.GC.CancelFullGCNotification%2A> metody, gdy nie można czekać przed upłynięciem limitu czasu minie.  
  
 Należy przestrzegać tej metody za pomocą wywołania <xref:System.GC.WaitForFullGCComplete%2A> metody, aby upewnić się, mieli pełne wyrzucanie elementów bezużytecznych. Wywołanie tej metody tylko powoduje, że wyniki nieokreślony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> musi być nieujemną lub mniejsze niż lub równe <see cref="F:System.Int32.MaxValue" /> lub wartość -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca stan zarejestrowanego powiadomienia do określenia, czy pełny blokowanie wyrzucania elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego została ukończona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca stan zarejestrowanego powiadomienia do określenia, czy pełny blokowanie wyrzucania elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego została ukończona.</summary>
        <returns>Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.GCNotificationStatus> zwracane przez tę metodę pozwala ustalić stan bieżącego powiadomienia kolekcji wyrzucania elementów, który został zarejestrowany przy użyciu wyliczenia <xref:System.GC.RegisterForFullGCNotification%2A> metody. Można również użyć <xref:System.GC.WaitForFullGCApproach%2A> metodę, aby określić, czy pełne wyrzucanie elementów bezużytecznych jest bezpośrednie.  
  
 Gdy zwraca wyliczenie <xref:System.GCNotificationStatus.Succeeded>, mogą wykonywać zadania, takie jak wznawiania pracy i uzyskiwanie liczby kolekcji, za pomocą <xref:System.GC.CollectionCount%2A> właściwości.  
  
 Ta metoda przez czas nieokreślony oczekuje można uzyskać powiadomienia wyrzucania elementów kolekcji. Aby określić limit czasu dla metody do zwrócenia, jeśli nie można uzyskać powiadomienia, należy użyć <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> przeciążenie metody. Jeśli ta metoda jest wywoływana bez określania upływu limitu czasu, można wywołać <xref:System.GC.CancelFullGCNotification%2A> metodę, jeśli oczekujesz dłużej niż preferowany.  
  
 Wywołanie tej metody, powinien zostać poprzedzony wywołaniem <xref:System.GC.WaitForFullGCApproach%2A> metody, aby upewnić się, mieli pełne wyrzucanie elementów bezużytecznych. Wywołanie tej metody tylko może wygenerować wyniki nieokreślony.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ta metoda służy do określenia, czy pełne wyrzucanie elementów bezużytecznych zostało zakończone. Zawsze, gdy jest w stanie powiadomienia <xref:System.GCNotificationStatus.Succeeded>, metoda użytkownika `OnFullGCCompletedNotify` jest wywoływana w celu wykonania akcji w odpowiedzi na ukończone kolekcji. Ten przykład kodu jest częścią większego przykładu przewidzianego dla [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md) tematu.  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Długość czasu oczekiwania, można uzyskać stanu powiadomień. Określ wartość -1, aby czekać w nieskończoność.</param>
        <summary>Zwraca określony przekroczył limit czasu, stan zarejestrowanego powiadomienia do określenia, czy pełny, blokowanie wyrzucania elementów bezużytecznych za pomocą wspólnego języka środowiska uruchomieniowego została ukończona.</summary>
        <returns>Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.GCNotificationStatus> zwracane przez tę metodę pozwala ustalić stan bieżącego powiadomienia kolekcji wyrzucania elementów, który został zarejestrowany przy użyciu wyliczenia <xref:System.GC.RegisterForFullGCNotification%2A> metody. Można również użyć <xref:System.GC.WaitForFullGCApproach%2A> metodę, aby określić, czy pełne wyrzucanie elementów bezużytecznych jest bezpośrednie.  
  
 Należy zauważyć, że ta metoda zwraca natychmiast zawsze, gdy uzyskany stanu powiadomień kolekcji wyrzucania elementów, bez względu na wartość określoną przez `millisecondsTimeout`. Jeśli stan powiadomień kolekcji wyrzucania elementów nie zostanie osiągnięta przed `millisecondsTimeout` razy, Metoda ta zwraca <xref:System.GCNotificationStatus.NotApplicable>.  
  
 Gdy zwraca wyliczenie <xref:System.GCNotificationStatus.Succeeded>, mogą wykonywać zadania, takie jak wznawiania pracy i uzyskiwanie liczby kolekcji, za pomocą <xref:System.GC.CollectionCount%2A> właściwości.  
  
 Możesz wywołać <xref:System.GC.CancelFullGCNotification%2A> metody, gdy nie można czekać przed upłynięciem limitu czasu minie.  
  
 Wywołanie tej metody, powinien zostać poprzedzony wywołaniem <xref:System.GC.WaitForFullGCApproach%2A> metody, aby upewnić się, mieli pełne wyrzucanie elementów bezużytecznych. Wywołanie tej metody tylko może wygenerować wyniki nieokreślony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="millisecondsTimeout" /> musi być nieujemną lub mniejsze niż lub równe <see cref="F:System.Int32.MaxValue" /> lub wartość -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstrzymuje działanie bieżącego wątku, aż wątek, który przetwarza kolejki finalizatory został opróżniony tej kolejki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy moduł zbierający elementy bezużyteczne wykryje obiektów, które można odzyskać, sprawdza każdy obiekt, aby ustalić wymagania finalizacji obiektu. Jeśli obiekt implementuje finalizator, a nie wyłączył finalizację przez wywołanie metody <xref:System.GC.SuppressFinalize%2A>, obiekt jest umieszczany na liście obiektów oznaczonych jako gotowe do finalizacji. Moduł odśmiecania pamięci wywołuje <xref:System.Object.Finalize%2A> metod dla obiektów w tej liście, a Usuwa wpisy z listy. To bloki metody do wszystkich finalizatory mają zostało ukończone.  
  
 Wątek, na którym są uruchamiane finalizatory jest nieokreślony, więc nie ma żadnej gwarancji, że ta metoda zostanie zakończona. Jednak ten wątek może zostać przerwane przez inny wątek podczas <xref:System.GC.WaitForPendingFinalizers%2A> metoda jest w toku. Na przykład można uruchomić inny wątek, który czeka przez pewien czas, a następnie przerywa działanie tego wątku, jeśli ten wątek jest nadal zawieszone.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.GC.WaitForPendingFinalizers%2A> metodę, aby zawiesić bieżącego wątku, aż do finalizacji zebranych obiektów.  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
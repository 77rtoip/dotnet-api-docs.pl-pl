<Type Name="GC" FullName="System.GC">
  <Metadata><Meta Name="ms.openlocfilehash" Value="be23d111dc399e846c969bd517a2458710d1f961" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58719949" /></Metadata><TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="e8704-101">Określa moduł zbierający elementy bezużyteczne systemu to usługa, która automatycznie odzyskuje nieużywanej pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-101">Controls the system garbage collector, a service that automatically reclaims unused memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-102">Moduł odśmiecania pamięci jest wspólnego składnika środowiska uruchomieniowego języka, który kontroluje przydzielaniem i zwalnianiem pamięci zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="e8704-102">The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</span></span> <span data-ttu-id="e8704-103">Metody tej klasy wpływ podczas wyrzucania elementów bezużytecznych jest wykonywane na obiekcie i są wydawane zasoby przydzielone przez obiekt.</span><span class="sxs-lookup"><span data-stu-id="e8704-103">The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</span></span> <span data-ttu-id="e8704-104">Właściwości tej klasy zawierają informacje o całkowitej ilości dostępnej pamięci w systemie i wiek, kategorii lub generowania ilość pamięci przydzielona do obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8704-104">Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</span></span>  
  
 <span data-ttu-id="e8704-105">Wyrzucanie elementów bezużytecznych śledzi i ponownie wzywa obiekty przydzielone w pamięci zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="e8704-105">The garbage collector tracks and reclaims objects allocated in managed memory.</span></span> <span data-ttu-id="e8704-106">Okresowo moduł zbierający elementy bezużyteczne wykonuje wyrzucanie elementów bezużytecznych w celu odzyskania pamięci przydzielonej do obiektów, dla których nie istnieją żadne prawidłowe odwołania.</span><span class="sxs-lookup"><span data-stu-id="e8704-106">Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</span></span> <span data-ttu-id="e8704-107">Wyrzucanie elementów bezużytecznych odbywa się automatycznie, gdy żądanie pamięci nie mogą być spełnione przy użyciu dostępnej wolnej pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-107">Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</span></span> <span data-ttu-id="e8704-108">Alternatywnie, aplikację można wymusić przy użyciu kolekcji wyrzucania elementów <xref:System.GC.Collect%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-108">Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.</span></span>  
  
 <span data-ttu-id="e8704-109">Wyrzucanie elementów bezużytecznych składa się z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="e8704-109">Garbage collection consists of the following steps:</span></span>  
  
1.  <span data-ttu-id="e8704-110">Moduł zbierający elementy bezużyteczne wyszukuje zarządzanych obiektów, do których istnieją odwołania w kodzie zarządzanym.</span><span class="sxs-lookup"><span data-stu-id="e8704-110">The garbage collector searches for managed objects that are referenced in managed code.</span></span>  
  
2.  <span data-ttu-id="e8704-111">Moduł zbierający elementy bezużyteczne próbuje zakończyć obiektów, które nie są wywoływane.</span><span class="sxs-lookup"><span data-stu-id="e8704-111">The garbage collector tries to finalize objects that are not referenced.</span></span>  
  
3.  <span data-ttu-id="e8704-112">Moduł zbierający elementy bezużyteczne zwalnia obiektów, które nie są wywoływane i odzyskuje ich pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-112">The garbage collector frees objects that are not referenced and reclaims their memory.</span></span>  
  
 <span data-ttu-id="e8704-113">Ten temat zawiera następujące sekcje:</span><span class="sxs-lookup"><span data-stu-id="e8704-113">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="e8704-114">[Moduł odśmiecania pamięci i zasobów niezarządzanych](#unmanaged) </span><span class="sxs-lookup"><span data-stu-id="e8704-114">[The garbage collector and unmanaged resources](#unmanaged) </span></span>  
 <span data-ttu-id="e8704-115">[Obiekt przedawnienia i generacji](#generations) </span><span class="sxs-lookup"><span data-stu-id="e8704-115">[Object aging and generations](#generations) </span></span>  
 [<span data-ttu-id="e8704-116">Nie można przydzielać wyrzucania elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="e8704-116">Disallowing garbage collection</span></span>](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a><span data-ttu-id="e8704-117">Moduł odśmiecania pamięci i zasobów niezarządzanych</span><span class="sxs-lookup"><span data-stu-id="e8704-117">The garbage collector and unmanaged resources</span></span>  
 <span data-ttu-id="e8704-118">Podczas wyrzucania moduł odśmiecania pamięci nie zwolni obiektu, jeśli znajdzie jedno lub więcej odwołań do obiektu w kodzie zarządzanym.</span><span class="sxs-lookup"><span data-stu-id="e8704-118">During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</span></span> <span data-ttu-id="e8704-119">Jednak moduł odśmiecania pamięci nie może rozpoznać odwołania do obiektu z niezarządzanego kodu i mogą zwalniać obiekty, które są używane wyłącznie w przypadku kodu niezarządzanego, chyba że jawnie zabronione w myśl.</span><span class="sxs-lookup"><span data-stu-id="e8704-119">However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</span></span> <span data-ttu-id="e8704-120"><xref:System.GC.KeepAlive%2A> Metoda zapewnia mechanizm, który uniemożliwia zbieranie obiektów, które są nadal używane w niezarządzanym kodzie moduł odśmiecania pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-120">The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</span></span>  
  
 <span data-ttu-id="e8704-121">Oprócz alokacje pamięci zarządzanej implementacji modułu odśmiecania pamięci nie zachowują informacje o zasobach w posiadaniu obiektu, takie jak dojścia do plików lub połączenia z bazą danych.</span><span class="sxs-lookup"><span data-stu-id="e8704-121">Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</span></span> <span data-ttu-id="e8704-122">Gdy typ używa niezarządzane zasoby, które muszą zostać zwolnione wystąpienia tego typu są odzyskiwane, typ może implementować finalizatora.</span><span class="sxs-lookup"><span data-stu-id="e8704-122">When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</span></span>  
  
 <span data-ttu-id="e8704-123">W większości przypadków finalizatory są implementowane przez zastąpienie <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody; jednak typów napisane w języku C# lub C++ implementuje destruktory, w których kompilatory przekształcić w zastąpieniu obiektu <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e8704-123">In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e8704-124">W większości przypadków Jeśli obiekt ma finalizatora, moduł odśmiecania pamięci wywołuje on przed zwalnianie obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8704-124">In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</span></span> <span data-ttu-id="e8704-125">Jednak moduł odśmiecania pamięci nie jest wymagane do wywołania finalizatory we wszystkich sytuacjach; na przykład <xref:System.GC.SuppressFinalize%2A> metoda jawnie zapobiega finalizatora obiektu wywoływana.</span><span class="sxs-lookup"><span data-stu-id="e8704-125">However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called.</span></span> <span data-ttu-id="e8704-126">Ponadto moduł odśmiecania pamięci nie jest wymagany na potrzeby określonego wątku finalize obiektów lub gwarantuje kolejności, w którym finalizatory są nazywane dla obiektów, które zależą od siebie, ale w przeciwnym razie są dostępne do wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-126">Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</span></span>  
  
 <span data-ttu-id="e8704-127">W scenariuszach, w którym zasoby muszą zostać zwolnione w taki sposób, w określonym czasie, można zaimplementować klasy <xref:System.IDisposable> interfejs, który zawiera <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodę, która wykonuje zadania zarządzania i czyszczenie zasobów.</span><span class="sxs-lookup"><span data-stu-id="e8704-127">In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method that performs resource management and cleanup tasks.</span></span> <span data-ttu-id="e8704-128">Klasy, które implementują <xref:System.IDisposable.Dispose%2A> należy określić, w ramach umowy klasy, jeśli klasa konsumentów wywołania metody w celu oczyszczenia obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8704-128">Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</span></span> <span data-ttu-id="e8704-129">Moduł zbierający elementy bezużyteczne, domyślnie niewywołujący <xref:System.IDisposable.Dispose%2A> metoda; jednak implementacje <xref:System.IDisposable.Dispose%2A> metodę można wywołać metody w <xref:System.GC> klasy, aby dostosować zachowanie finalizacji modułu odśmiecania pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-129">The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.</span></span>  
  
 <span data-ttu-id="e8704-130">Aby uzyskać więcej informacji na wzorzec dispose i finalizacja obiektu, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="e8704-130">For more information on object finalization and the dispose pattern, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a><span data-ttu-id="e8704-131">Obiekt przedawnienia i generacji</span><span class="sxs-lookup"><span data-stu-id="e8704-131">Object aging and generations</span></span>  
 <span data-ttu-id="e8704-132">Moduł zbierający elementy bezużyteczne w środowisko uruchomieniowe języka wspólnego obsługuje przestarzałej obiektu przy użyciu generacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-132">The garbage collector in the common language runtime supports object aging using generations.</span></span> <span data-ttu-id="e8704-133">Generowanie jest jednostką miary względnej wiek obiektów w pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-133">A generation is a unit of measure of the relative age of objects in memory.</span></span> <span data-ttu-id="e8704-134">Generowanie liczby lub wieku obiektu wskazuje generacji, do której należy dany obiekt.</span><span class="sxs-lookup"><span data-stu-id="e8704-134">The generation number, or age, of an object indicates the generation to which an object belongs.</span></span> <span data-ttu-id="e8704-135">Obiekty utworzone więcej ostatnio są częścią nowszej generacji i mieć niższych numerach generowania niż cykl obiekty utworzone wcześniej w cyklu życia aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-135">Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</span></span> <span data-ttu-id="e8704-136">Obiekty w najnowszej generacji znajdują się w generacji 0.</span><span class="sxs-lookup"><span data-stu-id="e8704-136">Objects in the most recent generation are in generation 0.</span></span> <span data-ttu-id="e8704-137">Ta implementacja modułu odśmiecania pamięci obsługuje trzy generacje obiektów, generacji 0, 1 i 2.</span><span class="sxs-lookup"><span data-stu-id="e8704-137">This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</span></span> <span data-ttu-id="e8704-138">Można pobrać wartość <xref:System.GC.MaxGeneration%2A> właściwości w celu określenia liczby generacji maksymalny obsługiwany przez system.</span><span class="sxs-lookup"><span data-stu-id="e8704-138">You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.</span></span>  
  
 <span data-ttu-id="e8704-139">Przedawnianie obiekt umożliwia aplikacjom docelowej wyrzucania elementów bezużytecznych na określony zbiór generacje zamiast konieczności moduł odśmiecania pamięci ocenić wszystkie generacje.</span><span class="sxs-lookup"><span data-stu-id="e8704-139">Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</span></span> <span data-ttu-id="e8704-140">Przeciążenia <xref:System.GC.Collect%2A> metody, które obejmują `generation` parametru pozwalają na określenie najstarsze generowania się bezużyteczne.</span><span class="sxs-lookup"><span data-stu-id="e8704-140">Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected.</span></span>  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a><span data-ttu-id="e8704-141">Nie można przydzielać wyrzucania elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="e8704-141">Disallowing garbage collection</span></span>  
 <span data-ttu-id="e8704-142">Począwszy od [!INCLUDE[net_v46](~/includes/net-v46-md.md)], moduł odśmiecania pamięci obsługuje nie GC region opóźnienie trybie który może być używana podczas wykonywania ścieżek krytycznych, w których wyrzucania elementów kolekcji może niekorzystnie wpłynąć na wydajność aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-142">Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</span></span> <span data-ttu-id="e8704-143">Nie GC region opóźnienie tryb wymaga, określ ilość pamięci, która może być przydzielona bez zakłóceń z modułu odśmiecania pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-143">The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</span></span> <span data-ttu-id="e8704-144">Jeśli środowisko uruchomieniowe można przydzielić pamięci, środowisko wykonawcze nie wykonuje wyrzucania elementów bezużytecznych, podczas wykonywania kodu w ścieżce krytycznej.</span><span class="sxs-lookup"><span data-stu-id="e8704-144">If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</span></span>  
  
 <span data-ttu-id="e8704-145">Zdefiniuj początku ścieżki krytycznej, nie regionu GC, wywołując jedną z przeciążeń <xref:System.GC.TryStartNoGCRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="e8704-145">You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>.</span></span> <span data-ttu-id="e8704-146">Określ koniec jego ścieżki krytycznej, wywołując <xref:System.GC.EndNoGCRegion%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-146">You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 <span data-ttu-id="e8704-147">Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, na które powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko wykonawcze jest w trybie opóźnienia w regionie nie GC.</span><span class="sxs-lookup"><span data-stu-id="e8704-147">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="e8704-148">Innymi słowy, nie należy wywołać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania nie powiedzie się), a nie powinni oczekiwać od wywołania <xref:System.GC.EndNoGCRegion%2A> zakończyło się sukcesem, po prostu, ponieważ jest to pierwsze wywołanie do <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e8704-148">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8704-149">W poniższym przykładzie użyto kilka metod odzyskiwania pamięci generacji i informacje o pamięci o bloku nieużywanych obiektów i drukować do konsoli.</span><span class="sxs-lookup"><span data-stu-id="e8704-149">The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</span></span> <span data-ttu-id="e8704-150">Następnie zbieranymi nieużywanych obiektów, a uzyskane sumy pamięci są wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="e8704-150">The unused objects are then collected, and the resulting memory totals are displayed.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md"><span data-ttu-id="e8704-151">Odzyskiwanie pamięci</span><span class="sxs-lookup"><span data-stu-id="e8704-151">Garbage Collection</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="e8704-152">Podstawy dotyczące wyrzucania elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="e8704-152">Fundamentals of Garbage Collection</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated"><span data-ttu-id="e8704-153">Przyrostowe ilość niezarządzanej pamięci, która została przydzielona.</span><span class="sxs-lookup"><span data-stu-id="e8704-153">The incremental amount of unmanaged memory that has been allocated.</span></span></param>
        <summary><span data-ttu-id="e8704-154">Informuje środowisko uruchomieniowe dużych alokacji niezarządzanej pamięci, która powinna być brana pod uwagę podczas planowania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-154">Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-155">Określenie, kiedy należy zaplanować wyrzucania elementów bezużytecznych, środowisko uruchomieniowe bierze pod uwagę ilość pamięci zarządzanej jest przydzielony.</span><span class="sxs-lookup"><span data-stu-id="e8704-155">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="e8704-156">Dużą ilość niezarządzanej pamięci są przydzielane w małych obiektów zarządzanych, środowisko uruchomieniowe uwzględnia pamięci zarządzanej, a zatem szacuje zbyt nisko pilność planowania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-156">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="e8704-157"><xref:System.GC.AddMemoryPressure%2A> Metoda informuje środowisko uruchomieniowe to dodatkowe wykorzystanie pamięci systemu.</span><span class="sxs-lookup"><span data-stu-id="e8704-157">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.</span></span>  
  
 <span data-ttu-id="e8704-158">We wzorcu najprostszy sposób użycia obiektu zarządzanego niezarządzanej pamięci w Konstruktorze przydziela i zwalnia go w `Dispose` lub `Finalize` metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-158">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="e8704-159">Wywołaj <xref:System.GC.AddMemoryPressure%2A> metoda po przydzieleniu niezarządzanej pamięci i wywoływać <xref:System.GC.RemoveMemoryPressure%2A> metody po jego.</span><span class="sxs-lookup"><span data-stu-id="e8704-159">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="e8704-160">W bardziej skomplikowane sytuacje, w którym niezarządzane przydzielanie pamięci znacznie zmienia się w okresie istnienia obiektu zarządzanego, można wywołać <xref:System.GC.AddMemoryPressure%2A> i <xref:System.GC.RemoveMemoryPressure%2A> metody do komunikowania się przyrostowe zmiany środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="e8704-160">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e8704-161">Należy zadbać o usunięcie dokładnie ilość wykorzystanie, które można dodać.</span><span class="sxs-lookup"><span data-stu-id="e8704-161">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="e8704-162">Niepowodzenie w tym może niekorzystnie wpłynąć na wydajność systemu w aplikacjach wykonywanych przez długi czas.</span><span class="sxs-lookup"><span data-stu-id="e8704-162">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e8704-163"><paramref name="bytesAllocated" /> jest mniejsza niż lub równa 0.</span><span class="sxs-lookup"><span data-stu-id="e8704-163"><paramref name="bytesAllocated" /> is less than or equal to 0.</span></span>  
  
<span data-ttu-id="e8704-164">—lub—</span><span class="sxs-lookup"><span data-stu-id="e8704-164">-or-</span></span> 
<span data-ttu-id="e8704-165">Na komputerze 32-bitowych <paramref name="bytesAllocated" /> jest większy niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="e8704-165">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="e8704-166">Aby uzyskać możliwość wywoływać kod niezarządzany, podczas manipulacji priorytet wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-166">for the ability to call unmanaged code when manipulating garbage-collection priority.</span></span> <span data-ttu-id="e8704-167">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="e8704-167">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="e8704-168">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e8704-168">requires full trust for the immediate caller.</span></span> <span data-ttu-id="e8704-169">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="e8704-169">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e8704-170">Anulowanie rejestracji powiadomienia wyrzucania elementów kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e8704-170">Cancels the registration of a garbage collection notification.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-171">Ta metoda anuluje powiadomienie kolekcji wyrzucania elementów, które zostało zarejestrowane przy użyciu <xref:System.GC.RegisterForFullGCNotification%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-171">This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="e8704-172">Nie trzeba wywołać tę metodę przed dostosowaniem progu wartości parametrów w kolejnych wywołaniach <xref:System.GC.RegisterForFullGCNotification%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-172">You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8704-173">Poniższy przykład anuluje rejestracji kolekcji wyrzucania elementów.</span><span class="sxs-lookup"><span data-stu-id="e8704-173">The following example cancels a garbage collection registration.</span></span> <span data-ttu-id="e8704-174">W tym przykładzie jest częścią większego przykładu przewidzianego dla [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md) tematu.</span><span class="sxs-lookup"><span data-stu-id="e8704-174">This example is part of a larger example provided for the [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e8704-175">Ten element członkowski nie jest dostępna, gdy jest włączona współbieżne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-175">This member is not available when concurrent garbage collection is enabled.</span></span> <span data-ttu-id="e8704-176">Zobacz [ &lt;gcconcurrent —&gt; ](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) ustawienia środowiska wykonawczego, aby uzyskać informacje o tym, jak wyłączyć współbieżne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-176">See the [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="e8704-177">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e8704-177">for full trust for the immediate caller.</span></span> <span data-ttu-id="e8704-178">Ten element członkowski nie może być używany przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="e8704-178">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="e8704-179">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e8704-179">requires full trust for the immediate caller.</span></span> <span data-ttu-id="e8704-180">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="e8704-180">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="e8704-181">Powiadomienia dotyczące odzyskiwania pamięci</span><span class="sxs-lookup"><span data-stu-id="e8704-181">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e8704-182">Wymusza wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-182">Forces garbage collection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e8704-183">Wymusza natychmiastowe wyrzucanie elementów bezużytecznych dla wszystkich generacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-183">Forces an immediate garbage collection of all generations.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-184">Ta metoda próbuje odzyskać wszystkie pamięci, który jest niedostępny.</span><span class="sxs-lookup"><span data-stu-id="e8704-184">Use this method to try to reclaim all memory that is inaccessible.</span></span> <span data-ttu-id="e8704-185">Wykonuje blokowania wyrzucania elementów bezużytecznych dla wszystkich generacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-185">It performs a blocking garbage collection of all generations.</span></span>  
  
 <span data-ttu-id="e8704-186">Wszystkie obiekty, niezależnie od tego, ile znajdowały się w pamięci, są traktowane jako kolekcji; obiekty, do których istnieją odwołania w kodzie zarządzanym nie są zbierane.</span><span class="sxs-lookup"><span data-stu-id="e8704-186">All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</span></span> <span data-ttu-id="e8704-187">Ta metoda umożliwia wymuszanie próby odzyskania maksymalną ilość dostępnej pamięci w systemie.</span><span class="sxs-lookup"><span data-stu-id="e8704-187">Use this method to force the system to try to reclaim the maximum amount of available memory.</span></span>  
  
 <span data-ttu-id="e8704-188">Począwszy od [!INCLUDE[net_v451](~/includes/net-v451-md.md)], można kompaktowania sterty dużych obiektów (LOH), ustawiając <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> właściwości <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> przed wywołaniem <xref:System.GC.Collect%2A> metody, w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="e8704-188">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], you can compact the large object heap (LOH) by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="e8704-189">Poniższy przykład pokazuje sposób użycia <xref:System.GC.Collect%2A> metodę, aby przeprowadzić wyrzucanie bezużytecznych na wszystkie generacje pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-189">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on all generations of memory.</span></span> <span data-ttu-id="e8704-190">Kod, który generuje liczby nieużywanych obiektów, a następnie wywołuje <xref:System.GC.Collect%2A> metodę, aby oczyścić je z pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-190">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="e8704-191">Wywołane kolekcje</span><span class="sxs-lookup"><span data-stu-id="e8704-191">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="e8704-192">Liczba najstarsze generowania się bezużyteczne.</span><span class="sxs-lookup"><span data-stu-id="e8704-192">The number of the oldest generation to be garbage collected.</span></span></param>
        <summary><span data-ttu-id="e8704-193">Wymusza natychmiastowe wyrzucanie elementów bezużytecznych z generacji 0 za pomocą określonej generacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-193">Forces an immediate garbage collection from generation 0 through a specified generation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-194">Metoda ta jest przydatna w celu odzyskania pamięci, który jest niedostępny.</span><span class="sxs-lookup"><span data-stu-id="e8704-194">Use this method to try to reclaim memory that is inaccessible.</span></span> <span data-ttu-id="e8704-195">Jednak przy użyciu tej metody nie gwarantuje, że wszystkie pamięci niedostępne w określonej generacji jest odzyskiwane.</span><span class="sxs-lookup"><span data-stu-id="e8704-195">However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="e8704-196">Jeśli zaimplementowano przestarzałej obiektu, moduł odśmiecania pamięci nie są zbierane obiektów z liczbą generacji jest wyższa niż określonej generacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-196">If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</span></span> <span data-ttu-id="e8704-197">Jeśli przestarzałej obiektu nie jest zaimplementowana, moduł odśmiecania pamięci uznaje wszystkich obiektów podczas wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-197">If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</span></span>  
  
 <span data-ttu-id="e8704-198">Użyj <xref:System.GC.MaxGeneration%2A> własność, aby określić prawidłową wartość maksymalna `generation` parametru.</span><span class="sxs-lookup"><span data-stu-id="e8704-198">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of the `generation` parameter.</span></span>  
  
 <span data-ttu-id="e8704-199">Aby uzyskać moduł odśmiecania pamięci, należy wziąć pod uwagę wszystkie obiekty, niezależnie od ich generowania, należy użyć wersji tej metody, która nie przyjmuje żadnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="e8704-199">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span> <span data-ttu-id="e8704-200">Aby moduł zbierający elementy bezużyteczne odzyskać obiektów na podstawie <xref:System.GCCollectionMode> ustawienia, użyj <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-200">To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8704-201">Poniższy przykład pokazuje sposób użycia <xref:System.GC.Collect%2A> metodę, aby przeprowadzić wyrzucanie bezużytecznych na poszczególnych warstw pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-201">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on individual layers of memory.</span></span> <span data-ttu-id="e8704-202">Kod, który generuje liczby nieużywanych obiektów, a następnie wywołuje <xref:System.GC.Collect%2A> metodę, aby oczyścić je z pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-202">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e8704-203"><paramref name="generation" /> nie jest prawidłowy.</span><span class="sxs-lookup"><span data-stu-id="e8704-203"><paramref name="generation" /> is not valid.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="e8704-204">Wywołane kolekcje</span><span class="sxs-lookup"><span data-stu-id="e8704-204">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="e8704-205">Liczba najstarsze generowania się bezużyteczne.</span><span class="sxs-lookup"><span data-stu-id="e8704-205">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="e8704-206">Wartość wyliczenia, który określa, czy wyrzucanie elementów bezużytecznych jest wymuszone (<see cref="F:System.GCCollectionMode.Default" /> lub <see cref="F:System.GCCollectionMode.Forced" />) lub zoptymalizowane pod kątem (<see cref="F:System.GCCollectionMode.Optimized" />).</span><span class="sxs-lookup"><span data-stu-id="e8704-206">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <summary><span data-ttu-id="e8704-207">Wymusza wyrzucania elementów bezużytecznych z generacji 0 za pomocą określonej generacji w czasie określonym przez <see cref="T:System.GCCollectionMode" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="e8704-207">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-208">Użyj `mode` parametru do określenia, czy wyrzucanie elementów bezużytecznych powinna występować bezpośrednio lub tylko jeśli godzina jest optymalna do odzyskania obiektów.</span><span class="sxs-lookup"><span data-stu-id="e8704-208">Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</span></span> <span data-ttu-id="e8704-209">Przy użyciu tej metody nie gwarantuje, że wszystkie pamięci niedostępne w określonej generacji jest odzyskiwane.</span><span class="sxs-lookup"><span data-stu-id="e8704-209">Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="e8704-210">Aby dostosować ingerencję operacji wyrzucania elementów bezużytecznych w krytycznych okresach w aplikacji, należy ustawić <xref:System.Runtime.GCSettings.LatencyMode%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="e8704-210">To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property.</span></span>  
  
 <span data-ttu-id="e8704-211">Moduł odśmiecania pamięci nie są zbierane w obiekty z liczbą generowania nowszej niż określona w `generation` parametru.</span><span class="sxs-lookup"><span data-stu-id="e8704-211">The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter.</span></span> <span data-ttu-id="e8704-212">Użyj <xref:System.GC.MaxGeneration%2A> własność, aby określić prawidłową wartość maksymalna `generation`.</span><span class="sxs-lookup"><span data-stu-id="e8704-212">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`.</span></span>  
  
 <span data-ttu-id="e8704-213">Aby uzyskać moduł odśmiecania pamięci, należy wziąć pod uwagę wszystkie obiekty, niezależnie od ich generowania, należy użyć wersji tej metody, która nie przyjmuje żadnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="e8704-213">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span>  
  
 <span data-ttu-id="e8704-214">Aby moduł zbierający elementy bezużyteczne odzyskać obiekty do określonej generacji obiektów, należy użyć <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-214">To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="e8704-215">Po określeniu generacji maksymalny, wszystkie obiekty są zbierane.</span><span class="sxs-lookup"><span data-stu-id="e8704-215">When you specify the maximum generation, all objects are collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8704-216">Poniższy przykład wymusza wyrzucania elementów bezużytecznych generacji 2 obiektów za pomocą <xref:System.GCCollectionMode.Optimized> ustawienie.</span><span class="sxs-lookup"><span data-stu-id="e8704-216">The following example forces a garbage collection for generation 2 objects with the <xref:System.GCCollectionMode.Optimized> setting.</span></span>  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e8704-217"><paramref name="generation" /> nie jest prawidłowy.</span><span class="sxs-lookup"><span data-stu-id="e8704-217"><paramref name="generation" /> is not valid.</span></span>  
  
<span data-ttu-id="e8704-218">—lub—</span><span class="sxs-lookup"><span data-stu-id="e8704-218">-or-</span></span> 
 <span data-ttu-id="e8704-219"><paramref name="mode" /> nie jest jednym z <see cref="T:System.GCCollectionMode" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="e8704-219"><paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="e8704-220">Wywołane kolekcje</span><span class="sxs-lookup"><span data-stu-id="e8704-220">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="e8704-221">Liczba najstarsze generowania się bezużyteczne.</span><span class="sxs-lookup"><span data-stu-id="e8704-221">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="e8704-222">Wartość wyliczenia, który określa, czy wyrzucanie elementów bezużytecznych jest wymuszone (<see cref="F:System.GCCollectionMode.Default" /> lub <see cref="F:System.GCCollectionMode.Forced" />) lub zoptymalizowane pod kątem (<see cref="F:System.GCCollectionMode.Optimized" />).</span><span class="sxs-lookup"><span data-stu-id="e8704-222">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <param name="blocking"><span data-ttu-id="e8704-223"><see langword="true" /> do blokowania wyrzucania elementów bezużytecznych; <see langword="false" /> przeprowadzić tle wyrzucania elementów bezużytecznych, jeśli jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="e8704-223"><see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span></span></param>
        <summary><span data-ttu-id="e8704-224">Wymusza wyrzucania elementów bezużytecznych z generacji 0 za pomocą określonej generacji w czasie określonym przez <see cref="T:System.GCCollectionMode" /> wartością wartość określającą, czy kolekcja powinny blokować.</span><span class="sxs-lookup"><span data-stu-id="e8704-224">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with a value specifying whether the collection should be blocking.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-225">Poniższa tabela podsumowuje interakcje `mode` i `blocking` parametry:</span><span class="sxs-lookup"><span data-stu-id="e8704-225">The following table summarizes the interaction of the `mode` and `blocking` parameters:</span></span>  
  
|`mode`|<span data-ttu-id="e8704-226">`blocking` jest `true`</span><span class="sxs-lookup"><span data-stu-id="e8704-226">`blocking` is `true`</span></span>|<span data-ttu-id="e8704-227">`blocking` jest `false`</span><span class="sxs-lookup"><span data-stu-id="e8704-227">`blocking` is `false`</span></span>|  
|-|-|-|  
|<span data-ttu-id="e8704-228"><xref:System.GCCollectionMode.Forced> lub <xref:System.GCCollectionMode.Default></span><span class="sxs-lookup"><span data-stu-id="e8704-228"><xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default></span></span>|<span data-ttu-id="e8704-229">Blokowanie kolekcji jest wykonywane tak szybko, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="e8704-229">A blocking collection is performed as soon as possible.</span></span> <span data-ttu-id="e8704-230">Jeśli zbieranie w tle jest w toku i `generation` jest równa 0 lub 1, <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> metoda natychmiast wyzwala zbieranie blokujące i zwraca po zakończeniu zbierania.</span><span class="sxs-lookup"><span data-stu-id="e8704-230">If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished.</span></span> <span data-ttu-id="e8704-231">Jeśli zbieranie w tle jest w toku i `generation` 2, metoda czeka, dopóki nie zakończy bezużytecznych w tle, wyzwala zbieranie blokujące 2. generacji, a następnie zwraca.</span><span class="sxs-lookup"><span data-stu-id="e8704-231">If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</span></span>|<span data-ttu-id="e8704-232">Kolekcja jest wykonywana tak szybko, jak to możliwe.</span><span class="sxs-lookup"><span data-stu-id="e8704-232">A collection is performed as soon as possible.</span></span> <span data-ttu-id="e8704-233"><xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> Metoda żąda kolekcja tła, ale nie jest to gwarantowane; w zależności od okoliczności nadal może być wykonywana kolekcja blokowania.</span><span class="sxs-lookup"><span data-stu-id="e8704-233">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="e8704-234">Jeśli zbieranie w tle jest już w toku, metoda zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="e8704-234">If a background collection is already in progress, the method returns immediately.</span></span>|  
|<xref:System.GCCollectionMode.Optimized>|<span data-ttu-id="e8704-235">Blokowanie kolekcji mogą być wykonywane w zależności od stanu modułu odśmiecania pamięci i `generation` parametru.</span><span class="sxs-lookup"><span data-stu-id="e8704-235">A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter.</span></span> <span data-ttu-id="e8704-236">Wyrzucanie elementów bezużytecznych stara się zapewnić optymalną wydajność.</span><span class="sxs-lookup"><span data-stu-id="e8704-236">The garbage collector tries to provide optimal performance.</span></span>|<span data-ttu-id="e8704-237">Kolekcja może być wykonywana w zależności od stanu modułu odśmiecania pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-237">A collection may be performed, depending on the state of the garbage collector.</span></span> <span data-ttu-id="e8704-238"><xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> Metoda żąda kolekcja tła, ale nie jest to gwarantowane; w zależności od okoliczności nadal może być wykonywana kolekcja blokowania.</span><span class="sxs-lookup"><span data-stu-id="e8704-238">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="e8704-239">Wyrzucanie elementów bezużytecznych stara się zapewnić optymalną wydajność.</span><span class="sxs-lookup"><span data-stu-id="e8704-239">The garbage collector tries to provide optimal performance.</span></span> <span data-ttu-id="e8704-240">Jeśli zbieranie w tle jest już w toku, metoda zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="e8704-240">If a background collection is already in progress, the method returns immediately.</span></span>|  
  
 <span data-ttu-id="e8704-241">Jeśli wywołanie <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> metoda wykonuje pełne blokowanie wyrzucania elementów bezużytecznych, możesz również skompaktować stertę dużego obiektu przez ustawienie <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> właściwości <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> przed wywołaniem <xref:System.GC.Collect%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-241">If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e8704-242"><paramref name="generation" /> nie jest prawidłowy.</span><span class="sxs-lookup"><span data-stu-id="e8704-242"><paramref name="generation" /> is not valid.</span></span>  
  
<span data-ttu-id="e8704-243">—lub—</span><span class="sxs-lookup"><span data-stu-id="e8704-243">-or-</span></span> 
 <span data-ttu-id="e8704-244"><paramref name="mode" /> nie jest jednym z <see cref="T:System.GCCollectionMode" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="e8704-244"><paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="compacting" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="e8704-245">Liczba najstarsze generowania się bezużyteczne.</span><span class="sxs-lookup"><span data-stu-id="e8704-245">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="e8704-246">Wartość wyliczenia, który określa, czy wyrzucanie elementów bezużytecznych jest wymuszone (<see cref="F:System.GCCollectionMode.Default" /> lub <see cref="F:System.GCCollectionMode.Forced" />) lub zoptymalizowane pod kątem (<see cref="F:System.GCCollectionMode.Optimized" />).</span><span class="sxs-lookup"><span data-stu-id="e8704-246">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <param name="blocking"><span data-ttu-id="e8704-247"><see langword="true" /> do blokowania wyrzucania elementów bezużytecznych; <see langword="false" /> przeprowadzić tle wyrzucania elementów bezużytecznych, jeśli jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="e8704-247"><see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span></span></param>
        <param name="compacting"><span data-ttu-id="e8704-248"><see langword="true" /> kompaktowanie stosu małych obiektów; <see langword="false" /> do tylko odchylenia.</span><span class="sxs-lookup"><span data-stu-id="e8704-248"><see langword="true" /> to compact the small object heap; <see langword="false" /> to sweep only.</span></span></param>
        <summary><span data-ttu-id="e8704-249">Wymusza wyrzucania elementów bezużytecznych z generacji 0 za pomocą określonej generacji w czasie określonym przez <see cref="T:System.GCCollectionMode" /> wartość z wartościami, które określają, czy blokowanie i kompaktowanie kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e8704-249">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with values that specify whether the collection should be blocking and compacting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-250">Jeśli `blocking` jest `false`, GC decyduje, czy ma być przeprowadzane w tle lub blokowanie wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-250">If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection.</span></span> <span data-ttu-id="e8704-251">Jeśli `compacting` jest `true`, wykonuje blokowania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-251">If `compacting` is `true`, it performs a blocking garbage collection.</span></span>  
  
 <span data-ttu-id="e8704-252">Jeśli `compacting` jest `true`, środowisko uruchomieniowe kompaktuje stos małych obiektów (raportu o kondycji).</span><span class="sxs-lookup"><span data-stu-id="e8704-252">If `compacting` is `true`, the runtime compacts the small object heap (SOH).</span></span> <span data-ttu-id="e8704-253">Stos dużych obiektów (LOH) nie jest kompaktowana, chyba że <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> właściwość jest ustawiona na <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e8704-253">The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e8704-254">Należy pamiętać, że w tym wszystkie blokowania wyrzucania elementów bezużytecznych, nie tylko pełne blokowanie wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-254">Note that this includes all blocking garbage collections, not just full blocking garbage collections.</span></span>  
  
 <span data-ttu-id="e8704-255">Możesz wywołać <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> metodę, aby zmniejszyć sterty zarządzanej na najmniejszą możliwą rozmiar, tak jak pokazano w poniższy fragment kodu.</span><span class="sxs-lookup"><span data-stu-id="e8704-255">You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</span></span>  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 <span data-ttu-id="e8704-256">Określanie `true` dla `compacting` argument gwarantuje kompaktowania, pełny blokowania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-256">Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection.</span></span> <span data-ttu-id="e8704-257">Ustawienie <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> właściwość <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> zapewnia skompaktować LOH i raportu o kondycji.</span><span class="sxs-lookup"><span data-stu-id="e8704-257">Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> ensures that both the LOH and SOH are compacted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="e8704-258">Generowanie obiektów, dla których ma być oznaczona liczba kolekcji wyrzucania elementów.</span><span class="sxs-lookup"><span data-stu-id="e8704-258">The generation of objects for which the garbage collection count is to be determined.</span></span></param>
        <summary><span data-ttu-id="e8704-259">Zwraca liczbę przypadków, gdy wystąpiło wyrzucania elementów bezużytecznych dla określonej generacji obiektów.</span><span class="sxs-lookup"><span data-stu-id="e8704-259">Returns the number of times garbage collection has occurred for the specified generation of objects.</span></span></summary>
        <returns><span data-ttu-id="e8704-260">Liczba przypadków, gdy wystąpił wyrzucania elementów bezużytecznych dla określonej generacji, ponieważ proces został uruchomiony.</span><span class="sxs-lookup"><span data-stu-id="e8704-260">The number of times garbage collection has occurred for the specified generation since the process was started.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-261">W przypadku zastosowania zarządzania zasobów, konieczne może być okresowo wymuszenia wyrzucania elementów bezużytecznych przez wywołanie metody <xref:System.GC.Collect%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-261">If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="e8704-262">Ponieważ jest kosztowną operacją, może poprawić wydajność, pomijając wywołania, jeśli ostatnio nastąpiła wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-262">Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</span></span> <span data-ttu-id="e8704-263">Zapisz wartość zwrócona przez obiekt <xref:System.GC.CollectionCount%2A> natychmiast po wywołaniu <xref:System.GC.Collect%2A>.</span><span class="sxs-lookup"><span data-stu-id="e8704-263">Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>.</span></span> <span data-ttu-id="e8704-264">Następnym razem, należy wywołać <xref:System.GC.Collect%2A>, porównanie bieżącej wartości zwracanej przez <xref:System.GC.CollectionCount%2A> zapisane wartości.</span><span class="sxs-lookup"><span data-stu-id="e8704-264">The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value.</span></span> <span data-ttu-id="e8704-265">Jeśli dwie wartości są równe, w międzyczasie wystąpił nie kolekcji i można wywołać <xref:System.GC.Collect%2A> ponownie.</span><span class="sxs-lookup"><span data-stu-id="e8704-265">If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e8704-266"><paramref name="generation" /> jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="e8704-266"><paramref name="generation" /> is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e8704-267">Kończy się nie GC region opóźnienia w trybie.</span><span class="sxs-lookup"><span data-stu-id="e8704-267">Ends the no GC region latency mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-268"><xref:System.GC.EndNoGCRegion%2A> Metoda zgłasza wyjątek <xref:System.InvalidOperationException> Jeśli moduł odśmiecania pamięci nie jest w trybie opóźnienia w regionie nie GC.</span><span class="sxs-lookup"><span data-stu-id="e8704-268">The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode.</span></span> <span data-ttu-id="e8704-269">Dzieje się w żadnej z następujących warunków:</span><span class="sxs-lookup"><span data-stu-id="e8704-269">This occurs under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="e8704-270"><xref:System.GC.TryStartNoGCRegion%2A> Nie wywołano metody wcześniej.</span><span class="sxs-lookup"><span data-stu-id="e8704-270">The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously.</span></span>  
  
-   <span data-ttu-id="e8704-271">Wywołanie <xref:System.GC.TryStartNoGCRegion%2A> zwróconej metody `false`.</span><span class="sxs-lookup"><span data-stu-id="e8704-271">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method returned `false`.</span></span>  
  
-   <span data-ttu-id="e8704-272">Wywołanie <xref:System.GC.TryStartNoGCRegion%2A> metoda wywołała wyjątek.</span><span class="sxs-lookup"><span data-stu-id="e8704-272">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception.</span></span>  
  
 <span data-ttu-id="e8704-273">Aby zapobiec wyjątkowi dla każdego z tych powodów, przy użyciu kodu, takie jak następujące:</span><span class="sxs-lookup"><span data-stu-id="e8704-273">You can prevent an exception for any of these reasons by using code such as the following:</span></span>  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e8704-274">Moduł odśmiecania pamięci nie jest w trybie opóźnienia w regionie nie GC.</span><span class="sxs-lookup"><span data-stu-id="e8704-274">The garbage collector is not in no GC region latency mode.</span></span>  
  
<span data-ttu-id="e8704-275">—lub—</span><span class="sxs-lookup"><span data-stu-id="e8704-275">-or-</span></span> 
<span data-ttu-id="e8704-276">Nie GC region opóźnienia w trybie zostało wcześniej zakończone, ponieważ wyrzucania elementów bezużytecznych zostało wywołane.</span><span class="sxs-lookup"><span data-stu-id="e8704-276">The no GC region latency mode was ended previously because a garbage collection was induced.</span></span>  
  
<span data-ttu-id="e8704-277">—lub—</span><span class="sxs-lookup"><span data-stu-id="e8704-277">-or-</span></span> 
<span data-ttu-id="e8704-278">Alokacja pamięci przekracza wartość określoną w wywołaniu <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-278">A memory allocation exceeded the amount specified in the call to the <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> method.</span></span></exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="e8704-279">Tryby opóźnienia</span><span class="sxs-lookup"><span data-stu-id="e8704-279">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e8704-280">Pobiera liczba bajtów przydzielonych w bieżącym wątku od początku jego okres istnienia.</span><span class="sxs-lookup"><span data-stu-id="e8704-280">Gets the total number of bytes allocated to the current thread since the beginning of its lifetime.</span></span></summary>
        <returns><span data-ttu-id="e8704-281">Całkowita liczba bajtów przydzielonych w bieżącym wątku od początku jego okres istnienia.</span><span class="sxs-lookup"><span data-stu-id="e8704-281">The total number of bytes allocated to the current thread since the beginning of its lifetime.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="e8704-282">`GetAllocatedBytesForCurrentThread` Metoda zwróci wartość całkowita liczba bajtów przydzielonych w zarządzanym stosie, w okresie istnienia wątku, a nie całkowita liczba bajtów, które przetrwały wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-282">The `GetAllocatedBytesForCurrentThread` method returns the total number of bytes allocated on the managed heap during the lifetime of a thread, not the total number of bytes that have survived garbage collection.</span></span> <span data-ttu-id="e8704-283">Zwracana wartość nie zawiera również natywnych alokacje.</span><span class="sxs-lookup"><span data-stu-id="e8704-283">The returned value also does not include any native allocations.</span></span>

<span data-ttu-id="e8704-284">Ta metoda jest najbardziej przydatne podczas monitorowania scenariuszy do mierzenia różnicy w alokacji pamięci odstępach czasu lub zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="e8704-284">This method is most useful in monitoring scenarios for measuring the difference in memory allocation between time intervals or events.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e8704-285">Zwraca numer bieżącej generacji obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8704-285">Returns the current generation number of an object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e8704-286">Obiekt, który generowania informacje są pobierane dla.</span><span class="sxs-lookup"><span data-stu-id="e8704-286">The object that generation information is retrieved for.</span></span></param>
        <summary><span data-ttu-id="e8704-287">Zwraca numer bieżącej generacji określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8704-287">Returns the current generation number of the specified object.</span></span></summary>
        <returns><span data-ttu-id="e8704-288">Numer bieżącej generacji <paramref name="obj" />.</span><span class="sxs-lookup"><span data-stu-id="e8704-288">The current generation number of <paramref name="obj" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-289">Ta metoda służy do określenia wieku obiektu, a następnie użyć tych informacji z <xref:System.GC.Collect%2A> metodę wymuszania moduł odśmiecania pamięci, aby zebrać obiektów w tej samej generacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-289">Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation.</span></span> <span data-ttu-id="e8704-290">Na przykład użyć tej metody, gdy masz zestaw obiektów, które są tworzone jako grupą i które stały się niedostępne w tym samym czasie.</span><span class="sxs-lookup"><span data-stu-id="e8704-290">For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8704-291">Poniższy przykład pokazuje sposób użycia <xref:System.GC.GetGeneration%2A> metodę pozwala ustalić okres ważności obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8704-291">The following example demonstrates how to use the <xref:System.GC.GetGeneration%2A> method to determine the age of an object.</span></span> <span data-ttu-id="e8704-292">Przykład następnie wykonuje wyrzucania elementów bezużytecznych do wyczyszczenia pamięci sortujące i porównujące wstępnie — Opublikuj kolekcję sum pamięci w konsoli.</span><span class="sxs-lookup"><span data-stu-id="e8704-292">The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="wo"><span data-ttu-id="e8704-293">A <see cref="T:System.WeakReference" /> odwołujący się do obiektu docelowego, którego numer generacja zostanie określony.</span><span class="sxs-lookup"><span data-stu-id="e8704-293">A <see cref="T:System.WeakReference" /> that refers to the target object whose generation number is to be determined.</span></span></param>
        <summary><span data-ttu-id="e8704-294">Zwraca numer bieżącej generacji celem określone odwołanie słabe.</span><span class="sxs-lookup"><span data-stu-id="e8704-294">Returns the current generation number of the target of a specified weak reference.</span></span></summary>
        <returns><span data-ttu-id="e8704-295">Numer bieżącej generacji celem <paramref name="wo" />.</span><span class="sxs-lookup"><span data-stu-id="e8704-295">The current generation number of the target of <paramref name="wo" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e8704-296">W poniższym przykładzie pokazano użycie <xref:System.GC.GetGeneration%2A> metodę pozwala ustalić okres ważności obiektu słabe odwołanie.</span><span class="sxs-lookup"><span data-stu-id="e8704-296">The following example demonstrates the use of the <xref:System.GC.GetGeneration%2A> method to determine the age of a weak reference object.</span></span>  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e8704-297">Wyrzucanie elementów bezużytecznych została już wykonana na <paramref name="wo" />.</span><span class="sxs-lookup"><span data-stu-id="e8704-297">Garbage collection has already been performed on <paramref name="wo" />.</span></span></exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection"><span data-ttu-id="e8704-298"><see langword="true" /> Aby wskazać, że ta metoda może oczekiwać wyrzucanie elementów bezużytecznych przed zwróceniem; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e8704-298"><see langword="true" /> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="e8704-299">Pobiera liczbę bajtów, które obecnie traktować do przydzielenia.</span><span class="sxs-lookup"><span data-stu-id="e8704-299">Retrieves the number of bytes currently thought to be allocated.</span></span> <span data-ttu-id="e8704-300">Parametr wskazuje, czy ta metoda może czekać przez krótki czas przed zwróceniem, aby zezwolić na zbieranie pamięci i zakończyć obiektów systemu.</span><span class="sxs-lookup"><span data-stu-id="e8704-300">A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</span></span></summary>
        <returns><span data-ttu-id="e8704-301">Liczba, która jest dostępna najlepiej zbliżenia liczbę aktualnie przydzielonych bajtów w pamięci zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="e8704-301">A number that is the best available approximation of the number of bytes currently allocated in managed memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-302">Jeśli `forceFullCollection` parametr jest `true`, ta metoda czeka przez krótki czas przed zwróceniem systemu umożliwia zbieranie informacji o pamięci i kończenie znajdujących się w obiektach.</span><span class="sxs-lookup"><span data-stu-id="e8704-302">If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects.</span></span> <span data-ttu-id="e8704-303">Długość interwału jest wewnętrznie określony limit określana przez liczbę cykli kolekcji wyrzucania elementów ukończone i zmiana ilości pamięci odzyskana między cykle.</span><span class="sxs-lookup"><span data-stu-id="e8704-303">The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</span></span> <span data-ttu-id="e8704-304">Moduł odśmiecania pamięci nie gwarantuje zbierane wszystkie pamięci niedostępne.</span><span class="sxs-lookup"><span data-stu-id="e8704-304">The garbage collector does not guarantee that all inaccessible memory is collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8704-305">Poniższy przykład pokazuje sposób użycia <xref:System.GC.GetTotalMemory%2A> metodę, aby pobrać i wyświetlić liczbę aktualnie przydzielonych bajtów w pamięci zarządzanej.</span><span class="sxs-lookup"><span data-stu-id="e8704-305">The following example demonstrates how to use the <xref:System.GC.GetTotalMemory%2A> method to get and display the number of bytes currently allocated in managed memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e8704-306">Obiekt do odwołania.</span><span class="sxs-lookup"><span data-stu-id="e8704-306">The object to reference.</span></span></param>
        <summary><span data-ttu-id="e8704-307">Odwołuje się do określonego obiektu, dzięki czemu nie kwalifikuje się do wyrzucania elementów bezużytecznych od początku bieżącego procedury do punktu, w którym ta metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="e8704-307">References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-308">Celem <xref:System.GC.KeepAlive%2A> metodą jest zapewnić istnienie odwołania do obiektu, który jest zagrożona przez przedwcześnie są odzyskiwane przez moduł odśmiecania pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-308">The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</span></span> <span data-ttu-id="e8704-309">Jest to typowy scenariusz, w którym może się to zdarzyć, istnieją żadnych odwołań do obiektu w kodzie zarządzanym lub danych, kiedy obiekt jest nadal używany w niezarządzanym kodzie, takich jak interfejsy API systemu Win32, niezarządzanych bibliotek DLL, lub metody za pomocą modelu COM.</span><span class="sxs-lookup"><span data-stu-id="e8704-309">A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.</span></span>  
  
 <span data-ttu-id="e8704-310">Odwołuje się ta metoda `obj` parametru, dzięki czemu ten obiekt nie kwalifikuje się do wyrzucania elementów bezużytecznych od samego początku procedury do punktu, w kolejności wykonywania której ta metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="e8704-310">This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</span></span> <span data-ttu-id="e8704-311">Kod tej metody, na końcu, a nie początku zakresu instrukcje gdzie `obj` muszą być dostępne.</span><span class="sxs-lookup"><span data-stu-id="e8704-311">Code this method at the end, not the beginning, of the range of instructions where `obj` must be available.</span></span>  
  
 <span data-ttu-id="e8704-312"><xref:System.GC.KeepAlive%2A> Metoda nie wykonuje żadnej operacji i tworzy żadnych efektów ubocznych niż rozszerzanie okresu istnienia obiektu przekazany jako parametr.</span><span class="sxs-lookup"><span data-stu-id="e8704-312">The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8704-313">Poniższy przykład kodu tworzy obiekt na początku jego `Main` metody i nie odwołuje się do obiektu ponownie do czasu zakończenia, gdy <xref:System.GC.KeepAlive%2A> metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="e8704-313">The following code example creates an object at the beginning of its `Main` method and does not refer to the object again until the end, when the <xref:System.GC.KeepAlive%2A> method is called.</span></span> <span data-ttu-id="e8704-314">Obiekt będzie nadal występować po 30 sekund czasu trwania `Main` metody, niezależnie od wywołania <xref:System.GC.Collect%2A> i <xref:System.GC.WaitForPendingFinalizers%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-314">The object persists for the 30-second duration of the `Main` method, despite calls to the <xref:System.GC.Collect%2A> and <xref:System.GC.WaitForPendingFinalizers%2A> methods.</span></span>  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e8704-315">Pobiera maksymalną liczbę generacje, które obsługuje obecnie system.</span><span class="sxs-lookup"><span data-stu-id="e8704-315">Gets the maximum number of generations that the system currently supports.</span></span></summary>
        <value><span data-ttu-id="e8704-316">Wartość z zakresu od 0 do maksymalną liczbę obsługiwanych generacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-316">A value that ranges from zero to the maximum number of supported generations.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-317">Generowanie liczby lub wieku obiektu jest zdefiniowane w implementacji Względna miara obiektu życia.</span><span class="sxs-lookup"><span data-stu-id="e8704-317">The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</span></span> <span data-ttu-id="e8704-318">Ostatnio utworzone obiekty są w generacji 0 i najstarsze obiekty w generacji mniejsze niż lub równe Generowanie zwróconych przez <xref:System.GC.MaxGeneration%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="e8704-318">The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.</span></span>  
  
 <span data-ttu-id="e8704-319">Moduł zbierający elementy bezużyteczne przyjęto założenie, czy nowszej pamięci jest bardziej prawdopodobne zakwalifikować się do wyrzucania elementów bezużytecznych niż starsze pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-319">The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</span></span> <span data-ttu-id="e8704-320">W związku z tym, moduł odśmiecania pamięci zwiększa jego wydajność, dostosowując generowania liczb każdorazowo odzyskuje pamięć, a <xref:System.GC.MaxGeneration%2A> wartość właściwości może rosnąć wraz z upływem czasu.</span><span class="sxs-lookup"><span data-stu-id="e8704-320">Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.</span></span>  
  
 <span data-ttu-id="e8704-321">Jeśli obiekt przestarzałej jest zaimplementowana, <xref:System.GC.MaxGeneration%2A> właściwość zwraca liczbę maksymalną generowania używaną przez system; w przeciwnym razie ta właściwość zwraca wartość zero.</span><span class="sxs-lookup"><span data-stu-id="e8704-321">If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8704-322">Poniższy przykład pokazuje, jak użyć właściwości MaxGeneration, aby wyświetlić największa liczba generacji obecnie w użyciu.</span><span class="sxs-lookup"><span data-stu-id="e8704-322">The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="e8704-323">Dla tej implementacji wartość zwracana przez <see cref="P:System.GC.MaxGeneration" /> właściwość jest gwarantowane, pozostaje niezmienna przez okres istnienia realizowanej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-323">For this implementation, the value returned by the <see cref="P:System.GC.MaxGeneration" /> property is guaranteed to remain constant for the lifetime of an executing application.</span></span>  
  
<span data-ttu-id="e8704-324">Użyj <see cref="P:System.GC.MaxGeneration" /> właściwość, aby określić maksymalną wartość można określić podczas wywoływania <see cref="M:System.GC.Collect(System.Int32)" /> metody, która przyjmuje parametr generacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-324">Use the <see cref="P:System.GC.MaxGeneration" /> property to determine the maximum value you can specify when calling the <see cref="M:System.GC.Collect(System.Int32)" /> method that takes a generation parameter.</span></span></para></block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold"><span data-ttu-id="e8704-325">Liczbą z zakresu od 1 do 99 określający, kiedy powinien być wywoływany powiadomienia na podstawie obiekty przydzielone w generacji 2.</span><span class="sxs-lookup"><span data-stu-id="e8704-325">A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</span></span></param>
        <param name="largeObjectHeapThreshold"><span data-ttu-id="e8704-326">Liczbą z zakresu od 1 do 99 określający, kiedy powinien być wywoływany powiadomienia na podstawie obiekty przydzielone w stosie dużego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8704-326">A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</span></span></param>
        <summary><span data-ttu-id="e8704-327">Określa, że powiadomienie kolekcji wyrzucania elementów powinien być wywoływany w przypadku, gdy warunki Preferuj pełne wyrzucanie elementów bezużytecznych i kiedy kolekcji zostały ukończone.</span><span class="sxs-lookup"><span data-stu-id="e8704-327">Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-328">Dla każdej generacji moduł zbierający elementy bezużyteczne ustawia próg alokacji w tej generacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-328">For each generation, the garbage collector sets a threshold for allocations into that generation.</span></span> <span data-ttu-id="e8704-329">Gdy rozmiar alokacji przekracza wartość progowa, wyrzucanie elementów bezużytecznych jest wyzwalana dla tej generacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-329">When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</span></span> <span data-ttu-id="e8704-330">Aby uzyskać przykład, jeśli próg generacji 2 jest o rozmiarze 20MB (co oznacza, że o rozmiarze 20MB przeżyje kolekcji generacji 1 i są promowane do generacji 2) i więcej niż 20MB ma przetrwały generacji 1 i zostanie poproszony w generacji 2, zostanie podjęta próba następnego wyrzucania elementów bezużytecznych jako kolekcji generacji 2.</span><span class="sxs-lookup"><span data-stu-id="e8704-330">For example, if generation 2's threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</span></span> <span data-ttu-id="e8704-331">Podobnie jeśli sterty dużych obiektów (LOH) próg wynosi 20MB i aplikację przydzieliła więcej niż 20MB pamięci dużych obiektów, następnego wyrzucania elementów bezużytecznych zostanie również podjęta jako kolekcji generacji 2 (ponieważ LOH są zbierane w gen2 wyrzucania elementów bezużytecznych).</span><span class="sxs-lookup"><span data-stu-id="e8704-331">Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</span></span>  
  
 <span data-ttu-id="e8704-332">`maxGenerationThreshold` i `largeObjectHeapThreshold` progi kontrolować, ile wcześniej otrzymasz powiadomienie, zanim wystąpi pełne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-332">The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs.</span></span> <span data-ttu-id="e8704-333">Wyższa wartość progową, więcej przydziały, które mogą wystąpić między powiadomienia i dalej pełne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-333">The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</span></span>  
  
 <span data-ttu-id="e8704-334">W przypadku sytuacji, w których pełne wyrzucanie elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego może niekorzystnie wpłynąć na wydajność aplikacji, możesz poprosić otrzymywać powiadomienia, gdy środowisko uruchomieniowe ma pełną wyrzucania elementów bezużytecznych i obejście tej kolekcji przez wykonuje kolekcję, samodzielnie (przy użyciu <xref:System.GC.Collect%2A> metoda) Jeśli warunki są nadal pozytywnych.</span><span class="sxs-lookup"><span data-stu-id="e8704-334">If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable.</span></span> <span data-ttu-id="e8704-335">Validated harmonogramy zbierania śmieci samodzielnie, pełne powiadomienie GC przydaje się w poniższych scenariuszach:</span><span class="sxs-lookup"><span data-stu-id="e8704-335">In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</span></span>  
  
-   <span data-ttu-id="e8704-336">Możesz monitorować podejście pełne odśmiecanie, i po wyświetleniu powiadomienia, że zbliża się jeden, zmniejszyć rozmiar danych na żywo (na przykład dzięki niektóre wpisy w pamięci podręcznej).</span><span class="sxs-lookup"><span data-stu-id="e8704-336">You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</span></span> <span data-ttu-id="e8704-337">W rezultacie po wystąpieniu wyrzucania elementów bezużytecznych jest w stanie odzyskać większej ilości pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-337">As a result, when the garbage collection occurs, it is able to reclaim more memory.</span></span>  
  
-   <span data-ttu-id="e8704-338">Możesz monitorować zakończenia pełne odśmiecanie, tak, aby zbierać statystykami.</span><span class="sxs-lookup"><span data-stu-id="e8704-338">You monitor for the completion of a full garbage collection so that you can collect some statistics.</span></span>  <span data-ttu-id="e8704-339">Na przykład można mierzyć rozmiar sterty po ukończeniu odzyskiwania pamięci, dzięki czemu będzie wiadomo, rozmiar danych na żywo.</span><span class="sxs-lookup"><span data-stu-id="e8704-339">For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</span></span> <span data-ttu-id="e8704-340">(Po pełną operacją GC sterty jest na najmniejszy).</span><span class="sxs-lookup"><span data-stu-id="e8704-340">(After a full GC, the heap is at its smallest size.)</span></span>  
  
 <span data-ttu-id="e8704-341">Aby uzyskać więcej informacji na temat co reprezentuje pełne odśmiecanie, zobacz [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md).</span><span class="sxs-lookup"><span data-stu-id="e8704-341">For more information about what represents a full garbage collection, see [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md).</span></span>  
  
 <span data-ttu-id="e8704-342">Po zarejestrowaniu powiadomienia kolekcji wyrzucania elementów, możesz otrzymać, gdy zbliża się pełne wyrzucanie elementów bezużytecznych, a po jego zakończeniu.</span><span class="sxs-lookup"><span data-stu-id="e8704-342">When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</span></span> <span data-ttu-id="e8704-343">Ten wzorzec jest podobny, jak system operacyjny monitoruje dla powiadomień o małej ilości pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-343">This pattern resembles how the operating system monitors for low memory notifications.</span></span>  
  
 <span data-ttu-id="e8704-344">Skorzystaj z poniższych wskazówek w celu określania `maxGenerationThreshold` i `largeObjectHeapThreshold` parametry:</span><span class="sxs-lookup"><span data-stu-id="e8704-344">Use the following guidelines for specifying the `maxGenerationThreshold` and `largeObjectHeapThreshold` parameters:</span></span>  
  
-   <span data-ttu-id="e8704-345">Im większa wartość progowa, wystąpi więcej alokacje między powiadomienia i pełne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-345">The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</span></span>  
  
     <span data-ttu-id="e8704-346">Wyższa wartość progowa zapewnia dodatkowe możliwości dla środowiska uruchomieniowego pod kątem bliskim kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e8704-346">A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</span></span> <span data-ttu-id="e8704-347">Zwiększa prawdopodobieństwo, że użytkownik będzie powiadamiany.</span><span class="sxs-lookup"><span data-stu-id="e8704-347">This increases the likelihood that you will be notified.</span></span> <span data-ttu-id="e8704-348">Nie należy jednak ustawić zbyt wysoki próg, ponieważ wyniki w alokacjach więcej przed środowisko uruchomieniowe wywołuje kolejnego zbierania.</span><span class="sxs-lookup"><span data-stu-id="e8704-348">However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</span></span>  
  
     <span data-ttu-id="e8704-349">Gdy możesz wywołać kolekcję samodzielnie na powiadomienia za pomocą wartość progowa, mniejszą liczbę obiektów są odzyskiwane nie będzie można odzyskać przy następnej kolekcji w środowisku uruchomieniowym.</span><span class="sxs-lookup"><span data-stu-id="e8704-349">When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</span></span>  
  
-   <span data-ttu-id="e8704-350">Niższa wartość progowa, mniej alokacje między powiadomienia i pełne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-350">The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8704-351">Poniższy przykład pokazuje, jak do rejestracji powiadomień kolekcji wyrzucania elementów i uruchomić wątku do monitorowania stanu powiadomień kolekcji wyrzucania elementów.</span><span class="sxs-lookup"><span data-stu-id="e8704-351">The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</span></span> <span data-ttu-id="e8704-352">Ten przykład kodu jest częścią większego przykładu przewidzianego dla [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md) tematu.</span><span class="sxs-lookup"><span data-stu-id="e8704-352">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e8704-353"><paramref name="maxGenerationThreshold" /> lub <paramref name="largeObjectHeapThreshold" /> nie jest w zakresie od 1 do 99.</span><span class="sxs-lookup"><span data-stu-id="e8704-353"><paramref name="maxGenerationThreshold" /> or <paramref name="largeObjectHeapThreshold" /> is not between 1 and 99.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="e8704-354">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e8704-354">for full trust for the immediate caller.</span></span> <span data-ttu-id="e8704-355">Ten element członkowski nie może być używany przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="e8704-355">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="e8704-356">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e8704-356">requires full trust for the immediate caller.</span></span> <span data-ttu-id="e8704-357">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="e8704-357">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="e8704-358">Powiadomienia dotyczące odzyskiwania pamięci</span><span class="sxs-lookup"><span data-stu-id="e8704-358">Garbage Collection Notifications</span></span></related>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e8704-359">Ten element członkowski nie jest dostępna, gdy jest włączona współbieżne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-359">This member is not available when concurrent garbage collection is enabled.</span></span> <span data-ttu-id="e8704-360">Zobacz &lt;gcconcurrent —&gt; ustawienia środowiska wykonawczego, aby uzyskać informacje o tym, jak wyłączyć współbieżne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-360">See the &lt;gcConcurrent&gt; runtime setting for information about how to disable concurrent garbage collection.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated"><span data-ttu-id="e8704-361">Ilość niezarządzanej pamięci, która została zwolniona.</span><span class="sxs-lookup"><span data-stu-id="e8704-361">The amount of unmanaged memory that has been released.</span></span></param>
        <summary><span data-ttu-id="e8704-362">Informuje środowisko uruchomieniowe wydano niezarządzanej pamięci, a nie musi już być brana pod uwagę podczas planowania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-362">Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-363">Określenie, kiedy należy zaplanować wyrzucania elementów bezużytecznych, środowisko uruchomieniowe bierze pod uwagę ilość pamięci zarządzanej jest przydzielony.</span><span class="sxs-lookup"><span data-stu-id="e8704-363">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="e8704-364">Dużą ilość niezarządzanej pamięci są przydzielane w małych obiektów zarządzanych, środowisko uruchomieniowe uwzględnia pamięci zarządzanej, a zatem szacuje zbyt nisko pilność planowania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-364">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="e8704-365"><xref:System.GC.AddMemoryPressure%2A> Metoda informuje środowiska wykonawczego o ten dodatkowy nacisk na pamięci systemowej i <xref:System.GC.RemoveMemoryPressure%2A> metoda informuje środowisko uruchomieniowe po udostępnieniu dodatkowych ciśnienia.</span><span class="sxs-lookup"><span data-stu-id="e8704-365">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.</span></span>  
  
 <span data-ttu-id="e8704-366">We wzorcu najprostszy sposób użycia obiektu zarządzanego niezarządzanej pamięci w Konstruktorze przydziela i zwalnia go w `Dispose` lub `Finalize` metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-366">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="e8704-367">Wywołaj <xref:System.GC.AddMemoryPressure%2A> metoda po przydzieleniu niezarządzanej pamięci i wywoływać <xref:System.GC.RemoveMemoryPressure%2A> metody po jego.</span><span class="sxs-lookup"><span data-stu-id="e8704-367">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="e8704-368">W bardziej skomplikowane sytuacje, w którym niezarządzane przydzielanie pamięci znacznie zmienia się w okresie istnienia obiektu zarządzanego, można wywołać <xref:System.GC.AddMemoryPressure%2A> i <xref:System.GC.RemoveMemoryPressure%2A> metody do komunikowania się przyrostowe zmiany środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="e8704-368">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e8704-369">Należy zadbać o usunięcie dokładnie ilość wykorzystanie, które można dodać.</span><span class="sxs-lookup"><span data-stu-id="e8704-369">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="e8704-370">Niepowodzenie w tym może niekorzystnie wpłynąć na wydajność systemu w aplikacjach wykonywanych przez długi czas.</span><span class="sxs-lookup"><span data-stu-id="e8704-370">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e8704-371"><paramref name="bytesAllocated" /> jest mniejsza niż lub równa 0.</span><span class="sxs-lookup"><span data-stu-id="e8704-371"><paramref name="bytesAllocated" /> is less than or equal to 0.</span></span>  
  
<span data-ttu-id="e8704-372">—lub—</span><span class="sxs-lookup"><span data-stu-id="e8704-372">-or-</span></span> 
<span data-ttu-id="e8704-373">Na komputerze 32-bitowych <paramref name="bytesAllocated" /> jest większy niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="e8704-373">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="e8704-374">Aby uzyskać możliwość wywoływać kod niezarządzany, podczas manipulacji priorytet wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-374">for the ability to call unmanaged code when manipulating garbage-collection priority.</span></span> <span data-ttu-id="e8704-375">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="e8704-375">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="e8704-376">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e8704-376">requires full trust for the immediate caller.</span></span> <span data-ttu-id="e8704-377">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="e8704-377">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e8704-378">Obiekt, który należy wywołać finalizatora dla.</span><span class="sxs-lookup"><span data-stu-id="e8704-378">The object that a finalizer must be called for.</span></span></param>
        <summary><span data-ttu-id="e8704-379">Żąda system wywołać finalizatora dla określonego obiektu, dla którego <see cref="M:System.GC.SuppressFinalize(System.Object)" /> wcześniej została wywołana.</span><span class="sxs-lookup"><span data-stu-id="e8704-379">Requests that the system call the finalizer for the specified object for which <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has previously been called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-380"><xref:System.GC.ReRegisterForFinalize%2A> Metoda dodaje `obj` parametru do listy obiektów żądających finalizacji, zanim moduł odśmiecania pamięci zwalnia obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8704-380">The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object.</span></span> <span data-ttu-id="e8704-381">`obj` Parametr musi być wywołujący tę metodę.</span><span class="sxs-lookup"><span data-stu-id="e8704-381">The `obj` parameter must be the caller of this method.</span></span>  
  
 <span data-ttu-id="e8704-382">Wywoływanie <xref:System.GC.ReRegisterForFinalize%2A> metody nie gwarantuje, że moduł odśmiecania pamięci będzie wywołać finalizatora obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8704-382">Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer.</span></span>  
  
 <span data-ttu-id="e8704-383">Domyślnie wszystkie obiekty, które implementują finalizatory są dodawane do listy obiektów, które wymagają finalizacji; jednak może mieć już sfinalizowany lub może być wyłączone finalizacja przez wywołanie obiektu <xref:System.GC.SuppressFinalize%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-383">By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method.</span></span>  
  
 <span data-ttu-id="e8704-384">Finalizator umożliwia operacji przywracania aktywności siebie lub obiekt, który odwołuje się do tej metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-384">A finalizer can use this method to resurrect itself or an object that it references.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8704-385">Poniższy przykład pokazuje, jak zakończyć obiektu na sekundę przy użyciu metody ReRegisterForFinalize czas po wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-385">The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</span></span>  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e8704-386"><paramref name="obj" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e8704-386"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e8704-387">Obiekt, którego finalizatora nie musi zostać wykonana.</span><span class="sxs-lookup"><span data-stu-id="e8704-387">The object whose finalizer must not be executed.</span></span></param>
        <summary><span data-ttu-id="e8704-388">Żądania, że środowisko uruchomieniowe języka wspólnego nie wywołać finalizatora dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8704-388">Requests that the common language runtime not call the finalizer for the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-389">Ta metoda ustawia bit w nagłówku obiektu `obj`, której środowisko uruchomieniowe sprawdza podczas wywoływania finalizatorów.</span><span class="sxs-lookup"><span data-stu-id="e8704-389">This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers.</span></span> <span data-ttu-id="e8704-390">Finalizator, który jest reprezentowany przez <xref:System.Object.Finalize%2A?displayProperty=nameWithType> służy metody, aby zwolnić niezarządzane zasoby, zanim obiekt będzie jesdnostką zbierającą śmieci.</span><span class="sxs-lookup"><span data-stu-id="e8704-390">A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method, is used to release unmanaged resources before an object is garbage-collected.</span></span> <span data-ttu-id="e8704-391">Jeśli `obj` nie ma finalizatora, wywołanie <xref:System.GC.SuppressFinalize%2A> metoda nie ma wpływu.</span><span class="sxs-lookup"><span data-stu-id="e8704-391">If `obj` does not have a finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect.</span></span>  
  
 <span data-ttu-id="e8704-392">Obiekty, które implementują <xref:System.IDisposable> interfejsu można wywołać tej metody z obiektu <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji, aby uniemożliwić moduł zbierający elementy bezużyteczne wywoływania <xref:System.Object.Finalize%2A?displayProperty=nameWithType> na obiekt, który nie jest wymagane.</span><span class="sxs-lookup"><span data-stu-id="e8704-392">Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=nameWithType> on an object that does not require it.</span></span> <span data-ttu-id="e8704-393">Zazwyczaj w ten sposób zapobiec finalizator zwalniania niezarządzanych zasobów, które już mają zostać zwolniony przez <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-393">Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8704-394">Poniższy przykład pokazuje sposób użycia <xref:System.GC.SuppressFinalize%2A> metody w klasie zasobów, aby zapobiec nadmiarowe wyrzucanie elementów bezużytecznych z wywołanego.</span><span class="sxs-lookup"><span data-stu-id="e8704-394">The following example demonstrates how to use the <xref:System.GC.SuppressFinalize%2A> method in a resource class to prevent a redundant garbage collection from being called.</span></span> <span data-ttu-id="e8704-395">W przykładzie użyto [dispose](~/docs/standard/garbage-collection/implementing-dispose.md) wzorzec zwolnienie zarówno zasoby zarządzane (czyli obiekty, które implementują <xref:System.IDisposable>) i niezarządzanych zasobów.</span><span class="sxs-lookup"><span data-stu-id="e8704-395">The example uses the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose .md) to free both managed resources (that is, objects that implement <xref:System.IDisposable>) and unmanaged resources.</span></span>  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e8704-396"><paramref name="obj" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e8704-396"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="https://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb"><span data-ttu-id="e8704-397">Wzorzec Dispose</span><span class="sxs-lookup"><span data-stu-id="e8704-397">Dispose Pattern</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e8704-398">Próbuje nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżkę krytyczną.</span><span class="sxs-lookup"><span data-stu-id="e8704-398">Attempts to disallow garbage collection during the execution of a critical path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="e8704-399">Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, na które powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko wykonawcze jest w trybie opóźnienia w regionie nie GC.</span><span class="sxs-lookup"><span data-stu-id="e8704-399">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="e8704-400">Innymi słowy, nie należy wywołać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania nie powiedzie się), a nie powinni oczekiwać od wywołania <xref:System.GC.EndNoGCRegion%2A> zakończyło się sukcesem, po prostu, ponieważ jest to pierwsze wywołanie do <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e8704-400">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="e8704-401">Ilość pamięci w bajtach, można przydzielić bez powodowania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-401">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="e8704-402">Może być mniejsza niż lub równy rozmiarowi segment efemeryczny.</span><span class="sxs-lookup"><span data-stu-id="e8704-402">It must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="e8704-403">Aby uzyskać informacje dotyczące rozmiaru segment efemeryczny, zobacz sekcję "generacje i segmenty Efemeryczne" w [podstawowe informacje dotyczące wyrzucania elementów bezużytecznych](~/docs/standard/garbage-collection/fundamentals.md) artykułu.</span><span class="sxs-lookup"><span data-stu-id="e8704-403">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <summary><span data-ttu-id="e8704-404">Próby nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżki krytycznej, jeśli określona ilość pamięci jest dostępny.</span><span class="sxs-lookup"><span data-stu-id="e8704-404">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</span></span></summary>
        <returns><span data-ttu-id="e8704-405"><see langword="true" /> Jeśli środowisko uruchomieniowe można było zatwierdzić wymagana ilość pamięci i odśmiecania pamięci jest w stanie nie tryb opóźnienie region GC; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e8704-405"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-406"><xref:System.GC.TryStartNoGCRegion%28System.Int64%29> Metoda próbuje umieścić moduł zbierający elementy bezużyteczne w nie GC region opóźnienie trybie, który nie zezwala wyrzucania elementów bezużytecznych, gdy aplikacja wykonuje krytyczne obszar kodu.</span><span class="sxs-lookup"><span data-stu-id="e8704-406">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="e8704-407">Jeśli środowisko wykonawcze nie może przydzielić pierwotnie żądanej ilości pamięci, moduł zbierający elementy bezużyteczne wykonuje pełne blokowanie wyrzucania elementów bezużytecznych zwolnić więcej pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-407">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="e8704-408">Moduł zbierający elementy bezużyteczne przechodzi tryb bez GC region opóźnienia, jeśli jest w stanie przydzielić wymagana ilość pamięci, w tym przypadku jest faktycznie 2 \* `totalSize` bajtów (próbuje przydzielić `totalSize` bajtów dla sterty małego obiektu i `totalSize` bajtów sterty dużego obiektu).</span><span class="sxs-lookup"><span data-stu-id="e8704-408">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap).</span></span>  
  
 <span data-ttu-id="e8704-409">`totalSize` musi być wystarczająco duży, aby obsłużyć wszystkie alokacje pamięci, które występują w ścieżce krytycznej.</span><span class="sxs-lookup"><span data-stu-id="e8704-409">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="e8704-410">Obejmuje to alokacje przez aplikację, a także alokacji, który sprawia, że środowisko wykonawcze w imieniu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-410">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e8704-411">Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, na które powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko wykonawcze jest w trybie opóźnienia w regionie nie GC.</span><span class="sxs-lookup"><span data-stu-id="e8704-411">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="e8704-412">Innymi słowy, nie należy wywołać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania nie powiedzie się), a nie powinni oczekiwać od wywołania <xref:System.GC.EndNoGCRegion%2A> zakończyło się sukcesem, po prostu, ponieważ jest to pierwsze wywołanie do <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e8704-412">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="e8704-413">Możesz wyjść z nie GC region opóźnienie trybu przez wywołanie metody <xref:System.GC.EndNoGCRegion%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-413">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e8704-414"><paramref name="totalSize" /> przekracza rozmiar segment efemeryczny.</span><span class="sxs-lookup"><span data-stu-id="e8704-414"><paramref name="totalSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e8704-415">Proces jest już w trybie opóźnienia w regionie nie GC.</span><span class="sxs-lookup"><span data-stu-id="e8704-415">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="e8704-416">Podstawy dotyczące wyrzucania elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="e8704-416">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="e8704-417">Tryby opóźnienia</span><span class="sxs-lookup"><span data-stu-id="e8704-417">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="e8704-418">Ilość pamięci w bajtach, można przydzielić bez powodowania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-418">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="e8704-419">Może być mniejsza niż lub równy rozmiarowi segment efemeryczny.</span><span class="sxs-lookup"><span data-stu-id="e8704-419">It must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="e8704-420">Aby uzyskać informacje dotyczące rozmiaru segment efemeryczny, zobacz sekcję "generacje i segmenty Efemeryczne" w [podstawowe informacje dotyczące wyrzucania elementów bezużytecznych](~/docs/standard/garbage-collection/fundamentals.md) artykułu.</span><span class="sxs-lookup"><span data-stu-id="e8704-420">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="disallowFullBlockingGC"><span data-ttu-id="e8704-421"><see langword="true" /> Aby pominąć pełną blokowania wyrzucania elementów bezużytecznych, jeśli moduł odśmiecania pamięci jest początkowo nie można przydzielić <paramref name="totalSize" /> bajtów; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e8704-421"><see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <paramref name="totalSize" /> bytes; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="e8704-422">Próbuje nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżki krytycznej, jeśli określona ilość pamięci jest dostępny i formantów, czy moduł odśmiecania pamięci jest pełna blokowania wyrzucania elementów bezużytecznych, jeśli nie wystarczającej ilości pamięci jest początkowo dostępna.</span><span class="sxs-lookup"><span data-stu-id="e8704-422">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span></span></summary>
        <returns><span data-ttu-id="e8704-423"><see langword="true" /> Jeśli środowisko uruchomieniowe można było zatwierdzić wymagana ilość pamięci i odśmiecania pamięci jest w stanie nie tryb opóźnienie region GC; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e8704-423"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-424"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> Metoda próbuje umieścić moduł zbierający elementy bezużyteczne w nie GC region opóźnienie trybie, który nie zezwala wyrzucania elementów bezużytecznych, gdy aplikacja wykonuje krytyczne obszar kodu.</span><span class="sxs-lookup"><span data-stu-id="e8704-424">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="e8704-425">Jeśli środowisko uruchomieniowe jest nie można wstępnie przydzielić żądanej ilości pamięci i `disallowFullBlockingGC` argument jest `false`, moduł zbierający elementy bezużyteczne wykonuje pełne blokowanie wyrzucania elementów bezużytecznych zwolnić więcej pamięci; w przeciwnym razie alokacji kończy się niepowodzeniem i metoda zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="e8704-425">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="e8704-426">Moduł zbierający elementy bezużyteczne przechodzi tryb bez GC region opóźnienia, jeśli jest w stanie przydzielić wymagana ilość pamięci, w tym przypadku jest faktycznie 2 \* `totalSize` (próbuje przydzielić `totalSize` dla sterty małego obiektu i `totalSize` dla dużego obiektu Sterta).</span><span class="sxs-lookup"><span data-stu-id="e8704-426">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap).</span></span>  
  
 <span data-ttu-id="e8704-427">`totalSize` musi być wystarczająco duży, aby obsłużyć wszystkie alokacje pamięci, które występują w ścieżce krytycznej.</span><span class="sxs-lookup"><span data-stu-id="e8704-427">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="e8704-428">Obejmuje to alokacje przez aplikację, a także alokacji, który sprawia, że środowisko wykonawcze w imieniu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-428">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="e8704-429">Ustawienie `disallowFullBlockingGC` do `true` zapobiegające pełnego blokowania wyrzucania elementów kolekcji, jeśli nie ma wystarczającej ilości pamięci jest początkowo dostępna jest najbardziej przydatna w scenariusze równoważenia obciążenia: jeden system może wywołać tę metodę i przedstawia się jako gotowy do akceptowania żądań, jeśli zostanie zwrócona `true`, i modułu równoważenia obciążenia, Przekieruj żądania do innych systemów, jeśli zwróci ona `false`.</span><span class="sxs-lookup"><span data-stu-id="e8704-429">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="e8704-430">Go następnie wykonaj pełną blokowania wyrzucania elementów bezużytecznych, gdy go nie obsługuje żądania przez wywołanie metody <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-430">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e8704-431">Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, na które powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko wykonawcze jest w trybie opóźnienia w regionie nie GC.</span><span class="sxs-lookup"><span data-stu-id="e8704-431">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="e8704-432">Innymi słowy, nie należy wywołać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania nie powiedzie się), a nie powinni oczekiwać od wywołania <xref:System.GC.EndNoGCRegion%2A> zakończyło się sukcesem, po prostu, ponieważ jest to pierwsze wywołanie do <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e8704-432">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="e8704-433">Możesz wyjść z nie GC region opóźnienie trybu przez wywołanie metody <xref:System.GC.EndNoGCRegion%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-433">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e8704-434"><paramref name="totalSize" /> przekracza rozmiar segment efemeryczny.</span><span class="sxs-lookup"><span data-stu-id="e8704-434"><paramref name="totalSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e8704-435">Proces jest już w trybie opóźnienia w regionie nie GC.</span><span class="sxs-lookup"><span data-stu-id="e8704-435">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="e8704-436">Podstawy dotyczące wyrzucania elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="e8704-436">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="e8704-437">Tryby opóźnienia</span><span class="sxs-lookup"><span data-stu-id="e8704-437">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="e8704-438">Ilość pamięci w bajtach, można przydzielić bez powodowania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-438">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="e8704-439"><paramref name="totalSize" /> -<paramref name="lohSize" /> musi być mniejsza niż lub równy rozmiarowi segment efemeryczny.</span><span class="sxs-lookup"><span data-stu-id="e8704-439"><paramref name="totalSize" /> -<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="e8704-440">Aby uzyskać informacje dotyczące rozmiaru segment efemeryczny, zobacz sekcję "generacje i segmenty Efemeryczne" w [podstawowe informacje dotyczące wyrzucania elementów bezużytecznych](~/docs/standard/garbage-collection/fundamentals.md) artykułu.</span><span class="sxs-lookup"><span data-stu-id="e8704-440">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="lohSize"><span data-ttu-id="e8704-441">Liczba bajtów w <paramref name="totalSize" /> na potrzeby alokacji sterty (LOH) dużego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8704-441">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span></span></param>
        <summary><span data-ttu-id="e8704-442">Próby nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżki krytycznej, jeśli określona ilość pamięci jest dostępna dla stosu dużych obiektów i stosu małych obiektów.</span><span class="sxs-lookup"><span data-stu-id="e8704-442">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</span></span></summary>
        <returns><span data-ttu-id="e8704-443"><see langword="true" /> Jeśli środowisko uruchomieniowe można było zatwierdzić wymagana ilość pamięci i odśmiecania pamięci jest w stanie nie tryb opóźnienie region GC; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e8704-443"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-444"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> Metoda próbuje umieścić moduł zbierający elementy bezużyteczne w nie GC region opóźnienie trybie, który nie zezwala wyrzucania elementów bezużytecznych, gdy aplikacja wykonuje krytyczne obszar kodu.</span><span class="sxs-lookup"><span data-stu-id="e8704-444">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="e8704-445">Jeśli środowisko wykonawcze nie może przydzielić pierwotnie żądanej ilości pamięci, moduł zbierający elementy bezużyteczne wykonuje pełne blokowanie wyrzucania elementów bezużytecznych zwolnić więcej pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-445">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="e8704-446">Moduł zbierający elementy bezużyteczne przechodzi nie w trybie opóźnienia region GC, jeśli jest w stanie przydzielić `lohSize` dla LOH i `totalSize`  -  `lohSize` dla sterty małego obiektu (raportu o kondycji).</span><span class="sxs-lookup"><span data-stu-id="e8704-446">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` - `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="e8704-447">`lohSize` musi być wystarczająco duży, aby obsłużyć wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla LOH, i `totalSize`  -  `lohSize` musi być wystarczająco duży, aby obsłużyć wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla raportu o kondycji.</span><span class="sxs-lookup"><span data-stu-id="e8704-447">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` - `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="e8704-448">Obejmuje to alokacje przez aplikację, a także alokacji, który sprawia, że środowisko wykonawcze w imieniu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-448">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e8704-449">Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, na które powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko wykonawcze jest w trybie opóźnienia w regionie nie GC.</span><span class="sxs-lookup"><span data-stu-id="e8704-449">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="e8704-450">Innymi słowy, nie należy wywołać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania nie powiedzie się), a nie powinni oczekiwać od wywołania <xref:System.GC.EndNoGCRegion%2A> zakończyło się sukcesem, po prostu, ponieważ jest to pierwsze wywołanie do <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e8704-450">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="e8704-451">Możesz wyjść z nie GC region opóźnienie trybu przez wywołanie metody <xref:System.GC.EndNoGCRegion%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-451">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e8704-452"><paramref name="totalSize" /> - <paramref name="lohSize" /> przekracza rozmiar segment efemeryczny.</span><span class="sxs-lookup"><span data-stu-id="e8704-452"><paramref name="totalSize" /> - <paramref name="lohSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e8704-453">Proces jest już w trybie opóźnienia w regionie nie GC.</span><span class="sxs-lookup"><span data-stu-id="e8704-453">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="e8704-454">Podstawy dotyczące wyrzucania elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="e8704-454">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="e8704-455">Tryby opóźnienia</span><span class="sxs-lookup"><span data-stu-id="e8704-455">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="e8704-456">Ilość pamięci w bajtach, można przydzielić bez powodowania wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-456">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="e8704-457"><paramref name="totalSize" /> -<paramref name="lohSize" /> musi być mniejsza niż lub równy rozmiarowi segment efemeryczny.</span><span class="sxs-lookup"><span data-stu-id="e8704-457"><paramref name="totalSize" /> -<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="e8704-458">Aby uzyskać informacje dotyczące rozmiaru segment efemeryczny, zobacz sekcję "generacje i segmenty Efemeryczne" w [podstawowe informacje dotyczące wyrzucania elementów bezużytecznych](~/docs/standard/garbage-collection/fundamentals.md) artykułu.</span><span class="sxs-lookup"><span data-stu-id="e8704-458">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="lohSize"><span data-ttu-id="e8704-459">Liczba bajtów w <paramref name="totalSize" /> na potrzeby alokacji sterty (LOH) dużego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8704-459">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span></span></param>
        <param name="disallowFullBlockingGC"><span data-ttu-id="e8704-460"><see langword="true" /> Aby pominąć pełną blokowania wyrzucania elementów bezużytecznych, jeśli moduł odśmiecania pamięci jest początkowo nie można przydzielić określonym pamięci sterty małego obiektu (raportu o kondycji) i LOH; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e8704-460"><see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="e8704-461">Nie zezwalaj na odzyskiwanie pamięci podczas wykonywania ścieżki krytycznej, jeśli określonej ilości pamięci jest dostępny dla sterty dużych obiektów i stos małych obiektów i kontrolek, czy moduł odśmiecania pamięci jest pełna blokowania wyrzucania elementów bezużytecznych, jeśli nie prób początkowo dostępna jest wystarczająca ilość pamięci.</span><span class="sxs-lookup"><span data-stu-id="e8704-461">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span></span></summary>
        <returns><span data-ttu-id="e8704-462"><see langword="true" /> Jeśli środowisko uruchomieniowe można było zatwierdzić wymagana ilość pamięci i odśmiecania pamięci jest w stanie nie tryb opóźnienie region GC; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e8704-462"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-463"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> Metoda próbuje umieścić moduł zbierający elementy bezużyteczne w nie GC region opóźnienie trybie, który nie zezwala wyrzucania elementów bezużytecznych, gdy aplikacja wykonuje krytyczne obszar kodu.</span><span class="sxs-lookup"><span data-stu-id="e8704-463">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="e8704-464">Jeśli środowisko uruchomieniowe jest nie można wstępnie przydzielić żądanej ilości pamięci i `disallowFullBlockingGC` argument jest `false`, moduł zbierający elementy bezużyteczne wykonuje pełne blokowanie wyrzucania elementów bezużytecznych zwolnić więcej pamięci; w przeciwnym razie alokacji kończy się niepowodzeniem i metoda zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="e8704-464">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="e8704-465">Moduł zbierający elementy bezużyteczne przechodzi nie w trybie opóźnienia region GC, jeśli jest w stanie przydzielić `lohSize` dla LOH i `totalSize`  -  `lohSize` dla sterty małego obiektu (raportu o kondycji).</span><span class="sxs-lookup"><span data-stu-id="e8704-465">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` - `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="e8704-466">`lohSize` musi być wystarczająco duży, aby obsłużyć wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla LOH, i `totalSize`  -  `lohSize` musi być wystarczająco duży, aby obsłużyć wszystkie alokacje pamięci, które występują w ścieżce krytycznej dla raportu o kondycji.</span><span class="sxs-lookup"><span data-stu-id="e8704-466">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` - `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="e8704-467">Obejmuje to alokacje przez aplikację, a także alokacji, który sprawia, że środowisko wykonawcze w imieniu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-467">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="e8704-468">Ustawienie `disallowFullBlockingGC` do `true` zapobiegające pełnego blokowania wyrzucania elementów kolekcji, jeśli nie ma wystarczającej ilości pamięci jest początkowo dostępna jest najbardziej przydatna w scenariusze równoważenia obciążenia: jeden system może wywołać tę metodę i przedstawia się jako gotowy do akceptowania żądań, jeśli zostanie zwrócona `true`, i modułu równoważenia obciążenia, Przekieruj żądania do innych systemów, jeśli zwróci ona `false`.</span><span class="sxs-lookup"><span data-stu-id="e8704-468">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="e8704-469">Go następnie wykonaj pełną blokowania wyrzucania elementów bezużytecznych, gdy go nie obsługuje żądania przez wywołanie metody <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-469">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e8704-470">Nie można zagnieździć wywołań <xref:System.GC.TryStartNoGCRegion%2A> metody, na które powinny wywoływać tylko <xref:System.GC.EndNoGCRegion%2A> metodę, jeśli środowisko wykonawcze jest w trybie opóźnienia w regionie nie GC.</span><span class="sxs-lookup"><span data-stu-id="e8704-470">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="e8704-471">Innymi słowy, nie należy wywołać <xref:System.GC.TryStartNoGCRegion%2A> wiele razy (po pierwszym wywołaniu metody, kolejne wywołania nie powiedzie się), a nie powinni oczekiwać od wywołania <xref:System.GC.EndNoGCRegion%2A> zakończyło się sukcesem, po prostu, ponieważ jest to pierwsze wywołanie do <xref:System.GC.TryStartNoGCRegion%2A> zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e8704-471">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="e8704-472">Możesz wyjść z nie GC region opóźnienie trybu przez wywołanie metody <xref:System.GC.EndNoGCRegion%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-472">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e8704-473"><paramref name="totalSize" /> - <paramref name="lohSize" /> przekracza rozmiar segment efemeryczny.</span><span class="sxs-lookup"><span data-stu-id="e8704-473"><paramref name="totalSize" /> - <paramref name="lohSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e8704-474">Proces jest już w trybie opóźnienia w regionie nie GC.</span><span class="sxs-lookup"><span data-stu-id="e8704-474">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="e8704-475">Podstawy dotyczące wyrzucania elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="e8704-475">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="e8704-476">Tryby opóźnienia</span><span class="sxs-lookup"><span data-stu-id="e8704-476">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e8704-477">Zwraca stan zarejestrowanego powiadomienia do określenia, czy pełny blokowanie wyrzucania elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego jest bliska.</span><span class="sxs-lookup"><span data-stu-id="e8704-477">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e8704-478">Zwraca stan zarejestrowanego powiadomienia do określenia, czy pełny blokowanie wyrzucania elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego jest bliska.</span><span class="sxs-lookup"><span data-stu-id="e8704-478">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
        <returns><span data-ttu-id="e8704-479">Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-479">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-480">Użyj <xref:System.GCNotificationStatus> zwracane przez tę metodę pozwala ustalić stan bieżącego powiadomienia kolekcji wyrzucania elementów, który został zarejestrowany przy użyciu wyliczenia <xref:System.GC.RegisterForFullGCNotification%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-480">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="e8704-481">Można również użyć <xref:System.GC.WaitForFullGCComplete%2A> metodę pozwala ustalić, czy pełne wyrzucanie elementów bezużytecznych zostało zakończone.</span><span class="sxs-lookup"><span data-stu-id="e8704-481">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="e8704-482">Gdy zwraca wyliczenie <xref:System.GCNotificationStatus.Succeeded>, mogą wykonywać zadania, takie jak uniemożliwia dodatkowe obiekty są przydzielane i wykonuje kolekcję, samodzielnie za pomocą <xref:System.GC.Collect%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-482">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="e8704-483">Należy pamiętać, że powiadomienia nie gwarantuje, że pełne wyrzucanie elementów bezużytecznych nastąpi, tylko, że warunki Osiągnięto próg jest preferowana dla pełne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-483">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="e8704-484">Ta metoda przez czas nieokreślony oczekuje można uzyskać powiadomienia wyrzucania elementów kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e8704-484">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="e8704-485">Aby określić limit czasu dla metody do zwrócenia, jeśli nie można uzyskać powiadomienia, należy użyć <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-485">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="e8704-486">Jeśli ta metoda jest wywoływana bez określania upływu limitu czasu, można wywołać <xref:System.GC.CancelFullGCNotification%2A> metodę, jeśli oczekujesz dłużej niż preferowany.</span><span class="sxs-lookup"><span data-stu-id="e8704-486">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="e8704-487">Należy przestrzegać tej metody za pomocą wywołania <xref:System.GC.WaitForFullGCComplete%2A> metody, aby upewnić się, mieli pełne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-487">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="e8704-488">Wywołanie tej metody tylko powoduje, że wyniki nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="e8704-488">Calling this method alone causes indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8704-489">Poniższy przykład pokazuje, jak ta metoda służy do określenia, czy zbliża się pełne, blokowanie wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-489">The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</span></span> <span data-ttu-id="e8704-490">Zawsze, gdy jest w stanie powiadomienia <xref:System.GCNotificationStatus.Succeeded>, metoda użytkownika `OnFullGCApproachNotify` jest wywoływana w celu wykonania akcji w odpowiedzi na Bliskim kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e8704-490">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCApproachNotify` is called to perform actions in response to the approaching collection.</span></span> <span data-ttu-id="e8704-491">Ten przykład kodu jest częścią większego przykładu przewidzianego dla [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md) tematu.</span><span class="sxs-lookup"><span data-stu-id="e8704-491">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="e8704-492">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e8704-492">for full trust for the immediate caller.</span></span> <span data-ttu-id="e8704-493">Ten element członkowski nie może być używany przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="e8704-493">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="e8704-494">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e8704-494">requires full trust for the immediate caller.</span></span> <span data-ttu-id="e8704-495">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="e8704-495">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="e8704-496">Powiadomienia dotyczące odzyskiwania pamięci</span><span class="sxs-lookup"><span data-stu-id="e8704-496">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="e8704-497">Długość czasu oczekiwania, można uzyskać stanu powiadomień.</span><span class="sxs-lookup"><span data-stu-id="e8704-497">The length of time to wait before a notification status can be obtained.</span></span> <span data-ttu-id="e8704-498">Określ wartość -1, aby czekać w nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="e8704-498">Specify -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="e8704-499">Zwraca określony przekroczył limit czasu, stan zarejestrowanego powiadomienia do określenia, czy pełny blokowanie wyrzucania elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego jest bliska.</span><span class="sxs-lookup"><span data-stu-id="e8704-499">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
        <returns><span data-ttu-id="e8704-500">Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-500">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-501">Użyj <xref:System.GCNotificationStatus> zwracane przez tę metodę pozwala ustalić stan bieżącego powiadomienia kolekcji wyrzucania elementów, który został zarejestrowany przy użyciu wyliczenia <xref:System.GC.RegisterForFullGCNotification%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-501">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="e8704-502">Można również użyć <xref:System.GC.WaitForFullGCComplete%2A> metodę pozwala ustalić, czy pełne wyrzucanie elementów bezużytecznych zostało zakończone.</span><span class="sxs-lookup"><span data-stu-id="e8704-502">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="e8704-503">Należy zauważyć, że ta metoda zwraca natychmiast zawsze, gdy uzyskany stanu powiadomień kolekcji wyrzucania elementów, bez względu na wartość określoną przez `millisecondsTimeout`.</span><span class="sxs-lookup"><span data-stu-id="e8704-503">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="e8704-504">Jeśli stan powiadomień kolekcji wyrzucania elementów nie zostanie osiągnięta przed `millisecondsTimeout` razy, Metoda ta zwraca <xref:System.GCNotificationStatus.NotApplicable>.</span><span class="sxs-lookup"><span data-stu-id="e8704-504">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="e8704-505">Gdy zwraca wyliczenie <xref:System.GCNotificationStatus.Succeeded>, mogą wykonywać zadania, takie jak uniemożliwia dodatkowe obiekty są przydzielane i wykonuje kolekcję, samodzielnie za pomocą <xref:System.GC.Collect%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-505">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="e8704-506">Należy pamiętać, że powiadomienia nie gwarantuje, że pełne wyrzucanie elementów bezużytecznych nastąpi, tylko, że warunki Osiągnięto próg jest preferowana dla pełne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-506">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="e8704-507">Możesz wywołać <xref:System.GC.CancelFullGCNotification%2A> metody, gdy nie można czekać przed upłynięciem limitu czasu minie.</span><span class="sxs-lookup"><span data-stu-id="e8704-507">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="e8704-508">Należy przestrzegać tej metody za pomocą wywołania <xref:System.GC.WaitForFullGCComplete%2A> metody, aby upewnić się, mieli pełne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-508">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="e8704-509">Wywołanie tej metody tylko powoduje, że wyniki nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="e8704-509">Calling this method alone causes indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e8704-510"><paramref name="millisecondsTimeout" /> musi być nieujemną lub mniejsze niż lub równe <see cref="F:System.Int32.MaxValue" /> lub wartość -1.</span><span class="sxs-lookup"><span data-stu-id="e8704-510"><paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="e8704-511">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e8704-511">for full trust for the immediate caller.</span></span> <span data-ttu-id="e8704-512">Ten element członkowski nie może być używany przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="e8704-512">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="e8704-513">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e8704-513">requires full trust for the immediate caller.</span></span> <span data-ttu-id="e8704-514">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="e8704-514">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="e8704-515">Powiadomienia dotyczące odzyskiwania pamięci</span><span class="sxs-lookup"><span data-stu-id="e8704-515">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e8704-516">Zwraca stan zarejestrowanego powiadomienia do określenia, czy pełny blokowanie wyrzucania elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego została ukończona.</span><span class="sxs-lookup"><span data-stu-id="e8704-516">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e8704-517">Zwraca stan zarejestrowanego powiadomienia do określenia, czy pełny blokowanie wyrzucania elementów bezużytecznych przez środowisko uruchomieniowe języka wspólnego została ukończona.</span><span class="sxs-lookup"><span data-stu-id="e8704-517">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span></span></summary>
        <returns><span data-ttu-id="e8704-518">Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-518">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-519">Użyj <xref:System.GCNotificationStatus> zwracane przez tę metodę pozwala ustalić stan bieżącego powiadomienia kolekcji wyrzucania elementów, który został zarejestrowany przy użyciu wyliczenia <xref:System.GC.RegisterForFullGCNotification%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-519">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="e8704-520">Można również użyć <xref:System.GC.WaitForFullGCApproach%2A> metodę, aby określić, czy pełne wyrzucanie elementów bezużytecznych jest bezpośrednie.</span><span class="sxs-lookup"><span data-stu-id="e8704-520">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="e8704-521">Gdy zwraca wyliczenie <xref:System.GCNotificationStatus.Succeeded>, mogą wykonywać zadania, takie jak wznawiania pracy i uzyskiwanie liczby kolekcji, za pomocą <xref:System.GC.CollectionCount%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="e8704-521">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="e8704-522">Ta metoda przez czas nieokreślony oczekuje można uzyskać powiadomienia wyrzucania elementów kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e8704-522">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="e8704-523">Aby określić limit czasu dla metody do zwrócenia, jeśli nie można uzyskać powiadomienia, należy użyć <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-523">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="e8704-524">Jeśli ta metoda jest wywoływana bez określania upływu limitu czasu, można wywołać <xref:System.GC.CancelFullGCNotification%2A> metodę, jeśli oczekujesz dłużej niż preferowany.</span><span class="sxs-lookup"><span data-stu-id="e8704-524">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="e8704-525">Wywołanie tej metody, powinien zostać poprzedzony wywołaniem <xref:System.GC.WaitForFullGCApproach%2A> metody, aby upewnić się, mieli pełne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-525">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="e8704-526">Wywołanie tej metody tylko może wygenerować wyniki nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="e8704-526">Calling this method alone can produce indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8704-527">Poniższy przykład pokazuje, jak ta metoda służy do określenia, czy pełne wyrzucanie elementów bezużytecznych zostało zakończone.</span><span class="sxs-lookup"><span data-stu-id="e8704-527">The following example shows how to use this method to determine whether a full garbage collection has completed.</span></span> <span data-ttu-id="e8704-528">Zawsze, gdy jest w stanie powiadomienia <xref:System.GCNotificationStatus.Succeeded>, metoda użytkownika `OnFullGCCompletedNotify` jest wywoływana w celu wykonania akcji w odpowiedzi na ukończone kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e8704-528">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCCompletedNotify` is called to perform actions in response to the completed collection.</span></span> <span data-ttu-id="e8704-529">Ten przykład kodu jest częścią większego przykładu przewidzianego dla [powiadomienia dotyczące odzyskiwania pamięci](~/docs/standard/garbage-collection/notifications.md) tematu.</span><span class="sxs-lookup"><span data-stu-id="e8704-529">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="e8704-530">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e8704-530">for full trust for the immediate caller.</span></span> <span data-ttu-id="e8704-531">Ten element członkowski nie może być używany przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="e8704-531">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="e8704-532">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e8704-532">requires full trust for the immediate caller.</span></span> <span data-ttu-id="e8704-533">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="e8704-533">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="e8704-534">Powiadomienia dotyczące odzyskiwania pamięci</span><span class="sxs-lookup"><span data-stu-id="e8704-534">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="e8704-535">Długość czasu oczekiwania, można uzyskać stanu powiadomień.</span><span class="sxs-lookup"><span data-stu-id="e8704-535">The length of time to wait before a notification status can be obtained.</span></span> <span data-ttu-id="e8704-536">Określ wartość -1, aby czekać w nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="e8704-536">Specify -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="e8704-537">Zwraca określony przekroczył limit czasu, stan zarejestrowanego powiadomienia do określenia, czy pełny, blokowanie wyrzucania elementów bezużytecznych za pomocą wspólnego języka środowiska uruchomieniowego została ukończona.</span><span class="sxs-lookup"><span data-stu-id="e8704-537">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</span></span></summary>
        <returns><span data-ttu-id="e8704-538">Stan zarejestrowanego powiadomienia o wyrzucaniu elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-538">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-539">Użyj <xref:System.GCNotificationStatus> zwracane przez tę metodę pozwala ustalić stan bieżącego powiadomienia kolekcji wyrzucania elementów, który został zarejestrowany przy użyciu wyliczenia <xref:System.GC.RegisterForFullGCNotification%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e8704-539">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="e8704-540">Można również użyć <xref:System.GC.WaitForFullGCApproach%2A> metodę, aby określić, czy pełne wyrzucanie elementów bezużytecznych jest bezpośrednie.</span><span class="sxs-lookup"><span data-stu-id="e8704-540">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="e8704-541">Należy zauważyć, że ta metoda zwraca natychmiast zawsze, gdy uzyskany stanu powiadomień kolekcji wyrzucania elementów, bez względu na wartość określoną przez `millisecondsTimeout`.</span><span class="sxs-lookup"><span data-stu-id="e8704-541">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="e8704-542">Jeśli stan powiadomień kolekcji wyrzucania elementów nie zostanie osiągnięta przed `millisecondsTimeout` razy, Metoda ta zwraca <xref:System.GCNotificationStatus.NotApplicable>.</span><span class="sxs-lookup"><span data-stu-id="e8704-542">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="e8704-543">Gdy zwraca wyliczenie <xref:System.GCNotificationStatus.Succeeded>, mogą wykonywać zadania, takie jak wznawiania pracy i uzyskiwanie liczby kolekcji, za pomocą <xref:System.GC.CollectionCount%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="e8704-543">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="e8704-544">Możesz wywołać <xref:System.GC.CancelFullGCNotification%2A> metody, gdy nie można czekać przed upłynięciem limitu czasu minie.</span><span class="sxs-lookup"><span data-stu-id="e8704-544">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="e8704-545">Wywołanie tej metody, powinien zostać poprzedzony wywołaniem <xref:System.GC.WaitForFullGCApproach%2A> metody, aby upewnić się, mieli pełne wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="e8704-545">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="e8704-546">Wywołanie tej metody tylko może wygenerować wyniki nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="e8704-546">Calling this method alone can produce indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e8704-547"><paramref name="millisecondsTimeout" /> musi być nieujemną lub mniejsze niż lub równe <see cref="F:System.Int32.MaxValue" /> lub wartość -1.</span><span class="sxs-lookup"><span data-stu-id="e8704-547"><paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="e8704-548">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e8704-548">for full trust for the immediate caller.</span></span> <span data-ttu-id="e8704-549">Ten element członkowski nie może być używany przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="e8704-549">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="e8704-550">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e8704-550">requires full trust for the immediate caller.</span></span> <span data-ttu-id="e8704-551">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="e8704-551">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="e8704-552">Powiadomienia dotyczące odzyskiwania pamięci</span><span class="sxs-lookup"><span data-stu-id="e8704-552">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e8704-553">Wstrzymuje działanie bieżącego wątku, aż wątek, który przetwarza kolejki finalizatory został opróżniony tej kolejki.</span><span class="sxs-lookup"><span data-stu-id="e8704-553">Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8704-554">Gdy moduł zbierający elementy bezużyteczne wykryje obiektów, które można odzyskać, sprawdza każdy obiekt, aby ustalić wymagania finalizacji obiektu.</span><span class="sxs-lookup"><span data-stu-id="e8704-554">When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</span></span> <span data-ttu-id="e8704-555">Jeśli obiekt implementuje finalizator, a nie wyłączył finalizację przez wywołanie metody <xref:System.GC.SuppressFinalize%2A>, obiekt jest umieszczany na liście obiektów oznaczonych jako gotowe do finalizacji.</span><span class="sxs-lookup"><span data-stu-id="e8704-555">If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization.</span></span> <span data-ttu-id="e8704-556">Moduł odśmiecania pamięci wywołuje <xref:System.Object.Finalize%2A> metod dla obiektów w tej liście, a Usuwa wpisy z listy.</span><span class="sxs-lookup"><span data-stu-id="e8704-556">The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list.</span></span> <span data-ttu-id="e8704-557">To bloki metody do wszystkich finalizatory mają zostało ukończone.</span><span class="sxs-lookup"><span data-stu-id="e8704-557">This method blocks until all finalizers have run to completion.</span></span>  
  
 <span data-ttu-id="e8704-558">Wątek, na którym są uruchamiane finalizatory jest nieokreślony, więc nie ma żadnej gwarancji, że ta metoda zostanie zakończona.</span><span class="sxs-lookup"><span data-stu-id="e8704-558">The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</span></span> <span data-ttu-id="e8704-559">Jednak ten wątek może zostać przerwane przez inny wątek podczas <xref:System.GC.WaitForPendingFinalizers%2A> metoda jest w toku.</span><span class="sxs-lookup"><span data-stu-id="e8704-559">However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress.</span></span> <span data-ttu-id="e8704-560">Na przykład można uruchomić inny wątek, który czeka przez pewien czas, a następnie przerywa działanie tego wątku, jeśli ten wątek jest nadal zawieszone.</span><span class="sxs-lookup"><span data-stu-id="e8704-560">For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8704-561">Poniższy przykład pokazuje sposób użycia <xref:System.GC.WaitForPendingFinalizers%2A> metodę, aby zawiesić bieżącego wątku, aż do finalizacji zebranych obiektów.</span><span class="sxs-lookup"><span data-stu-id="e8704-561">The following example demonstrates how to use the <xref:System.GC.WaitForPendingFinalizers%2A> method to suspend the current thread until finalization of all the collected objects is complete.</span></span>  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
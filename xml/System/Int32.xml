<Type Name="Int32" FullName="System.Int32">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a761dd229f8dca7bce672ead43967acdbfa072d6" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30744758" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Int32 : IComparable, IComparable&lt;int&gt;, IConvertible, IEquatable&lt;int&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit int32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;int32&gt;, class System.IConvertible, class System.IEquatable`1&lt;int32&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Int32" />
  <TypeSignature Language="VB.NET" Value="Public Structure Int32&#xA;Implements IComparable, IComparable(Of Integer), IConvertible, IEquatable(Of Integer), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Int32 : IComparable, IComparable&lt;int&gt;, IConvertible, IEquatable&lt;int&gt;, IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Int32&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Int32&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje całkowita 32-bitowych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32> jest typu modyfikować wartości, który reprezentuje podpisane liczby całkowite z wartościami w zakresie od ujemna 2 147 483 648 (reprezentowany przez <xref:System.Int32.MinValue?displayProperty=nameWithType> stałej) za pośrednictwem dodatnią 2 147 483 647 (reprezentowany przez <xref:System.Int32.MaxValue?displayProperty=nameWithType> stałej. Typ wartości bez znaku 32-bitowa liczba całkowita obejmuje również .NET Framework <xref:System.UInt32>, który reprezentuje wartości, które należeć do zakresu od 0 do 4 294 967 295.  
  
## <a name="instantiating-an-int32-value"></a>Utworzenie wystąpienia wartości Int32  
 Można utworzyć wystąpienia <xref:System.Int32> wartość na kilka sposobów:  
  
-   Można zadeklarować <xref:System.Int32> zmiennej i przypisz jej wartość literału liczba całkowita, która jest spoza zakresu <xref:System.Int32> — typ danych. Poniższy przykład deklaruje dwa <xref:System.Int32> zmienne i przypisuje je wartości w ten sposób.  
  
     [!code-csharp[System.Int32.Instantiation#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.Instantiation/cs/Instantiate1.cs#1)]
     [!code-vb[System.Int32.Instantiation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.Instantiation/vb/Instantiate1.vb#1)]  
  
-   Można przypisać wartości typu Liczba całkowita, której zakres jest podzbiorem z <xref:System.Int32> typu. Jest to konwersję rozszerzającą, która nie wymaga operatora rzutowania w języku C# lub metody konwersji w języku Visual Basic.  
  
     [!code-csharp[System.Int32.Instantiation#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.Instantiation/cs/Instantiate1.cs#4)]
     [!code-vb[System.Int32.Instantiation#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.Instantiation/vb/Instantiate1.vb#4)]  
  
-   Można przypisać wartości typu liczbowego, której zakres przekracza z <xref:System.Int32> typu. Jest to konwersji zawężającej, dzięki czemu wymaga operatora rzutowania w języku C# i metoda konwersji w języku Visual Basic, jeśli `Option Strict` znajduje się na. Jeśli wartość liczbowa jest <xref:System.Single>, <xref:System.Double>, lub <xref:System.Decimal> wartość, która zawiera składnik ułamkowych obsługi jego część ułamkowa zależy od kompilatora wykonywania konwersji. Poniższy przykład wykonuje konwersji zawężającej można przypisać kilku wartości numerycznych <xref:System.Int32> zmiennych.  
  
     [!code-csharp[System.Int32.Instantiation#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.Instantiation/cs/Instantiate1.cs#2)]
     [!code-vb[System.Int32.Instantiation#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.Instantiation/vb/Instantiate1.vb#2)]  
  
-   Należy wywołać metodę <xref:System.Convert> klasy przekonwertować żadnego obsługiwany typ <xref:System.Int32> wartość. Jest to możliwe, ponieważ <xref:System.Int32> obsługuje <xref:System.IConvertible> interfejsu. Poniższy przykład przedstawia konwersji tablicy <xref:System.Decimal> wartości do <xref:System.Int32> wartości.  
  
     [!code-csharp[System.Convert.ToInt32#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#4)]
     [!code-vb[System.Convert.ToInt32#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#4)]  
  
-   Możesz wywołać <xref:System.Int32.Parse%2A> lub <xref:System.Int32.TryParse%2A> metodę, aby przekonwertować reprezentację ciągu <xref:System.Int32> do wartości <xref:System.Int32>. Ten ciąg może zawierać cyfry dziesiętne lub szesnastkowe. Poniższy przykład przedstawia operację analizy, używając wartości dziesiętnej i ciąg szesnastkowy.  
  
     [!code-csharp[System.Int32.Instantiation#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.Instantiation/cs/Instantiate1.cs#3)]
     [!code-vb[System.Int32.Instantiation#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.Instantiation/vb/Instantiate1.vb#3)]  
  
## <a name="performing-operations-on-int32-values"></a>Wykonywanie operacji na wartościach Int32  
 <xref:System.Int32> Typ obsługuje standardowe operacji matematycznych, takich jak dodawanie, odejmowania, dzielenia, mnożenia, negacji i negacji jednoargumentowy. Inne typy całkowite, takich jak <xref:System.Int32> typu obsługuje również operatora testu koniunkcji `AND`, `OR`, `XOR`, lewego shift i operatory przesunięcia w prawo.  
  
 Standardowych operatorów liczbowa służy do porównywania dwóch <xref:System.Int32> wartości, lub można wywołać <xref:System.Int32.CompareTo%2A> lub <xref:System.Int32.Equals%2A> metody.  
  
 Możesz także wywołać członków <xref:System.Math> klasę, aby wykonać szereg operacji liczbowych, włącznie z pobierania wartość bezwzględna liczby obliczanie iloraz i resztę z dzielenia wartości całkowitych określania wartości maksymalnej lub minimalnej liczby dwa uzyskanie znak liczby i zaokrąglanie liczby liczb całkowitych.  
  
## <a name="representing-an-int32-as-a-string"></a>Reprezentowanie wartości Int32 jako ciągu  
 <xref:System.Int32> Typu zapewnia pełną obsługę ciągi formatujące standardowe i niestandardowe. (Aby uzyskać więcej informacji, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md), [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md), i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
 Aby sformatować <xref:System.Int32> wartość jako ciąg integralną nie zera wiodące można wywołać bez parametrów <xref:System.Int32.ToString> metody. Przy użyciu specyfikatora formatu "D", mogą również obejmować określoną liczbę zera wiodące w reprezentacji ciągu. Przy użyciu specyfikator formatu "N", mogą zawierać separatorów grup i określić liczbę miejsc dziesiętnych, które mają być widoczne w reprezentację liczby. Przy użyciu specyfikatora formatu "X", reprezentują <xref:System.Int32> wartość jako ciąg szesnastkowy. Poniższy przykład formatuje elementów w tablicy <xref:System.Int32> wartości w tych sposobów.  
  
 [!code-csharp[System.Int32.Formatting#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.Formatting/cs/Formatting1.cs#1)]
 [!code-vb[System.Int32.Formatting#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.Formatting/vb/Formatting1.vb#1)]  
  
 Można również sformatować <xref:System.Int32> wartość jako wartość binarną, ósemkowego dziesiętną lub szesnastkową ciąg przez wywołanie metody <xref:System.Convert.ToString%28System.Int32%2CSystem.Int32%29> — metoda i dostarczenie base jako drugiego parametru metody. Poniższy przykład wywołuje ten metodę w celu wyświetlenia danych binarnych, ósemkowego i szesnastkowe reprezentacje tablicę wartości będące liczbami całkowitymi.  
  
 [!code-csharp[System.Int32.Formatting#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.Formatting/cs/Formatting1.cs#2)]
 [!code-vb[System.Int32.Formatting#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.Formatting/vb/Formatting1.vb#2)]  
  
## <a name="working-with-non-decimal-32-bit-integer-values"></a>Posługiwanie się niedziesiętnymi 32-bitowymi liczbami całkowitymi  
 Oprócz pracy z poszczególnych liczb całkowitych jako wartości dziesiętnej, możesz wykonywać operacje bitowe o wartości będące liczbami całkowitymi i pracować z binary lub szesnastkowe reprezentacje wartości będące liczbami całkowitymi. <xref:System.Int32> wartości są reprezentowane w bitach 31 z bitowego trzydzieści sekund używany jako bitem znaku. Wartości dodatnie są reprezentowane przy użyciu reprezentacja logowania i wielkości. Wartości ujemne są w dwóch jego reprezentacja dopełnienia. Jest to ważne, należy wziąć pod uwagę podczas przeprowadzania Operacje bitowe <xref:System.Int32> wartości lub podczas pracy z poszczególnych bitów. Aby wykonać liczbową, logiczną lub operacja porównania dwóch wartości podawać, obie wartości musi być taką samą reprezentację.  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie tego typu są bezpieczne wątkowo. Elementy członkowskie, które na pierwszy rzut oka modyfikują stan wystąpienia, w rzeczywistości zwracają nowe wystąpienie zainicjowane z nową wartością. Podobnie jak w przypadku innych typów odczytywanie i zapisywanie w udostępnionej zmiennej, która zawiera wystąpienie tego typu, musi być chronione przez blokadę w celu zagwarantowania bezpieczeństwa wątków.</threadsafe>
    <altmember cref="T:System.UInt32" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje tego wystąpienia określonego obiektu lub <see cref="T:System.Int32" /> i zwraca dane dotyczące ich względne wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.CompareTo(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(int value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Liczba całkowita do porównania.</param>
        <summary>Porównuje tego wystąpienia określonego całkowita 32-bitowe i zwraca dane dotyczące ich względne wartości.</summary>
        <returns>Podpisem liczbę określającą względne wartości tego wystąpienia i <paramref name="value" />.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Opis elementu  
  
 </description></listheader><item><term> Mniejsza od zera.  
  
 </term><description> To wystąpienie jest mniejsza niż <paramref name="value" />.  
  
 </description></item><item><term> Zero  
  
 </term><description> To wystąpienie jest równe <paramref name="value" />.  
  
 </description></item><item><term> Większa niż zero  
  
 </term><description> To wystąpienie jest większa niż <paramref name="value" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje <xref:System.IComparable%601?displayProperty=nameWithType> interfejsu i wykonuje nieco lepsza niż <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> — metoda, ponieważ nie muszą być konwertowane `value` parametru do obiektu.  
  
 W zależności od języka programowania, może być możliwe do kodu <xref:System.Int32.CompareTo%2A> metody, których typ parametru ma mniejszą liczbę bitów (mniejszą niż jest) niż typ wystąpienia. To jest możliwe, ponieważ w niektórych językach programowania jest wykonywana niejawna konwersja poszerzająca, która powoduje reprezentowanie parametru jako typu z taką samą liczbą bitów jak liczba bitów wystąpienia.  
  
 Na przykład, załóżmy, że typ wystąpienia <xref:System.Int32> i typ parametru jest <xref:System.Byte>. Kompilator języka Microsoft C# generuje instrukcje do reprezentowania wartości parametru jako <xref:System.Int32>, następnie generuje <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> metodę, która porównuje wartości <xref:System.Int32> wystąpienia i <xref:System.Int32> reprezentacja wartości parametru.  
  
 Aby ustalić, czy kompilator metody dokonuje na typach liczbowych niejawnych konwersji poszerzających, zajrzyj do dokumentacji języka programowania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Int32.CompareTo%28System.Int32%29?displayProperty=nameWithType> metody. Oprócz wyświetlania wartości zwracanych przez metodę czterech różnych porównań, konwertuje wartość zwracana do elementu członkowskiego niestandardowego `Comparison` wyliczenia, którego wartość jest również wyświetlana.  
  
 [!code-csharp[System.Int32.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.CompareTo/cs/CompareTo1.cs#1)]
 [!code-vb[System.Int32.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.CompareTo/vb/CompareTo1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.UInt32" />
        <altmember cref="M:System.Int32.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania, lub <see langword="null" />.</param>
        <summary>Porównuje to wystąpienie z określonym obiektem i zwraca wskazanie ich względnych wartości.</summary>
        <returns>Podpisem liczbę określającą względne wartości tego wystąpienia i <paramref name="value" />.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Opis elementu  
  
 </description></listheader><item><term> Mniejsza od zera.  
  
 </term><description> To wystąpienie jest mniejsza niż <paramref name="value" />.  
  
 </description></item><item><term> Zero  
  
 </term><description> To wystąpienie jest równe <paramref name="value" />.  
  
 </description></item><item><term> Większa niż zero  
  
 </term><description> To wystąpienie jest większa niż <paramref name="value" />.  
  
 —lub—  
  
 <paramref name="value" /> jest <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie wystąpienia <xref:System.Int32>, niezależnie od jego wartość jest uznawany za większy niż `null`.  
  
 `value` musi być `null` lub wystąpienie <xref:System.Int32>; w przeciwnym razie jest zwracany wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> Nie jest <see cref="T:System.Int32" />.</exception>
        <altmember cref="T:System.UInt32" />
        <altmember cref="M:System.Int32.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest taki sam jak określony obiekt lub <see cref="T:System.Int32" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (int obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(int32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.Equals(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(int obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Int32" /> Wartość do porównania z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe określonej <see cref="T:System.Int32" /> wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> ma taką samą wartość jak to wystąpienie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje <xref:System.IEquatable%601?displayProperty=nameWithType> interfejsu i wykonuje nieco większą niż <xref:System.Int32.Equals%28System.Object%29?displayProperty=nameWithType> , ponieważ nie muszą być konwertowane `obj` parametru do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Rozpoznanie przeciążenia kompilator może konto do widocznej różnicy zachowanie dwóch <see cref="M:System.Int32.Equals(System.Int32)" /> przeciążenia metody. Jeśli niejawna konwersja między <paramref name="obj" /> argumentu i <see cref="T:System.Int32" /> zdefiniowano i argument nie jest typu <see cref="T:System.Object" />, kompilatory wykonać niejawnej konwersji i wywołanie <see cref="M:System.Int32.Equals(System.Int32)" /> metody. W przeciwnym razie wywołać <see cref="M:System.Int32.Equals(System.Object)" /> metody, która zawsze zwraca <see langword="false" /> jeśli jego <paramref name="obj" /> argument nie jest <see cref="T:System.Int32" /> wartość. Poniższy przykład przedstawia różnicy w zachowaniu przeciążenia dwie metody. W przypadku programu <see cref="T:System.Byte" />, <see cref="T:System.Int16" />, <see cref="T:System.SByte" />, i <see cref="T:System.UInt16" /> wartości, zwraca pierwszy porównanie <see langword="true" /> ponieważ kompilator automatycznie wykonuje konwersję rozszerzającą i wywołania <see cref="M:System.Int32.Equals(System.Int32)" /> metody, natomiast drugi argument porównania <see langword="false" /> ponieważ wywołuje kompilator <see cref="M:System.Int32.Equals(System.Object)" /> metody.  
  
 [!code-csharp[System.Int32.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.int32.equals/cs/equalsoverloads2.cs#1)]
 [!code-vb[System.Int32.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.int32.equals/vb/equalsoverloads2.vb#1)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> jest wystąpieniem <see cref="T:System.Int32" /> i wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia użycie `Equals` w kontekście `Int32`, porównanie dwóch `int` wartości i zwracanie `true` jeśli reprezentują ten sam numer lub `false` Jeśli tak nie jest.  
  
 [!code-cpp[Int32_Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/Int32_Equals/CPP/int32_equals.cpp#1)]
 [!code-csharp[Int32_Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/Int32_Equals/CS/int32_equals.cs#1)]
 [!code-vb[Int32_Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Int32_Equals/VB/int32_equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Rozpoznanie przeciążenia kompilator może konto do widocznej różnicy zachowanie dwóch <see cref="M:System.Int32.Equals(System.Int32)" /> przeciążenia metody. Jeśli niejawna konwersja między <paramref name="obj" /> argumentu i <see cref="T:System.Int32" /> zdefiniowano i argument nie jest typu <see cref="T:System.Object" />, kompilatory wykonać niejawnej konwersji i wywołanie <see cref="M:System.Int32.Equals(System.Int32)" /> metody. W przeciwnym razie wywołać <see cref="M:System.Int32.Equals(System.Object)" /> metody, która zawsze zwraca <see langword="false" /> jeśli jego <paramref name="obj" /> argument nie jest <see cref="T:System.Int32" /> wartość. Poniższy przykład przedstawia różnicy w zachowaniu przeciążenia dwie metody. W przypadku programu <see cref="T:System.Byte" />, <see cref="T:System.Int16" />, <see cref="T:System.SByte" />, i <see cref="T:System.UInt16" /> wartości, zwraca pierwszy porównanie <see langword="true" /> ponieważ kompilator automatycznie wykonuje konwersję rozszerzającą i wywołania <see cref="M:System.Int32.Equals(System.Int32)" /> metody, natomiast drugi argument porównania <see langword="false" /> ponieważ wywołuje kompilator <see cref="M:System.Int32.Equals(System.Object)" /> metody.  
  
 [!code-csharp[System.Int32.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.int32.equals/cs/equalsoverloads2.cs#1)]
 [!code-vb[System.Int32.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.int32.equals/vb/equalsoverloads2.vb#1)]</para>
        </block>
        <altmember cref="M:System.Int32.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.TypeCode" /> dla typu wartości <see cref="T:System.Int32" />.</summary>
        <returns>Stała wyliczeniowa <see cref="F:System.TypeCode.Int32" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const int MaxValue = 2147483647;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxValue = int32(2147483647)" />
      <MemberSignature Language="DocId" Value="F:System.Int32.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Integer  = 2147483647" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxValue = 2147483647;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2147483647</MemberValue>
      <Docs>
        <summary>Reprezentuje największa możliwa wartość z <see cref="T:System.Int32" />. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest 2 147 483 647; oznacza to, szesnastkowa 0x7FFFFFFF.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Int32.MaxValue> właściwość, aby zapobiec <xref:System.OverflowException> podczas konwertowania na <xref:System.Int32> wartość.  
  
 [!code-cpp[System.Int32.MaxValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.int32.maxvalue/cpp/maxvalue1.cpp#1)]
 [!code-csharp[System.Int32.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.int32.maxvalue/cs/maxvalue1.cs#1)]
 [!code-vb[System.Int32.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.int32.maxvalue/vb/maxvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Int32.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const int MinValue = -2147483648;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MinValue = int32(-2147483648)" />
      <MemberSignature Language="DocId" Value="F:System.Int32.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Integer  = -2147483648" />
      <MemberSignature Language="C++ CLI" Value="public: int MinValue = -2147483648;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-2147483648</MemberValue>
      <Docs>
        <summary>Reprezentuje najniższą możliwą wartość elementu <see cref="T:System.Int32" />. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest -2,147,483,648; oznacza to, szesnastkowa 0x80000000.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Int32.MinValue> właściwość, aby zapobiec <xref:System.OverflowException> podczas konwertowania na <xref:System.Int32> wartość.  
  
 [!code-cpp[System.Int32.MaxValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.int32.maxvalue/cpp/maxvalue1.cpp#1)]
 [!code-csharp[System.Int32.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.int32.maxvalue/cs/maxvalue1.cs#1)]
 [!code-vb[System.Int32.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.int32.maxvalue/vb/maxvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Int32.MaxValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje liczbę reprezentację ciągu jego 32-bitowej liczby całkowitej ze znakiem równoważne.</summary>
        <altmember cref="Overload:System.Int32.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static int Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, która ma zostać przekształcona.</param>
        <summary>Konwertuje liczbę reprezentację ciągu jego 32-bitowej liczby całkowitej ze znakiem równoważne.</summary>
        <returns>32-bitowe całkowita odpowiednikiem numer zawarty w <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `s` Parametr zawiera szereg formularza:  
  
 [odstęp][znak]cyfry[odstęp]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|ws|Opcjonalny odstęp.|  
|znak|Opcjonalny znak.|  
|cyfry|Sekwencja cyfr od 0 do 9.|  
  
 `s` Parametr jest interpretowany za pomocą <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu. Poza cyframi dziesiętnymi dopuszcza się tylko spacje początkowe i końcowe razem z wiodącym znakiem. Aby oznaczyć elementy style, które mogą być obecne w `s`, użyj jednej <xref:System.Int32.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> lub <xref:System.Int32.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 `s` Parametru jest analizować przy użyciu formatowania informacji w <xref:System.Globalization.NumberFormatInfo> obiekt inicjowany dla bieżącego ustawienia kulturowego systemu. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Aby przeanalizować ciągu przy użyciu formatowania informacji niektóre inne kultury, użyj <xref:System.Int32.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób konwertowania wartości ciągu na wartość całkowita 32-bitowej przy użyciu <xref:System.Int32.Parse%28System.String%29?displayProperty=nameWithType> metody. Wynikową wartość całkowitą jest następnie wyświetlane w konsoli.  
  
 [!code-cpp[System.Int32.Parse#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Int32.Parse/cpp/parse1.cpp#1)]
 [!code-csharp[System.Int32.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Int32.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> nie jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> reprezentuje liczbę mniej niż <see cref="F:System.Int32.MinValue" /> lub większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="M:System.Int32.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static int Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, która ma zostać przekształcona.</param>
        <param name="style">Bitowe połączenie wartości wyliczenia wskazująca elementy style, które mogą być obecne w <c>s</c>. Jest Typowa wartość do określenia <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <summary>Konwertuje reprezentacja ciągu liczb w stylu określonego jego 32-bitowej liczby całkowitej ze znakiem równoważne.</summary>
        <returns>32-bitowe całkowita odpowiednikiem liczbie określonej w <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` Parametru definiuje elementy style (takie jak biały znak, symbol znaku dodatnią lub ujemną lub tysięcy symbol separatora) mogą w `s` parametr powodzenie operacji analizy. Musi być kombinacją flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. W zależności od wartości `style`, `s` parametr może zawierać następujące elementy:  
  
 [odstęp][$][znak][cyfry,]cyfry[.cyfry_ułamkowe][e[znak]cyfry_potęgowe][odstęp]  
  
 Lub, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowHexSpecifier>:  
  
 [odstęp]cyfry_szesnastkowe[odstęp]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp. Biały znak, może występować na początku `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę która może występować na końcu `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.|  
|*$*|Symbol waluty specyficzny dla kultury. Jej położenie w ciągu jest definiowana za pomocą <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> właściwości bieżącej kultury. Symbol waluty bieżącej kultury może występować w `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.|  
|*sign*|Opcjonalny znak. Logowania może wystąpić na początku `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę która może występować na końcu `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi. Użycie nawiasów w `s` wskaż wartość ujemną, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flagi.|  
|*cyfr*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Sekwencja cyfr od 0 do 9. Aby uzyskać *fractional_digits*tylko cyfry 0 jest prawidłowy.|  
|*,*|Symbol separatora tysięcy specyficzny dla kultury. Bieżąca kultura tysięcy separatora może występować w `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.|  
|*.*|Symbol dziesiętny specyficzny dla kultury. Symbol punktu dziesiętnego bieżącej kultury może występować w `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi. Tylko cyfry 0 może występować jako cyfrę ułamkowych analizy operacja powiodła się; Jeśli *fractional_digits* zawiera dowolną cyfrę <xref:System.OverflowException> jest generowany.|  
|*e*|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym. `s` Parametr może reprezentować liczbę w notacji wykładniczej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.|  
|*hexdigits*|Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.|  
  
 Ciąg zawierający tylko cyfry (które odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> styl) zawsze przeanalizowany pomyślnie. Większość pozostałych <xref:System.Globalization.NumberStyles> członkowie sterować elementów, które mogą być, ale nie muszą znajdować się w ciągu wejściowym. W poniższej tabeli przedstawiono poszczególne <xref:System.Globalization.NumberStyles> elementów członkowskich mają wpływ na elementy, które mogą być obecne w `s`.  
  
|Wartość wyliczenia NumberStyles|Dodatkowe (poza cyframi) elementy dozwolone w parametrze s|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*Cyfr* tylko element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Dziesiętnego ( *.* ) i *cyfr ułamkowych* elementów.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s` Parametr można również użyć notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* element na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* element na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Znak* element na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Znak* element na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Znak* elementu w postaci nawiasów otaczającej wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Tysięcy separatora ( *,* ) elementu.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|* $ * Elementu.|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie. `s` Parametr nie może reprezentować liczbę szesnastkową lub numer w notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* element na początku lub na końcu `s`, *znak* na początku `s`i dziesiętnego ( *.* ) symbolu. `s` Parametr można również użyć notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, Tysięcy separatora ( *,* ), a separatorem dziesiętnym ( *.* ) elementów.|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie style, z wyjątkiem `s` nie może reprezentować liczbę szesnastkową.|  
  
 Jeśli <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flaga jest wykorzystywana, `s` musi mieć wartość szesnastkową bez prefiksu. Na przykład "C9AF3" analizuje pomyślnie, ale nie ma "0xC9AF3". Tylko innych flagi, które można łączyć z `s` parametru czy <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. ( <xref:System.Globalization.NumberStyles> Wyliczenie zawiera styl numer złożone, <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>, który obejmuje zarówno flagi biały znak.)  
  
 `s` Parametru jest analizować przy użyciu formatowania informacji w <xref:System.Globalization.NumberFormatInfo> obiekt, który został zainicjowany dla bieżącego ustawienia kulturowego systemu. Aby określić kulturę, którego formatowania informacje są używane dla operacji analizy, należy wywołać <xref:System.Int32.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> przeciążenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Int32.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> metodę, aby przeanalizować reprezentacji ciągu kilka <xref:System.Int32> wartości. W przykładzie bieżącą kulturą jest en-US.  
  
 [!code-cpp[System.Int32.Parse#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Int32.Parse/cpp/parse2.cpp#2)]
 [!code-csharp[System.Int32.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.Parse/cs/Parse2.cs#2)]
 [!code-vb[System.Int32.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.Parse/vb/Parse2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.  
  
 —lub—  
  
 <paramref name="style" /> nie jest kombinacją <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> i <see cref="F:System.Globalization.NumberStyles.HexNumber" /> wartości.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> nie jest w formacie zgodne z <paramref name="style" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> reprezentuje liczbę mniej niż <see cref="F:System.Int32.MinValue" /> lub większa niż <see cref="F:System.Int32.MaxValue" />.  
  
 —lub—  
  
 <paramref name="s" /> zawiera inną niż zero, ułamkowych cyfry.</exception>
        <altmember cref="M:System.Int32.ToString" />
        <altmember cref="Overload:System.Int32.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static int Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, która ma zostać przekształcona.</param>
        <param name="provider">Obiekt, który dostarcza specyficzne dla kultury formatowania informacji na temat <c>s</c>.</param>
        <summary>Konwertuje reprezentację liczby w określonym formacie specyficzne dla kultury jego 32-bitowej liczby całkowitej ze znakiem równoważne.</summary>
        <returns>32-bitowe całkowita odpowiednikiem liczbie określonej w <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody <xref:System.Int32.Parse%28System.String%2CSystem.IFormatProvider%29> metoda jest zwykle używana do konwersji tekstu, które mogą być sformatowane na różne sposoby <xref:System.Int32> wartość. Może na przykład służyć do skonwertowania tekstu wprowadzanego przez użytkownika w polu tekstowym HTML na wartość liczbową.  
  
 `s` Parametr zawiera szereg formularza:  
  
 [odstęp][znak]cyfry[odstęp]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp.|  
|*sign*|Opcjonalny znak.|  
|*cyfr*|Sekwencja cyfr od 0 do 9.|  
  
 `s` Parametr jest interpretowany za pomocą <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu. Poza cyframi dziesiętnymi dopuszcza się tylko spacje początkowe i końcowe razem z wiodącym znakiem. Aby oznaczyć elementy style, które mogą być obecne w `s`, użyj <xref:System.Int32.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 `provider` Parametr jest <xref:System.IFormatProvider> wdrożenia, takich jak <xref:System.Globalization.NumberFormatInfo> lub <xref:System.Globalization.CultureInfo> obiektu. `provider` Parametr dostarcza informacje specyficzne dla kultury format `s`. Jeśli `provider` jest `null`, <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury jest używany.  
  
   
  
## Examples  
 W poniższym przykładzie występuje program obsługi zdarzeń kliknięcia przycisku w formularzu sieci Web. Używa tablicy zwracanej przez <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> właściwości w celu określenia ustawień regionalnych użytkownika. Następnie tworzy <xref:System.Globalization.CultureInfo> obiekt, który odpowiada ustawień regionalnych. <xref:System.Globalization.NumberFormatInfo> Obiektu, który należy do tego <xref:System.Globalization.CultureInfo> obiektu są następnie przekazywane do <xref:System.Int32.Parse%28System.String%2CSystem.IFormatProvider%29> wejściowych metodę, aby przekonwertować użytkownika do <xref:System.Int32> wartości.  
  
 [!code-csharp[ParseMethod#4](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#4)]
 [!code-vb[ParseMethod#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> nie jest poprawnym formacie.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> reprezentuje liczbę mniej niż <see cref="F:System.Int32.MinValue" /> lub większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="M:System.Int32.ToString" />
        <altmember cref="Overload:System.Int32.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static int Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Integer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static int Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, która ma zostać przekształcona.</param>
        <param name="style">Bitowe połączenie wartości wyliczenia wskazująca elementy style, które mogą być obecne w <c>s</c>. Jest Typowa wartość do określenia <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Obiekt, który dostarcza informacje specyficzne dla kultury format <c>s</c>.</param>
        <summary>Konwertuje reprezentację liczby w określonym styl i format specyficzne dla kultury jego 32-bitowej liczby całkowitej ze znakiem równoważne.</summary>
        <returns>32-bitowe całkowita odpowiednikiem liczbie określonej w <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` Parametru definiuje elementy stylu (na przykład biały znak lub dodatnią logowania), które są dozwolone w `s` parametr powodzenie operacji analizy. Musi być kombinacją flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. W zależności od wartości `style`, `s` parametr może zawierać następujące elementy:  
  
 [ws][$][sign][digits,]digits[.fractional_digist][e[sign]exponential_digits][ws]  
  
 Lub, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowHexSpecifier>:  
  
 [odstęp]cyfry_szesnastkowe[odstęp]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp. Biały znak, może występować na początku `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę która może występować na końcu `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.|  
|*$*|Symbol waluty specyficzny dla kultury. Jej położenie w ciągu jest definiowana za pomocą <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> właściwość <xref:System.Globalization.NumberFormatInfo> obiektu zwróconego przez <xref:System.IFormatProvider.GetFormat%2A> metody `provider` parametru. Symbol waluty może występować w `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.|  
|*sign*|Opcjonalny znak. Logowania może wystąpić na początku `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagi lub na końcu `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi. Użycie nawiasów w `s` wskaż wartość ujemną, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flagi.|  
|*cyfr*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Sekwencja cyfr od 0 do 9. Aby uzyskać *fractional_digits*tylko cyfry 0 jest prawidłowy.|  
|*,*|Symbol separatora tysięcy specyficzny dla kultury. Tysięcy separatora kultury określonej przez `provider` może występować w `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.|  
|*.*|Symbol dziesiętny specyficzny dla kultury. Symbol punktu dziesiętnego kultury określonej przez `provider` może występować w `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.<br /><br /> Tylko cyfry 0 może występować jako cyfrę ułamkowych analizy operacja powiodła się; Jeśli *fractional_digits* zawiera dowolną cyfrę <xref:System.OverflowException> jest generowany.|  
|*e*|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym. `s` Parametr może reprezentować liczbę w notacji wykładniczej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.|  
|*hexdigits*|Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.|  
  
 Ciąg zawierający tylko cyfry dziesiętne (które odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> styl) zawsze zostanie przetworzona pomyślnie, jeśli znajduje się w zakresie <xref:System.Int32> typu. Większość pozostałych <xref:System.Globalization.NumberStyles> członkowie sterować elementów, które mogą być, ale nie muszą znajdować się w tym ciągu wejściowego. W poniższej tabeli przedstawiono poszczególne <xref:System.Globalization.NumberStyles> elementów członkowskich mają wpływ na elementy, które mogą być obecne w `s`.  
  
|Niezłożone wartości wyliczenia NumberStyles|Dodatkowe (poza cyframi) elementy dozwolone w parametrze s|  
|----------------------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>|Tylko cyfry dziesiętne.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>|Dziesiętnego ( *.* ) i *cyfr ułamkowych* elementów. Jednak *cyfr ułamkowych* musi składać się z tylko jedną lub więcej cyfry 0 lub <xref:System.OverflowException> jest generowany.|  
|<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>|`s` Parametr można również użyć notacji wykładniczej. Jeśli `s` reprezentuje numer w notacji wykładniczej, musi reprezentować całkowitą w zakresie <xref:System.Int32> bez składnika inną niż zero, ułamkową — typ danych.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>|*Ws* element na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>|*Ws* element na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>|Znak dodatni mogą występować przed *cyfr*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>|Znak dodatni może występować po *cyfr*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>|*Znak* elementu w postaci nawiasów otaczającej wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>|Tysięcy separatora ( *,* ) elementu.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>|* $ * Elementu.|  
  
 Jeśli <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flaga jest wykorzystywana, `s` musi mieć wartość szesnastkową bez prefiksu. Na przykład "C9AF3" analizuje pomyślnie, ale nie ma "0xC9AF3". Tylko innych flagi, które mogą być obecne w `style` są <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. ( <xref:System.Globalization.NumberStyles> Wyliczenie ma stylu numer złożone <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>, który obejmuje zarówno flagi biały znak.)  
  
 `provider` Parametr jest <xref:System.IFormatProvider> wdrożenia, takich jak <xref:System.Globalization.NumberFormatInfo> lub <xref:System.Globalization.CultureInfo> obiektu. `provider` Parametru zapewnia informacje specyficzne dla kultury używany podczas analizy. Jeśli `provider` jest `null`, <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury jest używany.  
  
   
  
## Examples  
 W poniższym przykładzie użyto różnych `style` i `provider` parametry, można przeanalizować ciągu reprezentacje <xref:System.Int32> wartości. On również przedstawia kilka różnych sposobów, w jaki te same parametry mogą być interpretowane w zależności od kultury, na których formatowania informacje są używane do analizowania operacji.  
  
 [!code-cpp[System.Int32.Parse#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Int32.Parse/cpp/parse3.cpp#3)]
 [!code-csharp[System.Int32.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.Parse/cs/Parse3.cs#3)]
 [!code-vb[System.Int32.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.Parse/vb/Parse3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.  
  
 —lub—  
  
 <paramref name="style" /> nie jest kombinacją <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> i <see cref="F:System.Globalization.NumberStyles.HexNumber" /> wartości.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> nie jest w formacie zgodne z <paramref name="style" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> reprezentuje liczbę mniej niż <see cref="F:System.Int32.MinValue" /> lub większa niż <see cref="F:System.Int32.MaxValue" />.  
  
 —lub—  
  
 <paramref name="s" /> zawiera inną niż zero, ułamkowych cyfry.</exception>
        <altmember cref="M:System.Int32.ToString" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość bieżącego wystąpienia nie jest 0; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Int32> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego wystąpienia przekonwertować <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Int32> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToByte%28System.Int32%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego wystąpienia przekonwertować <see cref="T:System.Char" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Int32> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToChar%28System.Int32%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda zgłasza <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Ta konwersja nie jest obsługiwana. Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego wystąpienia przekonwertować <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Int32> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDecimal%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego wystąpienia przekonwertować <see cref="T:System.Double" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Int32> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDouble%28System.Int32%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego wystąpienia przekonwertować <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Int32> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt16%28System.Int32%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego wystąpienia, bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Int32> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego wystąpienia przekonwertować <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Int32> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt64%28System.Int32%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego wystąpienia przekonwertować <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Int32> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSByte%28System.Int32%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego wystąpienia przekonwertować <see cref="T:System.Single" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Int32> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSingle%28System.Int32%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Typ, do którego można przekonwertować to <see cref="T:System.Int32" /> wartość.</param>
        <param name="provider">Obiekt, który zawiera informacje o formacie zwracanej wartości.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego wystąpienia przekonwertować <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Int32> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie `static` (`Shared` w języku Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego wystąpienia przekonwertować <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Int32> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt16%28System.Int32%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego wystąpienia przekonwertować <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Int32> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt32%28System.Int32%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego wystąpienia przekonwertować <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Int32> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt64%28System.Int32%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu.</summary>
        <returns>Reprezentacja ciągu wartość tego wystąpienia, składające się z znaku minus, jeśli wartość jest wartością ujemną oraz sekwencję cyfr od 0 do 9 z nie zera wiodące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString> Formatów metody <xref:System.Int32> wartości domyślnej ("G" lub ogólny) format przy użyciu <xref:System.Globalization.NumberFormatInfo> obiektu bieżącej kultury. Jeśli chcesz określić inny format lub kultury, użyj innego przeciążenia metody <xref:System.Int32.ToString%2A> metody, w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Format domyślny ("G")|Określoną kulturę|<xref:System.Int32.ToString%28System.IFormatProvider%29>|  
|Określony format|Domyślną kulturę (bieżącego)|<xref:System.Int32.ToString%28System.String%29>|  
|Określony format|Określoną kulturę|<xref:System.Int32.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Int32> wartości przy użyciu domyślnego <xref:System.Int32.ToString> metody. Wyświetla również reprezentacji ciągu <xref:System.Int32> wartość będącą wynikiem przy użyciu wielu specyfikatorów formatu standardowych. W przykładach jest używana konwencja formatowania kultury en-US.  
  
 [!code-cpp[System.Int32.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Int32.ToString/cpp/ToString1.cpp#1)]
 [!code-csharp[System.Int32.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.ToString/cs/ToString.cs#1)]
 [!code-vb[System.Int32.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.ToString/vb/ToString.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Int32.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu przy użyciu podanych danych formatowania specyficznych dla kultury.</summary>
        <returns>Reprezentacja ciągu wartość tego wystąpienia, określony przez <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%28System.IFormatProvider%29> Formatów metody <xref:System.Int32> wartości domyślnej ("G" lub ogólny) format przy użyciu <xref:System.Globalization.NumberFormatInfo> obiektu określonej kultury. Jeśli chcesz określić inny format lub bieżącej kultury, użyj innego przeciążenia metody <xref:System.Int32.ToString%2A> metody, w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Format domyślny ("G")|Domyślną kulturę (bieżącego)|<xref:System.Int32.ToString>|  
|Określony format|Domyślną kulturę (bieżącego)|<xref:System.Int32.ToString%28System.String%29>|  
|Określony format|Określoną kulturę|<xref:System.Int32.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 `provider` Parametr jest obiekt, który implementuje <xref:System.IFormatProvider> interfejsu. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który zawiera informacje specyficzne dla kultury o formatu ciągu, która jest zwracana przez tę metodę. Obiekt, który implementuje <xref:System.IFormatProvider> może być dowolną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury reguły formatowania, które mają być używane.  
  
-   A <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera liczbową formatowania informacji specyficznych dla tej wartości.  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> i których <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 Jeśli `provider` jest `null` lub <xref:System.Globalization.NumberFormatInfo> obiektu nie można uzyskać z `provider`, wartość zwracana jest sformatowany przy użyciu <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury wątku. Aby uzyskać informacje o bieżącej kultury wątku, zobacz <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono reprezentację ciągu <xref:System.Int32> wartości przy użyciu <xref:System.Globalization.CultureInfo> obiektów, które reprezentują kilka innych kultur.  
  
 [!code-cpp[System.Int32.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Int32.ToString/cpp/ToString2.cpp#2)]
 [!code-csharp[System.Int32.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.ToString/cs/ToString.cs#2)]
 [!code-vb[System.Int32.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.ToString/vb/ToString.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Int32.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Standardowy lub niestandardowy ciąg formatu liczbowego.</param>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu przy użyciu podanego formatu.</summary>
        <returns>Reprezentacja ciągu wartość tego wystąpienia, określony przez <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%28System.String%29> Formatów metody <xref:System.Int32> wartości w określonym formacie za pomocą <xref:System.Globalization.NumberFormatInfo> obiekt, który reprezentuje konwencje bieżącej kultury. Jeśli chcesz użyć domyślnej ("G" lub ogólny) format lub określ inną kulturę, użyj innego przeciążenia metody <xref:System.Int32.ToString%2A> metody, w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Format domyślny ("G")|Domyślną kulturę (bieżącego)|<xref:System.Int32.ToString>|  
|Format domyślny ("G")|Określoną kulturę|<xref:System.Int32.ToString%28System.IFormatProvider%29>|  
|Określony format|Określoną kulturę|<xref:System.Int32.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 `format` Parametr może mieć żadnych specyfikator prawidłowy standardowego formatu liczbowego, z wyjątkiem "R", a także dowolną kombinację specyfikatory niestandardowego formatu liczbowego. Jeśli `format` jest `null` lub ciąg pusty (""), zwracana wartość tego wystąpienia jest sformatowany w systemie specyfikator formatu liczbowego ogólne ("G").  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Zwracana wartość tego wystąpienia jest sformatowany w systemie <xref:System.Globalization.NumberFormatInfo> dla bieżącej kultury.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Int32> wartość przy użyciu specyfikatory obsługiwanego formatu liczbowego standardowe, wraz z dwóch niestandardowe ciągi formatujące liczby. W celu przeliczenia wartości liczbowych na ciągi w przykładzie użyto konwencji formatowania kultury en-US.  
  
 [!code-cpp[System.Int32.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Int32.ToString/cpp/ToString3.cpp#3)]
 [!code-csharp[System.Int32.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.ToString/cs/ToString.cs#3)]
 [!code-vb[System.Int32.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.ToString/vb/ToString.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowa lub nie jest obsługiwana.</exception>
        <altmember cref="M:System.Int32.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Standardowy lub niestandardowy ciąg formatu liczbowego.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu przy użyciu podanego formatu i informacji specyficznych dla kultury.</summary>
        <returns>Reprezentacja ciągu wartość tego wystąpienia, określony przez <paramref name="format" /> i <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%28System.String%2CSystem.IFormatProvider%29> Formatów metody <xref:System.Int32> wartości w określonym formacie za pomocą <xref:System.Globalization.NumberFormatInfo> obiektu określonej kultury. Jeśli chcesz użyć formatu lub kultury ustawień domyślnych, użyj innego przeciążenia metody <xref:System.Int32.ToString%2A> metody, w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Format domyślny ("G")|Domyślną kulturę (bieżącego)|<xref:System.Int32.ToString>|  
|Format domyślny ("G")|Określoną kulturę|<xref:System.Int32.ToString%28System.IFormatProvider%29>|  
|Określony format|Domyślną kulturę (bieżącego)|<xref:System.Int32.ToString%28System.String%29>|  
  
 `format` Parametr może być standard lub ciąg niestandardowego formatu liczbowego. Obsługiwane są wszystkie standardowe ciągi formatu liczbowego inne niż „R” (lub „r”), podobnie jak wszystkie znaki niestandardowych formatów liczbowych. Jeśli `format` jest `null` lub ciąg pusty (""), wartość zwracana dla tego wystąpienia jest sformatowany w systemie specyfikator formatu liczbowego ogólne ("G").  
  
 `provider` Parametr jest obiekt, który implementuje <xref:System.IFormatProvider> interfejsu. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje specyficzne dla kultury format o formacie ciągu, która jest zwracana przez tę metodę. Obiekt, który implementuje <xref:System.IFormatProvider> może być dowolną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury reguły formatowania, które mają być używane.  
  
-   A <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera liczbową formatowania informacji specyficznych dla tej wartości.  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> i których <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 Jeśli `provider` jest `null` lub <xref:System.Globalization.NumberFormatInfo> obiektu nie można uzyskać z `provider`, wartość zwracana dla tego wystąpienia jest sformatowany w systemie <xref:System.Globalization.NumberFormatInfo> dla bieżącej kultury.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono dodatnią i ujemną przy użyciu specyfikatory obsługiwanego formatu liczbowego standardowe dla trzech różnych kultur.  
  
 [!code-cpp[System.Int32.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Int32.ToString/cpp/ToString4.cpp#4)]
 [!code-csharp[System.Int32.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.ToString/cs/ToString.cs#4)]
 [!code-vb[System.Int32.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.ToString/vb/ToString.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowa lub nie jest obsługiwana.</exception>
        <altmember cref="M:System.Int32.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje liczbę reprezentację ciągu jego 32-bitowej liczby całkowitej ze znakiem równoważne. Wartości zwracanej wskazuje, czy operacja zakończyła się pomyślnie.</summary>
        <altmember cref="Overload:System.Int32.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out int result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] int32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.TryParse(System.ReadOnlySpan{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] int % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out int result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] int32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.TryParse(System.String,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] int % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, która ma zostać przekształcona.</param>
        <param name="result">Po powrocie z tej metody zawiera równoważne wartości 32-bitowej podpisanej liczby całkowitej liczby zawarte w <c>s</c>, jeśli konwersja powiodła się lub zero, jeśli konwersja nie powiodła się. Konwersja nie powiedzie się, jeśli <c>s</c> parametr jest <see langword="null" /> lub <see cref="F:System.String.Empty" />, nie jest poprawnym formacie lub reprezentuje liczbę mniej niż <see cref="F:System.Int32.MinValue" /> lub większa niż <see cref="F:System.Int32.MaxValue" />. Ten parametr jest przekazywany jako niezainicjowany; dowolna wartość pierwotnie podane w <c>wynik</c> zostaną zastąpione.</param>
        <summary>Konwertuje liczbę reprezentację ciągu jego 32-bitowej liczby całkowitej ze znakiem równoważne. Wartości zwracanej wskazuje, czy konwersja powiodła się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="s" /> został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.TryParse%2A> Metody przypomina <xref:System.Int32.Parse%2A> metody, z wyjątkiem <xref:System.Int32.TryParse%2A> — metoda nie zgłosić wyjątek, jeśli konwersja nie powiedzie się. Eliminuje konieczność użycia obsługi wyjątków do testowania <xref:System.FormatException> w przypadku gdy `s` jest nieprawidłowy i nie może zostać przeanalizowany pomyślnie.  
  
 `s` Parametr zawiera szereg formularza:  
  
 [odstęp][znak]cyfry[odstęp]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp.|  
|*sign*|Opcjonalny znak.|  
|*cyfr*|Sekwencja cyfr od 0 do 9.|  
  
 `s` Parametr jest interpretowany za pomocą <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu. Oprócz cyfr dziesiętnych dozwolone są tylko spacje początkowe i końcowe wraz z wiodący znak. Aby oznaczyć element style wraz z informacjami formatowania specyficzne dla kultury, które mogą być obecne w `s`, użyj <xref:System.Int32.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Int32%40%29?displayProperty=nameWithType> metody.  
  
 `s` Parametru jest analizować przy użyciu formatowania informacji w <xref:System.Globalization.NumberFormatInfo> obiekt inicjowany dla bieżącego ustawienia kulturowego systemu. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 To przeciążenie metody <xref:System.Int32.TryParse%2A> cyfr wszystkich zinterpretuje — metoda `s` parametr jako cyfr dziesiętnych. Aby przeanalizować liczbę szesnastkową reprezentację ciągu, należy wywołać <xref:System.Int32.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Int32%40%29?displayProperty=nameWithType> przeciążenia.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Int32.TryParse%28System.String%2CSystem.Int32%40%29?displayProperty=nameWithType> metodę o szereg różnych ciągami.  
  
 [!code-cpp[System.Int32.TryParse#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Int32.TryParse/cpp/int32.tryparse1.cpp#1)]
 [!code-csharp[System.Int32.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.TryParse/cs/TryParse1.cs#1)]
 [!code-vb[System.Int32.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.TryParse/vb/TryParse1.vb#1)]  
  
 Niektóre z ciągów który <xref:System.Int32.TryParse%28System.String%2CSystem.Int32%40%29> — metoda nie może przekonwertować w tym przykładzie są:  
  
-   "9432.0". Konwersja nie powiedzie się, ponieważ ciąg nie może zawierać separatora dziesiętnego; musi ona zawierać tylko cyfry wartości całkowitych.  
  
-   "16,667". Konwersja nie powiedzie się, ponieważ ciąg nie może zawierać separatorów grup; musi ona zawierać tylko cyfry wartości całkowitych.  
  
-   "(100)". Konwersja nie powiedzie się, ponieważ ciąg nie może zawierać znaku minus innego niż ten, który został zdefiniowany przez bieżącej kultury <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.NumberNegativePattern%2A?displayProperty=nameWithType> właściwości.  
  
-   "01FA". Konwersja nie powiedzie się, ponieważ ciąg nie może zawierać cyfry szesnastkowe; musi ona zawierać tylko cyfr dziesiętnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Int32.Parse(System.String)" />
        <altmember cref="M:System.Int32.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out int result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] int32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] int % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out int result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] int32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int32.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] int % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, która ma zostać przekształcona. Ten ciąg jest interpretowany przy użyciu stylu określony przez <c>styl</c>.</param>
        <param name="style">Bitowe połączenie wartości wyliczenia wskazująca elementy style, które mogą być obecne w <c>s</c>. Jest Typowa wartość do określenia <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Obiekt, który dostarcza specyficzne dla kultury formatowania informacji na temat <c>s</c>.</param>
        <param name="result">Po powrocie z tej metody zawiera równoważne wartości 32-bitowej podpisanej liczby całkowitej liczby zawarte w <c>s</c>, jeśli konwersja powiodła się lub zero, jeśli konwersja nie powiodła się. Konwersja nie powiedzie się, jeśli <c>s</c> parametr jest <see langword="null" /> lub <see cref="F:System.String.Empty" />, nie jest w formacie zgodne z <c>styl</c>, lub reprezentuje liczbę mniej niż <see cref="F:System.Int32.MinValue" /> lub większa niż <see cref="F:System.Int32.MaxValue" />. Ten parametr jest przekazywany jako niezainicjowany; dowolna wartość pierwotnie podane w <c>wynik</c> zostaną zastąpione.</param>
        <summary>Konwertuje reprezentację liczby w określonym styl i format specyficzne dla kultury jego 32-bitowej liczby całkowitej ze znakiem równoważne. Wartości zwracanej wskazuje, czy konwersja powiodła się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="s" /> został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.TryParse%2A> Metody przypomina <xref:System.Int32.Parse%2A> metody, z wyjątkiem <xref:System.Int32.TryParse%2A> — metoda nie zgłosić wyjątek, jeśli konwersja nie powiedzie się. Eliminuje konieczność użycia obsługi wyjątków do testowania <xref:System.FormatException> w przypadku gdy `s` jest nieprawidłowy i nie może zostać przeanalizowany pomyślnie.  
  
 `style` Parametru definiuje elementy stylu (na przykład biały znak lub znak dodatnie lub ujemne), które są dozwolone w `s` parametr powodzenie operacji analizy. Musi być kombinacją flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. W zależności od wartości `style`, `s` parametr może zawierać następujące elementy:  
  
 [odstęp][$][znak][cyfry,]cyfry[.cyfry_ułamkowe][e[znak]cyfry][odstęp]  
  
 Lub, jeśli `style` zawiera parametr <xref:System.Globalization.NumberStyles.AllowHexSpecifier>:  
  
 [odstęp]cyfry_szesnastkowe[odstęp]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp. Biały znak, może występować na początku `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagi, lub na końcu `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.|  
|*$*|Symbol waluty specyficzny dla kultury. Jej położenie w ciągu jest definiowana za pomocą <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> właściwość <xref:System.Globalization.NumberFormatInfo> obiektu zwróconego przez <xref:System.IFormatProvider.GetFormat%2A> metody `provider` parametru. Symbol waluty może występować w `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.|  
|*sign*|Opcjonalny znak. Symbol logowania może wystąpić w `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> lub <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi.|  
|*cyfr*|Sekwencja cyfr od 0 do 9.|  
|*,*|Tysięcy specyficzne dla kultury separatora. Tysięcy separatora kultury określonej przez `provider` może występować w `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.|  
|*.*|Symbol dziesiętny specyficzny dla kultury. Symbol punktu dziesiętnego kultury określonej przez `provider` może występować w `s` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.|  
|*fractional_digits*|Jedno lub więcej wystąpień cyfry 0. Cyfr ułamkowych może występować w `s` tylko wtedy, gdy `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.|  
|*e*|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym. `s` Parametr może reprezentować liczbę w notacji wykładniczej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.|  
|*hexdigits*|Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.|  
  
 Ciąg zawierający tylko cyfry dziesiętne (które odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> flagi) zawsze przeanalizowany pomyślnie. Większość pozostałych <xref:System.Globalization.NumberStyles> członkowie sterować elementów, które mogą być, ale nie muszą znajdować się w tym ciągu wejściowego. W poniższej tabeli przedstawiono poszczególne <xref:System.Globalization.NumberStyles> elementów członkowskich mają wpływ na elementy, które mogą być obecne w `s`.  
  
|Niezłożone wartości wyliczenia NumberStyles|Dodatkowe (poza cyframi) elementy dozwolone w parametrze s|  
|----------------------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>|Tylko cyfry dziesiętne.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>|Dziesiętnego (*.*) i *fractional_digits* elementów. Jednak *fractional_digits* musi składać się z jednego lub więcej cyfry 0 lub metoda zwraca `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>|`s` Parametr można również użyć notacji wykładniczej. Jeśli `s` reprezentuje numer w notacji wykładniczej, musi reprezentować całkowitą w zakresie <xref:System.Int32> bez składnika inną niż zero, ułamkową — typ danych.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>|*Ws* element na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>|*Ws* element na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>|Znak mogą występować przed *cyfr*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>|Logowania może wystąpić po *cyfr*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>|*Znak* elementu w postaci nawiasów otaczającej wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>|Tysięcy separatora (*,*) elementu.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>|* $ * Elementu.|  
|<xref:System.Globalization.NumberStyles.Currency?displayProperty=nameWithType>|Wszystkie elementy. `s` Parametr nie może reprezentować liczbę szesnastkową lub numer w notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>|*Ws* element na początku lub na końcu `s`, *znak* na początku `s`i dziesiętnego (*.*) symbolu. `s` Parametr można również użyć notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number?displayProperty=nameWithType>|*Ws*, *znak*, tysięcy separatora (*,*), a separatorem dziesiętnym (*.*) elementów.|  
|<xref:System.Globalization.NumberStyles.Any?displayProperty=nameWithType>|Wszystkie style, z wyjątkiem `s` nie może reprezentować liczbę szesnastkową.|  
  
 Jeśli <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flaga jest wykorzystywana, `s` musi mieć wartość szesnastkową bez prefiksu. Na przykład "C9AF3" analizuje pomyślnie, ale nie ma "0xC9AF3". Tylko innych flagi, które mogą być obecne w `style` są <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. ( <xref:System.Globalization.NumberStyles> Wyliczenie ma stylu złożonego <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>, który obejmuje zarówno flagi biały znak.)  
  
 `provider` Parametr jest <xref:System.IFormatProvider> wdrożenia, takich jak <xref:System.Globalization.CultureInfo> obiektu lub <xref:System.Globalization.NumberFormatInfo> obiektu, którego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu. <xref:System.Globalization.NumberFormatInfo> Obiektu zawiera informacje specyficzne dla kultury o format `s`. Jeśli `provider` jest `null`, <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury jest używany.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Int32.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Int32%40%29?displayProperty=nameWithType> metodę o szereg różnych ciągu i <xref:System.Globalization.NumberStyles> wartości.  
  
 [!code-cpp[System.Int32.TryParse#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Int32.TryParse/cpp/int32.tryparse2.cpp#2)]
 [!code-csharp[System.Int32.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Int32.TryParse/cs/TryParse2.cs#2)]
 [!code-vb[System.Int32.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Int32.TryParse/vb/TryParse2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.  
  
 —lub—  
  
 <paramref name="style" /> nie jest kombinacją <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> i <see cref="F:System.Globalization.NumberStyles.HexNumber" /> wartości.</exception>
        <altmember cref="M:System.Int32.Parse(System.String)" />
        <altmember cref="T:System.Globalization.NumberStyles" />
        <altmember cref="M:System.Int32.ToString" />
      </Docs>
    </Member>
  </Members>
</Type>
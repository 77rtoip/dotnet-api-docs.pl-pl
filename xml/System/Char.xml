<Type Name="Char" FullName="System.Char">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7df9951623e69508ef97ce060bbd734eb7c0d11c" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37481992" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit char extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;char&gt;, class System.IConvertible, class System.IEquatable`1&lt;char&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Char" />
  <TypeSignature Language="VB.NET" Value="Public Structure Char&#xA;Implements IComparable, IComparable(Of Char), IConvertible, IEquatable(Of Char)" />
  <TypeSignature Language="C++ CLI" Value="public value class Char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type char = struct&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Char&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje znak jako jednostkę kodu UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Używa <xref:System.Char> struktury do reprezentowania znaku Unicode. Unicode Standard identyfikuje każdy znak Unicode zwierające unikatowy numer skalarne 21-bitowa, o nazwie punkt kodu i definiuje formularza kodowania UTF-16, który określa, jak punkt kodu jest zakodowany sekwencję co najmniej jednej wartości 16-bitowych. Każda wartość 16-bitowych od 0x0000 szesnastkowe 0xFFFF i są przechowywane w <xref:System.Char> struktury.  Wartość <xref:System.Char> obiektu jest jego wartość liczbowa 16-bitowych (numer).  
  
 Poniższe sekcje opisują relację między <xref:System.Char> obiektu i znak i omówiono niektóre typowe zadania przeprowadzane przy użyciu <xref:System.Char> wystąpień.  
  
 [Obiekty char, znaki Unicode i ciągi](#Relationship)   
 [Znaki i kategorii znaków](#Categories)   
 [Znaki i elementy tekstowe](#Elements)   
 [Typowe operacje](#Operations)   
 [Wartości CHAR i współdziałanie](#Interop)  
  
<a name="Relationship"></a>   
## <a name="char-objects-unicode-characters-and-strings"></a>Obiekty char, znaki Unicode i ciągi  
 A <xref:System.String> obiektu to kolejny zbiór <xref:System.Char> struktur, które reprezentuje ciągu tekstowego. Znaki Unicode mogą być reprezentowane przez jeden <xref:System.Char> obiektu, ale znak, który jest kodowany jako podstawowego znak Para dwuskładnikowa i/lub łącząc sekwencja znaków jest reprezentowany przez wiele <xref:System.Char> obiektów. Z tego powodu <xref:System.Char> struktury w <xref:System.String> obiekt nie jest odpowiednikiem musi być pojedynczy znak Unicode.  
  
 Wiele jednostek 16-bitowego kodu są używane do reprezentowania pojedynczych znaków Unicode w następujących przypadkach:  
  
-   Symbole, które może obejmować jeden znak lub podstawowego znak następuje jeden lub więcej znaków łączenie. Na przykład znak ä jest reprezentowany przez element <xref:System.Char> obiektu kod, którego jednostka to U + 0061 następuje a <xref:System.Char> obiektu, którego jednostka kodu jest 0308 U +. (Można także definiować znaku ä przez pojedynczy element <xref:System.Char> obiekt, który ma element kodu jednostki 00E4 U +.) W poniższym przykładzie pokazano, że znaku ä składa się z dwóch <xref:System.Char> obiektów.  
  
     [!code-csharp[System.Char.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/grapheme1.cs#1)]
     [!code-vb[System.Char.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/grapheme1.vb#1)]  
  
-   Znaki spoza płaszczyzny wielojęzyczny podstawowy Unicode (BMP). Unicode obsługuje szesnastu płaszczyzn oprócz BMP, który reprezentuje warstwy 0. Punkt kodu Unicode jest reprezentowany w UTF-32 według wartości 21-bitowa, która obejmuje płaszczyznę. Na przykład U + 1D160 reprezentuje znak KOMPOZYCJĄ Uwaga ÓSMEGO symboli. Kodowanie UTF-16 jest tylko 16 bitów, dlatego znaki spoza BMP są reprezentowane przez znaki dwuskładnikowe UTF-16. W poniższym przykładzie pokazano, UTF-32 wielokrotność U + 1D160, w KOMPOZYCJĄ Uwaga ÓSMEGO SYMBOL znaku, to U + D834 U + DD60. U + D834 jest znakiem zastępczym wysokiego poziomu; Wysoka surogatów z zakresu od U + D800 za pośrednictwem U + DBFF. U + DD60 jest dwuskładnikowego; niski surogatów z zakresu od U + DC00 za pośrednictwem U + DFFF.  
  
     [!code-csharp[System.Char.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/surrogate1.cs#2)]
     [!code-vb[System.Char.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/surrogate1.vb#2)]  
  
<a name="Categories"></a>   
## <a name="characters-and-character-categories"></a>Znaki i kategorii znaków  
 Każdy znak Unicode, lub para zastępcza prawidłowe należy do kategorii Unicode. W .NET Framework, kategorii Unicode są reprezentowane przez członków <xref:System.Globalization.UnicodeCategory> wyliczenie i obejmują wartości, takie jak <xref:System.Globalization.UnicodeCategory.CurrencySymbol?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType>, i <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType>, na przykład.  
  
 Aby określić kategorię Unicode znak, należy wywołać <xref:System.Char.GetUnicodeCategory%2A> metody. Na przykład, poniższy przykład wywołuje <xref:System.Char.GetUnicodeCategory%2A> do wyświetlania kategorii Unicode każdego znaku w ciągu.  
  
 [!code-csharp[System.Char.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/GetUnicodeCategory3.cs#6)]
 [!code-vb[System.Char.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/GetUnicodeCategory3.vb#6)]  
  
 Wewnętrznie, aby uzyskać znaki spoza zakresu ASCII (U + 0000 do U + 00FF) <xref:System.Char.GetUnicodeCategory%2A> metoda zależy od kategorii Unicode zgłoszone przez <xref:System.Globalization.CharUnicodeInfo> klasy. Począwszy od [!INCLUDE[net_v462](~/includes/net-v462-md.md)], znaki Unicode są klasyfikowane na podstawie [Unicode Standard, wersja 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). W wersjach programu .NET Framework z [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] do [!INCLUDE[net_v461](~/includes/net-v461-md.md)], są klasyfikowane na podstawie [Unicode Standard, wersja wersji 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
<a name="Elements"></a>   
## <a name="characters-and-text-elements"></a>Znaki i elementy tekstowe  
 Ponieważ pojedynczy znak może być reprezentowany za pomocą wielu <xref:System.Char> obiektów, nie zawsze jest istotne, aby pracować z poszczególnymi <xref:System.Char> obiektów. Na przykład poniższy przykład konwertuje punkty kodowe Unicode, które reprezentują Morza Egejskiego cyfry 0 do 9 jednostek kodu zakodowane UTF-16. Ponieważ błędnie bazom <xref:System.Char> obiektów ze znakami, niepoprawnie zgłasza, że wynikowy ciąg ma 20 znaków.  
  
 [!code-csharp[System.Char.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/textelements2.cs#3)]
 [!code-vb[System.Char.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/textelements2.vb#3)]  
  
 Można wykonać następujące polecenie, aby uniknąć przy założeniu, <xref:System.Char> obiekt reprezentuje pojedynczy znak.  
  
-   Możesz pracować z <xref:System.String> obiektu w całości, a nie Praca z jego pojedynczych znaków do reprezentowania i analizy językowej zawartości.  
  
-   Możesz użyć <xref:System.Globalization.StringInfo> klasy, aby pracować z elementami tekstu, zamiast poszczególnych <xref:System.Char> obiektów. W poniższym przykładzie użyto <xref:System.Globalization.StringInfo> obiekt, aby określić liczbę elementów tekstu w ciąg, który składa się z Morza Egejskiego liczby zero do 9. Ponieważ para zastępcza traktuje pojedynczy znak, poprawnie raportów to, czy ciąg zawiera znaki dziesięć.  
  
     [!code-csharp[System.Char.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/textelements2a.cs#4)]
     [!code-vb[System.Char.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/textelements2a.vb#4)]  
  
-   Jeśli ciąg zawiera podstawowego znak, który ma co najmniej jeden znak łączenie, można wywołać <xref:System.String.Normalize%2A?displayProperty=nameWithType> metodę, aby przekonwertować podciąg do pojedynczej jednostki zakodowany kodu UTF-16. Poniższy przykład wywołuje <xref:System.String.Normalize%2A?displayProperty=nameWithType> metodę, aby przekonwertować podstawowego znak U + 0061 (ŁACIŃSKI, MAŁA litera A) i znaku U + 0308 (łączenie DIAEREZĄ) do U + 00E4 (ŁACIŃSKI małe litery z DIAEREZĄ).  
  
     [!code-csharp[System.Char.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/normalized.cs#5)]
     [!code-vb[System.Char.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/normalized.vb#5)]  
  
<a name="Operations"></a>   
## <a name="common-operations"></a>Typowe operacje  
 <xref:System.Char> Struktura zapewnia metody do porównania <xref:System.Char> obiektów, konwertuje wartość bieżącego <xref:System.Char> obiekt do obiektu innego typu, a następnie określić kategorię Unicode <xref:System.Char> obiektu:  
  
|Wymagana czynność|Te `System.Char` metody|  
|----------------|-------------------------------------|  
|Porównaj <xref:System.Char> obiektów|<xref:System.Char.CompareTo%2A> i <xref:System.Char.Equals%2A>|  
|Konwertuj na ciąg punkt kodowy|<xref:System.Char.ConvertFromUtf32%2A>|  
|Konwertuj <xref:System.Char> obiektu lub para zastępcza <xref:System.Char> obiektów punkt kodowy|Dla pojedynczego znaku: <xref:System.Convert.ToInt32%28System.Char%29?displayProperty=nameWithType><br /><br /> Para zastępcza lub znak w ciągu: <xref:System.Char.ConvertToUtf32%2A?displayProperty=nameWithType>|  
|Pobierz kategorii Unicode znaku|<xref:System.Char.GetUnicodeCategory%2A>|  
|Określić, czy znak jest w określonej kategorii Unicode, takich jak cyfry, litery, znaki interpunkcyjne, znak sterujący i tak dalej|<xref:System.Char.IsControl%2A>, <xref:System.Char.IsDigit%2A>, <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLetter%2A>, <xref:System.Char.IsLetterOrDigit%2A>, <xref:System.Char.IsLower%2A>, <xref:System.Char.IsLowSurrogate%2A>, <xref:System.Char.IsNumber%2A>, <xref:System.Char.IsPunctuation%2A>, <xref:System.Char.IsSeparator%2A>, <xref:System.Char.IsSurrogate%2A>, <xref:System.Char.IsSurrogatePair%2A>, <xref:System.Char.IsSymbol%2A>, <xref:System.Char.IsUpper%2A>, i <xref:System.Char.IsWhiteSpace%2A>|  
|Konwertuj <xref:System.Char> obiekt, który reprezentuje liczbę, typ wartości liczbowych|<xref:System.Char.GetNumericValue%2A>|  
|Konwertuj znak w ciągu do <xref:System.Char> obiektu|<xref:System.Char.Parse%2A> i <xref:System.Char.TryParse%2A>|  
|Konwertuj <xref:System.Char> obiekt <xref:System.String> obiektu|<xref:System.Char.ToString%2A>|  
|Zmień wielkość liter <xref:System.Char> obiektu|<xref:System.Char.ToLower%2A>, <xref:System.Char.ToLowerInvariant%2A>, <xref:System.Char.ToUpper%2A>, i <xref:System.Char.ToUpperInvariant%2A>|  
  
<a name="Interop"></a>   
## <a name="char-values-and-interop"></a>Wartości CHAR i współdziałanie  
W przypadku zarządzanych <xref:System.Char> typ, który jest reprezentowany jako jednostka kodu zakodowana Unicode UTF-16, jest przekazywany do kodu niezarządzanego, organizator międzyoperacyjny konwertuje znak domyślnie ustawiany na ANSI. Można zastosować <xref:System.Runtime.InteropServices.DllImportAttribute> atrybut platformę wywołania deklaracje i <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybutu deklaracji międzyoperacyjnego modelu COM do kontroli zorganizowanej zestawu znaków <xref:System.Char> typu używa.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano niektóre z metod opisanych w <xref:System.Char>.  
  
 [!code-cpp[System.Char &#91;Type Level&#93;#23](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char [Type Level]/CPP/charstructure.cpp#23)]
 [!code-csharp[System.Char &#91;Type Level&#93;#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char [Type Level]/CS/charstructure.cs#23)]
 [!code-vb[System.Char &#91;Type Level&#93;#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char [Type Level]/VB/charstructure.vb#23)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie tego typu są bezpieczne wątkowo. Elementy członkowskie, które na pierwszy rzut oka modyfikują stan wystąpienia, w rzeczywistości zwracają nowe wystąpienie zainicjowane z nową wartością. Podobnie jak w przypadku innych typów odczytywanie i zapisywanie w udostępnionej zmiennej, która zawiera wystąpienie tego typu, musi być chronione przez blokadę w celu zagwarantowania bezpieczeństwa wątków.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje to wystąpienie określonego obiektu lub typu wartości i wskazuje, czy to wystąpienie poprzedza, następuje po lub pojawia się w tym samym miejscu w kolejności sortowania określonego typu obiektu lub wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.CompareTo(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(char value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : char -&gt; int&#xA;override this.CompareTo : char -&gt; int" Usage="char.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Char" /> obiekt do porównania.</param>
        <summary>Porównuje to wystąpienie określonej <see cref="T:System.Char" /> obiektu i wskazuje, czy to wystąpienie poprzedza, następuje po lub pojawia się w tej samej pozycji w porządku sortowania określonych <see cref="T:System.Char" /> obiektu.</summary>
        <returns>Liczba ze znakiem wskazującą położenie tego wystąpienia w porządku sortowania w odniesieniu do <paramref name="value" /> parametru.  
  
 <list type="table"><listheader><term> Wartość zwracana </term><description> opis </description></listheader><item><term> mniejsza niż zero </term><description> to wystąpienie poprzedza <paramref name="value" />.  </description></item><item><term> Zero </term><description> to wystąpienie ma tej samej pozycji w kolejności sortowania, co <paramref name="value" />.  </description></item><item><term> Większa od zera </term><description> to wystąpienie następuje po <paramref name="value" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje <xref:System.IComparable%601?displayProperty=nameWithType> interfejs i wykonuje nieco lepiej niż <xref:System.Char.CompareTo%2A?displayProperty=nameWithType> metody, ponieważ nie trzeba przekonwertować `value` parametr do obiektu.  
  
 Porównanie wykonana przez tę metodę jest oparty na zakodowanych wartości tego wystąpienia i `value`, nie ich lexicographical właściwości.  
  
 Jeśli <xref:System.Char.CompareTo%2A> typ parametru metody ma mniejszą liczbę bitów (jest mniejsza) niż typ wystąpienia niektórych językach programowania jest wykonywana niejawna konwersja poszerzająca, która przekształca wartości parametru na wartość z bitami więcej.  
  
 Załóżmy, że typem wystąpienia jest <xref:System.Int32> i typ parametru jest <xref:System.Byte>. Kompilator Microsoft C# generuje instrukcje do reprezentowania wartości jako parametr <xref:System.Int32> obiektu, a następnie generuje <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> metodę, która porównuje wartości wystąpienia <xref:System.Int32> wystąpienia i <xref:System.Int32> parametru Reprezentacja.  
  
 Zazwyczaj niejawne konwersje rozszerzające są wykonywane na typach liczbowych. Zapoznaj się z dokumentacją języka programowania, aby ustalić, czy jego kompilator wykonuje konwersje rozszerzające. W przypadku niezgodności typów wystąpienia i parametru i odpowiedniej konwersji nie jest dostępna, kompilator generuje instrukcje, aby pole parametru, a następnie wywołaj <xref:System.Char.CompareTo%2A> przeciążenia przyjmującego <xref:System.Object> parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje ogólnych i nieogólnych wersje `CompareTo` metody dla kilku typów wartości i odwołań.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="char.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z tym wystąpieniem, lub <see langword="null" />.</param>
        <summary>Porównuje to wystąpienie określonego obiektu i wskazuje, czy to wystąpienie poprzedza, następuje po lub pojawia się w tej samej pozycji w porządku sortowania określonych <see cref="T:System.Object" />.</summary>
        <returns>Liczba ze znakiem wskazującą położenie tego wystąpienia w porządku sortowania w odniesieniu do <paramref name="value" /> parametru.  
  
 <list type="table"><listheader><term> Wartość zwracana </term><description> opis </description></listheader><item><term> mniejsza niż zero </term><description> to wystąpienie poprzedza <paramref name="value" />.  </description></item><item><term> Zero </term><description> to wystąpienie ma tej samej pozycji w kolejności sortowania, co <paramref name="value" />.  </description></item><item><term> Większa od zera </term><description> to wystąpienie następuje po <paramref name="value" />.  - lub - <paramref name="value" /> jest <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.CompareTo%2A> Implementuje metodę <xref:System.IComparable> interfejsu.  
  
 `value` Parametr musi być `null` lub wystąpienie <xref:System.Char>; w przeciwnym razie jest zgłaszany wyjątek.  
  
 Porównanie wykonana przez tę metodę jest oparty na zakodowanych wartości tego wystąpienia i `value`, niekoniecznie ich lexicographical właściwości. Dowolne wystąpienie <xref:System.Char>, niezależnie od jej wartość jest uznawany za większy niż `null`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.CompareTo%2A>.  
  
 [!code-cpp[System.Char.CompareTo#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.CompareTo/CPP/compareto.cpp#19)]
 [!code-csharp[System.Char.CompareTo#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.CompareTo/CS/compareto.cs#19)]
 [!code-vb[System.Char.CompareTo#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.CompareTo/VB/compareto.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> nie jest <see cref="T:System.Char" /> obiektu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConvertFromUtf32">
      <MemberSignature Language="C#" Value="public static string ConvertFromUtf32 (int utf32);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ConvertFromUtf32(int32 utf32) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertFromUtf32(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertFromUtf32 (utf32 As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ConvertFromUtf32(int utf32);" />
      <MemberSignature Language="F#" Value="static member ConvertFromUtf32 : int -&gt; string" Usage="System.char.ConvertFromUtf32 utf32" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf32" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="utf32">Punkt kodu Unicode 21-bitowa.</param>
        <summary>Konwertuje określony punkt kodu Unicode na ciąg UTF-16 zakodowany.</summary>
        <returns>Ciąg składający się z jednego <see cref="T:System.Char" /> obiektu lub Para dwuskładnikowa <see cref="T:System.Char" /> obiekty równoważne punkt kodu określonego przez <paramref name="utf32" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia konwertowanie punkt kodu Unicode 21-bitowa na ciąg UTF-16 zakodowane przed testowaniem ciągu za pomocą metod, takich jak <xref:System.Char.IsLowSurrogate%28System.Char%29> i <xref:System.Char.IsHighSurrogate%28System.Char%29>.  
  
 Prawidłowy punkt kodu poza Basic Multilingual Plane (BMP) zawsze daje para zastępcza prawidłowe. Jednak prawidłowy punkt kodu w ramach BMP może nie przynieść prawidłowy wynik zgodnie ze standardem Unicode, ponieważ żadne językowej przetwarzanie jest używana podczas konwersji. Z tego powodu należy użyć <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> klasy w celu przekonwertowania zbiorczo danych UTF-32 do zbiorczego danych UTF-16.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.ConvertToUtf32%2A> i <xref:System.Char.ConvertFromUtf32%2A> metody.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="utf32" /> jest nie prawidłowy 21-bitowa punkt kodu Unicode w zakresie od U + od 0 do U + 10FFFF, z wyjątkiem zakresu para zastępcza od U + D800 za pośrednictwem U + DFFF.</exception>
        <altmember cref="M:System.Char.ConvertToUtf32(System.Char,System.Char)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertToUtf32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość pary zastępczej UTF-16 zakodowane punkt kodu Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertToUtf32">
      <MemberSignature Language="C#" Value="public static int ConvertToUtf32 (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ConvertToUtf32(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertToUtf32(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToUtf32 (highSurrogate As Char, lowSurrogate As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ConvertToUtf32(char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="F#" Value="static member ConvertToUtf32 : char * char -&gt; int" Usage="System.char.ConvertToUtf32 (highSurrogate, lowSurrogate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="highSurrogate">Jednostka kodu znakiem zastępczym wysokiego poziomu (czyli jednostka kodu od U + D800 za pośrednictwem U + DBFF).</param>
        <param name="lowSurrogate">Jednostka kodu znak zastępczy niskiego poziomu (czyli jednostka kodu od U + DC00 za pośrednictwem U + DFFF).</param>
        <summary>Konwertuje wartość pary zastępczej UTF-16 zakodowane punkt kodu Unicode.</summary>
        <returns>Punkt kodowy Unicode 21-bitowa, reprezentowane przez <paramref name="highSurrogate" /> i <paramref name="lowSurrogate" /> parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia konwertowanie para zastępcza punkt kodu Unicode 21-bitowa. Aby przekonwertować danych UTF-16, UTF-32 danych, użyj <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> klasy.  
  
 Jako jednostki 16-bitowego kodu zwykle kodowanie UTF-16 reprezentuje pojedynczy znak Unicode. Jednak obsługuje ona również par zastępczych, umożliwiających abstrakcyjne pojedynczy znak może być reprezentowana jako dwie jednostki 16-bitowego kodu. Te dwa <xref:System.Char> obiekty muszą mieć jednostki kodu tego zakresu od U + D800 do U + DBFF dla pierwszego zastępczy (wysoka) oraz od U + DC00 do U + DFFF dla drugiego zastępczy (niska). Pary zastępcze są obsługiwane tylko przez UTF-16 kodowania. Ta metoda umożliwia znaku, reprezentowane przez para zastępcza UTF-16 są konwertowane na znak, przy użyciu kodowania UTF-32.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.ConvertToUtf32%2A> i <xref:System.Char.ConvertFromUtf32%2A> metody.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="highSurrogate" /> nie jest z zakresu od U + D800 do U + DBFF lub <paramref name="lowSurrogate" /> nie znajduje się w zakresie od U + DC00 do U + DFFF.</exception>
        <altmember cref="M:System.Char.ConvertFromUtf32(System.Int32)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <Member MemberName="ConvertToUtf32">
      <MemberSignature Language="C#" Value="public static int ConvertToUtf32 (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ConvertToUtf32(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertToUtf32(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToUtf32 (s As String, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ConvertToUtf32(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member ConvertToUtf32 : string * int -&gt; int" Usage="System.char.ConvertToUtf32 (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg, który zawiera parę znak lub zastępcze.</param>
        <param name="index">Indeks pary znaków lub zastępcze w <c>s</c>.</param>
        <summary>Konwertuje wartość UTF-16 zakodowanych znaków lub zastępcze pary na określonej pozycji w ciągu w punkt kodu Unicode.</summary>
        <returns>Punkt kodowy Unicode 21-bitowa, reprezentowany przez znak lub zastępcze pary w pozycji w <paramref name="s" /> określony przez parametr <paramref name="index" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia konwertowanie pary znaków lub zastępcze punkt kodu Unicode 21-bitowa. Aby przekonwertować danych UTF-16, UTF-32 danych, użyj <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.ConvertToUtf32%2A> i <xref:System.Char.ConvertFromUtf32%2A> metody.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest pozycją w parametrze <paramref name="s" />.</exception>
        <exception cref="T:System.ArgumentException">Określony indeks zawiera pary zastępczej i pierwszy znak w parę nie jest prawidłowym znakiem zastępczym wysokiego poziomu lub drugim znakiem w parę nie jest prawidłowy znak zastępczy niskiego poziomu.</exception>
        <altmember cref="M:System.Char.ConvertFromUtf32(System.Int32)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi lub <see cref="T:System.Char" /> wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (char obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(char obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Equals(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(char obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : char -&gt; bool" Usage="char.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe określonej <see cref="T:System.Char" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> parametr ma wartość wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje <xref:System.IEquatable%601?displayProperty=nameWithType> interfejs i wykonuje nieco lepiej niż <xref:System.Char.Equals%28System.Object%29?displayProperty=nameWithType> , ponieważ nie trzeba rozpakowania `obj` parametru.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="char.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z tym wystąpieniem lub <see langword="null" />.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> jest wystąpieniem <see cref="T:System.Char" /> i równości wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównanie wykonana przez tę metodę jest oparty na zakodowanych wartości tego wystąpienia i `obj`, niekoniecznie ich lexicographical właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.Equals%2A>.  
  
 [!code-cpp[System.Char.Equals#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.Equals/CPP/equals.cpp#20)]
 [!code-csharp[System.Char.Equals#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.Equals/CS/equals.cs#20)]
 [!code-vb[System.Char.Equals#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.Equals/VB/equals.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="char.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNumericValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określony znak Unicode liczbowych na liczbę zmiennoprzecinkową podwójnej precyzji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetNumericValue(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (c As Char) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(char c);" />
      <MemberSignature Language="F#" Value="static member GetNumericValue : char -&gt; double" Usage="System.char.GetNumericValue c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <summary>Konwertuje określony znak Unicode liczbowe o podwójnej dokładności liczba zmiennoprzecinkowa.</summary>
        <returns>Wartość liczbową <paramref name="c" /> Jeśli ten znak przedstawia liczbę; w przeciwnym razie, od – 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `c` Parametr musi być <xref:System.Char> reprezentacja wartości liczbowej. Na przykład jeśli `c` "5", wartość zwracana wynosi 5. Jednak jeśli `c` jest "z", wartość zwracana wynosi od – 1,0.  
  
 Znak ma skojarzoną wartość liczbową, tylko wtedy, gdy jest on członkiem jednej z następujących <xref:System.Globalization.UnicodeCategory> kategorie: `DecimalDigitNumber`, `LetterNumber`, lub `OtherNumber`.  
  
 <xref:System.Char.GetNumericValue%2A> Metoda zakłada, że `c` odnosi się do pojedynczego znaku językowej i sprawdza, czy ten znak może być konwertowane na cyfrę dziesiętną. Jednak niektóre numery w standardzie Unicode są reprezentowane przez dwa <xref:System.Char> obiekty, które tworzą pary zastępczej. Na przykład system numeracji Morza Egejskiego składa się z kodów znaku U+10107 do U+10133. W poniższym przykładzie użyto <xref:System.Char.ConvertFromUtf32%2A> metodę, aby utworzyć wystąpienie ciąg reprezentujący Morza EGEJSKIEGO jeden numer. Jak wynika z w przykładzie pokazano <xref:System.Char.GetNumericValue%28System.Char%29> metoda zwraca wartość -1, jeśli zostanie przekazana, znakiem zastępczym wysokiego poziomu lub znak zastępczy niskiego poziomu tego znaku.  
  
 [!code-csharp[System.Char.GetNumericValue#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue1.cs#2)]
 [!code-vb[System.Char.GetNumericValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue1.vb#2)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.GetNumericValue%2A>.  
  
 [!code-cpp[System.Char.GetNumericValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CPP/getnumericvalue.cpp#1)]
 [!code-csharp[System.Char.GetNumericValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue.cs#1)]
 [!code-vb[System.Char.GetNumericValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetNumericValue(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (s As String, index As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member GetNumericValue : string * int -&gt; double" Usage="System.char.GetNumericValue (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A <see cref="T:System.String" />.</param>
        <param name="index">Pozycja znaku w <c>s</c>.</param>
        <summary>Konwertuje znak Unicode numeryczne w określonej pozycji w ciągu określonej podwójnej precyzji liczb zmiennoprzecinkowych.</summary>
        <returns>Wartość liczbową znak na pozycji <paramref name="index" /> w <paramref name="s" /> Jeśli ten znak przedstawia liczbę; w przeciwnym razie, wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `s` Parametr musi być ciąg reprezentujący wartość liczbową. Na przykład jeśli znak na pozycji `index` w `s` "5", wartość zwracana wynosi 5. Jednakże jeśli znak na pozycji `index` w `s` jest "z", wartość zwracana jest wartość -1.  
  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Znak ma skojarzoną wartość liczbową, tylko wtedy, gdy jest on członkiem jednej z następujących <xref:System.Globalization.UnicodeCategory> kategorie: `DecimalDigitNumber`, `LetterNumber`, lub `OtherNumber`.  
  
 Jeśli <xref:System.Char> obiektu w położeniu `index` jest pierwszym znakiem para zastępcza prawidłowe <xref:System.Char.GetNumericValue%28System.String%2CSystem.Int32%29> Metoda określa, czy para zastępcza formularzy zawierać cyfrę. Na przykład system numeracji Morza Egejskiego składa się z kodów znaku U+10107 do U+10133. W poniższym przykładzie użyto <xref:System.Char.ConvertFromUtf32%2A> metody do utworzenia wystąpienia ciąg reprezentujący każdą liczbę Morza Egejskiego. Jak wynika z w przykładzie pokazano <xref:System.Char.GetNumericValue%28System.String%2CSystem.Int32%29> metoda zwraca prawidłową wartość liczbową, jeśli został przekazany znakiem zastępczym wysokiego poziomu liczbą Morza Egejskiego. Jednakże, jeśli został przekazany znak zastępczy niskiego poziomu, uwzględnia tylko znak zastępczy niskiego poziomu w izolacji i zwraca wartość -1.  
  
 [!code-csharp[System.Char.GetNumericValue#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue1.cs#3)]
 [!code-vb[System.Char.GetNumericValue#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue1.vb#3)]  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.GetNumericValue%2A>.  
  
 [!code-cpp[System.Char.GetNumericValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CPP/getnumericvalue.cpp#1)]
 [!code-csharp[System.Char.GetNumericValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue.cs#1)]
 [!code-vb[System.Char.GetNumericValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w parametrze <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="char.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.TypeCode" /> dla typu wartości <see cref="T:System.Char" />.</summary>
        <returns>Stała wyliczeniowa <see cref="F:System.TypeCode.Char" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetUnicodeCategory">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Klasyfikuje znak Unicode do grupy identyfikowane za pomocą jednej z <see cref="T:System.Globalization.UnicodeCategory" /> wartości.</summary>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetUnicodeCategory(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (c As Char) As UnicodeCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(char c);" />
      <MemberSignature Language="F#" Value="static member GetUnicodeCategory : char -&gt; System.Globalization.UnicodeCategory" Usage="System.char.GetUnicodeCategory c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode kategoryzacji.</param>
        <summary>Klasyfikuje określony znak Unicode do grupy identyfikowane za pomocą jednej z <see cref="T:System.Globalization.UnicodeCategory" /> wartości.</summary>
        <returns>A <see cref="T:System.Globalization.UnicodeCategory" /> wartość, która identyfikuje grupę, która zawiera <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> Metody nie zawsze zwracają takie same <xref:System.Globalization.UnicodeCategory> wartość jako <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> metody, jeśli określony znak jest przekazywana jako parametr. <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> Metodę zaprojektowano w celu odzwierciedlenia bieżącej wersji standardu Unicode. W odróżnieniu od nich mimo że <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> metoda zazwyczaj odzwierciedla bieżącą wersję Unicode standard, może on zwrócić kategorii znaków na podstawie poprzednich wersji standard lub zwracają kategorię, która różni się od bieżącego planu standard w kolejności Aby zachować zgodność z poprzednimi wersjami. W rezultacie firma Microsoft zaleca użycie <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> zamiast metody <xref:System.Char.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType>.  
  
 Począwszy od [!INCLUDE[net_v462](~/includes/net-v462-md.md)], znaki Unicode są klasyfikowane na podstawie [standardowa systemu Unix, wersja 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). W wersjach programu .NET Framework z [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] do [!INCLUDE[net_v461](~/includes/net-v461-md.md)], są klasyfikowane na podstawie [standardowa systemu Unix, wersja wersji 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.GetUnicodeCategory%2A>.  
  
 [!code-cpp[System.Char.GetUnicodeCategory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CPP/getunicodecategory.cpp#1)]
 [!code-csharp[System.Char.GetUnicodeCategory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CS/getunicodecategory.cs#1)]
 [!code-vb[System.Char.GetUnicodeCategory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/VB/getunicodecategory.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetUnicodeCategory(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (s As String, index As Integer) As UnicodeCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member GetUnicodeCategory : string * int -&gt; System.Globalization.UnicodeCategory" Usage="System.char.GetUnicodeCategory (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A <see cref="T:System.String" />.</param>
        <param name="index">Pozycja znaku w <c>s</c>.</param>
        <summary>Klasyfikuje znak w określonej pozycji w ciągu określonego w grupie identyfikowane za pomocą jednej z <see cref="T:System.Globalization.UnicodeCategory" /> wartości.</summary>
        <returns>A <see cref="T:System.Globalization.UnicodeCategory" /> Stała wyliczeniowa, która identyfikuje grupę, która zawiera znak na pozycji <paramref name="index" /> w <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> Metody nie zawsze zwracają takie same <xref:System.Globalization.UnicodeCategory> wartość jako <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> metody, jeśli określony znak jest przekazywana jako parametr. <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> Metodę zaprojektowano w celu odzwierciedlenia bieżącej wersji standardu Unicode. W odróżnieniu od nich mimo że <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> metoda zazwyczaj odzwierciedla bieżącą wersję Unicode standard, może on zwrócić kategorii znaków na podstawie poprzednich wersji standard lub zwracają kategorię, która różni się od bieżącego planu standard w kolejności Aby zachować zgodność z poprzednimi wersjami. W rezultacie firma Microsoft zaleca użycie <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> zamiast metody <xref:System.Char.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>.  
  
 Począwszy od [!INCLUDE[net_v462](~/includes/net-v462-md.md)], znaki Unicode są klasyfikowane na podstawie [standardowa systemu Unix, wersja 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). W wersjach programu .NET Framework z [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] do [!INCLUDE[net_v461](~/includes/net-v461-md.md)], są klasyfikowane na podstawie [standardowa systemu Unix, wersja wersji 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.GetUnicodeCategory%2A>.  
  
 [!code-cpp[System.Char.GetUnicodeCategory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CPP/getunicodecategory.cpp#1)]
 [!code-csharp[System.Char.GetUnicodeCategory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CS/getunicodecategory.cs#1)]
 [!code-vb[System.Char.GetUnicodeCategory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/VB/getunicodecategory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w parametrze <paramref name="s" />.</exception>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsControl">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy określony znak Unicode jest dzielony na kategorie jako znak kontrolny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki kontrolne są formatowania i inne niedrukowalne znaki, takie jak potwierdzenia, etykiety, CR, FF, LF i VT. W standardzie Unicode przypisuje punkty kodowe od \U0000 do \U001F, \U007F i z \U0080 do \U009F do znaków kontrolnych. Zgodnie ze standardem Unicode te wartości są interpretowane jako znaki kontrolne, chyba że ich użycie w przeciwnym razie jest zdefiniowany przez aplikację. Znaki kontrolne prawidłowe są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> kategorii.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsControl(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(char c);" />
      <MemberSignature Language="F#" Value="static member IsControl : char -&gt; bool" Usage="System.char.IsControl c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest dzielony na kategorie jako znak kontrolny.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest formantem znaku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki kontrolne są formatowania i inne niedrukowalne znaki, takie jak potwierdzenia, etykiety, CR, FF, LF i VT. Standardu Unicode T przypisuje punkty kodowe od \U0000 do \U001F, \U007F i z \U0080 do \U009F do znaków kontrolnych. Zgodnie ze standardem Unicode te wartości są interpretowane jako znaki kontrolne, chyba że ich użycie w przeciwnym razie jest zdefiniowany przez aplikację. Znaki kontrolne prawidłowe są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> kategorii.  
  
   
  
## Examples  
 Poniższy przykład wyświetla punkt kodu Unicode poszczególnych znaków kontrolnych.  
  
 [!code-cpp[System.Char.IsControl#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsControl/CPP/iscontrol1.cpp#1)]
 [!code-csharp[System.Char.IsControl#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsControl/CS/IsControl1.cs#1)]
 [!code-vb[System.Char.IsControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsControl/VB/IsControl1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsControl(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsControl : string * int -&gt; bool" Usage="System.char.IsControl (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku umożliwia ocenę w <c>s</c>.</param>
        <summary>Wskazuje, czy znak w określonej pozycji w określony ciąg jest dzielony na kategorie jako znak kontrolny.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest formantem znaku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Znaki kontrolne są formatowania i inne niedrukowalne znaki, takie jak potwierdzenia, etykiety, CR, FF, LF i VT. W standardzie Unicode przypisuje punkty kodowe od \U0000 do \U001F, \U007F i z \U0080 do \U009F do znaków kontrolnych. Zgodnie ze standardem Unicode te wartości są interpretowane jako znaki kontrolne, chyba że ich użycie w przeciwnym razie jest zdefiniowany przez aplikację. Znaki kontrolne prawidłowe są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> kategorii.  
  
   
  
## Examples  
 Poniższy przykład wylicza znaków w ciągu i określa, czy są dowolne znaki kontrolne.  
  
 [!code-cpp[System.Char.IsControl#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsControl/CPP/iscontrol2.cpp#2)]
 [!code-csharp[System.Char.IsControl#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsControl/CS/IsControl2.cs#2)]
 [!code-vb[System.Char.IsControl#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsControl/VB/IsControl2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w parametrze <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsDigit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest dzielony na kategorie, wyświetlaną cyfrą dziesiętną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowych cyfr są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> kategorii.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(char c);" />
      <MemberSignature Language="F#" Value="static member IsDigit : char -&gt; bool" Usage="System.char.IsDigit c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest dzielony na kategorie, wyświetlaną cyfrą dziesiętną.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest dziesiętną wartością cyfrową; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Char> jest cyfrą podstawa 10. To zachowanie różni się od <xref:System.Char.IsNumber%2A>, która określa, czy `Char` jest dowolnej kategorii Unicode, liczbowych. Numery zawierają znaki, takie jak ułamki, indeksy dolne, indeksów górnych, rzymskie, łącznik waluty, otoczony liczb i cyfr specyficzne dla skryptu.  
  
 Prawidłowych cyfr są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> kategorii.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsDigit%2A>.  
  
 [!code-cpp[System.Char.IsDigit#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsDigit/CPP/isdigit.cpp#4)]
 [!code-csharp[System.Char.IsDigit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsDigit/CS/isdigit.cs#4)]
 [!code-vb[System.Char.IsDigit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsDigit/VB/isdigit.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsNumber(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsDigit(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsDigit : string * int -&gt; bool" Usage="System.char.IsDigit (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku umożliwia ocenę w <c>s</c>.</param>
        <summary>Wskazuje, czy znak w określonej pozycji w określony ciąg jest dzielony na kategorie, wyświetlaną cyfrą dziesiętną.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest dziesiętną wartością cyfrową; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Char> jest cyfrą podstawa 10. To zachowanie różni się od <xref:System.Char.IsNumber%2A>, która określa, czy <xref:System.Char> jest dowolnej kategorii Unicode, liczbowych. Numery zawierają znaki, takie jak ułamki, indeksy dolne, indeksów górnych, rzymskie, łącznik waluty, otoczony liczb i cyfr specyficzne dla skryptu.  
  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Prawidłowych cyfr są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> kategorii.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsDigit%2A>.  
  
 [!code-cpp[System.Char.IsDigit#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsDigit/CPP/isdigit.cpp#4)]
 [!code-csharp[System.Char.IsDigit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsDigit/CS/isdigit.cs#4)]
 [!code-vb[System.Char.IsDigit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsDigit/VB/isdigit.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w parametrze <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsNumber(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsHighSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy określony <see cref="T:System.Char" /> obiekt jest znakiem zastępczym wysokiego poziomu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsHighSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsHighSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHighSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsHighSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHighSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHighSurrogate(char c);" />
      <MemberSignature Language="F#" Value="static member IsHighSurrogate : char -&gt; bool" Usage="System.char.IsHighSurrogate c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony <see cref="T:System.Char" /> obiekt jest znakiem zastępczym wysokiego poziomu.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość liczbową <paramref name="c" /> parametru z zakresu od U + D800 za pośrednictwem U + DBFF; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oprócz reprezentowania pojedynczych znaków przy użyciu 16-bitowego kodu znaku, kodowanie UTF-16 pozwala na przedstawianie znaków abstrakcyjnych za pomocą dwóch 16-bitowych kodów znaku, znanych jako para zastępcza. Pierwszy element z tej pary jest znakiem zastępczym wysokiego poziomu. Jego punkt kodowy należą do zakresu od U + D800 do U + DBFF. Indywidualny znak zastępczy ma nie interpretacji własnych; jest istotny tylko wtedy, gdy jest używany jako część pary zastępczej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, i <xref:System.Char.IsSurrogatePair%2A> metody.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHighSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsHighSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHighSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsHighSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHighSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHighSurrogate(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsHighSurrogate : string * int -&gt; bool" Usage="System.char.IsHighSurrogate (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku umożliwia ocenę w <c>s</c>.</param>
        <summary>Wskazuje, czy <see cref="T:System.Char" /> obiektu w określonej pozycji w ciągu jest znakiem zastępczym wysokiego poziomu.</summary>
        <returns>
          <see langword="true" /> Jeśli określony znak w wartości liczbowej <paramref name="s" /> parametru z zakresu od U + D800 za pośrednictwem U + DBFF; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` Parametr jest liczony od zera.  
  
 Oprócz reprezentowania pojedynczych znaków przy użyciu 16-bitowego kodu znaku, kodowanie UTF-16 pozwala na przedstawianie znaków abstrakcyjnych za pomocą dwóch 16-bitowych kodów znaku, znanych jako para zastępcza. Pierwszy element z tej pary jest znakiem zastępczym wysokiego poziomu. Jego punkt kodowy należą do zakresu od U + D800 do U + DBFF. Indywidualny znak zastępczy ma nie interpretacji własnych; jest istotny tylko wtedy, gdy jest używany jako część pary zastępczej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, i <xref:System.Char.IsSurrogatePair%2A> metody.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest pozycją w parametrze <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLetter">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest dzielony na kategorie litery Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Char> jest członkiem dowolnej kategorii Unicode literę. Litery Unicode są następujące:  
  
-   Wielkie litery, np. U + 0041 (LATIN CAPITAL LETTER A) za pośrednictwem U + 005A (LATIN CAPITAL LETTER Z) lub U + 0400 (CYRYLICA litera IE WITH GRAVE) za pośrednictwem U + 042F (CYRYLICA litera YA). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Małe litery, np. U + 0061 (ŁACIŃSKI, MAŁA litera A) za pośrednictwem U + 007A (ŁACIŃSKI małe litery Z), lub U + 03AC (GRECKI małej litery ALFA z AKCENTEM) za pośrednictwem U + 03CE (GRECKI MAŁA litera OMEGA z AKCENTEM). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Tytuł wielkość liter, takich jak U + 01 C 5 (ŁACIŃSKI wielkiej litery D z małej litery Z z odwróconym DASZKIEM) lub U + 1FFC (GRECKI litera OMEGA z PROSGEGRAMMENI). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Modyfikatory, np. U + 02B0 (H małej litery MODYFIKATOR) za pośrednictwem U + 02C 1 (MODYFIKATOR LITERĘ ODWRÓCONE GLOTTAL STOP), lub U + 1D2C (MODYFIKATOR litery A kapitału) za pośrednictwem U + 1 d 61 (MODYFIKATOR CHI małe litery). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> kategorii.  
  
-   Pozostałe litery, np. U + 05 D 0 (ALEF LITERĘ HEBRAJSKI) za pośrednictwem U + 05EA (TAV litery HEBRAJSKI), U + 0621 (ARABSKI HAMZA LITERĄ) za pośrednictwem U + 063A (ARABSKI GHAIN litery), lub U + 4E00 (\<ideogramów CJK, pierwsza >) za pośrednictwem U + 9 FC 3 (\<ideogramów CJK, ostatni >). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> kategorii.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(char c);" />
      <MemberSignature Language="F#" Value="static member IsLetter : char -&gt; bool" Usage="System.char.IsLetter c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest dzielony na kategorie litery Unicode.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest literą; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Char> jest członkiem dowolnej kategorii Unicode literę. Litery Unicode są następujące:  
  
-   Wielkie litery, np. U + 0041 (LATIN CAPITAL LETTER A) za pośrednictwem U + 005A (LATIN CAPITAL LETTER Z) lub U + 0400 (CYRYLICA litera IE WITH GRAVE) za pośrednictwem U + 042F (CYRYLICA litera YA). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Małe litery, np. U + 0061 (ŁACIŃSKI, MAŁA litera A) za pośrednictwem U + 007A (ŁACIŃSKI małe litery Z), lub U + 03AC (GRECKI małej litery ALFA z AKCENTEM) za pośrednictwem U + 03CE (GRECKI MAŁA litera OMEGA z AKCENTEM). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Tytuł wielkość liter, takich jak U + 01 C 5 (ŁACIŃSKI wielkiej litery D z małej litery Z z odwróconym DASZKIEM) lub U + 1FFC (GRECKI litera OMEGA z PROSGEGRAMMENI). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Modyfikatory, np. U + 02B0 (H małej litery MODYFIKATOR) za pośrednictwem U + 02C 1 (MODYFIKATOR LITERĘ ODWRÓCONE GLOTTAL STOP), lub U + 1D2C (MODYFIKATOR litery A kapitału) za pośrednictwem U + 1 d 61 (MODYFIKATOR CHI małe litery). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> kategorii.  
  
-   Pozostałe litery, np. U + 05 D 0 (ALEF LITERĘ HEBRAJSKI) za pośrednictwem U + 05EA (TAV litery HEBRAJSKI), U + 0621 (ARABSKI HAMZA LITERĄ) za pośrednictwem U + 063A (ARABSKI GHAIN litery), lub U + 4E00 (\<ideogramów CJK, pierwsza >) za pośrednictwem U + 9 FC 3 (\<ideogramów CJK, ostatni >). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> kategorii.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsLetter%2A>.  
  
 [!code-cpp[System.Char.IsLetter#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetter/CPP/isletter.cpp#5)]
 [!code-csharp[System.Char.IsLetter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetter/CS/isletter.cs#5)]
 [!code-vb[System.Char.IsLetter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetter/VB/isletter.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetter(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsLetter : string * int -&gt; bool" Usage="System.char.IsLetter (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku umożliwia ocenę w <c>s</c>.</param>
        <summary>Wskazuje, czy znak w określonej pozycji w określony ciąg jest dzielony na kategorie litery Unicode.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest literą; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Ta metoda określa, czy znak na pozycji indeksu określonego w ciągu jest członkiem dowolnej kategorii Unicode literę. Litery Unicode są następujące:  
  
-   Wielkie litery, np. U + 0041 (LATIN CAPITAL LETTER A) za pośrednictwem U + 005A (LATIN CAPITAL LETTER Z) lub U + 0400 (CYRYLICA litera IE WITH GRAVE) za pośrednictwem U + 042F (CYRYLICA litera YA). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Małe litery, np. U + 0061 (ŁACIŃSKI, MAŁA litera A) za pośrednictwem U + 007A (ŁACIŃSKI małe litery Z), lub U + 03AC (GRECKI małej litery ALFA z AKCENTEM) za pośrednictwem U + 03CE (GRECKI MAŁA litera OMEGA z AKCENTEM). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Tytuł wielkość liter, takich jak U + 01 C 5 (ŁACIŃSKI wielkiej litery D z małej litery Z z odwróconym DASZKIEM) lub U + 1FFC (GRECKI litera OMEGA z PROSGEGRAMMENI). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Modyfikatory, np. U + 02B0 (H małej litery MODYFIKATOR) za pośrednictwem U + 02C 1 (MODYFIKATOR LITERĘ ODWRÓCONE GLOTTAL STOP), lub U + 1D2C (MODYFIKATOR litery A kapitału) za pośrednictwem U + 1 d 61 (MODYFIKATOR CHI małe litery). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> kategorii.  
  
-   Pozostałe litery, np. U + 05 D 0 (ALEF LITERĘ HEBRAJSKI) za pośrednictwem U + 05EA (TAV litery HEBRAJSKI), U + 0621 (ARABSKI HAMZA LITERĄ) za pośrednictwem U + 063A (ARABSKI GHAIN litery), lub U + 4E00 (\<ideogramów CJK, pierwsza >) za pośrednictwem U + 9 FC 3 (\<ideogramów CJK, ostatni >). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> kategorii.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsLetter%2A>.  
  
 [!code-cpp[System.Char.IsLetter#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetter/CPP/isletter.cpp#5)]
 [!code-csharp[System.Char.IsLetter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetter/CS/isletter.cs#5)]
 [!code-vb[System.Char.IsLetter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetter/VB/isletter.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w parametrze <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLetterOrDigit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest dzielony na kategorie się literą lub dziesiętną wartością cyfrową.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe litery i cyfry dziesiętne należą następujące kategorie w <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, lub `DecimalDigitNumber`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetterOrDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(char c);" />
      <MemberSignature Language="F#" Value="static member IsLetterOrDigit : char -&gt; bool" Usage="System.char.IsLetterOrDigit c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest dzielony na kategorie się literą lub dziesiętną wartością cyfrową.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest literą lub dziesiętną wartością cyfrową; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe litery i cyfry dziesiętne należą następujące kategorie w <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, lub `DecimalDigitNumber`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsLetterOrDigit%2A>.  
  
 [!code-cpp[System.Char.IsLetterOrDigit#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CPP/isletterordigit.cpp#6)]
 [!code-csharp[System.Char.IsLetterOrDigit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CS/isletterordigit.cs#6)]
 [!code-vb[System.Char.IsLetterOrDigit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/VB/isletterordigit.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetterOrDigit(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsLetterOrDigit : string * int -&gt; bool" Usage="System.char.IsLetterOrDigit (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku umożliwia ocenę w <c>s</c>.</param>
        <summary>Wskazuje, czy znak w określonej pozycji w określony ciąg jest dzielony na kategorie się literą lub dziesiętną wartością cyfrową.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest literą lub dziesiętną wartością cyfrową; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Prawidłowe litery i cyfry dziesiętne należą następujące kategorie w <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, lub `DecimalDigitNumber`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsLetterOrDigit%2A>.  
  
 [!code-cpp[System.Char.IsLetterOrDigit#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CPP/isletterordigit.cpp#6)]
 [!code-csharp[System.Char.IsLetterOrDigit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CS/isletterordigit.cs#6)]
 [!code-vb[System.Char.IsLetterOrDigit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/VB/isletterordigit.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w parametrze <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest dzielony na kategorie małe litery.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLower(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(char c);" />
      <MemberSignature Language="F#" Value="static member IsLower : char -&gt; bool" Usage="System.char.IsLower c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest dzielony na kategorie małe litery.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest mała litera; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nieprawidłowa małe litery należą do następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `LowercaseLetter`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsLower%2A>.  
  
 [!code-cpp[System.Char.IsLower#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLower/CPP/islower.cpp#7)]
 [!code-csharp[System.Char.IsLower#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLower/CS/islower.cs#7)]
 [!code-vb[System.Char.IsLower#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLower/VB/islower.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsUpper(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLower(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsLower : string * int -&gt; bool" Usage="System.char.IsLower (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku umożliwia ocenę w <c>s</c>.</param>
        <summary>Wskazuje, czy znak w określonej pozycji w określony ciąg jest dzielony na kategorie małe litery.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest mała litera; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Nieprawidłowa małe litery należą do następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `LowercaseLetter`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsLower%2A>.  
  
 [!code-cpp[System.Char.IsLower#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLower/CPP/islower.cpp#7)]
 [!code-csharp[System.Char.IsLower#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLower/CS/islower.cs#7)]
 [!code-vb[System.Char.IsLower#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLower/VB/islower.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w parametrze <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Char.IsUpper(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLowSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy określony <see cref="T:System.Char" /> obiekt jest znak zastępczy niskiego poziomu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLowSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsLowSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLowSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLowSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLowSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLowSurrogate(char c);" />
      <MemberSignature Language="F#" Value="static member IsLowSurrogate : char -&gt; bool" Usage="System.char.IsLowSurrogate c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak do oceny.</param>
        <summary>Wskazuje, czy określony <see cref="T:System.Char" /> obiekt jest znak zastępczy niskiego poziomu.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość liczbową <paramref name="c" /> parametru z zakresu od U + DC00 za pośrednictwem U + DFFF; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oprócz reprezentowania pojedynczych znaków przy użyciu 16-bitowego kodu znaku, kodowanie UTF-16 pozwala na przedstawianie znaków abstrakcyjnych za pomocą dwóch 16-bitowych kodów znaku, znanych jako para zastępcza. Drugi element Ta para jest znak zastępczy niskiego poziomu. Jego punkt kodowy należą do zakresu od U + DC00 do U + DFFF. Indywidualny znak zastępczy ma nie interpretacji własnych; jest istotny tylko wtedy, gdy jest używany jako część pary zastępczej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, i <xref:System.Char.IsSurrogatePair%2A> metody.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLowSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsLowSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLowSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLowSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLowSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLowSurrogate(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsLowSurrogate : string * int -&gt; bool" Usage="System.char.IsLowSurrogate (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku umożliwia ocenę w <c>s</c>.</param>
        <summary>Wskazuje, czy <see cref="T:System.Char" /> obiektu w określonej pozycji w ciągu jest znak zastępczy niskiego poziomu.</summary>
        <returns>
          <see langword="true" /> Jeśli określony znak w wartości liczbowej <paramref name="s" /> parametru z zakresu od U + DC00 za pośrednictwem U + DFFF; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` Parametr jest liczony od zera.  
  
 Oprócz reprezentowania pojedynczych znaków przy użyciu 16-bitowego kodu znaku, kodowanie UTF-16 pozwala na przedstawianie znaków abstrakcyjnych za pomocą dwóch 16-bitowych kodów znaku, znanych jako para zastępcza. Drugi element Ta para jest znak zastępczy niskiego poziomu. Jego punkt kodowy należą do zakresu od U + DC00 do U + DFFF. Indywidualny znak zastępczy ma nie interpretacji własnych; jest istotny tylko wtedy, gdy jest używany jako część pary zastępczej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, i <xref:System.Char.IsSurrogatePair%2A> metody.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest pozycją w parametrze <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNumber">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest dzielony na kategorie jako liczby.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsNumber(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(char c);" />
      <MemberSignature Language="F#" Value="static member IsNumber : char -&gt; bool" Usage="System.char.IsNumber c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest dzielony na kategorie jako liczby.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest liczbą; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Char> jest dowolnej kategorii Unicode, liczbowych. Oprócz cyfr, numery obejmują znaków, ułamki, indeksy dolne, indeksów górnych, rzymskie, łącznik waluty i otoczony liczb. Ta metoda różni się znacząco od <xref:System.Char.IsDigit%2A> metody, która określa, czy <xref:System.Char> jest cyfrą podstawa 10.  
  
> [!IMPORTANT]
>  <xref:System.Char.IsNumber%28System.Char%29> Metoda nie jest przeznaczona do określenia, czy ciąg zawiera znaki numeryczne (na przykład, wywołując metodę dla każdego znaku w ciągu). Aby ustalić, czy ciąg zawiera znaki numeryczne, wywoływanie jednego z przeciążeń `TryParse` — metoda (takie jak <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> lub <xref:System.Double.TryParse%2A?displayProperty=nameWithType> typu całkowitą lub zmiennoprzecinkową.  
  
 Prawidłowe numery są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LetterNumber?displayProperty=nameWithType>, lub <xref:System.Globalization.UnicodeCategory.OtherNumber?displayProperty=nameWithType> kategorii.  
  
 <xref:System.Char.IsNumber%28System.Char%29> Metoda zakłada, że `c` odnosi się do pojedynczego znaku językowej i sprawdza, czy ten znak reprezentuje liczbę. Jednak niektóre numery w standardzie Unicode są reprezentowane przez dwa <xref:System.Char> obiekty, które tworzą pary zastępczej. Na przykład system numeracji Morza Egejskiego składa się z kodów znaku U+10107 do U+10133. W poniższym przykładzie użyto <xref:System.Char.ConvertFromUtf32%2A> metodę, aby utworzyć wystąpienie ciąg reprezentujący Morza EGEJSKIEGO jeden numer. Jak wynika z w przykładzie pokazano <xref:System.Char.IsNumber%28System.Char%29> metoda zwraca `false` Jeśli jest przekazywana znakiem zastępczym wysokiego poziomu lub znak zastępczy niskiego poziomu tego znaku.  
  
 [!code-csharp[System.Char.IsNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber1.cs#1)]
 [!code-vb[System.Char.IsNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber1.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.IsNumber%2A>.  
  
 [!code-cpp[System.Char.IsNumber#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsNumber/CPP/isnumber.cpp#8)]
 [!code-csharp[System.Char.IsNumber#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber.cs#8)]
 [!code-vb[System.Char.IsNumber#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsDigit(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsNumber(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsNumber : string * int -&gt; bool" Usage="System.char.IsNumber (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku umożliwia ocenę w <c>s</c>.</param>
        <summary>Wskazuje, czy znak w określonej pozycji w określony ciąg jest dzielony na kategorie jako liczby.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest liczbą; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Char> jest dowolnej kategorii Unicode, liczbowych. Oprócz cyfr, numery obejmują znaków, ułamki, indeksy dolne, indeksów górnych, rzymskie, łącznik waluty i otoczony liczb. Ta metoda różni się znacząco od <xref:System.Char.IsDigit%2A> metody, która określa, czy <xref:System.Char> jest cyfrą podstawa 10.  
  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
> [!IMPORTANT]
>  <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> Metoda nie jest przeznaczona do określenia, czy ciąg zawiera znaki numeryczne (na przykład, wywołując metodę dla każdego znaku w ciągu). Aby ustalić, czy ciąg zawiera znaki numeryczne, wywoływanie jednego z przeciążeń `TryParse` — metoda (takie jak <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> lub <xref:System.Double.TryParse%2A?displayProperty=nameWithType> typu całkowitą lub zmiennoprzecinkową.  
  
 Prawidłowe numery są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LetterNumber?displayProperty=nameWithType>, lub <xref:System.Globalization.UnicodeCategory.OtherNumber?displayProperty=nameWithType> kategorii.  
  
 Jeśli <xref:System.Char> obiektu w położeniu `index` jest pierwszym znakiem para zastępcza prawidłowe <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> Metoda określa, czy para zastępcza formularzy zawierać cyfrę. Na przykład system numeracji Morza Egejskiego składa się z kodów znaku U+10107 do U+10133. W poniższym przykładzie użyto <xref:System.Char.ConvertFromUtf32%2A> metodę, aby utworzyć wystąpienie ciąg reprezentujący Morza EGEJSKIEGO jeden numer. Jak wynika z w przykładzie pokazano <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> metoda zwraca `true` , jeśli został przekazany znakiem zastępczym wysokiego poziomu o jeden liczbę Morza EGEJSKIEGO. Jednakże, jeśli został przekazany znak zastępczy niskiego poziomu, uwzględnia tylko kategorii znak zastępczy niskiego poziomu i zwraca `false`.  
  
 [!code-csharp[System.Char.IsNumber#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber1.cs#2)]
 [!code-vb[System.Char.IsNumber#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber1.vb#2)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.IsNumber%2A>.  
  
 [!code-cpp[System.Char.IsNumber#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsNumber/CPP/isnumber.cpp#8)]
 [!code-csharp[System.Char.IsNumber#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber.cs#8)]
 [!code-vb[System.Char.IsNumber#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w parametrze <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Char.IsDigit(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPunctuation">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest dzielony na kategorie jako znak interpunkcyjny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe znaki interpunkcyjne należą następujące kategorie w <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, lub `OtherPunctuation`. Obejmują one znaków punkty kodowe Unicode, które są wymienione w poniższej tabeli.  
  
|||||  
|-|-|-|-|  
|U + 0021 do U + 0023|U + 060C i D 060 U +|1800 U + do U + 180A|3014 U + do U + 301F|  
|U + 0025 do U + 002A|U+061B|U + 1944 i U + 1945|U+3030|  
|U + 002C do U + 002F|U + 061E i U + 061F|U + 19DE i U + 19DF|U+303D|  
|U + 003a Notebook i U + 003B|U + 066A do U + 066D|U + 1A1E i U + 1A1F|U+30A0|  
|U + 003F i U + 0040|U+06D4|U + 1B5A do U + 1B60|U+30FB|  
|U + 005B do U + 005D|U + 0700 do U + 070D|U + 2010 do U + 2027|U + A874 do U + A877|  
|U+005F|U + 07F7 do U + 07F9|2030 U + do U + 2043|U + FD3E i U + FD3F|  
|U+007B|U + 0964 i U + 0965|U + 2045 do U + 2051|U + FE10 do U + FE19|  
|U+007D|U+0970|2053 U + do U + 205E|U + FE30 do U + FE52|  
|U+00A1|U+0DF4|U + 207D i U + 207E|U + FE54 do U + FE61|  
|U+00AB|U + 0E4F do U + 0E5B|U + 208D i U + 208E|U+FE63|  
|U+00AD|U + 0F04 do U + 0F12|U + 2329 i U + 232A|U+FE68|  
|U+00B7|U + 0F3A do U + 0F3D|U + 2768 do U + 2775|U + FE6A i U + FE6B|  
|U+00BB|U+0F85|U + 5 27 c do U + 27 c 6|U + FF01 do U + FF03|  
|U+00BF|U + 0FD0 i U + 0FD1|U + 27E6 do U + 27EB|U + FF05 do U + FF0A|  
|U+037E|104 a U + – U + 104F|U + 2983 do U + 2998|U + FF0C do U + FF0F|  
|U+0387|U+10FB|U + 8 29D do U + 29DB|U + FF1A i U + FF1B|  
|U + 055A do U + 055F|U + 1361 do U + 1368|U + 29FC i U + 29FD|U + FF1F i U + FF20|  
|U + 0589 i U + 058A|U + 166D i U + 166E|U + 2CF9 do U + 2CFC|U + FF3B do U + FF3D|  
|U+05BE|U + 169B i U + 169C|U + 2CFE i U + 2CFF|U+FF3F|  
|U+05C0|U + 16EB do U + 16ED|U + 2E00 do U + 2E17|U+FF5B|  
|U+05C3|U + 1735 i U + 1736|U + 2E1C i U + 2E1D|U+FF5D|  
|U+05C6|U + 4 17D do U + 17D 6|3001 U + do U + 3003|U + FF5F do U + FF65|  
|U + 05F3 i U + 05F4|U + 8 17D do U + 17DA|3008 U + do U + 3011||  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsPunctuation(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(char c);" />
      <MemberSignature Language="F#" Value="static member IsPunctuation : char -&gt; bool" Usage="System.char.IsPunctuation c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest dzielony na kategorie jako znak interpunkcyjny.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest znak interpunkcyjny; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe znaki interpunkcyjne należą następujące kategorie w <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, lub `OtherPunctuation`. Obejmują one znaków punkty kodowe Unicode, które są wymienione w poniższej tabeli.  
  
|||||  
|-|-|-|-|  
|U + 0021 do U + 0023|U + 060C i D 060 U +|1800 U + do U + 180A|3014 U + do U + 301F|  
|U + 0025 do U + 002A|U+061B|U + 1944 i U + 1945|U+3030|  
|U + 002C do U + 002F|U + 061E i U + 061F|U + 19DE i U + 19DF|U+303D|  
|U + 003a Notebook i U + 003B|U + 066A do U + 066D|U + 1A1E i U + 1A1F|U+30A0|  
|U + 003F i U + 0040|U+06D4|U + 1B5A do U + 1B60|U+30FB|  
|U + 005B do U + 005D|U + 0700 do U + 070D|U + 2010 do U + 2027|U + A874 do U + A877|  
|U+005F|U + 07F7 do U + 07F9|2030 U + do U + 2043|U + FD3E i U + FD3F|  
|U+007B|U + 0964 i U + 0965|U + 2045 do U + 2051|U + FE10 do U + FE19|  
|U+007D|U+0970|2053 U + do U + 205E|U + FE30 do U + FE52|  
|U+00A1|U+0DF4|U + 207D i U + 207E|U + FE54 do U + FE61|  
|U+00AB|U + 0E4F do U + 0E5B|U + 208D i U + 208E|U+FE63|  
|U+00AD|U + 0F04 do U + 0F12|U + 2329 i U + 232A|U+FE68|  
|U+00B7|U + 0F3A do U + 0F3D|U + 2768 do U + 2775|U + FE6A i U + FE6B|  
|U+00BB|U+0F85|U + 5 27 c do U + 27 c 6|U + FF01 do U + FF03|  
|U+00BF|U + 0FD0 i U + 0FD1|U + 27E6 do U + 27EB|U + FF05 do U + FF0A|  
|U+037E|104 a U + – U + 104F|U + 2983 do U + 2998|U + FF0C do U + FF0F|  
|U+0387|U+10FB|U + 8 29D do U + 29DB|U + FF1A i U + FF1B|  
|U + 055A do U + 055F|U + 1361 do U + 1368|U + 29FC i U + 29FD|U + FF1F i U + FF20|  
|U + 0589 i U + 058A|U + 166D i U + 166E|U + 2CF9 do U + 2CFC|U + FF3B do U + FF3D|  
|U+05BE|U + 169B i U + 169C|U + 2CFE i U + 2CFF|U+FF3F|  
|U+05C0|U + 16EB do U + 16ED|U + 2E00 do U + 2E17|U+FF5B|  
|U+05C3|U + 1735 i U + 1736|U + 2E1C i U + 2E1D|U+FF5D|  
|U+05C6|U + 4 17D do U + 17D 6|3001 U + do U + 3003|U + FF5F do U + FF65|  
|U + 05F3 i U + 05F4|U + 8 17D do U + 17DA|3008 U + do U + 3011||  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsPunctuation%2A>.  
  
 [!code-cpp[System.Char.IsPunctuation#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CPP/ispunctuation.cpp#9)]
 [!code-csharp[System.Char.IsPunctuation#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CS/ispunctuation.cs#9)]
 [!code-vb[System.Char.IsPunctuation#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsPunctuation/VB/ispunctuation.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsPunctuation(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsPunctuation : string * int -&gt; bool" Usage="System.char.IsPunctuation (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku umożliwia ocenę w <c>s</c>.</param>
        <summary>Wskazuje, czy znak w określonej pozycji w określony ciąg jest dzielony na kategorie jako znak interpunkcyjny.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest znak interpunkcyjny; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Prawidłowe znaki interpunkcyjne należą następujące kategorie w <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, lub `OtherPunctuation`. Obejmują one znaków punkty kodowe Unicode, które są wymienione w poniższej tabeli.  
  
|||||  
|-|-|-|-|  
|U + 0021 do U + 0023|U + 060C i D 060 U +|1800 U + do U + 180A|3014 U + do U + 301F|  
|U + 0025 do U + 002A|U+061B|U + 1944 i U + 1945|U+3030|  
|U + 002C do U + 002F|U + 061E i U + 061F|U + 19DE i U + 19DF|U+303D|  
|U + 003a Notebook i U + 003B|U + 066A do U + 066D|U + 1A1E i U + 1A1F|U+30A0|  
|U + 003F i U + 0040|U+06D4|U + 1B5A do U + 1B60|U+30FB|  
|U + 005B do U + 005D|U + 0700 do U + 070D|U + 2010 do U + 2027|U + A874 do U + A877|  
|U+005F|U + 07F7 do U + 07F9|2030 U + do U + 2043|U + FD3E i U + FD3F|  
|U+007B|U + 0964 i U + 0965|U + 2045 do U + 2051|U + FE10 do U + FE19|  
|U+007D|U+0970|2053 U + do U + 205E|U + FE30 do U + FE52|  
|U+00A1|U+0DF4|U + 207D i U + 207E|U + FE54 do U + FE61|  
|U+00AB|U + 0E4F do U + 0E5B|U + 208D i U + 208E|U+FE63|  
|U+00AD|U + 0F04 do U + 0F12|U + 2329 i U + 232A|U+FE68|  
|U+00B7|U + 0F3A do U + 0F3D|U + 2768 do U + 2775|U + FE6A i U + FE6B|  
|U+00BB|U+0F85|U + 5 27 c do U + 27 c 6|U + FF01 do U + FF03|  
|U+00BF|U + 0FD0 i U + 0FD1|U + 27E6 do U + 27EB|U + FF05 do U + FF0A|  
|U+037E|104 a U + – U + 104F|U + 2983 do U + 2998|U + FF0C do U + FF0F|  
|U+0387|U+10FB|U + 8 29D do U + 29DB|U + FF1A i U + FF1B|  
|U + 055A do U + 055F|U + 1361 do U + 1368|U + 29FC i U + 29FD|U + FF1F i U + FF20|  
|U + 0589 i U + 058A|U + 166D i U + 166E|U + 2CF9 do U + 2CFC|U + FF3B do U + FF3D|  
|U+05BE|U + 169B i U + 169C|U + 2CFE i U + 2CFF|U+FF3F|  
|U+05C0|U + 16EB do U + 16ED|U + 2E00 do U + 2E17|U+FF5B|  
|U+05C3|U + 1735 i U + 1736|U + 2E1C i U + 2E1D|U+FF5D|  
|U+05C6|U + 4 17D do U + 17D 6|3001 U + do U + 3003|U + FF5F do U + FF65|  
|U + 05F3 i U + 05F4|U + 8 17D do U + 17DA|3008 U + do U + 3011||  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsPunctuation%2A>.  
  
 [!code-cpp[System.Char.IsPunctuation#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CPP/ispunctuation.cpp#9)]
 [!code-csharp[System.Char.IsPunctuation#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CS/ispunctuation.cs#9)]
 [!code-vb[System.Char.IsPunctuation#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsPunctuation/VB/ispunctuation.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w parametrze <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSeparator">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest dzielony na kategorie jako znak separatora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W standardzie Unicode rozpoznaje trzy podkategorie separatorów:  
  
-   Miejsce separatora ( <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> kategorii), który zawiera znaki, takie jak \u0020.  
  
-   Separatory wierszy ( <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> kategorii), która obejmuje \u2028.  
  
-   Akapitu separatorów ( <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> kategorii), która obejmuje \u2029.  
  
> [!NOTE]
>  Unicode standard klasyfikuje \u000A znaków (LF), \u000C (FF) i \u000D (CR) jako znaki kontrolne (elementy członkowskie <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> kategorii), a nie jako znaki separatora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSeparator(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(char c);" />
      <MemberSignature Language="F#" Value="static member IsSeparator : char -&gt; bool" Usage="System.char.IsSeparator c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest dzielony na kategorie jako znak separatora.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest separatorem znaku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W standardzie Unicode rozpoznaje trzy podkategorie separatorów:  
  
-   Miejsce separatora ( <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> kategorii), który zawiera znaki, takie jak \u0020.  
  
-   Separatory wierszy ( <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> kategorii), która obejmuje \u2028.  
  
-   Akapitu separatorów ( <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> kategorii), która obejmuje \u2029.  
  
> [!NOTE]
>  Unicode standard klasyfikuje \u000A znaków (LF), \u000C (FF) i \u000D (CR) jako znaki kontrolne (elementy członkowskie <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> kategorii), a nie jako znaki separatora.  
  
   
  
## Examples  
 Na poniższych listach przykład <xref:System.Char> obiektów, które są klasyfikowane jako znaki separatora.  
  
 [!code-cpp[System.Char.IsSeparator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSeparator/CPP/isseparator1.cpp#1)]
 [!code-csharp[System.Char.IsSeparator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSeparator/CS/isseparator1.cs#1)]
 [!code-vb[System.Char.IsSeparator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSeparator/VB/isseparator1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSeparator(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsSeparator : string * int -&gt; bool" Usage="System.char.IsSeparator (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku umożliwia ocenę w <c>s</c>.</param>
        <summary>Wskazuje, czy znak w określonej pozycji w określony ciąg jest dzielony na kategorie jako znak separatora.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest separatorem znaku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 W standardzie Unicode rozpoznaje trzy podkategorie separatorów:  
  
-   Miejsce separatora ( <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> kategorii), który zawiera znaki, takie jak \u0020.  
  
-   Separatory wierszy ( <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> kategorii), która obejmuje \u2028.  
  
-   Akapitu separatorów ( <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> kategorii), która obejmuje \u2029.  
  
> [!NOTE]
>  Unicode standard klasyfikuje \u000A znaków (LF), \u000C (FF) i \u000D (CR) jako znaki kontrolne (elementy członkowskie <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> kategorii), a nie jako znaki separatora.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.IsSeparator%2A>.  
  
 [!code-cpp[System.Char.IsSeparator#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSeparator/CPP/isseparator.cpp#10)]
 [!code-csharp[System.Char.IsSeparator#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSeparator/CS/isseparator.cs#10)]
 [!code-vb[System.Char.IsSeparator#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSeparator/VB/isseparator.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w parametrze <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak ma jednostki kodu zastępczy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogate(char c);" />
      <MemberSignature Language="F#" Value="static member IsSurrogate : char -&gt; bool" Usage="System.char.IsSurrogate c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak ma jednostki kodu zastępczy.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest znakiem zastępczym wysokiego poziomu lub dwuskładnikowego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastępczy jest <xref:System.Char> obiektu o jednostkę kodu UTF-16 z zakresu od U + D800 do U + DFFF. Każdy znak w ramach jednostki kodu, w tym zakresie, o których należy <xref:System.Globalization.UnicodeCategory.Surrogate?displayProperty=nameWithType> kategorii. Jednostka kodu indywidualny znak zastępczy ma nie interpretacji własnych, ale ma znaczenie tylko wtedy, gdy jest używana jako część pary zastępczej. Aby uzyskać więcej informacji dotyczących par zastępczych, zobacz Unicode Standard na [strony głównej Unicode](http://go.microsoft.com/fwlink/?linkid=37123).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.IsSurrogate%2A> metody.  
  
 [!code-cpp[System.Char.IsSurrogate#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CPP/issurrogate.cpp#11)]
 [!code-csharp[System.Char.IsSurrogate#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CS/issurrogate.cs#11)]
 [!code-vb[System.Char.IsSurrogate#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSurrogate/VB/issurrogate.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Char.IsHighSurrogate" />
        <altmember cref="Overload:System.Char.IsLowSurrogate" />
        <altmember cref="Overload:System.Char.IsSurrogatePair" />
      </Docs>
    </Member>
    <Member MemberName="IsSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogate(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsSurrogate : string * int -&gt; bool" Usage="System.char.IsSurrogate (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku umożliwia ocenę w <c>s</c>.</param>
        <summary>Wskazuje, czy znak w określonej pozycji w określonym ciągu ma jednostki kodu zastępczy.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest znakiem zastępczym wysokiego poziomu lub dwuskładnikowego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Zastępczy jest <xref:System.Char> obiektu o jednostkę kodu UTF-16 z zakresu od U + D800 do U + DFFF. Każdy znak w ramach jednostki kodu, w tym zakresie, o których należy <xref:System.Globalization.UnicodeCategory.Surrogate?displayProperty=nameWithType> kategorii. Jednostka kodu indywidualny znak zastępczy ma nie interpretacji własnych, ale ma znaczenie tylko wtedy, gdy jest używana jako część pary zastępczej. Aby uzyskać więcej informacji dotyczących par zastępczych, zobacz Unicode Standard na [strony głównej Unicode](http://go.microsoft.com/fwlink/?linkid=37123).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsSurrogate%2A>.  
  
 [!code-cpp[System.Char.IsSurrogate#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CPP/issurrogate.cpp#11)]
 [!code-csharp[System.Char.IsSurrogate#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CS/issurrogate.cs#11)]
 [!code-vb[System.Char.IsSurrogate#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSurrogate/VB/issurrogate.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w parametrze <paramref name="s" />.</exception>
        <altmember cref="Overload:System.Char.IsHighSurrogate" />
        <altmember cref="Overload:System.Char.IsLowSurrogate" />
        <altmember cref="Overload:System.Char.IsSurrogatePair" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSurrogatePair">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy dwa określone <see cref="T:System.Char" /> obiekty tworzą pary zastępczej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSurrogatePair">
      <MemberSignature Language="C#" Value="public static bool IsSurrogatePair (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogatePair(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogatePair(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogatePair (highSurrogate As Char, lowSurrogate As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="F#" Value="static member IsSurrogatePair : char * char -&gt; bool" Usage="System.char.IsSurrogatePair (highSurrogate, lowSurrogate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="highSurrogate">Znak do oceny jako znakiem zastępczym wysokiego poziomu para zastępcza.</param>
        <param name="lowSurrogate">Znak do oceny jako znak zastępczy niskiego poziomu para zastępcza.</param>
        <summary>Wskazuje, czy dwa określone <see cref="T:System.Char" /> obiekty tworzą pary zastępczej.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość liczbową <paramref name="highSurrogate" /> parametru z zakresu od U + D800 za pośrednictwem U + DBFF i wartości liczbowej <paramref name="lowSurrogate" /> parametru z zakresu od U + DC00 za pośrednictwem U + DFFF; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj pojedynczy znak jest reprezentowany przez pojedynczą jednostkę kodu Unicode 16-bitowych. Kodowanie UTF-16 obsługuje również par zastępczych, umożliwiających abstrakcyjne pojedynczy znak może być reprezentowana przez dwie jednostki 16-bitowego kodu. Pierwszy jednostki kodu, którego wartość może należeć do zakresu od U + D800 do U + DBFF, jest znakiem zastępczym wysokiego poziomu. Drugi jednostki kodu, którego wartość może należeć do zakresu od U + DC00 do U + DFFF, jest znak zastępczy niskiego poziomu. Punkty kodowe indywidualny znak zastępczy ma nie interpretacji własnych. Aby uzyskać więcej informacji na temat surogaty i Unicode Standard, zobacz [strony głównej Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, i <xref:System.Char.IsSurrogatePair%2A> metody.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.IsHighSurrogate(System.Char)" />
        <altmember cref="M:System.Char.IsLowSurrogate(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsSurrogatePair">
      <MemberSignature Language="C#" Value="public static bool IsSurrogatePair (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogatePair(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogatePair(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogatePair (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogatePair(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsSurrogatePair : string * int -&gt; bool" Usage="System.char.IsSurrogatePair (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja początkowa pary znaków do oceny, w ramach <c>s</c>.</param>
        <summary>Wskazuje, czy dwa sąsiadujące <see cref="T:System.Char" /> obiekty na określonej pozycji w ciągu tworzą pary zastępczej.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="s" /> parametr zawiera znaki przylegające w pozycjach <paramref name="index" /> i <paramref name="index" /> + 1, a wartość liczbową znak na pozycji <paramref name="index" /> z zakresu od U + D800 poprzez U + DBFF i wartość liczbową znak na pozycji pozycja <paramref name="index" />+ 1 zakresu od U + DC00 za pośrednictwem U + DFFF; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj pojedynczy znak jest reprezentowany przez pojedynczą jednostkę kodu Unicode 16-bitowych. Kodowanie UTF-16 obsługuje również par zastępczych, umożliwiających abstrakcyjne pojedynczy znak może być reprezentowana przez dwie jednostki 16-bitowego kodu. Pierwszy jednostki kodu, którego wartość może należeć do zakresu od U + D800 do U + DBFF, jest znakiem zastępczym wysokiego poziomu. Drugi jednostki kodu, którego wartość może należeć do zakresu od U + DC00 do U + DFFF, jest znak zastępczy niskiego poziomu. Punkty kodowe indywidualny znak zastępczy ma nie interpretacji własnych. Aby uzyskać więcej informacji na temat surogaty i Unicode Standard, zobacz [strony głównej Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, i <xref:System.Char.IsSurrogatePair%2A> metody.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest pozycją w parametrze <paramref name="s" />.</exception>
        <altmember cref="M:System.Char.IsHighSurrogate(System.Char)" />
        <altmember cref="M:System.Char.IsLowSurrogate(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSymbol">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest dzielony na kategorie jako znak symbolu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe symbole są członkami następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, i `OtherSymbol`.  
  
 Symbole w standardzie Unicode są luźno zdefiniowanego zestawu znaków, które obejmują następujące czynności:  
  
-   Symbole walut.  
  
-   Literopodobne symboli, które zawierają zestaw symbole matematyczne alfanumeryczne oraz symbole, takie jak ℅, nr, i rozwojowych.  
  
-   Liczba formularzy, takich jak indeksy dolne i górne.  
  
-   Operatory matematyczne i strzałki.  
  
-   Symbole geometrycznych.  
  
-   Symbole Technical Preview.  
  
-   Braille'a wzorców.  
  
-   Dingbats.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSymbol(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(char c);" />
      <MemberSignature Language="F#" Value="static member IsSymbol : char -&gt; bool" Usage="System.char.IsSymbol c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest dzielony na kategorie jako znak symbolu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> to symbol znaku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe symbole są członkami następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, i `OtherSymbol`.  
  
 Symbole w standardzie Unicode są luźno zdefiniowanego zestawu znaków, które obejmują następujące czynności:  
  
-   Symbole walut.  
  
-   Literopodobne symboli, które zawierają zestaw symbole matematyczne alfanumeryczne oraz symbole, takie jak ℅, nr, i rozwojowych.  
  
-   Liczba formularzy, takich jak indeksy dolne i górne.  
  
-   Operatory matematyczne i strzałki.  
  
-   Symbole geometrycznych.  
  
-   Symbole Technical Preview.  
  
-   Braille'a wzorców.  
  
-   Dingbats.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsSymbol%2A>.  
  
 [!code-cpp[System.Char.IsSymbol#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSymbol/CPP/issymbol.cpp#12)]
 [!code-csharp[System.Char.IsSymbol#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSymbol/CS/issymbol.cs#12)]
 [!code-vb[System.Char.IsSymbol#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSymbol/VB/issymbol.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSymbol(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsSymbol : string * int -&gt; bool" Usage="System.char.IsSymbol (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku umożliwia ocenę w <c>s</c>.</param>
        <summary>Wskazuje, czy znak w określonej pozycji w określony ciąg jest dzielony na kategorie jako znak symbolu.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> to symbol znaku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Prawidłowe symbole są członkami następujących kategorii w <xref:System.Globalization.UnicodeCategory?displayProperty=nameWithType>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, i `OtherSymbol`.  
  
 Symbole w standardzie Unicode są luźno zdefiniowanego zestawu znaków, które obejmują następujące czynności:  
  
-   Symbole walut.  
  
-   Literopodobne symboli, które zawierają zestaw symbole matematyczne alfanumeryczne oraz symbole, takie jak ℅, nr, i rozwojowych.  
  
-   Liczba formularzy, takich jak indeksy dolne i górne.  
  
-   Operatory matematyczne i strzałki.  
  
-   Symbole geometrycznych.  
  
-   Symbole Technical Preview.  
  
-   Braille'a wzorców.  
  
-   Dingbats.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsSymbol%2A>.  
  
 [!code-cpp[System.Char.IsSymbol#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSymbol/CPP/issymbol.cpp#12)]
 [!code-csharp[System.Char.IsSymbol#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSymbol/CS/issymbol.cs#12)]
 [!code-vb[System.Char.IsSymbol#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSymbol/VB/issymbol.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w parametrze <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest dzielony na kategorie jako wielką literą.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsUpper(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(char c);" />
      <MemberSignature Language="F#" Value="static member IsUpper : char -&gt; bool" Usage="System.char.IsUpper c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest dzielony na kategorie jako wielką literą.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest wielką literę; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nieprawidłowa wielkie litery należą do następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsLower(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsUpper(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsUpper : string * int -&gt; bool" Usage="System.char.IsUpper (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku umożliwia ocenę w <c>s</c>.</param>
        <summary>Wskazuje, czy znak w określonej pozycji w określony ciąg jest dzielony na kategorie jako wielką literą.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest wielką literę; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Nieprawidłowa wielkie litery należą do następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w parametrze <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsWhiteSpace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest dzielony na kategorie jako biały znak.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki odstępu są następujące znaki Unicode:  
  
-   Członkowie <xref:System.Globalization.UnicodeCategory.SpaceSeparator> kategorii, która zawiera znaki spację (U + 0020), miejsca OGHAM oznaczyć (U + 1680), cztery EN (U + 2000), cztery EM (U + 2001), EN spację (U + 2002), EM miejsca (U + 2003), trzech na Długiej spacji (U + 2004), cztery na Długiej spacji (U + 2005), 6 na EM SPACJĘ (U + 2006), rysunek miejsca (U + 2007), znaki INTERPUNKCYJNE wiele do zrobienia miejsca (U + 2008), miejsca (U + 2009), miejsca włosów (U + 200A), WĄSKIE spacja NIEROZDZIELAJĄCA (U + 202F), średnie miejsce MATEMATYCZNE (U + 205F) i IDEOGRAFICZNYCH (U + 3000).  
  
-   Elementy członkowskie <xref:System.Globalization.UnicodeCategory.LineSeparator> kategorii, która obejmuje tylko znak SEPARATORA linii (U + 2028).  
  
-   Elementy członkowskie <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> kategorię, która składa się wyłącznie ze znaków SEPARATOR AKAPITÓW (U + 2029).  
  
-   Znaki TABULACJA znak (U + 0009) spacji (U + 000A) WYSUWU wiersza, TABULACJA w wierszu (U + 000B), wysuw (U + 000C), powrotu KARETKI (U + 000D), OBOK wiersza (U + 0085) i spacja NIEROZDZIELAJĄCA (U + 00A0).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsWhiteSpace(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(char c);" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : char -&gt; bool" Usage="System.char.IsWhiteSpace c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest dzielony na kategorie jako biały znak.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest białe miejsca; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki odstępu są następujące znaki Unicode:  
  
-   Elementy członkowskie <xref:System.Globalization.UnicodeCategory.SpaceSeparator> kategorii, która zawiera znaki miejsca (U + 0020), spacja NIEROZDZIELAJĄCA (U + 00A0), OZNACZ miejsca OGHAM (U + 1680), cztery EN (U + 2000), cztery EM (U + 2001), EN spację (U + 2002), EM miejsca (U + 2003), trzech na Długiej spacji (U + 2004), (cztery na Długiej spacji U+ 2005), 6 na Długiej spacji (U + 2006), spacja (U + 2007), znaki INTERPUNKCYJNE wiele do zrobienia miejsca (U + 2008), miejsca (U + 2009), włosów miejsca (U + 200A), spacja NIEROZDZIELAJĄCA WĄSKIEGO (U + 202F), średnie miejsce MATEMATYCZNE (U + 205F) i IDEOGRAFICZNYCH (U + 3000).  
  
-   Elementy członkowskie <xref:System.Globalization.UnicodeCategory.LineSeparator> kategorii, która obejmuje tylko znak SEPARATORA linii (U + 2028).  
  
-   Elementy członkowskie <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> kategorię, która składa się wyłącznie ze znaków SEPARATOR AKAPITÓW (U + 2029).  
  
-   Znaki TABULACJA znak (U + 0009), wiersz źródła danych (U + 000A), TABULACJA w wierszu (U + 000B), wysuw (U + 000C), powrotu KARETKI (U + 000D), a następnie wiersza (U + 0085).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.IsWhiteSpace%28System.Char%29> metody.  
  
 [!code-cpp[System.Char.IsWhiteSpace#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CPP/iswhitespace.cpp#14)]
 [!code-csharp[System.Char.IsWhiteSpace#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CS/iswhitespace.cs#14)]
 [!code-vb[System.Char.IsWhiteSpace#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/VB/iswhitespace.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsWhiteSpace(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : string * int -&gt; bool" Usage="System.char.IsWhiteSpace (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku umożliwia ocenę w <c>s</c>.</param>
        <summary>Wskazuje, czy znak w określonej pozycji w określony ciąg jest dzielony na kategorie jako biały znak.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest białe miejsca; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Znaki odstępu są następujące znaki Unicode:  
  
-   Elementy członkowskie <xref:System.Globalization.UnicodeCategory.SpaceSeparator> kategorii, która zawiera znaki miejsca (U + 0020), spacja NIEROZDZIELAJĄCA (U + 00A0), OZNACZ miejsca OGHAM (U + 1680), cztery EN (U + 2000), cztery EM (U + 2001), EN spację (U + 2002), EM miejsca (U + 2003), trzech na Długiej spacji (U + 2004), (cztery na Długiej spacji U+ 2005), 6 na Długiej spacji (U + 2006), spacja (U + 2007), znaki INTERPUNKCYJNE wiele do zrobienia miejsca (U + 2008), miejsca (U + 2009), włosów miejsca (U + 200A), spacja NIEROZDZIELAJĄCA WĄSKIEGO (U + 202F), średnie miejsce MATEMATYCZNE (U + 205F) i IDEOGRAFICZNYCH (U + 3000).  
  
-   Elementy członkowskie <xref:System.Globalization.UnicodeCategory.LineSeparator> kategorii, która obejmuje tylko znak SEPARATORA linii (U + 2028).  
  
-   Elementy członkowskie <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> kategorię, która składa się wyłącznie ze znaków SEPARATOR AKAPITÓW (U + 2029).  
  
-   Znaki TABULACJA znak (U + 0009), wiersz źródła danych (U + 000A), TABULACJA w wierszu (U + 000B), wysuw (U + 000C), powrotu KARETKI (U + 000D), a następnie wiersza (U + 0085).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.IsWhiteSpace%2A>.  
  
 [!code-cpp[System.Char.IsWhiteSpace#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CPP/iswhitespace.cpp#14)]
 [!code-csharp[System.Char.IsWhiteSpace#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CS/iswhitespace.cs#14)]
 [!code-vb[System.Char.IsWhiteSpace#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/VB/iswhitespace.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w parametrze <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const char MaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal char MaxValue" />
      <MemberSignature Language="DocId" Value="F:System.Char.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Char " />
      <MemberSignature Language="C++ CLI" Value="public: char MaxValue;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : char" Usage="System.char.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje największa możliwa wartość z <see cref="T:System.Char" />. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest szesnastkowe 0xFFFF.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Char.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const char MinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal char MinValue" />
      <MemberSignature Language="DocId" Value="F:System.Char.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Char " />
      <MemberSignature Language="C++ CLI" Value="public: char MinValue;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : char" Usage="System.char.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje najniższą możliwą wartość elementu <see cref="T:System.Char" />. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest 0x00 szesnastkowe.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Char.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static char Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; char" Usage="System.char.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg, który zawiera pojedynczy znak lub <see langword="null" />.</param>
        <summary>Konwertuje wartość określonego ciągu na jego odpowiadające znaki Unicode.</summary>
        <returns>Znak Unicode, które jest odpowiednikiem znaku wyłącznie w <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.Parse%2A>.  
  
 [!code-cpp[System.Char.Parse#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.Parse/CPP/parse.cpp#15)]
 [!code-csharp[System.Char.Parse#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.Parse/CS/parse.cs#15)]
 [!code-vb[System.Char.Parse#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.Parse/VB/parse.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Długość <paramref name="s" /> nie jest 1.</exception>
        <altmember cref="M:System.Char.ToString" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>**Note** ta konwersja nie jest obsługiwana. Podjęto próbę wykonania powoduje zgłoszenie <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Ta konwersja nie jest obsługiwana. Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Ta konwersja nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToByte%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego <see cref="T:System.Char" /> obiektu bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>**Note** ta konwersja nie jest obsługiwana. Podjęto próbę wykonania powoduje zgłoszenie <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Ta konwersja nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>**Note** ta konwersja nie jest obsługiwana. Podjęto próbę wykonania powoduje zgłoszenie <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Ta konwersja nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>**Note** ta konwersja nie jest obsługiwana. Podjęto próbę wykonania powoduje zgłoszenie <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Ta konwersja nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt16%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt32%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt64%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSByte%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>**Note** ta konwersja nie jest obsługiwana. Podjęto próbę wykonania powoduje zgłoszenie <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Ta konwersja nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Element <see cref="T:System.Type" /> obiektu.</param>
        <param name="provider">
          <see cref="T:System.IFormatProvider" /> Obiektu.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Obiekt określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%2CSystem.IFormatProvider%29> metody zamiast tego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Wartość bieżącego <see cref="T:System.Char" /> obiektu nie można przekonwertować na typ określony przez <paramref name="type" /> parametru.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.IFormatProvider" /> Obiektu. (Określ <see langword="null" /> ponieważ <c>dostawcy</c> parametr jest ignorowany.)</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt16%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.IFormatProvider" /> Obiektu. (Określ <see langword="null" /> ponieważ <c>dostawcy</c> parametr jest ignorowany.)</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt32%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.IFormatProvider" /> Obiektu. (Określ <see langword="null" /> ponieważ <c>dostawcy</c> parametr jest ignorowany.)</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt64%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość znaku Unicode na odpowiadającą jej małe litery.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static char ToLower (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLower(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLower(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLower(char c);" />
      <MemberSignature Language="F#" Value="static member ToLower : char -&gt; char" Usage="System.char.ToLower c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <summary>Konwertuje wartość znaku Unicode na odpowiadającą jej małe litery.</summary>
        <returns>Małe równowartość <paramref name="c" />, lub bez zmian wartości <paramref name="c" />, jeśli <paramref name="c" /> jest już nie alfabetycznym czy małą.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguł stosowania wielkości liter są uzyskiwane z bieżącej kultury.  
  
 Użyj <xref:System.String.ToLower%2A?displayProperty=nameWithType> do przekonwertowania ciągu na małe litery.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.ToLower%2A>.  
  
 [!code-cpp[System.Char.ToLower#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToLower/CPP/tolower.cpp#16)]
 [!code-csharp[System.Char.ToLower#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToLower/CS/tolower.cs#16)]
 [!code-vb[System.Char.ToLower#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToLower/VB/tolower.vb#16)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Jak wyjaśniono w [najlepsze rozwiązania dotyczące przy użyciu Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod wielkość znaków i wielkości liter ciągu, które podstawiają wartości domyślne. Zamiast tego należy wywołać metody, które wymagają być jawnie określone parametry. Aby dokonać konwersji znaków na małe litery, przy użyciu konwencji obudowy bieżącej kultury, należy wywołać <see cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" /> przeciążenie metody z wartością <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> dla jego <paramref name="culture" /> parametru.</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static char ToLower (char c, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLower(char c, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (c As Char, culture As CultureInfo) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLower(char c, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToLower : char * System.Globalization.CultureInfo -&gt; char" Usage="System.char.ToLower (c, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <param name="culture">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</param>
        <summary>Konwertuje wartość określonego znaku Unicode równoważnik małe litery, przy użyciu określonego informacje o formatowaniu specyficzne dla kultury.</summary>
        <returns>Małe równowartość <paramref name="c" />, zmodyfikowane na podstawie położenia <paramref name="culture" />, lub bez zmian wartości <paramref name="c" />, jeśli <paramref name="c" /> jest już nie alfabetycznym czy małą.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.String.ToLower%2A?displayProperty=nameWithType> do przekonwertowania ciągu na małe litery.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.ToLower%2A>.  
  
 [!code-cpp[System.Char.ToLower#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToLower/CPP/tolower.cpp#16)]
 [!code-csharp[System.Char.ToLower#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToLower/CS/tolower.cs#16)]
 [!code-vb[System.Char.ToLower#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToLower/VB/tolower.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public static char ToLowerInvariant (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLowerInvariant(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLowerInvariant(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLowerInvariant (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLowerInvariant(char c);" />
      <MemberSignature Language="F#" Value="static member ToLowerInvariant : char -&gt; char" Usage="System.char.ToLowerInvariant c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <summary>Konwertuje wartość znaku Unicode równoważnik małe litery, używając reguł stosowania wielkości liter kultury niezmiennej.</summary>
        <returns>Małe równowartość <paramref name="c" /> parametr lub wartość niezmienione <paramref name="c" />, jeśli <paramref name="c" /> jest już nie alfabetycznym czy małą.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli aplikacja jest niezależny od bieżącej kultury i zależy od przypadku znak zmiany w przewidywalny sposób, należy użyć <xref:System.Char.ToLowerInvariant%2A> metody. <xref:System.Char.ToLowerInvariant%2A> Metoda jest równoważna `ToLower(Char, CultureInfo.InvariantCulture)`.  
  
 Użyj <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> do przekonwertowania ciągu na małe litery.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia na jego równoważną reprezentację w postaci ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="char.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia na jego równoważną reprezentację w postaci ciągu.</summary>
        <returns>Ciąg reprezentujący wartość tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToString (c As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ToString(char c);" />
      <MemberSignature Language="F#" Value="static member ToString : char -&gt; string" Usage="System.char.ToString c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <summary>Konwertuje określony znak Unicode na jego reprezentację ciągu równoważnego.</summary>
        <returns>Ciąg reprezentujący wartość <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="char.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Parametr zarezerwowany) Obiekt dostarczający informacji o formatowaniu specyficznych dla kultury.</param>
        <summary>Konwertuje wartość tego wystąpienia na jego reprezentację ciągu równoważnego, korzystając z informacji zawartych w określonym formacie specyficzne dla kultury.</summary>
        <returns>Ciąg reprezentujący wartość tego wystąpienia określony przez <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` Parametr jest ignorowany; nie uczestniczy w tej operacji.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje przeciążenia <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość znaku Unicode na odpowiadającą jej wielkie litery.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static char ToUpper (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpper(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpper(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpper(char c);" />
      <MemberSignature Language="F#" Value="static member ToUpper : char -&gt; char" Usage="System.char.ToUpper c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <summary>Konwertuje wartość znaku Unicode na odpowiadającą jej wielkie litery.</summary>
        <returns>Wielkie litery odpowiednikiem <paramref name="c" />, lub bez zmian wartości <paramref name="c" /> Jeśli <paramref name="c" /> już jest wielką literą, zawiera odpowiednika wielkie litery lub alfabetycznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguł stosowania wielkości liter są uzyskiwane z bieżącej kultury.  
  
 Użyj <xref:System.String.ToUpper%2A?displayProperty=nameWithType> do przekonwertowania ciągu na wielkie litery.  
  
   
  
## Examples  
 Poniższy przykład konwertuje każdy znak w tablicy na odpowiadającą jej wielkie litery.  
  
 [!code-csharp[System.Char.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.toupper/cs/toupper1.cs#1)]
 [!code-vb[System.Char.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.toupper/vb/toupper1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Jak wyjaśniono w [najlepsze rozwiązania dotyczące przy użyciu Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod wielkość znaków i wielkości liter ciągu, które podstawiają wartości domyślne. Zamiast tego należy wywołać metody, które wymagają być jawnie określone parametry. Aby dokonać konwersji znaków na wielkie litery, przy użyciu konwencji obudowy bieżącej kultury, należy wywołać <see cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" /> przeciążenie metody z wartością <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> dla jego <paramref name="culture" /> parametru.</para>
        </block>
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static char ToUpper (char c, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpper(char c, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (c As Char, culture As CultureInfo) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpper(char c, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToUpper : char * System.Globalization.CultureInfo -&gt; char" Usage="System.char.ToUpper (c, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <param name="culture">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</param>
        <summary>Konwertuje wartość określonego znaku Unicode równoważnik wielkie litery, przy użyciu określonego informacje o formatowaniu specyficzne dla kultury.</summary>
        <returns>Wielkie litery odpowiednikiem <paramref name="c" />, zmodyfikowane na podstawie położenia <paramref name="culture" />, lub bez zmian wartości <paramref name="c" /> Jeśli <paramref name="c" /> już jest wielką literą, zawiera odpowiednika wielkie litery lub alfabetycznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.String.ToUpper%2A?displayProperty=nameWithType> do przekonwertowania ciągu na wielkie litery.  
  
   
  
## Examples  
 Poniższy przykład konwertuje równoważnik wielkimi literami dla kultury en US, niezmiennej kultury i kultury tr-TR każdego znaku w tablicy. W tym przykładzie wielkie litery odpowiednikiem każdą małą literę jest taka sama dla wszystkich języków, z wyjątkiem jeden przypadek. Małe litery "i" znak (U + 0069) skonwertować "I" (U + 0049) w en US i niezmiennej kultury, ale "İ" (U + 0130) w kulturze tr-TR.  
  
 [!code-csharp[System.Char.ToUpper#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.toupper/cs/toupper5.cs#2)]
 [!code-vb[System.Char.ToUpper#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.toupper/vb/toupper5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public static char ToUpperInvariant (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpperInvariant(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpperInvariant(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpperInvariant (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpperInvariant(char c);" />
      <MemberSignature Language="F#" Value="static member ToUpperInvariant : char -&gt; char" Usage="System.char.ToUpperInvariant c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <summary>Konwertuje wartość znaku Unicode równoważnik wielkie litery, używając reguł stosowania wielkości liter kultury niezmiennej.</summary>
        <returns>Wielkie litery odpowiednikiem <paramref name="c" /> parametr lub wartość niezmienione <paramref name="c" />, jeśli <paramref name="c" /> jest już wielkie litery lub nie alfabetycznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli aplikacja nie jest zależny od bieżącej kultury, zależy od przypadku znak zmiany w przewidywalny sposób użycia <xref:System.Char.ToUpperInvariant%2A> metody.  <xref:System.Char.ToUpperInvariant%2A> Metoda jest równoważna `ToUpper(Char, CultureInfo.InvariantCulture)`.  
  
 Użyj <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> do przekonwertowania ciągu na wielkie litery.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out char result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] char&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.TryParse(System.String,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] char % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.char.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Char&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg, który zawiera pojedynczy znak lub <see langword="null" />.</param>
        <param name="result">Po powrocie z tej metody zawiera znak Unicode, które jest odpowiednikiem znaku wyłącznie w <c>s</c>, jeśli konwersja powiodła się, lub niezdefiniowaną wartość, jeśli konwersja nie powiodła się. Jeśli konwersja nie powiedzie się <c>s</c> parametr jest <see langword="null" /> lub długość <c>s</c> nie jest 1. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje wartość określonego ciągu na jego odpowiadające znaki Unicode. Kod powrotny wskazuje, czy konwersja powiodła się, czy nie powiodło się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="s" /> parametr został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.TryParse%2A> Metoda przypomina <xref:System.Char.Parse%2A> metody, z wyjątkiem <xref:System.Char.TryParse%2A> metoda zgłasza wyjątku, jeśli konwersja nie powiedzie się.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje przeciążenia <xref:System.Char.TryParse%2A> metody dla kilku typów podstawowych, a <xref:System.DateTime.TryParseExact%2A> metodę <xref:System.DateTime> typ podstawowy.  
  
 [!code-cpp[T.TryParse#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.TryParse/CPP/tp.cpp#1)]
 [!code-csharp[T.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.TryParse/CS/tp.cs#1)]
 [!code-vb[T.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.TryParse/VB/tp.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="M:System.Char.ToString" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Char" FullName="System.Char">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="40488152e512beff0c2ef2fb4e14f841dcd11dd7" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33684400" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit char extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;char&gt;, class System.IConvertible, class System.IEquatable`1&lt;char&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Char" />
  <TypeSignature Language="VB.NET" Value="Public Structure Char&#xA;Implements IComparable, IComparable(Of Char), IConvertible, IEquatable(Of Char)" />
  <TypeSignature Language="C++ CLI" Value="public value class Char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Char&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje znak jako jednostka kodu UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Używa <xref:System.Char> struktury do reprezentowania znak Unicode. Unicode Standard identyfikuje każdego znaku Unicode o unikatowy numer skalarne 21-bitowe o nazwie punkt kodu i definiuje formularzu kodowania UTF-16, który określa, jak punkt kodu jest zakodowany w sekwencji jedną lub więcej wartości 16-bitowych. Każda wartość 16-bitowych zakresów z szesnastkowe 0x0000 do 0xFFFF i są przechowywane w <xref:System.Char> struktury.  Wartość <xref:System.Char> obiektu jest jego wartość numeryczną 16-bitowych (numer).  
  
 Poniższe sekcje bada związek między <xref:System.Char> obiekt i znak oraz omówimy niektóre typowe zadania wykonywane z <xref:System.Char> wystąpień.  
  
 [Obiekty char, znaków Unicode i ciągi](#Relationship)   
 [Znaki i kategorie znaków](#Categories)   
 [Znaki i tekstowych elementów](#Elements)   
 [Typowe operacje](#Operations)   
 [Wartości CHAR i międzyoperacyjne](#Interop)  
  
<a name="Relationship"></a>   
## <a name="char-objects-unicode-characters-and-strings"></a>Obiekty char, znaków Unicode i ciągi  
 A <xref:System.String> obiektu jest kolekcją sekwencyjnych <xref:System.Char> struktur, które reprezentuje ciągu tekstowego. Znaki Unicode mogą być reprezentowane przez jeden <xref:System.Char> obiektu, ale znak, który został zakodowany jako znaku podstawowego para zastępcza i/lub łączenie sekwencja znaków jest reprezentowany przez wiele <xref:System.Char> obiektów. Z tego powodu <xref:System.Char> struktury w <xref:System.String> obiekt nie jest odpowiednikiem niekoniecznie pojedynczy znak Unicode.  
  
 Wiele jednostek 16-bitowego kodu są używane do reprezentowania pojedynczy znaki Unicode w następujących przypadkach:  
  
-   Symbole, które mogą składać się z jednego znaku lub znaku podstawowego następuje co najmniej jeden znak łączenie. Na przykład znak ä jest reprezentowany przez a <xref:System.Char> obiektu kod, którego jednostka to U + 0061 następuje a <xref:System.Char> obiektu, którego jednostka kodu jest U + 0308. (Ä znak może być także definiowane przez pojedynczy a <xref:System.Char> obiektu, który ma jednostki kodu a U + 00E4.) Poniższy przykład pokazuje, że znaku ä składa się z dwóch <xref:System.Char> obiektów.  
  
     [!code-csharp[System.Char.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/grapheme1.cs#1)]
     [!code-vb[System.Char.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/grapheme1.vb#1)]  
  
-   Znaki poza płaszczyzny wielojęzyczny Unicode Basic (BMP). Unicode obsługuje szesnastu płaszczyzn oprócz BMP, który reprezentuje płaszczyzny 0. Wartość 21-bitowego, która obejmuje płaszczyzny odpowiada punkt kodu Unicode w UTF-32. Na przykład U + 1D160 reprezentuje znak ÓSEMKA symbolu. Ponieważ kodowania UTF-16 ma tylko 16 bitów, znaki spoza BMP są reprezentowane przez znaki dwuskładnikowe UTF-16. Poniższy przykład przedstawia, to U + D834 U + DD60 odpowiednikiem U + 1D160, znak symbolu ÓSEMKA UTF-32. U + D834 jest znakiem zastępczym wysokiego poziomu; Wysoka surogatów z zakresu od U + D800 za pośrednictwem U + DBFF. U + DD60 jest dwuskładnikowego; niski surogatów z zakresu od U + DC00 za pośrednictwem U + DFFF.  
  
     [!code-csharp[System.Char.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/surrogate1.cs#2)]
     [!code-vb[System.Char.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/surrogate1.vb#2)]  
  
<a name="Categories"></a>   
## <a name="characters-and-character-categories"></a>Znaki i kategorie znaków  
 Każdy znak Unicode, lub para zastępcza prawidłowy należy do kategorii Unicode. W programie .NET Framework, kodowania Unicode z kategorii są reprezentowane przez członków <xref:System.Globalization.UnicodeCategory> wyliczenie i obejmują takie jak wartości <xref:System.Globalization.UnicodeCategory.CurrencySymbol?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType>, i <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType>, na przykład.  
  
 Aby określić kategorię znak Unicode, należy wywołać <xref:System.Char.GetUnicodeCategory%2A> metody. Na przykład poniższy przykład wywołuje <xref:System.Char.GetUnicodeCategory%2A> do wyświetlenia kategorii Unicode każdego znaku w ciągu.  
  
 [!code-csharp[System.Char.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/GetUnicodeCategory3.cs#6)]
 [!code-vb[System.Char.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/GetUnicodeCategory3.vb#6)]  
  
 Wewnętrznie dla znaki spoza zakresu ASCII (U + 0000 za pomocą U + 00FF) <xref:System.Char.GetUnicodeCategory%2A> metoda zależy od kodowania Unicode z kategorii zgłoszone przez <xref:System.Globalization.CharUnicodeInfo> klasy. Począwszy od [!INCLUDE[net_v462](~/includes/net-v462-md.md)], znaków Unicode są klasyfikowane na podstawie [Unicode Standard, wersja 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). W wersjach programu .NET Framework z [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] do [!INCLUDE[net_v461](~/includes/net-v461-md.md)], są klasyfikowane na podstawie [Unicode Standard, wersja 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
<a name="Elements"></a>   
## <a name="characters-and-text-elements"></a>Znaki i tekstowych elementów  
 Ponieważ pojedynczy znak może być reprezentowany przez wiele <xref:System.Char> obiektów, nie zawsze jest przydatne do pracy z poszczególnymi <xref:System.Char> obiektów. Na przykład poniższy przykład konwertuje punktów kodowych Unicode reprezentujących Morza Egejskiego cyfry 0 do 9 jednostek kodu UTF-16 zakodowany. Ponieważ błędnego oznacza <xref:System.Char> obiekty z znaków, niepoprawnie zgłasza, że wynikowy ciąg ma 20 znaków.  
  
 [!code-csharp[System.Char.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/textelements2.cs#3)]
 [!code-vb[System.Char.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/textelements2.vb#3)]  
  
 Można wykonać następujące polecenie, aby uniknąć przy założeniu który <xref:System.Char> obiekt reprezentuje pojedynczy znak.  
  
-   Możesz pracować z <xref:System.String> obiektu w całości, a nie Praca z jego znaki do reprezentowania i analizowania zawartości językowe.  
  
-   Można użyć <xref:System.Globalization.StringInfo> klasy do pracy z elementami tekstu zamiast poszczególnych <xref:System.Char> obiektów. W poniższym przykładzie użyto <xref:System.Globalization.StringInfo> obiekt, aby określić liczbę elementów tekst w ciągu, który składa się z Egejskiego liczby zero do 9. Ponieważ para zastępcza traktuje pojedynczym znakiem, poprawnie raporty czy ciąg zawiera 10 znaków.  
  
     [!code-csharp[System.Char.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/textelements2a.cs#4)]
     [!code-vb[System.Char.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/textelements2a.vb#4)]  
  
-   Jeśli ciąg zawiera znak podstawowy, który ma co najmniej jeden znak łączenie, należy wywołać <xref:System.String.Normalize%2A?displayProperty=nameWithType> metodę, aby przekonwertować podciąg do pojedynczej jednostki zakodowanego kodu UTF-16. Następujące przykładowe wywołania <xref:System.String.Normalize%2A?displayProperty=nameWithType> metodę, aby przekonwertować znak podstawowy U + 0061 (ŁACIŃSKI MAŁA litera A) i znaku U + 0308 (łączenie DIAEREZĄ) do U + 00E4 (ŁACIŃSKI MAŁA litera A z DIAEREZĄ).  
  
     [!code-csharp[System.Char.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/normalized.cs#5)]
     [!code-vb[System.Char.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/normalized.vb#5)]  
  
<a name="Operations"></a>   
## <a name="common-operations"></a>Typowe operacje  
 <xref:System.Char> Struktury udostępnia metody do porównania <xref:System.Char> obiektów, przekonwertować tę wartość bieżącego <xref:System.Char> obiektu do obiektu innego typu i określić kategorię Unicode <xref:System.Char> obiektu:  
  
|Wymagana czynność|Użyj tych `System.Char` metod|  
|----------------|-------------------------------------|  
|Porównaj <xref:System.Char> obiektów|<xref:System.Char.CompareTo%2A> I <xref:System.Char.Equals%2A>|  
|Konwertuj punkt kodu na ciąg|<xref:System.Char.ConvertFromUtf32%2A>|  
|Konwertuj <xref:System.Char> obiektu dysków lub para zastępcza <xref:System.Char> obiekty do punktu kodu|Dla pojedynczego znaku: <xref:System.Convert.ToInt32%28System.Char%29?displayProperty=nameWithType><br /><br /> Para zastępcza lub znak w ciągu: <xref:System.Char.ConvertToUtf32%2A?displayProperty=nameWithType>|  
|Pobierz kategorii Unicode znaku|<xref:System.Char.GetUnicodeCategory%2A>|  
|Określić, czy znak jest w określonej kategorii Unicode, takich jak cyfry, litery, znaki interpunkcyjne, kontrolować znak i tak dalej|<xref:System.Char.IsControl%2A>, <xref:System.Char.IsDigit%2A>, <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLetter%2A>, <xref:System.Char.IsLetterOrDigit%2A>, <xref:System.Char.IsLower%2A>, <xref:System.Char.IsLowSurrogate%2A>, <xref:System.Char.IsNumber%2A>, <xref:System.Char.IsPunctuation%2A>, <xref:System.Char.IsSeparator%2A>, <xref:System.Char.IsSurrogate%2A>, <xref:System.Char.IsSurrogatePair%2A>, <xref:System.Char.IsSymbol%2A>, <xref:System.Char.IsUpper%2A>, i <xref:System.Char.IsWhiteSpace%2A>|  
|Konwertuj <xref:System.Char> obiekt reprezentujący liczbę na typ wartości liczbowe|<xref:System.Char.GetNumericValue%2A>|  
|Konwertuj znaku w ciągu do <xref:System.Char> obiektu|<xref:System.Char.Parse%2A> I <xref:System.Char.TryParse%2A>|  
|Konwertuj <xref:System.Char> do obiektu <xref:System.String> obiektu|<xref:System.Char.ToString%2A>|  
|Zmień wielkość liter <xref:System.Char> obiektu|<xref:System.Char.ToLower%2A>, <xref:System.Char.ToLowerInvariant%2A>, <xref:System.Char.ToUpper%2A>, i <xref:System.Char.ToUpperInvariant%2A>|  
  
<a name="Interop"></a>   
## <a name="char-values-and-interop"></a>Wartości CHAR i międzyoperacyjne  
Gdy zarządzanego <xref:System.Char> typu, który jest reprezentowany jako jednostka kodu Unicode UTF-16 zakodowane, są przekazywane do kodu niezarządzanego, międzyoperacyjnego organizatora konwertuje znak domyślnie ustawiany na ANSI. Można zastosować <xref:System.Runtime.InteropServices.DllImportAttribute> atrybutu dla platformy wywołania deklaracje i <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybutu deklaracji międzyoperacyjnego COM do formantu organizowane zestawu znaków <xref:System.Char> wpisz zastosowań.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje pewnych metod w <xref:System.Char>.  
  
 [!code-cpp[System.Char &#91;Type Level&#93;#23](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char [Type Level]/CPP/charstructure.cpp#23)]
 [!code-csharp[System.Char &#91;Type Level&#93;#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char [Type Level]/CS/charstructure.cs#23)]
 [!code-vb[System.Char &#91;Type Level&#93;#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char [Type Level]/VB/charstructure.vb#23)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie tego typu są bezpieczne wątkowo. Elementy członkowskie, które na pierwszy rzut oka modyfikują stan wystąpienia, w rzeczywistości zwracają nowe wystąpienie zainicjowane z nową wartością. Podobnie jak w przypadku innych typów odczytywanie i zapisywanie w udostępnionej zmiennej, która zawiera wystąpienie tego typu, musi być chronione przez blokadę w celu zagwarantowania bezpieczeństwa wątków.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje to wystąpienie określonego obiektu lub typu wartości i wskazuje, czy to wystąpienie poprzedza, następuje czy pojawia się w tym samym miejscu porządku określonego typu obiektu lub wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.CompareTo(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(char value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Char" /> obiekt do porównania.</param>
        <summary>Porównuje tego wystąpienia określonej <see cref="T:System.Char" /> obiektu i wskazuje, czy to wystąpienie poprzedza, następuje czy pojawia się w tej samej pozycji w porządek sortowania określonych <see cref="T:System.Char" /> obiektu.</summary>
        <returns>Podpisem liczbę wskazującą położenie tego wystąpienia w kolejności sortowania w odniesieniu do <paramref name="value" /> parametru.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Opis elementu  
  
 </description></listheader><item><term> Mniejsza od zera.  
  
 </term><description> To wystąpienie poprzedza <paramref name="value" />.  
  
 </description></item><item><term> Zero  
  
 </term><description> To wystąpienie ma taką samą pozycję w kolejności sortowania jako <paramref name="value" />.  
  
 </description></item><item><term> Większa niż zero  
  
 </term><description> Następuje to wystąpienie <paramref name="value" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje <xref:System.IComparable%601?displayProperty=nameWithType> interfejsu i wykonuje nieco lepsza niż <xref:System.Char.CompareTo%2A?displayProperty=nameWithType> — metoda, ponieważ nie muszą być konwertowane `value` parametru do obiektu.  
  
 Porównanie wykonywane przez tę metodę jest oparta na wartości zakodowanej tego wystąpienia i `value`, nie ich lexicographical właściwości.  
  
 Jeśli <xref:System.Char.CompareTo%2A> typ parametru metody ma mniejszą liczbę bitów (mniejszą niż jest) niż typ wystąpienia niektóre języki programowania wykonać niejawną konwersję rozszerzającą przekształcenia wartości parametru na wartość więcej bitów.  
  
 Na przykład, załóżmy, że typ wystąpienia <xref:System.Int32> i typ parametru jest <xref:System.Byte>. Kompilator języka Microsoft C# generuje instrukcje do reprezentowania wartości parametru jako <xref:System.Int32> obiekt, a następnie generuje <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> metodę, która porównuje wartości <xref:System.Int32> wystąpienia i <xref:System.Int32> parametru reprezentacja wartości.  
  
 Zazwyczaj niejawną konwersję rozszerzającą są wykonywane na typy liczbowe. Dokumentacja języka programowania do ustalenia, czy jego kompilatora pełni poszerzanie konwersji. Jeśli niezgodność typów wystąpień i parametru i odpowiednie konwersja nie jest dostępna, kompilator generuje instrukcje polu parametru i wywoływać <xref:System.Char.CompareTo%2A> przeciążenia, które przyjmuje <xref:System.Object> parametru.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano wersje ogólne i inny niż ogólny `CompareTo` metody dla kilku typów wartości i odwołania.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z tym wystąpieniem, lub <see langword="null" />.</param>
        <summary>Porównuje tego wystąpienia określonego obiektu i wskazuje, czy to wystąpienie poprzedza, następuje czy pojawia się w tej samej pozycji w porządek sortowania określonych <see cref="T:System.Object" />.</summary>
        <returns>Podpisem liczbę wskazującą położenie tego wystąpienia w kolejności sortowania w odniesieniu do <paramref name="value" /> parametru.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Opis elementu  
  
 </description></listheader><item><term> Mniejsza od zera.  
  
 </term><description> To wystąpienie poprzedza <paramref name="value" />.  
  
 </description></item><item><term> Zero  
  
 </term><description> To wystąpienie ma taką samą pozycję w kolejności sortowania jako <paramref name="value" />.  
  
 </description></item><item><term> Większa niż zero  
  
 </term><description> Następuje to wystąpienie <paramref name="value" />.  
  
 —lub—  
  
 <paramref name="value" /> jest <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.CompareTo%2A> Implementuje metody <xref:System.IComparable> interfejsu.  
  
 `value` Parametr musi być `null` lub wystąpienie <xref:System.Char>; w przeciwnym razie jest zwracany wyjątek.  
  
 Porównanie wykonywane przez tę metodę jest oparta na wartości zakodowanej tego wystąpienia i `value`, niekoniecznie ich lexicographical właściwości. Wszystkie wystąpienia <xref:System.Char>, niezależnie od jego wartość jest uznawany za większy niż `null`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.CompareTo%2A>.  
  
 [!code-cpp[System.Char.CompareTo#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.CompareTo/CPP/compareto.cpp#19)]
 [!code-csharp[System.Char.CompareTo#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.CompareTo/CS/compareto.cs#19)]
 [!code-vb[System.Char.CompareTo#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.CompareTo/VB/compareto.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> nie jest <see cref="T:System.Char" /> obiektu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConvertFromUtf32">
      <MemberSignature Language="C#" Value="public static string ConvertFromUtf32 (int utf32);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ConvertFromUtf32(int32 utf32) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertFromUtf32(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertFromUtf32 (utf32 As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ConvertFromUtf32(int utf32);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf32" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="utf32">Punkt kodu Unicode 21-bitowych.</param>
        <summary>Konwertuje określony punkt kodu Unicode na ciąg kodowany w UTF-16.</summary>
        <returns>Ciąg składający się z jednego <see cref="T:System.Char" /> obiektu dysków lub para zastępcza <see cref="T:System.Char" /> obiekty równoważne określony przez punkt kodu <paramref name="utf32" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia przekonwertować na ciąg kodowany UTF-16 punkt kodu Unicode 21-bitowych przed testowaniem ciągu za pomocą metod, takich jak <xref:System.Char.IsLowSurrogate%28System.Char%29> i <xref:System.Char.IsHighSurrogate%28System.Char%29>.  
  
 Prawidłowy punkt kodu poza podstawowe płaszczyzny wielojęzyczne (BMP) zawsze daje para zastępcza prawidłowe. Jednak prawidłowy punkt kodu w ramach BMP nie może dać prawidłowego wyniku zgodnie ze standardem Unicode, ponieważ brak językowe przetwarzania jest używana w konwersji. Z tego powodu, użyj <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> klasy w celu przekonwertowania zbiorcze danych UTF-32 do zbiorczego danych UTF-16.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.ConvertToUtf32%2A> i <xref:System.Char.ConvertFromUtf32%2A> metody.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="utf32" /> jest nie prawidłowy 21-bitowy kod znaku Unicode, począwszy od U + 0 do U + 10FFFF, z wyjątkiem zakresu para zastępcza z U + D800 za pośrednictwem U + DFFF.</exception>
        <altmember cref="M:System.Char.ConvertToUtf32(System.Char,System.Char)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertToUtf32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość para zastępcza UTF-16 zakodowane punkt kodu Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertToUtf32">
      <MemberSignature Language="C#" Value="public static int ConvertToUtf32 (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ConvertToUtf32(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertToUtf32(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToUtf32 (highSurrogate As Char, lowSurrogate As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ConvertToUtf32(char highSurrogate, char lowSurrogate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="highSurrogate">Jednostka kodu zastępczym wysokiego poziomu (to znaczy kodu jednostka od U + D800 za pośrednictwem U + DBFF).</param>
        <param name="lowSurrogate">Jednostka kodu dwuskładnikowego (to znaczy kodu jednostka od U + DC00 za pośrednictwem U + DFFF).</param>
        <summary>Konwertuje wartość para zastępcza UTF-16 zakodowane punkt kodu Unicode.</summary>
        <returns>Punkt kodu Unicode 21-bitowy, reprezentowany przez <paramref name="highSurrogate" /> i <paramref name="lowSurrogate" /> parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby przekonwertować para zastępcza punkt kodu Unicode 21-bitowych. Aby przekonwertować danych UTF-16 UTF-32 danych, należy użyć <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> klasy.  
  
 Zwykle kodowania UTF-16 reprezentuje pojedynczy znak Unicode jako jednostka 16-bitowego kodu. Jednak obsługuje ona również znaki dwuskładnikowe, umożliwiających pojedynczy znak abstrakcyjny może być reprezentowana jako dwie jednostki 16-bitowego kodu. Te dwa <xref:System.Char> obiekty muszą mieć jednostek kodu zakresu z U + D800 do U + DBFF dla pierwszego surogatu (wysoka) i U + DC00 do U + DFFF dla drugiego surogatu (niski). Znaki dwuskładnikowe są obsługiwane tylko przez UTF-16 kodowania. Ta metoda umożliwia znak reprezentowany przez para zastępcza UTF-16 ma zostać przekonwertowane na znak, przy użyciu kodowania UTF-32.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.ConvertToUtf32%2A> i <xref:System.Char.ConvertFromUtf32%2A> metody.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="highSurrogate" /> nie jest w zasięgu U + D800 za pośrednictwem U + DBFF lub <paramref name="lowSurrogate" /> nie znajduje się w zakresie U + DC00 między U + DFFF.</exception>
        <altmember cref="M:System.Char.ConvertFromUtf32(System.Int32)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <Member MemberName="ConvertToUtf32">
      <MemberSignature Language="C#" Value="public static int ConvertToUtf32 (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ConvertToUtf32(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertToUtf32(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToUtf32 (s As String, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ConvertToUtf32(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg, który zawiera pary znaków lub dwuskładnikowego.</param>
        <param name="index">Indeks pary znaków lub zastępczego w <c>s</c>.</param>
        <summary>Konwertuje wartość UTF-16 zakodowane pary znaków lub Surogat na określonej pozycji w ciągu w punkt kodu Unicode.</summary>
        <returns>Punkt kodu Unicode 21-bitowy, reprezentowany przez znak lub Surogat pary w pozycji w <paramref name="s" /> określony przez parametr <paramref name="index" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby przekonwertować pary znaków lub Surogat punkt kodu Unicode 21-bitowych. Aby przekonwertować danych UTF-16 UTF-32 danych, należy użyć <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.ConvertToUtf32%2A> i <xref:System.Char.ConvertFromUtf32%2A> metody.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest w stanie <paramref name="s" />.</exception>
        <exception cref="T:System.ArgumentException">Określony indeks zawiera para zastępcza i pierwszy znak w parze nie jest prawidłowym znakiem zastępczym wysokiego poziomu lub znak pary nie jest prawidłową dwuskładnikowego.</exception>
        <altmember cref="M:System.Char.ConvertFromUtf32(System.Int32)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest taki sam jak określony obiekt lub <see cref="T:System.Char" /> wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (char obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(char obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Equals(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(char obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe określonej <see cref="T:System.Char" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> parametr ma wartość wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje <xref:System.IEquatable%601?displayProperty=nameWithType> interfejsu i wykonuje nieco lepsza niż <xref:System.Char.Equals%28System.Object%29?displayProperty=nameWithType> , ponieważ nie trzeba unbox — `obj` parametru.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z tym wystąpieniem lub <see langword="null" />.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> jest wystąpieniem <see cref="T:System.Char" /> i wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównanie wykonywane przez tę metodę jest oparta na wartości zakodowanej tego wystąpienia i `obj`, niekoniecznie ich lexicographical właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.Equals%2A>.  
  
 [!code-cpp[System.Char.Equals#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.Equals/CPP/equals.cpp#20)]
 [!code-csharp[System.Char.Equals#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.Equals/CS/equals.cs#20)]
 [!code-vb[System.Char.Equals#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.Equals/VB/equals.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNumericValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określony znak Unicode liczbowych liczbie zmiennoprzecinkowej podwójnej precyzji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetNumericValue(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (c As Char) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <summary>Konwertuje określony znak Unicode liczbowych podwójnej precyzji liczba zmiennoprzecinkowa.</summary>
        <returns>Wartość numeryczna <paramref name="c" /> Jeśli ten znak reprezentuje liczbę; w przeciwnym razie -1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `c` Parametr musi być <xref:System.Char> reprezentację liczbową wartości. Na przykład jeśli `c` "5", jest zwracana wartość 5. Jednak jeśli `c` "z", jest zwracana wartość jest -1,0.  
  
 Znak ma skojarzoną wartość liczbową tylko wtedy, gdy jest on członkiem jednej z następujących <xref:System.Globalization.UnicodeCategory> kategorii: `DecimalDigitNumber`, `LetterNumber`, lub `OtherNumber`.  
  
 <xref:System.Char.GetNumericValue%2A> Metody, przy założeniu, że `c` odpowiada pojedynczy znak językowe i sprawdza, czy ten znak może być konwertowane na dziesiętną wartością cyfrową. Jednak niektóre numery w standardzie Unicode są reprezentowane przez dwa <xref:System.Char> obiektów, które tworzą para zastępcza. Na przykład system numeracji Morza Egejskiego składa się z kodów znaku U+10107 do U+10133. W poniższym przykładzie użyto <xref:System.Char.ConvertFromUtf32%2A> metody tworzenia wystąpienia ciąg reprezentujący Morza EGEJSKIEGO liczby jeden. Jako dane wyjściowe w przykładzie pokazano <xref:System.Char.GetNumericValue%28System.Char%29> metoda zwraca wartość -1, jeśli został przekazany zastępczym wysokiego poziomu lub dwuskładnikowego tego znaku.  
  
 [!code-csharp[System.Char.GetNumericValue#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue1.cs#2)]
 [!code-vb[System.Char.GetNumericValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue1.vb#2)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.GetNumericValue%2A>.  
  
 [!code-cpp[System.Char.GetNumericValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CPP/getnumericvalue.cpp#1)]
 [!code-csharp[System.Char.GetNumericValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue.cs#1)]
 [!code-vb[System.Char.GetNumericValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetNumericValue(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (s As String, index As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A <see cref="T:System.String" />.</param>
        <param name="index">Pozycja znaku w <c>s</c>.</param>
        <summary>Konwertuje znaku numerycznego Unicode w określonej pozycji w ciągu określonej podwójnej precyzji liczba zmiennoprzecinkowa.</summary>
        <returns>Wartość numeryczna znak na pozycji <paramref name="index" /> w <paramref name="s" /> Jeśli ten znak reprezentuje liczbę; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `s` Parametr musi być reprezentację ciągu wartość liczbową. Na przykład jeśli znak na pozycji `index` w `s` "5", jest zwracana wartość 5. Jednak jeśli znak na pozycji `index` w `s` jest "z", wartość zwracana jest wartość -1.  
  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Znak ma skojarzoną wartość liczbową tylko wtedy, gdy jest on członkiem jednej z następujących <xref:System.Globalization.UnicodeCategory> kategorii: `DecimalDigitNumber`, `LetterNumber`, lub `OtherNumber`.  
  
 Jeśli <xref:System.Char> obiektu na pozycji `index` to pierwszy znak para zastępcza prawidłową <xref:System.Char.GetNumericValue%28System.String%2CSystem.Int32%29> Metoda określa, czy para zastępcza formularzy cyfrę. Na przykład system numeracji Morza Egejskiego składa się z kodów znaku U+10107 do U+10133. W poniższym przykładzie użyto <xref:System.Char.ConvertFromUtf32%2A> metody tworzenia wystąpienia ciąg reprezentujący każdą liczbę Morza Egejskiego. Jako dane wyjściowe w przykładzie pokazano <xref:System.Char.GetNumericValue%28System.String%2CSystem.Int32%29> , jeśli został przekazany liczby Morza Egejskiego znakiem zastępczym wysokiego poziomu, metoda zwraca prawidłową wartość liczbową. Jednak jeśli dwuskładnikowego został przekazany, traktuje dwuskładnikowego tylko izolacji i zwraca wartość -1.  
  
 [!code-csharp[System.Char.GetNumericValue#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue1.cs#3)]
 [!code-vb[System.Char.GetNumericValue#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue1.vb#3)]  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.GetNumericValue%2A>.  
  
 [!code-cpp[System.Char.GetNumericValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CPP/getnumericvalue.cpp#1)]
 [!code-csharp[System.Char.GetNumericValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue.cs#1)]
 [!code-vb[System.Char.GetNumericValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.TypeCode" /> dla typu wartości <see cref="T:System.Char" />.</summary>
        <returns>Stała wyliczeniowa <see cref="F:System.TypeCode.Char" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetUnicodeCategory">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kategoryzuje znaku Unicode w grupie identyfikowane za pomocą jednej z <see cref="T:System.Globalization.UnicodeCategory" /> wartości.</summary>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetUnicodeCategory(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (c As Char) As UnicodeCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do przeprowadzania kategoryzacji.</param>
        <summary>Kategoryzuje określony znak Unicode w grupie identyfikowane za pomocą jednej z <see cref="T:System.Globalization.UnicodeCategory" /> wartości.</summary>
        <returns>A <see cref="T:System.Globalization.UnicodeCategory" /> wartość, która identyfikuje grupę, która zawiera <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> Metoda nie zawsze zwraca takie same <xref:System.Globalization.UnicodeCategory> wartość jako <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> metody określonego znaku przekazywana jako parametr. <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> Metodę zaprojektowano w celu odzwierciedlenia bieżącej wersji Unicode standard. Z kolei mimo że <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> metoda zazwyczaj odzwierciedla bieżącą wersję Unicode standard, może zwrócić kategorii znaków na podstawie poprzedniej wersji standard lub może zwrócić kategorię, która różni się od bieżącej standard w kolejności w celu zachowania zgodności z poprzednimi wersjami. W związku z tym zaleca się używanie <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> zamiast metody <xref:System.Char.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType>.  
  
 Począwszy od [!INCLUDE[net_v462](~/includes/net-v462-md.md)], znaków Unicode są klasyfikowane na podstawie [standardowe Unix, wersja 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). W wersjach programu .NET Framework z [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] do [!INCLUDE[net_v461](~/includes/net-v461-md.md)], są klasyfikowane na podstawie [standardowe Unix, wersja 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.GetUnicodeCategory%2A>.  
  
 [!code-cpp[System.Char.GetUnicodeCategory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CPP/getunicodecategory.cpp#1)]
 [!code-csharp[System.Char.GetUnicodeCategory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CS/getunicodecategory.cs#1)]
 [!code-vb[System.Char.GetUnicodeCategory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/VB/getunicodecategory.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetUnicodeCategory(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (s As String, index As Integer) As UnicodeCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A <see cref="T:System.String" />.</param>
        <param name="index">Pozycja znaku w <c>s</c>.</param>
        <summary>Kategoryzuje znak na określonej pozycji w ciągu określonej w grupie identyfikowane za pomocą jednej z <see cref="T:System.Globalization.UnicodeCategory" /> wartości.</summary>
        <returns>A <see cref="T:System.Globalization.UnicodeCategory" /> wyliczany stałą, której identyfikuje grupę, która zawiera znak na pozycji <paramref name="index" /> w <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> Metoda nie zawsze zwraca takie same <xref:System.Globalization.UnicodeCategory> wartość jako <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> metody określonego znaku przekazywana jako parametr. <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> Metodę zaprojektowano w celu odzwierciedlenia bieżącej wersji Unicode standard. Z kolei mimo że <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> metoda zazwyczaj odzwierciedla bieżącą wersję Unicode standard, może zwrócić kategorii znaków na podstawie poprzedniej wersji standard lub może zwrócić kategorię, która różni się od bieżącej standard w kolejności w celu zachowania zgodności z poprzednimi wersjami. W związku z tym zaleca się używanie <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> zamiast metody <xref:System.Char.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>.  
  
 Począwszy od [!INCLUDE[net_v462](~/includes/net-v462-md.md)], znaków Unicode są klasyfikowane na podstawie [standardowe Unix, wersja 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). W wersjach programu .NET Framework z [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] do [!INCLUDE[net_v461](~/includes/net-v461-md.md)], są klasyfikowane na podstawie [standardowe Unix, wersja 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.GetUnicodeCategory%2A>.  
  
 [!code-cpp[System.Char.GetUnicodeCategory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CPP/getunicodecategory.cpp#1)]
 [!code-csharp[System.Char.GetUnicodeCategory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CS/getunicodecategory.cs#1)]
 [!code-vb[System.Char.GetUnicodeCategory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/VB/getunicodecategory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w <paramref name="s" />.</exception>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsControl">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy określony znak Unicode jest skategoryzowany jako znak kontrolny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki kontrolne są formatowanie i inne niedrukowalne znaki, takie jak potwierdzenia, ETYKIETĘ CR, FF, LF i VT. Standardu Unicode przypisuje punktów kodowych z \U0000 do \U001F, \U007F i \U0080 do \U009F do znaków kontrolnych. Zgodnie ze standardem Unicode te wartości są interpretowane jako znaki kontrolne, chyba że ich użycia w przeciwnym razie jest zdefiniowane przez aplikację. Znaki kontrolne prawidłowe są członkami <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> kategorii.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsControl(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest skategoryzowany jako znak kontrolny.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest formantem znaku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki kontrolne są formatowanie i inne niedrukowalne znaki, takie jak potwierdzenia, ETYKIETĘ CR, FF, LF i VT. Standardu Unicode T przypisuje punktów kodowych z \U0000 do \U001F, \U007F i \U0080 do \U009F do znaków kontrolnych. Zgodnie ze standardem Unicode te wartości są interpretowane jako znaki kontrolne, chyba że ich użycia w przeciwnym razie jest zdefiniowane przez aplikację. Znaki kontrolne prawidłowe są członkami <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> kategorii.  
  
   
  
## Examples  
 Poniższy przykład zawiera punkt kodu Unicode każdego znaków kontrolnych.  
  
 [!code-cpp[System.Char.IsControl#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsControl/CPP/iscontrol1.cpp#1)]
 [!code-csharp[System.Char.IsControl#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsControl/CS/IsControl1.cs#1)]
 [!code-vb[System.Char.IsControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsControl/VB/IsControl1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsControl(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku w celu oceny w <c>s</c>.</param>
        <summary>Wskazuje, czy znak na określonej pozycji w ciągu określonej jest skategoryzowany jako znak kontrolny.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest formantem znaku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Znaki kontrolne są formatowanie i inne niedrukowalne znaki, takie jak potwierdzenia, ETYKIETĘ CR, FF, LF i VT. Standardu Unicode przypisuje punktów kodowych z \U0000 do \U001F, \U007F i \U0080 do \U009F do znaków kontrolnych. Zgodnie ze standardem Unicode te wartości są interpretowane jako znaki kontrolne, chyba że ich użycia w przeciwnym razie jest zdefiniowane przez aplikację. Znaki kontrolne prawidłowe są członkami <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> kategorii.  
  
   
  
## Examples  
 W poniższym przykładzie wylicza znaków w ciągu i określa, czy są znaki kontrolne.  
  
 [!code-cpp[System.Char.IsControl#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsControl/CPP/iscontrol2.cpp#2)]
 [!code-csharp[System.Char.IsControl#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsControl/CS/IsControl2.cs#2)]
 [!code-vb[System.Char.IsControl#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsControl/VB/IsControl2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsDigit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest skategoryzowany jako dziesiętną wartością cyfrową.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowych cyfr są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> kategorii.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest skategoryzowany jako dziesiętną wartością cyfrową.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest dziesiętną wartością cyfrową; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Char> jest cyfrą podstawa 10. To zachowanie różni się od <xref:System.Char.IsNumber%2A>, który określa, czy `Char` żadnych liczbowych kategorii Unicode. Numery zawierają znaki, takie jak ułamków, indeksy dolne indeksów górnych, łacińskich cyfry, łącznik waluty, numery otoczony i cyfr specyficzne dla skryptu.  
  
 Prawidłowych cyfr są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> kategorii.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsDigit%2A>.  
  
 [!code-cpp[System.Char.IsDigit#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsDigit/CPP/isdigit.cpp#4)]
 [!code-csharp[System.Char.IsDigit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsDigit/CS/isdigit.cs#4)]
 [!code-vb[System.Char.IsDigit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsDigit/VB/isdigit.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsNumber(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsDigit(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku w celu oceny w <c>s</c>.</param>
        <summary>Wskazuje, czy znak na określonej pozycji w ciągu określonej kategorii jest dziesiętną wartością cyfrową.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest dziesiętną wartością cyfrową; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Char> jest cyfrą podstawa 10. To zachowanie różni się od <xref:System.Char.IsNumber%2A>, który określa, czy <xref:System.Char> żadnych liczbowych kategorii Unicode. Numery zawierają znaki, takie jak ułamków, indeksy dolne indeksów górnych, łacińskich cyfry, łącznik waluty, numery otoczony i cyfr specyficzne dla skryptu.  
  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Prawidłowych cyfr są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> kategorii.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsDigit%2A>.  
  
 [!code-cpp[System.Char.IsDigit#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsDigit/CPP/isdigit.cpp#4)]
 [!code-csharp[System.Char.IsDigit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsDigit/CS/isdigit.cs#4)]
 [!code-vb[System.Char.IsDigit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsDigit/VB/isdigit.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsNumber(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsHighSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy określony <see cref="T:System.Char" /> obiekt jest zastępczym wysokiego poziomu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsHighSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsHighSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHighSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsHighSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHighSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHighSurrogate(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony <see cref="T:System.Char" /> obiekt jest zastępczym wysokiego poziomu.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość liczbową <paramref name="c" /> parametru może się wahać od U + D800 za pośrednictwem U + DBFF; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oprócz reprezentowania pojedynczych znaków przy użyciu 16-bitowego kodu znaku, kodowanie UTF-16 pozwala na przedstawianie znaków abstrakcyjnych za pomocą dwóch 16-bitowych kodów znaku, znanych jako para zastępcza. Pierwszy element w tej pary jest znakiem zastępczym wysokiego poziomu. Punktu kodu może należeć do zakresu od U + D800 do U + DBFF. Indywidualny znak zastępczy ma nie interpretacji własnych; jest istotny tylko wtedy, gdy jest używany jako część pary zastępczej.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, i <xref:System.Char.IsSurrogatePair%2A> metody.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHighSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsHighSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHighSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsHighSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHighSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHighSurrogate(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku w celu oceny w <c>s</c>.</param>
        <summary>Wskazuje, czy <see cref="T:System.Char" /> obiekt na określonej pozycji w ciągu jest znakiem zastępczym wysokiego poziomu.</summary>
        <returns>
          <see langword="true" /> Jeśli określony znak w wartość liczbową <paramref name="s" /> parametru może się wahać od U + D800 za pośrednictwem U + DBFF; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` Parametr jest liczony od zera.  
  
 Oprócz reprezentowania pojedynczych znaków przy użyciu 16-bitowego kodu znaku, kodowanie UTF-16 pozwala na przedstawianie znaków abstrakcyjnych za pomocą dwóch 16-bitowych kodów znaku, znanych jako para zastępcza. Pierwszy element w tej pary jest znakiem zastępczym wysokiego poziomu. Punktu kodu może należeć do zakresu od U + D800 do U + DBFF. Indywidualny znak zastępczy ma nie interpretacji własnych; jest istotny tylko wtedy, gdy jest używany jako część pary zastępczej.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, i <xref:System.Char.IsSurrogatePair%2A> metody.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest w stanie <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLetter">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest skategoryzowany jako list Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Char> jest członkiem żadnych kategorii litery Unicode. Litery Unicode są następujące:  
  
-   Wielkie litery, np. U + 0041 (ŁACIŃSKI litera A) za pośrednictwem U + 005A (ŁACIŃSKI litera Z) lub U + 0400 (CYRYLICY litera programu Internet Explorer z DIAKRYTYCZNY) za pośrednictwem U + 042F (CYRYLICY litera YA). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Małe litery, np. U + 0061 (A MAŁA litera ŁACIŃSKA) za pośrednictwem U + 007A (ŁACIŃSKI małe litery Z), lub U + 03AC (GRECKIEGO MAŁA litera ALFA z AKCENTEM) za pośrednictwem U + 03CE (GRECKIEGO MAŁA litera OMEGA z AKCENTEM). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Tytuł wielkość liter, np. U + 01 C 5 (ŁACIŃSKI litera D z małej litery Z z CARON) lub U + 1FFC (GRECKIEGO litera OMEGA z PROSGEGRAMMENI). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Modyfikatory, np. U + 02B0 (H MAŁA litera MODYFIKATOR) za pośrednictwem 02C U + 1 (MODYFIKATOR litery ODWRÓCONE GLOTTAL STOP), lub U + 1D2C (A kapitału litera MODYFIKATORA) za pośrednictwem U + 1 d 61 (MODYFIKATOR CHI małe litery). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> kategorii.  
  
-   Inne litery, np. U + 05 D 0 (HEBRAJSKI litery ALEF) za pośrednictwem U + 05EA (HEBRAJSKI TAV litery), U + 0621 (ARABIC litery HAMZA) za pośrednictwem U + 063A (ARABIC GHAIN litery), lub U + 4E00 (\<ideogramów CJK, pierwsza >) za pośrednictwem U + 9 FC 3 (\<ideogramów CJK, ostatnie >). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> kategorii.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest skategoryzowany jako list Unicode.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest literą; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Char> jest członkiem żadnych kategorii litery Unicode. Litery Unicode są następujące:  
  
-   Wielkie litery, np. U + 0041 (ŁACIŃSKI litera A) za pośrednictwem U + 005A (ŁACIŃSKI litera Z) lub U + 0400 (CYRYLICY litera programu Internet Explorer z DIAKRYTYCZNY) za pośrednictwem U + 042F (CYRYLICY litera YA). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Małe litery, np. U + 0061 (A MAŁA litera ŁACIŃSKA) za pośrednictwem U + 007A (ŁACIŃSKI małe litery Z), lub U + 03AC (GRECKIEGO MAŁA litera ALFA z AKCENTEM) za pośrednictwem U + 03CE (GRECKIEGO MAŁA litera OMEGA z AKCENTEM). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Tytuł wielkość liter, np. U + 01 C 5 (ŁACIŃSKI litera D z małej litery Z z CARON) lub U + 1FFC (GRECKIEGO litera OMEGA z PROSGEGRAMMENI). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Modyfikatory, np. U + 02B0 (H MAŁA litera MODYFIKATOR) za pośrednictwem 02C U + 1 (MODYFIKATOR litery ODWRÓCONE GLOTTAL STOP), lub U + 1D2C (A kapitału litera MODYFIKATORA) za pośrednictwem U + 1 d 61 (MODYFIKATOR CHI małe litery). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> kategorii.  
  
-   Inne litery, np. U + 05 D 0 (HEBRAJSKI litery ALEF) za pośrednictwem U + 05EA (HEBRAJSKI TAV litery), U + 0621 (ARABIC litery HAMZA) za pośrednictwem U + 063A (ARABIC GHAIN litery), lub U + 4E00 (\<ideogramów CJK, pierwsza >) za pośrednictwem U + 9 FC 3 (\<ideogramów CJK, ostatnie >). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> kategorii.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsLetter%2A>.  
  
 [!code-cpp[System.Char.IsLetter#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetter/CPP/isletter.cpp#5)]
 [!code-csharp[System.Char.IsLetter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetter/CS/isletter.cs#5)]
 [!code-vb[System.Char.IsLetter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetter/VB/isletter.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetter(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku w celu oceny w <c>s</c>.</param>
        <summary>Wskazuje, czy znak na określonej pozycji w ciągu określonej jest skategoryzowany jako list Unicode.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest literą; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Ta metoda określa, czy znak na pozycji indeksu określonego w ciągu jest członkiem żadnych kategorii litery Unicode. Litery Unicode są następujące:  
  
-   Wielkie litery, np. U + 0041 (ŁACIŃSKI litera A) za pośrednictwem U + 005A (ŁACIŃSKI litera Z) lub U + 0400 (CYRYLICY litera programu Internet Explorer z DIAKRYTYCZNY) za pośrednictwem U + 042F (CYRYLICY litera YA). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Małe litery, np. U + 0061 (A MAŁA litera ŁACIŃSKA) za pośrednictwem U + 007A (ŁACIŃSKI małe litery Z), lub U + 03AC (GRECKIEGO MAŁA litera ALFA z AKCENTEM) za pośrednictwem U + 03CE (GRECKIEGO MAŁA litera OMEGA z AKCENTEM). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Tytuł wielkość liter, np. U + 01 C 5 (ŁACIŃSKI litera D z małej litery Z z CARON) lub U + 1FFC (GRECKIEGO litera OMEGA z PROSGEGRAMMENI). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> kategorii.  
  
-   Modyfikatory, np. U + 02B0 (H MAŁA litera MODYFIKATOR) za pośrednictwem 02C U + 1 (MODYFIKATOR litery ODWRÓCONE GLOTTAL STOP), lub U + 1D2C (A kapitału litera MODYFIKATORA) za pośrednictwem U + 1 d 61 (MODYFIKATOR CHI małe litery). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> kategorii.  
  
-   Inne litery, np. U + 05 D 0 (HEBRAJSKI litery ALEF) za pośrednictwem U + 05EA (HEBRAJSKI TAV litery), U + 0621 (ARABIC litery HAMZA) za pośrednictwem U + 063A (ARABIC GHAIN litery), lub U + 4E00 (\<ideogramów CJK, pierwsza >) za pośrednictwem U + 9 FC 3 (\<ideogramów CJK, ostatnie >). Następujące znaki są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> kategorii.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsLetter%2A>.  
  
 [!code-cpp[System.Char.IsLetter#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetter/CPP/isletter.cpp#5)]
 [!code-csharp[System.Char.IsLetter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetter/CS/isletter.cs#5)]
 [!code-vb[System.Char.IsLetter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetter/VB/isletter.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLetterOrDigit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest skategoryzowany jako literą lub dziesiętną wartością cyfrową.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe litery i cyfry dziesiętne są członkami następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, lub `DecimalDigitNumber`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetterOrDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest skategoryzowany jako literą lub dziesiętną wartością cyfrową.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest literą lub dziesiętną wartością cyfrową; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe litery i cyfry dziesiętne są członkami następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, lub `DecimalDigitNumber`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsLetterOrDigit%2A>.  
  
 [!code-cpp[System.Char.IsLetterOrDigit#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CPP/isletterordigit.cpp#6)]
 [!code-csharp[System.Char.IsLetterOrDigit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CS/isletterordigit.cs#6)]
 [!code-vb[System.Char.IsLetterOrDigit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/VB/isletterordigit.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetterOrDigit(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku w celu oceny w <c>s</c>.</param>
        <summary>Wskazuje, czy znak na określonej pozycji w ciągu określonej jest skategoryzowany jako literą lub dziesiętną wartością cyfrową.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest literą lub dziesiętną wartością cyfrową; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Prawidłowe litery i cyfry dziesiętne są członkami następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, lub `DecimalDigitNumber`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsLetterOrDigit%2A>.  
  
 [!code-cpp[System.Char.IsLetterOrDigit#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CPP/isletterordigit.cpp#6)]
 [!code-csharp[System.Char.IsLetterOrDigit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CS/isletterordigit.cs#6)]
 [!code-vb[System.Char.IsLetterOrDigit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/VB/isletterordigit.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest skategoryzowany jako się małą literą.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLower(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest skategoryzowany jako się małą literą.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest małą literę; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nieprawidłowa małe litery należą do następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `LowercaseLetter`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsLower%2A>.  
  
 [!code-cpp[System.Char.IsLower#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLower/CPP/islower.cpp#7)]
 [!code-csharp[System.Char.IsLower#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLower/CS/islower.cs#7)]
 [!code-vb[System.Char.IsLower#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLower/VB/islower.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsUpper(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLower(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku w celu oceny w <c>s</c>.</param>
        <summary>Wskazuje, czy znak na określonej pozycji w ciągu określonej jest skategoryzowany jako się małą literą.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest małą literę; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Nieprawidłowa małe litery należą do następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `LowercaseLetter`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsLower%2A>.  
  
 [!code-cpp[System.Char.IsLower#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLower/CPP/islower.cpp#7)]
 [!code-csharp[System.Char.IsLower#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLower/CS/islower.cs#7)]
 [!code-vb[System.Char.IsLower#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLower/VB/islower.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Char.IsUpper(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLowSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy określony <see cref="T:System.Char" /> obiekt jest dwuskładnikowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLowSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsLowSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLowSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLowSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLowSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLowSurrogate(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak do oceny.</param>
        <summary>Wskazuje, czy określony <see cref="T:System.Char" /> obiekt jest dwuskładnikowego.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość liczbową <paramref name="c" /> parametru może się wahać od U + DC00 za pośrednictwem U + DFFF; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oprócz reprezentowania pojedynczych znaków przy użyciu 16-bitowego kodu znaku, kodowanie UTF-16 pozwala na przedstawianie znaków abstrakcyjnych za pomocą dwóch 16-bitowych kodów znaku, znanych jako para zastępcza. Drugi element w tej pary jest dwuskładnikowego. Punktu kodu może należeć do zakresu od U + DC00 do U + DFFF. Indywidualny znak zastępczy ma nie interpretacji własnych; jest istotny tylko wtedy, gdy jest używany jako część pary zastępczej.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, i <xref:System.Char.IsSurrogatePair%2A> metody.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLowSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsLowSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLowSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLowSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLowSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLowSurrogate(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku w celu oceny w <c>s</c>.</param>
        <summary>Wskazuje, czy <see cref="T:System.Char" /> obiekt na określonej pozycji w ciągu jest dwuskładnikowego.</summary>
        <returns>
          <see langword="true" /> Jeśli określony znak w wartość liczbową <paramref name="s" /> parametru może się wahać od U + DC00 za pośrednictwem U + DFFF; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` Parametr jest liczony od zera.  
  
 Oprócz reprezentowania pojedynczych znaków przy użyciu 16-bitowego kodu znaku, kodowanie UTF-16 pozwala na przedstawianie znaków abstrakcyjnych za pomocą dwóch 16-bitowych kodów znaku, znanych jako para zastępcza. Drugi element w tej pary jest dwuskładnikowego. Punktu kodu może należeć do zakresu od U + DC00 do U + DFFF. Indywidualny znak zastępczy ma nie interpretacji własnych; jest istotny tylko wtedy, gdy jest używany jako część pary zastępczej.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, i <xref:System.Char.IsSurrogatePair%2A> metody.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest w stanie <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNumber">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest skategoryzowany jako liczby.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsNumber(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest skategoryzowany jako liczby.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest liczbą; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Char> żadnych liczbowych kategorii Unicode. Poza tym cyfr, liczby to między innymi znaków, ułamków indeksy dolne, indeksów górnych, łacińskich cyfry, łącznik waluty i otoczony cyfry. Ta metoda różni się znacząco od <xref:System.Char.IsDigit%2A> metodę, która określa, czy <xref:System.Char> jest cyfrą podstawa 10.  
  
> [!IMPORTANT]
>  <xref:System.Char.IsNumber%28System.Char%29> — Metoda nie jest przeznaczona do określenia, czy ciąg składa się z cyfr (na przykład, wywołując metodę dla każdego znaku w ciągu). Aby ustalić, czy ciąg składa się z cyfr, wywoływanie jednego z przeciążeń `TryParse` — metoda (takich jak <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> lub <xref:System.Double.TryParse%2A?displayProperty=nameWithType> typu całkowitą lub zmiennoprzecinkową.  
  
 Prawidłowe numery są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LetterNumber?displayProperty=nameWithType>, lub <xref:System.Globalization.UnicodeCategory.OtherNumber?displayProperty=nameWithType> kategorii.  
  
 <xref:System.Char.IsNumber%28System.Char%29> Metody, przy założeniu, że `c` odpowiada pojedynczy znak językowe i sprawdza, czy ten znak reprezentuje liczbę. Jednak niektóre numery w standardzie Unicode są reprezentowane przez dwa <xref:System.Char> obiektów, które tworzą para zastępcza. Na przykład system numeracji Morza Egejskiego składa się z kodów znaku U+10107 do U+10133. W poniższym przykładzie użyto <xref:System.Char.ConvertFromUtf32%2A> metody tworzenia wystąpienia ciąg reprezentujący Morza EGEJSKIEGO liczby jeden. Jako dane wyjściowe w przykładzie pokazano <xref:System.Char.IsNumber%28System.Char%29> metoda zwraca `false` Jeśli przekazaniem zastępczym wysokiego poziomu lub dwuskładnikowego tego znaku.  
  
 [!code-csharp[System.Char.IsNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber1.cs#1)]
 [!code-vb[System.Char.IsNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber1.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.IsNumber%2A>.  
  
 [!code-cpp[System.Char.IsNumber#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsNumber/CPP/isnumber.cpp#8)]
 [!code-csharp[System.Char.IsNumber#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber.cs#8)]
 [!code-vb[System.Char.IsNumber#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsDigit(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsNumber(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku w celu oceny w <c>s</c>.</param>
        <summary>Wskazuje, czy znak na określonej pozycji w ciągu określonej jest skategoryzowany jako liczby.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest liczbą; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Char> żadnych liczbowych kategorii Unicode. Poza tym cyfr, liczby to między innymi znaków, ułamków indeksy dolne, indeksów górnych, łacińskich cyfry, łącznik waluty i otoczony cyfry. Ta metoda różni się znacząco od <xref:System.Char.IsDigit%2A> metodę, która określa, czy <xref:System.Char> jest cyfrą podstawa 10.  
  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
> [!IMPORTANT]
>  <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> — Metoda nie jest przeznaczona do określenia, czy ciąg składa się z cyfr (na przykład, wywołując metodę dla każdego znaku w ciągu). Aby ustalić, czy ciąg składa się z cyfr, wywoływanie jednego z przeciążeń `TryParse` — metoda (takich jak <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> lub <xref:System.Double.TryParse%2A?displayProperty=nameWithType> typu całkowitą lub zmiennoprzecinkową.  
  
 Prawidłowe numery są elementami członkowskimi <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LetterNumber?displayProperty=nameWithType>, lub <xref:System.Globalization.UnicodeCategory.OtherNumber?displayProperty=nameWithType> kategorii.  
  
 Jeśli <xref:System.Char> obiektu na pozycji `index` to pierwszy znak para zastępcza prawidłową <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> Metoda określa, czy para zastępcza formularzy cyfrę. Na przykład system numeracji Morza Egejskiego składa się z kodów znaku U+10107 do U+10133. W poniższym przykładzie użyto <xref:System.Char.ConvertFromUtf32%2A> metody tworzenia wystąpienia ciąg reprezentujący Morza EGEJSKIEGO liczby jeden. Jako dane wyjściowe w przykładzie pokazano <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> metoda zwraca `true` , jeśli został przekazany znakiem zastępczym wysokiego poziomu o Morza EGEJSKIEGO liczby jeden. Jednak jeśli dwuskładnikowego został przekazany, uwzględnia tylko kategorii dwuskładnikowego i zwraca `false`.  
  
 [!code-csharp[System.Char.IsNumber#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber1.cs#2)]
 [!code-vb[System.Char.IsNumber#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber1.vb#2)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.IsNumber%2A>.  
  
 [!code-cpp[System.Char.IsNumber#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsNumber/CPP/isnumber.cpp#8)]
 [!code-csharp[System.Char.IsNumber#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber.cs#8)]
 [!code-vb[System.Char.IsNumber#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Char.IsDigit(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPunctuation">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest skategoryzowany jako znak interpunkcyjny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe znaki interpunkcyjne są członkami następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, lub `OtherPunctuation`. Obejmują one znaków punktów kodowych Unicode, które są wymienione w poniższej tabeli.  
  
|||||  
|-|-|-|-|  
|U + 0021 do U + 0023|U + 060C i U + 060D|U + 1800 do U + 180A|3014 U + do U + 301F|  
|U + 0025 do U + 002A|U+061B|U + 1944 i U + 1945|U+3030|  
|U + 002C, aby U + 002F|U + 061E i U + 061F|U + 19DE i U + 19DF|U+303D|  
|U + 003a Notebook i U + 003B|066A U + U + 066 d|U + 1A1E i U + 1A1F|U+30A0|  
|U + 003F i U + 0040|U+06D4|U + 1B5A do U + 1B60|U+30FB|  
|005B U + U + 005 d|0700 U + U + 070 d|U + 2010 2027 U +|U + A874 do U + A877|  
|U+005F|U + 07F7 do U + 07F9|U + 2030 do U + 2043|U + FD3E i U + FD3F|  
|U+007B|U + 0964 i U + 0965|U + 2045 do U + 2051|U + FE10 do U + FE19|  
|U+007D|U+0970|2053 U + do U + 205E|U + FE30 do U + FE52|  
|U+00A1|U+0DF4|U + 207D i U + 207E|U + FE54 do U + FE61|  
|U+00AB|U + 0E4F do U + 0E5B|U + 208D i U + 208E|U+FE63|  
|U+00AD|U + 0F04 do U + 0F12|U + 2329 i U + 232A|U+FE68|  
|U+00B7|U + 0F3A do U + 0F3D|U + 2768 do U + 2775|U + FE6A i U + FE6B|  
|U+00BB|U+0F85|27 c 5 U + U + 6 27 c|U + FF01 do U + FF03|  
|U+00BF|U + 0FD0 i U + 0FD1|U + 27E6 do U + 27EB|U + FF05 do U + FF0A|  
|U+037E|104 a U + – U + 104F|U + 2983 do U + 2998|U + FF0C do U + FF0F|  
|U+0387|U+10FB|U + 29D 8 U + 29DB|U + FF1A i U + FF1B|  
|U + 055A do U + 055F|U + 1361 do U + 1368|U + 29FC i U + 29FD|U + FF1F i U + FF20|  
|U + 0589 i U + 058A|U + 166D i U + 166E|U + 2CF9 do U + 2CFC|U + FF3B do U + FF3D|  
|U+05BE|U + 169B i U + 169C|U + 2CFE i U + 2CFF|U+FF3F|  
|U+05C0|U + 16EB do U + 16ED|U + 2E00 do U + 2E17|U+FF5B|  
|U+05C3|U + 1735 i U + 1736|U + 2E1C i U + 2E1D|U+FF5D|  
|U+05C6|4 17D U + U + 17D 6|3001 U + do U + 3003|U + FF5F do U + FF65|  
|U + 05F3 i U + 05F4|U + 17D 8 U + 17DA|3008 U + do U + 3011||  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsPunctuation(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest skategoryzowany jako znak interpunkcyjny.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest znak interpunkcyjny; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe znaki interpunkcyjne są członkami następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, lub `OtherPunctuation`. Obejmują one znaków punktów kodowych Unicode, które są wymienione w poniższej tabeli.  
  
|||||  
|-|-|-|-|  
|U + 0021 do U + 0023|U + 060C i U + 060D|U + 1800 do U + 180A|3014 U + do U + 301F|  
|U + 0025 do U + 002A|U+061B|U + 1944 i U + 1945|U+3030|  
|U + 002C, aby U + 002F|U + 061E i U + 061F|U + 19DE i U + 19DF|U+303D|  
|U + 003a Notebook i U + 003B|066A U + U + 066 d|U + 1A1E i U + 1A1F|U+30A0|  
|U + 003F i U + 0040|U+06D4|U + 1B5A do U + 1B60|U+30FB|  
|005B U + U + 005 d|0700 U + U + 070 d|U + 2010 2027 U +|U + A874 do U + A877|  
|U+005F|U + 07F7 do U + 07F9|U + 2030 do U + 2043|U + FD3E i U + FD3F|  
|U+007B|U + 0964 i U + 0965|U + 2045 do U + 2051|U + FE10 do U + FE19|  
|U+007D|U+0970|2053 U + do U + 205E|U + FE30 do U + FE52|  
|U+00A1|U+0DF4|U + 207D i U + 207E|U + FE54 do U + FE61|  
|U+00AB|U + 0E4F do U + 0E5B|U + 208D i U + 208E|U+FE63|  
|U+00AD|U + 0F04 do U + 0F12|U + 2329 i U + 232A|U+FE68|  
|U+00B7|U + 0F3A do U + 0F3D|U + 2768 do U + 2775|U + FE6A i U + FE6B|  
|U+00BB|U+0F85|27 c 5 U + U + 6 27 c|U + FF01 do U + FF03|  
|U+00BF|U + 0FD0 i U + 0FD1|U + 27E6 do U + 27EB|U + FF05 do U + FF0A|  
|U+037E|104 a U + – U + 104F|U + 2983 do U + 2998|U + FF0C do U + FF0F|  
|U+0387|U+10FB|U + 29D 8 U + 29DB|U + FF1A i U + FF1B|  
|U + 055A do U + 055F|U + 1361 do U + 1368|U + 29FC i U + 29FD|U + FF1F i U + FF20|  
|U + 0589 i U + 058A|U + 166D i U + 166E|U + 2CF9 do U + 2CFC|U + FF3B do U + FF3D|  
|U+05BE|U + 169B i U + 169C|U + 2CFE i U + 2CFF|U+FF3F|  
|U+05C0|U + 16EB do U + 16ED|U + 2E00 do U + 2E17|U+FF5B|  
|U+05C3|U + 1735 i U + 1736|U + 2E1C i U + 2E1D|U+FF5D|  
|U+05C6|4 17D U + U + 17D 6|3001 U + do U + 3003|U + FF5F do U + FF65|  
|U + 05F3 i U + 05F4|U + 17D 8 U + 17DA|3008 U + do U + 3011||  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsPunctuation%2A>.  
  
 [!code-cpp[System.Char.IsPunctuation#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CPP/ispunctuation.cpp#9)]
 [!code-csharp[System.Char.IsPunctuation#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CS/ispunctuation.cs#9)]
 [!code-vb[System.Char.IsPunctuation#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsPunctuation/VB/ispunctuation.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsPunctuation(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku w celu oceny w <c>s</c>.</param>
        <summary>Wskazuje, czy znak na określonej pozycji w ciągu określonej jest skategoryzowany jako znak interpunkcyjny.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest znak interpunkcyjny; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Prawidłowe znaki interpunkcyjne są członkami następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, lub `OtherPunctuation`. Obejmują one znaków punktów kodowych Unicode, które są wymienione w poniższej tabeli.  
  
|||||  
|-|-|-|-|  
|U + 0021 do U + 0023|U + 060C i U + 060D|U + 1800 do U + 180A|3014 U + do U + 301F|  
|U + 0025 do U + 002A|U+061B|U + 1944 i U + 1945|U+3030|  
|U + 002C, aby U + 002F|U + 061E i U + 061F|U + 19DE i U + 19DF|U+303D|  
|U + 003a Notebook i U + 003B|066A U + U + 066 d|U + 1A1E i U + 1A1F|U+30A0|  
|U + 003F i U + 0040|U+06D4|U + 1B5A do U + 1B60|U+30FB|  
|005B U + U + 005 d|0700 U + U + 070 d|U + 2010 2027 U +|U + A874 do U + A877|  
|U+005F|U + 07F7 do U + 07F9|U + 2030 do U + 2043|U + FD3E i U + FD3F|  
|U+007B|U + 0964 i U + 0965|U + 2045 do U + 2051|U + FE10 do U + FE19|  
|U+007D|U+0970|2053 U + do U + 205E|U + FE30 do U + FE52|  
|U+00A1|U+0DF4|U + 207D i U + 207E|U + FE54 do U + FE61|  
|U+00AB|U + 0E4F do U + 0E5B|U + 208D i U + 208E|U+FE63|  
|U+00AD|U + 0F04 do U + 0F12|U + 2329 i U + 232A|U+FE68|  
|U+00B7|U + 0F3A do U + 0F3D|U + 2768 do U + 2775|U + FE6A i U + FE6B|  
|U+00BB|U+0F85|27 c 5 U + U + 6 27 c|U + FF01 do U + FF03|  
|U+00BF|U + 0FD0 i U + 0FD1|U + 27E6 do U + 27EB|U + FF05 do U + FF0A|  
|U+037E|104 a U + – U + 104F|U + 2983 do U + 2998|U + FF0C do U + FF0F|  
|U+0387|U+10FB|U + 29D 8 U + 29DB|U + FF1A i U + FF1B|  
|U + 055A do U + 055F|U + 1361 do U + 1368|U + 29FC i U + 29FD|U + FF1F i U + FF20|  
|U + 0589 i U + 058A|U + 166D i U + 166E|U + 2CF9 do U + 2CFC|U + FF3B do U + FF3D|  
|U+05BE|U + 169B i U + 169C|U + 2CFE i U + 2CFF|U+FF3F|  
|U+05C0|U + 16EB do U + 16ED|U + 2E00 do U + 2E17|U+FF5B|  
|U+05C3|U + 1735 i U + 1736|U + 2E1C i U + 2E1D|U+FF5D|  
|U+05C6|4 17D U + U + 17D 6|3001 U + do U + 3003|U + FF5F do U + FF65|  
|U + 05F3 i U + 05F4|U + 17D 8 U + 17DA|3008 U + do U + 3011||  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsPunctuation%2A>.  
  
 [!code-cpp[System.Char.IsPunctuation#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CPP/ispunctuation.cpp#9)]
 [!code-csharp[System.Char.IsPunctuation#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CS/ispunctuation.cs#9)]
 [!code-vb[System.Char.IsPunctuation#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsPunctuation/VB/ispunctuation.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSeparator">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest skategoryzowany jako znak separatora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardu Unicode rozpoznaje trzech podkategorii separatorów:  
  
-   Miejsce separatorów ( <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> kategorii), który zawiera znaki, takie jak \u0020.  
  
-   Wiersz separatorów ( <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> kategorii), która obejmuje \u2028.  
  
-   Akapit separatory ( <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> kategorii), która obejmuje \u2029.  
  
> [!NOTE]
>  Unicode standard klasyfikuje \u000A znaków (LF), \u000C (FF) i \u000D (CR) jako znaki kontrolne (członkami <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> kategorii), a nie jako znaków separatora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSeparator(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest skategoryzowany jako znak separatora.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest separatorem znaku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardu Unicode rozpoznaje trzech podkategorii separatorów:  
  
-   Miejsce separatorów ( <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> kategorii), który zawiera znaki, takie jak \u0020.  
  
-   Wiersz separatorów ( <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> kategorii), która obejmuje \u2028.  
  
-   Akapit separatory ( <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> kategorii), która obejmuje \u2029.  
  
> [!NOTE]
>  Unicode standard klasyfikuje \u000A znaków (LF), \u000C (FF) i \u000D (CR) jako znaki kontrolne (członkami <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> kategorii), a nie jako znaków separatora.  
  
   
  
## Examples  
 Na poniższych listach przykład <xref:System.Char> obiektów, które są sklasyfikowane jako znaków separatora.  
  
 [!code-cpp[System.Char.IsSeparator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSeparator/CPP/isseparator1.cpp#1)]
 [!code-csharp[System.Char.IsSeparator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSeparator/CS/isseparator1.cs#1)]
 [!code-vb[System.Char.IsSeparator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSeparator/VB/isseparator1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSeparator(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku w celu oceny w <c>s</c>.</param>
        <summary>Wskazuje, czy znak na określonej pozycji w ciągu określonej jest skategoryzowany jako znak separatora.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest separatorem znaku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Standardu Unicode rozpoznaje trzech podkategorii separatorów:  
  
-   Miejsce separatorów ( <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> kategorii), który zawiera znaki, takie jak \u0020.  
  
-   Wiersz separatorów ( <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> kategorii), która obejmuje \u2028.  
  
-   Akapit separatory ( <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> kategorii), która obejmuje \u2029.  
  
> [!NOTE]
>  Unicode standard klasyfikuje \u000A znaków (LF), \u000C (FF) i \u000D (CR) jako znaki kontrolne (członkami <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> kategorii), a nie jako znaków separatora.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.IsSeparator%2A>.  
  
 [!code-cpp[System.Char.IsSeparator#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSeparator/CPP/isseparator.cpp#10)]
 [!code-csharp[System.Char.IsSeparator#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSeparator/CS/isseparator.cs#10)]
 [!code-vb[System.Char.IsSeparator#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSeparator/VB/isseparator.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak jednostki kodu dwuskładnikowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogate(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak jednostki kodu dwuskładnikowego.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> zastępczym wysokiego poziomu lub dwuskładnikowego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest surogatu <xref:System.Char> obiektu z zakresu od U + D800 do U + DFFF jednostki kodu UTF-16. Każdy znak z jednostek kodu, w tym zakresie należy <xref:System.Globalization.UnicodeCategory.Surrogate?displayProperty=nameWithType> kategorii. Jednostka kodu poszczególnych Surogat ma nie interpretacji własnych, ale ma znaczenie tylko wtedy, gdy jest używany jako część para zastępcza. Aby uzyskać więcej informacji na temat Znaki dwuskładnikowe, zobacz Unicode Standard na [strony głównej Unicode](http://go.microsoft.com/fwlink/?linkid=37123).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.IsSurrogate%2A> metody.  
  
 [!code-cpp[System.Char.IsSurrogate#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CPP/issurrogate.cpp#11)]
 [!code-csharp[System.Char.IsSurrogate#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CS/issurrogate.cs#11)]
 [!code-vb[System.Char.IsSurrogate#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSurrogate/VB/issurrogate.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Char.IsHighSurrogate" />
        <altmember cref="Overload:System.Char.IsLowSurrogate" />
        <altmember cref="Overload:System.Char.IsSurrogatePair" />
      </Docs>
    </Member>
    <Member MemberName="IsSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogate(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku w celu oceny w <c>s</c>.</param>
        <summary>Wskazuje, czy znak na określonej pozycji w ciągu określonej jednostki kodu dwuskładnikowego.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> może mieć zastępczym wysokiego poziomu lub dwuskładnikowego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Jest surogatu <xref:System.Char> obiektu z zakresu od U + D800 do U + DFFF jednostki kodu UTF-16. Każdy znak z jednostek kodu, w tym zakresie należy <xref:System.Globalization.UnicodeCategory.Surrogate?displayProperty=nameWithType> kategorii. Jednostka kodu poszczególnych Surogat ma nie interpretacji własnych, ale ma znaczenie tylko wtedy, gdy jest używany jako część para zastępcza. Aby uzyskać więcej informacji na temat Znaki dwuskładnikowe, zobacz Unicode Standard na [strony głównej Unicode](http://go.microsoft.com/fwlink/?linkid=37123).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsSurrogate%2A>.  
  
 [!code-cpp[System.Char.IsSurrogate#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CPP/issurrogate.cpp#11)]
 [!code-csharp[System.Char.IsSurrogate#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CS/issurrogate.cs#11)]
 [!code-vb[System.Char.IsSurrogate#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSurrogate/VB/issurrogate.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w <paramref name="s" />.</exception>
        <altmember cref="Overload:System.Char.IsHighSurrogate" />
        <altmember cref="Overload:System.Char.IsLowSurrogate" />
        <altmember cref="Overload:System.Char.IsSurrogatePair" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSurrogatePair">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy dwa określone <see cref="T:System.Char" /> para zastępcza tworzą obiektów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSurrogatePair">
      <MemberSignature Language="C#" Value="public static bool IsSurrogatePair (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogatePair(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogatePair(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogatePair (highSurrogate As Char, lowSurrogate As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="highSurrogate">Znak do oceny jako pary Surogat znakiem zastępczym wysokiego poziomu.</param>
        <param name="lowSurrogate">Znak do oceny jako dwuskładnikowego para zastępcza.</param>
        <summary>Wskazuje, czy dwa określone <see cref="T:System.Char" /> para zastępcza tworzą obiektów.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość liczbową <paramref name="highSurrogate" /> może się wahać od U + D800 za pośrednictwem U + DBFF parametr i wartość liczbową <paramref name="lowSurrogate" /> parametru może się wahać od U + DC00 za pośrednictwem U + DFFF; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle pojedynczy znak jest reprezentowany przez pojedynczą jednostkę kodu Unicode 16-bitowych. Kodowanie UTF-16 obsługuje również znaki dwuskładnikowe, umożliwiających pojedynczy znak abstrakcyjny może być reprezentowana przez dwie jednostki 16-bitowego kodu. Pierwszy jednostki kodu, którego wartość może należeć do zakresu od U + D800 do U + DBFF, jest znakiem zastępczym wysokiego poziomu. Drugi jednostki kodu, którego wartość może należeć do zakresu od U + DC00 do U + DFFF, jest dwuskładnikowego. Surogat poszczególne punkty kodu mają nie interpretacji we własnym. Aby uzyskać więcej informacji na temat surogatów i Unicode Standard, zobacz [strony głównej Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, i <xref:System.Char.IsSurrogatePair%2A> metody.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.IsHighSurrogate(System.Char)" />
        <altmember cref="M:System.Char.IsLowSurrogate(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsSurrogatePair">
      <MemberSignature Language="C#" Value="public static bool IsSurrogatePair (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogatePair(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogatePair(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogatePair (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogatePair(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja początkowa pary znaków do oceny w ramach <c>s</c>.</param>
        <summary>Wskazuje, czy dwóch sąsiadujących ze sobą <see cref="T:System.Char" /> para zastępcza tworzą obiekty w określonej pozycji w ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="s" /> parametr zawiera znaki przylegające w miejscach <paramref name="index" /> i <paramref name="index" /> + 1, a wartość liczbową znaku na pozycji <paramref name="index" /> może się wahać od U + D800 za pośrednictwem U + DBFF i wartość numeryczna znak na pozycji pozycja <paramref name="index" />+ 1 zakresów z U + DC00 za pośrednictwem U + DFFF; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle pojedynczy znak jest reprezentowany przez pojedynczą jednostkę kodu Unicode 16-bitowych. Kodowanie UTF-16 obsługuje również znaki dwuskładnikowe, umożliwiających pojedynczy znak abstrakcyjny może być reprezentowana przez dwie jednostki 16-bitowego kodu. Pierwszy jednostki kodu, którego wartość może należeć do zakresu od U + D800 do U + DBFF, jest znakiem zastępczym wysokiego poziomu. Drugi jednostki kodu, którego wartość może należeć do zakresu od U + DC00 do U + DFFF, jest dwuskładnikowego. Surogat poszczególne punkty kodu mają nie interpretacji we własnym. Aby uzyskać więcej informacji na temat surogatów i Unicode Standard, zobacz [strony głównej Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, i <xref:System.Char.IsSurrogatePair%2A> metody.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest w stanie <paramref name="s" />.</exception>
        <altmember cref="M:System.Char.IsHighSurrogate(System.Char)" />
        <altmember cref="M:System.Char.IsLowSurrogate(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSymbol">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest skategoryzowany jako znak symbolu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe symbole są członkami następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, i `OtherSymbol`.  
  
 Symbole w standardzie Unicode są luźno zdefiniowanego zestawu znaków, które obejmują następujące czynności:  
  
-   Symbole waluty.  
  
-   Symbole literopodobne, które obejmują zestaw symboli alfanumeryczne matematycznych, a także symbole, takie jak ℅, nr, i™.  
  
-   Liczba formularzy, takich jak indeksy dolne i górne.  
  
-   Operatory matematyczne i strzałki.  
  
-   Symbole geometrycznej.  
  
-   Symbole technicznych.  
  
-   Wzorce Braille'a.  
  
-   Dingbats.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSymbol(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest skategoryzowany jako znak symbolu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> to symbol znaku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe symbole są członkami następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, i `OtherSymbol`.  
  
 Symbole w standardzie Unicode są luźno zdefiniowanego zestawu znaków, które obejmują następujące czynności:  
  
-   Symbole waluty.  
  
-   Symbole literopodobne, które obejmują zestaw symboli alfanumeryczne matematycznych, a także symbole, takie jak ℅, nr, i™.  
  
-   Liczba formularzy, takich jak indeksy dolne i górne.  
  
-   Operatory matematyczne i strzałki.  
  
-   Symbole geometrycznej.  
  
-   Symbole technicznych.  
  
-   Wzorce Braille'a.  
  
-   Dingbats.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsSymbol%2A>.  
  
 [!code-cpp[System.Char.IsSymbol#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSymbol/CPP/issymbol.cpp#12)]
 [!code-csharp[System.Char.IsSymbol#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSymbol/CS/issymbol.cs#12)]
 [!code-vb[System.Char.IsSymbol#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSymbol/VB/issymbol.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSymbol(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku w celu oceny w <c>s</c>.</param>
        <summary>Wskazuje, czy znak na określonej pozycji w ciągu określonej jest skategoryzowany jako znak symbolu.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> to symbol znaku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Prawidłowe symbole są członkami następujących kategorii w <xref:System.Globalization.UnicodeCategory?displayProperty=nameWithType>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, i `OtherSymbol`.  
  
 Symbole w standardzie Unicode są luźno zdefiniowanego zestawu znaków, które obejmują następujące czynności:  
  
-   Symbole waluty.  
  
-   Symbole literopodobne, które obejmują zestaw symboli alfanumeryczne matematycznych, a także symbole, takie jak ℅, nr, i™.  
  
-   Liczba formularzy, takich jak indeksy dolne i górne.  
  
-   Operatory matematyczne i strzałki.  
  
-   Symbole geometrycznej.  
  
-   Symbole technicznych.  
  
-   Wzorce Braille'a.  
  
-   Dingbats.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsSymbol%2A>.  
  
 [!code-cpp[System.Char.IsSymbol#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSymbol/CPP/issymbol.cpp#12)]
 [!code-csharp[System.Char.IsSymbol#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSymbol/CS/issymbol.cs#12)]
 [!code-vb[System.Char.IsSymbol#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSymbol/VB/issymbol.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest podzielone na wielką literę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsUpper(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest podzielone na wielką literę.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest wielką literę; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nieprawidłowa wielkie litery należą do następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsLower(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsUpper(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku w celu oceny w <c>s</c>.</param>
        <summary>Wskazuje, czy znak na określonej pozycji w ciągu określonej jest podzielone na wielką literę.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest wielką literę; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Nieprawidłowa wielkie litery należą do następujących kategorii w <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsWhiteSpace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy znak Unicode jest skategoryzowany jako biały znak.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Białe znaki są następujące znaki Unicode:  
  
-   Członkami <xref:System.Globalization.UnicodeCategory.SpaceSeparator> kategorię, która zawiera znaki miejsce (U + 0020), miejsca OGHAM oznaczyć (U + 1680), EN QUAD (U + 2000), EM QUAD (U + 2001), EN miejsce (U + 2002), EM PRZESTRZENIE (U + 2003), trzech na Długiej spacji (U + 2004), czterech na Długiej spacji (U + 2005), SZEŚCIU na EM MIEJSCE (U + 2006), rysunek miejsca (U + 2007), znaki INTERPUNKCYJNE (U + 2008), miejsce CIENKI miejsce (U + 2009), włosów miejsca (U + 200A), WĄSKIE miejsca nie-BREAK (U + 202F), średni miejsca MATEMATYCZNE (U + 205F) i ODSTĘPÓW IDEOGRAFICZNYCH (U + 3000).  
  
-   Elementy członkowskie <xref:System.Globalization.UnicodeCategory.LineSeparator> kategorię, która obejmuje tylko znak SEPARATORA linii (U + 2028).  
  
-   Elementy członkowskie <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> kategorię, która obejmuje tylko znak SEPARATORA AKAPITU (U + 2029).  
  
-   Znaki TABULACJA znaków (U + 0009) WYSUWU wiersza (U + 000A), TABULACJA w wierszu (U + 000B), wysuw (U + 000C), powrotu KARETKI (U + 000D), OBOK wiersza (U + 0085) i nie-BREAK miejsca (U + 00A0).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsWhiteSpace(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode do oceny.</param>
        <summary>Wskazuje, czy określony znak Unicode jest skategoryzowany jako biały znak.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> jest białe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Białe znaki są następujące znaki Unicode:  
  
-   Członkowie <xref:System.Globalization.UnicodeCategory.SpaceSeparator> Kategoria, która zawiera znaki miejsca (U + 0020), spacja nie-BREAK (U + 00A0), OZNACZ miejsca OGHAM (U + 1680), EN QUAD (U + 2000), EM QUAD (U + 2001), EN miejsce (U + 2002), EM PRZESTRZENIE (U + 2003), trzech na Długiej spacji (U + 2004), (cztery na EM miejsca U+ 2005), SZEŚCIU na Długiej spacji (U + 2006), spacja (U + 2007), znaki INTERPUNKCYJNE (U + 2008), miejsce CIENKI miejsce (U + 2009), włosów miejsca (U + 200A), WĄSKIE miejsca nie-BREAK (U + 202F), średni miejsca MATEMATYCZNE (U + 205F) i ODSTĘPÓW IDEOGRAFICZNYCH (U + 3000).  
  
-   Elementy członkowskie <xref:System.Globalization.UnicodeCategory.LineSeparator> kategorię, która obejmuje tylko znak SEPARATORA linii (U + 2028).  
  
-   Elementy członkowskie <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> kategorię, która obejmuje tylko znak SEPARATORA AKAPITU (U + 2029).  
  
-   Znaki TABULACJA znaków (U + 0009), wiersz źródła danych (U + 000A), TABULACJA w wierszu (U + 000B), wysuw (U + 000C), powrotu KARETKI (U + 000D), a następnie wiersza (U + 0085).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.IsWhiteSpace%28System.Char%29> metody.  
  
 [!code-cpp[System.Char.IsWhiteSpace#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CPP/iswhitespace.cpp#14)]
 [!code-csharp[System.Char.IsWhiteSpace#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CS/iswhitespace.cs#14)]
 [!code-vb[System.Char.IsWhiteSpace#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/VB/iswhitespace.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsWhiteSpace(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg.</param>
        <param name="index">Pozycja znaku w celu oceny w <c>s</c>.</param>
        <summary>Wskazuje, czy znak na określonej pozycji w ciągu określonej jest skategoryzowany jako biały znak.</summary>
        <returns>
          <see langword="true" /> Jeśli znak na pozycji <paramref name="index" /> w <paramref name="s" /> jest białe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje znaku w ciągu są indeksowane począwszy od zera.  
  
 Białe znaki są następujące znaki Unicode:  
  
-   Członkowie <xref:System.Globalization.UnicodeCategory.SpaceSeparator> Kategoria, która zawiera znaki miejsca (U + 0020), spacja nie-BREAK (U + 00A0), OZNACZ miejsca OGHAM (U + 1680), EN QUAD (U + 2000), EM QUAD (U + 2001), EN miejsce (U + 2002), EM PRZESTRZENIE (U + 2003), trzech na Długiej spacji (U + 2004), (cztery na EM miejsca U+ 2005), SZEŚCIU na Długiej spacji (U + 2006), spacja (U + 2007), znaki INTERPUNKCYJNE (U + 2008), miejsce CIENKI miejsce (U + 2009), włosów miejsca (U + 200A), WĄSKIE miejsca nie-BREAK (U + 202F), średni miejsca MATEMATYCZNE (U + 205F) i ODSTĘPÓW IDEOGRAFICZNYCH (U + 3000).  
  
-   Elementy członkowskie <xref:System.Globalization.UnicodeCategory.LineSeparator> kategorię, która obejmuje tylko znak SEPARATORA linii (U + 2028).  
  
-   Elementy członkowskie <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> kategorię, która obejmuje tylko znak SEPARATORA AKAPITU (U + 2029).  
  
-   Znaki TABULACJA znaków (U + 0009), wiersz źródła danych (U + 000A), TABULACJA w wierszu (U + 000B), wysuw (U + 000C), powrotu KARETKI (U + 000D), a następnie wiersza (U + 0085).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.IsWhiteSpace%2A>.  
  
 [!code-cpp[System.Char.IsWhiteSpace#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CPP/iswhitespace.cpp#14)]
 [!code-csharp[System.Char.IsWhiteSpace#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CS/iswhitespace.cs#14)]
 [!code-vb[System.Char.IsWhiteSpace#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/VB/iswhitespace.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa od ostatniej pozycji w <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const char MaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal char MaxValue" />
      <MemberSignature Language="DocId" Value="F:System.Char.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Char " />
      <MemberSignature Language="C++ CLI" Value="public: char MaxValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje największa możliwa wartość z <see cref="T:System.Char" />. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest szesnastkową 0xFFFF.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Char.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const char MinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal char MinValue" />
      <MemberSignature Language="DocId" Value="F:System.Char.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Char " />
      <MemberSignature Language="C++ CLI" Value="public: char MinValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje najniższą możliwą wartość elementu <see cref="T:System.Char" />. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest 0x00 szesnastkową.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Char.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static char Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający pojedynczy znak lub <see langword="null" />.</param>
        <summary>Konwertuje wartość określonego ciągu na jej odpowiednik znaku Unicode.</summary>
        <returns>Odpowiednikiem wyłącznie znak w znaku Unicode <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.Parse%2A>.  
  
 [!code-cpp[System.Char.Parse#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.Parse/CPP/parse.cpp#15)]
 [!code-csharp[System.Char.Parse#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.Parse/CS/parse.cs#15)]
 [!code-vb[System.Char.Parse#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.Parse/VB/parse.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Długość <paramref name="s" /> nie jest 1.</exception>
        <altmember cref="M:System.Char.ToString" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>**Uwaga** ta konwersja nie jest obsługiwana. Próby zgłasza tak <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Ta konwersja nie jest obsługiwana. Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Ta konwersja nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToByte%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Wartość bieżącego <see cref="T:System.Char" /> obiektu bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>**Uwaga** ta konwersja nie jest obsługiwana. Próby zgłasza tak <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Ta konwersja nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>**Uwaga** ta konwersja nie jest obsługiwana. Próby zgłasza tak <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Ta konwersja nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>**Uwaga** ta konwersja nie jest obsługiwana. Próby zgłasza tak <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Ta konwersja nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt16%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt32%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt64%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSByte%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>**Uwaga** ta konwersja nie jest obsługiwana. Próby zgłasza tak <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Ta konwersja nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> obiektu.</param>
        <param name="provider">
          <see cref="T:System.IFormatProvider" /> Obiektu.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Obiekt określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%2CSystem.IFormatProvider%29> metody zamiast tego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Wartość bieżącego <see cref="T:System.Char" /> obiektu nie można przekonwertować na typ określony przez <paramref name="type" /> parametru.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.IFormatProvider" /> Obiektu. (Określ <see langword="null" /> ponieważ <c>dostawcy</c> parametru jest ignorowana.)</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt16%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.IFormatProvider" /> Obiektu. (Określ <see langword="null" /> ponieważ <c>dostawcy</c> parametru jest ignorowana.)</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt32%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.IFormatProvider" /> Obiektu. (Określ <see langword="null" /> ponieważ <c>dostawcy</c> parametru jest ignorowana.)</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.Char" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Char> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt64%28System.Char%29?displayProperty=nameWithType> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość znaku Unicode na jej odpowiednik małe litery.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static char ToLower (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLower(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLower(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLower(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <summary>Konwertuje wartość znaku Unicode na jej odpowiednik małe litery.</summary>
        <returns>Małe litery odpowiednikiem <paramref name="c" />, wartości bez zmian lub <paramref name="c" />, jeśli <paramref name="c" /> jest już małe lub nie alfabetu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wielkość liter reguły są uzyskiwane z bieżącej kultury.  
  
 Użyj <xref:System.String.ToLower%2A?displayProperty=nameWithType> do przekonwertowania ciągu na małe litery.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Char.ToLower%2A>.  
  
 [!code-cpp[System.Char.ToLower#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToLower/CPP/tolower.cpp#16)]
 [!code-csharp[System.Char.ToLower#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToLower/CS/tolower.cs#16)]
 [!code-vb[System.Char.ToLower#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToLower/VB/tolower.vb#16)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Zgodnie z objaśnieniem w [najlepsze rozwiązania dotyczące ciągów za pomocą](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod wielkości liter na znak i wielkości ciąg znaków, które zastępuje wartości domyślne. Zamiast tego należy wywołać metody, które są wymagane parametry, aby być jawnie określona. Aby dokonać konwersji znaków na małe litery przy użyciu konwencji wielkość liter w bieżącej kultury, należy wywołać <see cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" /> przeciążenie metody o wartości <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> dla jego <paramref name="culture" /> parametru.</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static char ToLower (char c, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLower(char c, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (c As Char, culture As CultureInfo) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLower(char c, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <param name="culture">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</param>
        <summary>Konwertuje wartość określonego znaku Unicode na jej odpowiednik małe przy użyciu określonego informacje dotyczące formatowania specyficzne dla kultury.</summary>
        <returns>Małe litery odpowiednikiem <paramref name="c" />, zmodyfikowane zgodnie z <paramref name="culture" />, wartości bez zmian lub <paramref name="c" />, jeśli <paramref name="c" /> jest już małe lub nie alfabetu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.String.ToLower%2A?displayProperty=nameWithType> do przekonwertowania ciągu na małe litery.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.ToLower%2A>.  
  
 [!code-cpp[System.Char.ToLower#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToLower/CPP/tolower.cpp#16)]
 [!code-csharp[System.Char.ToLower#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToLower/CS/tolower.cs#16)]
 [!code-vb[System.Char.ToLower#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToLower/VB/tolower.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public static char ToLowerInvariant (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLowerInvariant(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLowerInvariant(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLowerInvariant (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLowerInvariant(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <summary>Konwertuje wartość znaku Unicode na jej odpowiednik małe przy użyciu reguł wielkości liter Niezmienna kultura.</summary>
        <returns>Małe litery odpowiednikiem <paramref name="c" /> parametrów lub wartości bez zmian <paramref name="c" />, jeśli <paramref name="c" /> jest już małe lub nie alfabetu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli aplikacja jest niezależna od bieżącej kultury i zależy od przypadku znak zmienianie w sposób przewidywalne, użyj <xref:System.Char.ToLowerInvariant%2A> metody. <xref:System.Char.ToLowerInvariant%2A> Metoda jest odpowiednikiem `ToLower(Char, CultureInfo.InvariantCulture)`.  
  
 Użyj <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> do przekonwertowania ciągu na małe litery.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia na jego równoważną reprezentację w postaci ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia na jego równoważną reprezentację w postaci ciągu.</summary>
        <returns>Ciąg reprezentujący wartość tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToString (c As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ToString(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <summary>Konwertuje określony znak Unicode do reprezentacji ciągu równoważne.</summary>
        <returns>Reprezentacja ciągu wartości <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Parametr zarezerwowany) Obiekt dostarczający informacji o formatowaniu specyficznych dla kultury.</param>
        <summary>Konwertuje wartość tego wystąpienia reprezentacji ciągu równoważny, korzystając z informacji zawartych w określonym formacie specyficzne dla kultury.</summary>
        <returns>Reprezentacja ciągu wartość tego wystąpienia, określony przez <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` Parametr jest ignorowany; nie uczestniczy w tej operacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje przeciążenia <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość znaku Unicode na jej odpowiednik wielkie litery.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static char ToUpper (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpper(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpper(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpper(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <summary>Konwertuje wartość znaku Unicode na jej odpowiednik wielkie litery.</summary>
        <returns>Wielkie litery odpowiednikiem <paramref name="c" />, wartości bez zmian lub <paramref name="c" /> Jeśli <paramref name="c" /> jest już wielkie litery, nie zawiera wielkie odpowiednika lub nie jest od litery alfabetu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wielkość liter reguły są uzyskiwane z bieżącej kultury.  
  
 Użyj <xref:System.String.ToUpper%2A?displayProperty=nameWithType> do przekonwertowania ciągu na wielkie litery.  
  
   
  
## Examples  
 Poniższy przykład konwertuje każdego znaku w tablicy na jej odpowiednik wielkie litery.  
  
 [!code-csharp[System.Char.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.toupper/cs/toupper1.cs#1)]
 [!code-vb[System.Char.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.toupper/vb/toupper1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Zgodnie z objaśnieniem w [najlepsze rozwiązania dotyczące ciągów za pomocą](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod wielkości liter na znak i wielkości ciąg znaków, które zastępuje wartości domyślne. Zamiast tego należy wywołać metody, które są wymagane parametry, aby być jawnie określona. Aby dokonać konwersji znaków na wielkie litery przy użyciu konwencji wielkość liter w bieżącej kultury, należy wywołać <see cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" /> przeciążenie metody o wartości <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> dla jego <paramref name="culture" /> parametru.</para>
        </block>
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static char ToUpper (char c, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpper(char c, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (c As Char, culture As CultureInfo) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpper(char c, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <param name="culture">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</param>
        <summary>Konwertuje wartość określonego znaku Unicode na jej odpowiednik wielkie przy użyciu określonego informacje dotyczące formatowania specyficzne dla kultury.</summary>
        <returns>Wielkie litery odpowiednikiem <paramref name="c" />, zmodyfikowane zgodnie z <paramref name="culture" />, wartości bez zmian lub <paramref name="c" /> Jeśli <paramref name="c" /> jest już wielkie litery, nie zawiera wielkie odpowiednika lub nie jest od litery alfabetu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.String.ToUpper%2A?displayProperty=nameWithType> do przekonwertowania ciągu na wielkie litery.  
  
   
  
## Examples  
 Poniższy przykład konwertuje każdego znaku w tablicy na jej odpowiednik wielkie dla kultury en US, niezmienna kultura i kultury tr-TR. W tym przykładzie identyczne dla wszystkich języków, z wyjątkiem jeden przypadek jest odpowiednikiem wielkie litery każdego małą literę. Małe "litery i" znak (U + 0069) skonwertować "I" (U + 0049) w en US i kultur niezmienna, ale do "İ" (U + 0130) w tr-TR kultury.  
  
 [!code-csharp[System.Char.ToUpper#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.toupper/cs/toupper5.cs#2)]
 [!code-vb[System.Char.ToUpper#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.toupper/vb/toupper5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public static char ToUpperInvariant (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpperInvariant(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpperInvariant(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpperInvariant (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpperInvariant(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode, który ma zostać przekształcony.</param>
        <summary>Konwertuje wartość znaku Unicode na jej odpowiednik wielkie przy użyciu reguł wielkości liter Niezmienna kultura.</summary>
        <returns>Wielkie litery odpowiednikiem <paramref name="c" /> parametrów lub wartości bez zmian <paramref name="c" />, jeśli <paramref name="c" /> jest już wielkie lub nie alfabetu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli aplikacja jest niezależna od bieżącej kultury i zależy od przypadku znak zmienianie w sposób przewidywalne, użyj <xref:System.Char.ToUpperInvariant%2A> metody.  <xref:System.Char.ToUpperInvariant%2A> Metoda jest odpowiednikiem `ToUpper(Char, CultureInfo.InvariantCulture)`.  
  
 Użyj <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> do przekonwertowania ciągu na wielkie litery.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out char result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] char&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.TryParse(System.String,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] char % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Char&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający pojedynczy znak lub <see langword="null" />.</param>
        <param name="result">Po powrocie z tej metody zawiera równoważne wyłącznie znak w znaku Unicode <c>s</c>, jeśli konwersja powiodła się, lub niezdefiniowaną wartość, jeśli konwersja nie powiodła się. Konwersja nie powiedzie się, jeśli <c>s</c> parametr jest <see langword="null" /> lub długość <c>s</c> nie jest 1. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje wartość określonego ciągu na jej odpowiednik znaku Unicode. Kod powrotu wskazuje, czy konwersja powiodła się czy nie.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="s" /> parametr został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.TryParse%2A> Metody przypomina <xref:System.Char.Parse%2A> metody, z wyjątkiem <xref:System.Char.TryParse%2A> — metoda nie zgłosić wyjątek, jeśli konwersja nie powiedzie się.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje przeciążeń <xref:System.Char.TryParse%2A> metodę kilka typów podstawowych i <xref:System.DateTime.TryParseExact%2A> metodę <xref:System.DateTime> typ podstawowy.  
  
 [!code-cpp[T.TryParse#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.TryParse/CPP/tp.cpp#1)]
 [!code-csharp[T.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.TryParse/CS/tp.cs#1)]
 [!code-vb[T.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.TryParse/VB/tp.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="M:System.Char.ToString" />
      </Docs>
    </Member>
  </Members>
</Type>
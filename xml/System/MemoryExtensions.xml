<Type Name="MemoryExtensions" FullName="System.MemoryExtensions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="86d2b84efb967331997e1f983303066ef947a602" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69405595" /></Metadata><TypeSignature Language="C#" Value="public static class MemoryExtensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit MemoryExtensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MemoryExtensions" />
  <TypeSignature Language="VB.NET" Value="Public Module MemoryExtensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryExtensions abstract sealed" />
  <TypeSignature Language="F#" Value="type MemoryExtensions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia metody rozszerzające dla typów pamięci i powiązanej z zakresem, takich jak <see cref="T:System.Memory`1" /> <see cref="T:System.Span`1" />, <see cref="T:System.ReadOnlyMemory`1" />, i <see cref="T:System.ReadOnlySpan`1" />.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg docelowy.</param>
        <summary>Tworzy nowy <see langword="ReadOnlyMemory&lt;Char&gt;" /> element względem części ciągu docelowego.</summary>
        <returns>Reprezentacja ciągu z pamięcią tylko do odczytu lub <see langword="default" /> Jeśli <paramref name="text" /> jest <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String, startIndex As Index) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * Index -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg docelowy.</param>
        <param name="startIndex">Indeks, w którym ma zostać umieszczony ten plasterek.</param>
        <summary>Tworzy nową <see langword="ReadOnlyMemory&lt;Char&gt;" /> wartość dla części ciągu docelowego, zaczynając od określonego indeksu.</summary>
        <returns>Reprezentacja ciągu z pamięcią tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String, start As Integer) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, int start);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * int -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg docelowy.</param>
        <param name="start">Indeks, w którym ma zostać umieszczony ten plasterek.</param>
        <summary>Tworzy nową <see langword="ReadOnlyMemory&lt;Char&gt;" /> dla części ciągu docelowego, zaczynając od określonej pozycji znaku.</summary>
        <returns>Reprezentacja ciągu z pamięcią tylko do odczytu lub <see langword="default" /> Jeśli <paramref name="text" /> jest <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" />nie znajduje się w <paramref name="text" /> zakresie (<paramref name="start" /> is &lt; 0 lub &gt; Text) <c>. Długość</c>).</exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, Range range);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * Range -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg docelowy.</param>
        <param name="range">Zakres, który wskazuje początek i długość ciągu z wycinkami.</param>
        <summary>Tworzy nową <see langword="ReadOnlyMemory&lt;Char&gt;" /> wartość powyżej określonego zakresu ciągu docelowego.</summary>
        <returns>Reprezentacja ciągu z pamięcią tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String, start As Integer, length As Integer) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * int * int -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg docelowy.</param>
        <param name="start">Indeks, w którym ma zostać umieszczony ten plasterek.</param>
        <param name="length">Wymagana długość wycinka.</param>
        <summary>Tworzy nową <see langword="ReadOnlyMemory&lt;Char&gt;" /> wartość dla części ciągu docelowego, zaczynając od określonej pozycji o długości.</summary>
        <returns>Reprezentacja ciągu z pamięcią tylko do odczytu lub <see langword="default" /> Jeśli <paramref name="text" /> jest <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" />, <paramref name="length" />, lub <paramref name="start" /> nienależydo +  zakresu .<paramref name="text" /> <paramref name="length" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (segment As ArraySegment(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="F#" Value="static member AsMemory : ArraySegment&lt;'T&gt; -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ segmentu.</typeparam>
        <param name="segment">Segment do przekonwertowania.</param>
        <summary>Tworzy nowy region pamięci na części docelowego segmentu tablicy.</summary>
        <returns>Reprezentacja segmentu w pamięci.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T()) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="array">Tablica do przekonwertowania.</param>
        <summary>Tworzy nowy region pamięci na tablicy docelowej.</summary>
        <returns>Reprezentacja pamięci całości lub części tablicy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (segment As ArraySegment(Of T), start As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(ArraySegment&lt;T&gt; segment, int start);" />
      <MemberSignature Language="F#" Value="static member AsMemory : ArraySegment&lt;'T&gt; * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (segment, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="segment">Docelowy segment tablicy.</param>
        <param name="start">Indeks, w którym ma zostać rozpoczęta pamięć.</param>
        <summary>Tworzy nowy region pamięci nad częścią docelowego segmentu tablicy, zaczynając od określonej pozycji do końca segmentu.</summary>
        <returns>Reprezentacja pamięci całości lub części tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Zwraca `default` wartość `segment` , `null`gdy is.

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="segment" />jest współwariantem, a typ <paramref name="segment" /> nie jest dokładnie. <see langword="T[]" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" />jest mniejsza niż 0 lub większa niż <see langword="segment.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T(), startIndex As Index) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * Index -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="array">Tablica do przekonwertowania.</param>
        <param name="startIndex">Pierwsza pozycja tablicy.</param>
        <summary>Tworzy nowy region pamięci na części tablicy docelowej, zaczynając od określonego indeksu do końca tablicy.</summary>
        <returns>Reprezentacja pamięci całości lub części tablicy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T(), start As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, int start);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="array">Tablica docelowa.</param>
        <param name="start">Indeks, w którym ma zostać rozpoczęta pamięć.</param>
        <summary>Tworzy nowy region pamięci na części tablicy docelowej, zaczynając od określonej pozycji do końca tablicy.</summary>
        <returns>Reprezentacja pamięci całości lub części tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Zwraca `default` wartość `array` , `null`gdy is.

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="array" />jest współwariantem, a typ tablicy nie jest dokładnie <see langword="T[]" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" />indeks jest mniejszy niż 0 lub większy <see langword="array.Length" />niż.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, Range range);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * Range -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="array">Tablica do przekonwertowania.</param>
        <param name="range">Zakres, który ma zostać przekonwertowany z tablicy.</param>
        <summary>Tworzy nowy region pamięci nad częścią tablicy docelowej, rozpoczynając od indeksu początkowy zakres i kończąc na wyłącznym indeksie końcowym zakresu.</summary>
        <returns>Reprezentacja pamięci całości lub części tablicy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (segment As ArraySegment(Of T), start As Integer, length As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(ArraySegment&lt;T&gt; segment, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsMemory : ArraySegment&lt;'T&gt; * int * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (segment, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="segment">Docelowy segment tablicy.</param>
        <param name="start">Indeks, w którym ma zostać rozpoczęta pamięć.</param>
        <param name="length">Liczba elementów w pamięci.</param>
        <summary>Tworzy nowy region pamięci na części docelowego segmentu tablicy, zaczynając od określonej pozycji o określonej długości.</summary>
        <returns>Reprezentacja pamięci całości lub części tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Zwraca `default` wartość `segment` , `null`gdy is.

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="segment" />jest współwariantem, a typ tablicy nie jest dokładnie <see langword="T[]" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" />, <paramref name="length" />, lub <paramref name="start" /> nienależydo +  zakresu .<paramref name="segment" /> <paramref name="length" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T(), start As Integer, length As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * int * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="array">Tablica docelowa.</param>
        <param name="start">Indeks, w którym ma zostać rozpoczęty region pamięci.</param>
        <param name="length">Liczba elementów w regionie pamięci.</param>
        <summary>Tworzy nowy region pamięci na części tablicy docelowej, zaczynając od określonej pozycji o określonej długości.</summary>
        <returns>Reprezentacja pamięci całości lub części tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Zwraca `default` wartość `array` , `null`gdy is.

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="array" />jest współwariantem, a typ tablicy nie jest dokładnie <see langword="T[]" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" />, <paramref name="length" />, lub <paramref name="start" /> nienależydo +  zakresu .<paramref name="array" /> <paramref name="length" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; AsSpan(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan(System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan (text As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; AsSpan(System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member AsSpan : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.AsSpan text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg docelowy.</param>
        <summary>Tworzy nowy zakres tylko do odczytu dla części ciągu docelowego z określonego położenia dla określonej liczby znaków.</summary>
        <returns>Reprezentacja ciągu w trybie tylko do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Zwraca `default` wartość `text` , `null`gdy is.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string text, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; AsSpan(string text, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan (text As String, start As Integer) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; AsSpan(System::String ^ text, int start);" />
      <MemberSignature Language="F#" Value="static member AsSpan : string * int -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.AsSpan (text, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg docelowy.</param>
        <param name="start">Indeks, w którym ma zostać umieszczony ten plasterek.</param>
        <summary>Tworzy nowy zakres tylko do odczytu dla części ciągu docelowego od określonego położenia do końca ciągu.</summary>
        <returns>Reprezentacja ciągu w trybie tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="text" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" />jest mniejsza niż 0 lub większa niż <see langword="text.Length" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string text, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; AsSpan(string text, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan (text As String, start As Integer, length As Integer) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; AsSpan(System::String ^ text, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsSpan : string * int * int -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.AsSpan (text, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg docelowy.</param>
        <param name="start">Indeks, w którym ma zostać umieszczony ten plasterek.</param>
        <param name="length">Wymagana długość wycinka.</param>
        <summary>Tworzy nowy zakres tylko do odczytu w ciągu.</summary>
        <returns>Reprezentacja ciągu w trybie tylko do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Zwraca `default` wartość `text` , `null`gdy is.

            ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" />, <paramref name="length" />, lub <paramref name="start" /> nienależydo +  zakresu .<paramref name="text" /> <paramref name="length" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ segmentu tablicy.</typeparam>
        <param name="segment">Segment tablicy do przekonwertowania.</param>
        <summary>Tworzy nowy zakres dla docelowego segmentu tablicy.</summary>
        <returns>Reprezentacja ogniw segmentu tablicy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T()) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="array">Tablica do przekonwertowania.</param>
        <summary>Tworzy nowy zakres na tablicy docelowej.</summary>
        <returns>Reprezentacja zakresu tablicy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T), startIndex As Index) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * Index -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ segmentu tablicy.</typeparam>
        <param name="segment">Docelowy segment tablicy.</param>
        <param name="startIndex">Indeks, w którym ma zostać rozpoczęty zakres.</param>
        <summary>Tworzy nowy zakres na części docelowego segmentu tablicy, zaczynając od określonego indeksu i kończąc na końcu segmentu.</summary>
        <returns>Reprezentacja ogniw segmentu tablicy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T), start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, int start);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ segmentu tablicy.</typeparam>
        <param name="segment">Docelowy segment tablicy.</param>
        <param name="start">Indeks, w którym ma zostać rozpoczęta sieć San.</param>
        <summary>Tworzy nowy zakres na części docelowego segmentu tablicy od określonego położenia do końca segmentu.</summary>
        <returns>Reprezentacja ogniw segmentu tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Zwraca `default` wartość `segment` , `null`gdy is.

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="segment" />jest współwariantem, a typ tablicy nie jest dokładnie <see langword="T[]" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" />jest mniejsza niż 0 lub większa niż <see langword="segment.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, Range range);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * Range -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ segmentu tablicy.</typeparam>
        <param name="segment">Docelowy segment tablicy.</param>
        <param name="range">Zakres, który ma indeksy początkowe i końcowe do użycia w celu odtworzenia wycinków tablicy.</param>
        <summary>Tworzy nowy zakres dla części docelowego segmentu tablicy przy użyciu zakresu początkowego i końcowego indeksu</summary>
        <returns>Reprezentacja ogniw segmentu tablicy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T(), startIndex As Index) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * Index -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="array">Tablica do przekonwertowania.</param>
        <param name="startIndex">Indeks początkowy.</param>
        <summary>Tworzy nowy zakres na podstawie części tablicy docelowej zdefiniowanej przez <see cref="T:System.Index" /> wartość.</summary>
        <returns>Reprezentacja zakresu tablicy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T(), start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, int start);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="array">Tablica do przekonwertowania.</param>
        <param name="start">Początkowy indeks, z którego tablica zostanie przekonwertowana.</param>
        <summary>Tworzy nowy zakres na części tablicy docelowej, zaczynając od określonej pozycji do końca tablicy.</summary>
        <returns>Reprezentacja zakresu tablicy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, Range range);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * Range -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="array">Tablica do przekonwertowania.</param>
        <param name="range">Zakres tablicy do przekonwertowania.</param>
        <summary>Tworzy nowy zakres dla części tablicy docelowej zdefiniowanej przez <see cref="T:System.Range" /> wartość.</summary>
        <returns>Reprezentacja zakresu tablicy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T), start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * int * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ segmentu tablicy.</typeparam>
        <param name="segment">Docelowy segment tablicy.</param>
        <param name="start">Indeks, w którym ma zostać rozpoczęty zakres.</param>
        <param name="length">Liczba elementów w zakresie.</param>
        <summary>Tworzy nowy zakres dla części docelowego segmentu tablicy z określonego położenia dla określonej długości.</summary>
        <returns>Reprezentacja zakresu tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Zwraca `default` wartość `segment` , `null`gdy is.

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="segment" />jest współwariantem, a typ tablicy nie jest dokładnie <see langword="T[]" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" />, <paramref name="length" />, lub <paramref name="start" /> nienależydo +  zakresu .<paramref name="segment" /> <paramref name="length" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T(), start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * int * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="array">Tablica docelowa.</param>
        <param name="start">Indeks, w którym ma zostać rozpoczęty zakres.</param>
        <param name="length">Liczba elementów w zakresie.</param>
        <summary>Tworzy nowy zakres względem części tablicy docelowej, zaczynając od określonej pozycji dla określonej długości.</summary>
        <returns>Reprezentacja zakresu tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Zwraca `default` wartość `array` , `null`gdy is.

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="array" />jest współwariantem, a typ tablicy nie jest dokładnie <see langword="T[]" />".</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" />, <paramref name="length" />, lub <paramref name="start" /> nienależydo +  zakresu .<paramref name="text" /> <paramref name="length" /></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, IComparable&lt;T&gt; comparable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, class System.IComparable`1&lt;!!T&gt; comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T) (span As ReadOnlySpan(Of T), comparable As IComparable(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(ReadOnlySpan&lt;T&gt; span, IComparable&lt;T&gt; ^ comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : ReadOnlySpan&lt;'T&gt; * IComparable&lt;'T&gt; -&gt; int" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="System.IComparable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementu zakresu.</typeparam>
        <param name="span">Posortowane <see cref="T:System.ReadOnlySpan`1" /> do wyszukania.</param>
        <param name="comparable"><see cref="T:System.IComparable`1" /> Do użycia podczas porównywania.</param>
        <summary>Wyszukuje cały posortowane <see cref="T:System.ReadOnlySpan`1" /> wartości przy użyciu określonego <see cref="T:System.IComparable`1" /> interfejsu ogólnego.</summary>
        <returns>Indeks <paramref name="comparable" /> (liczony od zera) w sortowaniu <paramref name="span" />, jeśli <paramref name="comparable" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="comparable" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.ReadOnlySpan`1.Length" />bitowe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparable" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (this Span&lt;T&gt; span, IComparable&lt;T&gt; comparable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span, class System.IComparable`1&lt;!!T&gt; comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T) (span As Span(Of T), comparable As IComparable(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(Span&lt;T&gt; span, IComparable&lt;T&gt; ^ comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Span&lt;'T&gt; * IComparable&lt;'T&gt; -&gt; int" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="System.IComparable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementu zakresu.</typeparam>
        <param name="span">Posortowane <see cref="T:System.Span`1" /> do wyszukania.</param>
        <param name="comparable"><see cref="T:System.IComparable`1" /> Do użycia podczas porównywania.</param>
        <summary>Wyszukuje cały posortowane <see cref="T:System.Span`1" /> wartości przy użyciu określonego <see cref="T:System.IComparable`1" /> interfejsu ogólnego.</summary>
        <returns>Indeks <paramref name="comparable" /> (liczony od zera) w sortowaniu <paramref name="span" />, jeśli <paramref name="comparable" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="comparable" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.Span`1.Length" />bitowe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparable" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparable&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparable&gt; (this ReadOnlySpan&lt;T&gt; span, TComparable comparable) where TComparable : IComparable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.IComparable`1&lt;!!T&gt;) TComparable&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!TComparable comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparable) (span As ReadOnlySpan(Of T), comparable As TComparable) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparable&gt;&#xA; where TComparable : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(ReadOnlySpan&lt;T&gt; span, TComparable comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : ReadOnlySpan&lt;'T&gt; * 'Comparable -&gt; int (requires 'Comparable :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparable">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="TComparable" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementu zakresu.</typeparam>
        <typeparam name="TComparable">Określony typ <see cref="T:System.IComparable`1" />.</typeparam>
        <param name="span">Posortowane <see cref="T:System.ReadOnlySpan`1" /> do wyszukania.</param>
        <param name="comparable"><typeparamref name="TComparable" /> Do użycia podczas porównywania.</param>
        <summary>Wyszukuje cały posortowane <see cref="T:System.ReadOnlySpan`1" /> wartości przy użyciu określonego <typeparamref name="TComparable" /> typu ogólnego.</summary>
        <returns>Indeks <paramref name="comparable" /> (liczony od zera) w sortowaniu <paramref name="span" />, jeśli <paramref name="comparable" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="comparable" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.ReadOnlySpan`1.Length" />bitowe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparable" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparable&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparable&gt; (this Span&lt;T&gt; span, TComparable comparable) where TComparable : IComparable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.IComparable`1&lt;!!T&gt;) TComparable&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!TComparable comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparable) (span As Span(Of T), comparable As TComparable) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparable&gt;&#xA; where TComparable : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(Span&lt;T&gt; span, TComparable comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Span&lt;'T&gt; * 'Comparable -&gt; int (requires 'Comparable :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparable">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="TComparable" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementu zakresu.</typeparam>
        <typeparam name="TComparable">Określony typ <see cref="T:System.IComparable`1" />.</typeparam>
        <param name="span">Posortowane <see cref="T:System.Span`1" /> do wyszukania.</param>
        <param name="comparable"><typeparamref name="TComparable" /> Do użycia podczas porównywania.</param>
        <summary>Wyszukuje cały posortowane <see cref="T:System.Span`1" /> wartości przy użyciu określonego <typeparamref name="TComparable" /> typu ogólnego.</summary>
        <returns>Indeks <paramref name="comparable" /> (liczony od zera) w sortowaniu <paramref name="span" />, jeśli <paramref name="comparable" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="comparable" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.Span`1.Length" />bitowe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparable" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparer&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparer&gt; (this ReadOnlySpan&lt;T&gt; span, T value, TComparer comparer) where TComparer : System.Collections.Generic.IComparer&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.Collections.Generic.IComparer`1&lt;!!T&gt;) TComparer&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value, !!TComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparer) (span As ReadOnlySpan(Of T), value As T, comparer As TComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparer&gt;&#xA; where TComparer : System::Collections::Generic::IComparer&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(ReadOnlySpan&lt;T&gt; span, T value, TComparer comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : ReadOnlySpan&lt;'T&gt; * 'T * 'Comparer -&gt; int (requires 'Comparer :&gt; System.Collections.Generic.IComparer&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparer">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IComparer&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="TComparer" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementu zakresu.</typeparam>
        <typeparam name="TComparer">Określony typ <see cref="T:System.Collections.Generic.IComparer`1" />.</typeparam>
        <param name="span">Posortowane <see cref="T:System.ReadOnlySpan`1" /> do wyszukania.</param>
        <param name="value">Obiekt, który ma zostać zlokalizowany. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <param name="comparer"><typeparamref name="TComparer" /> Do użycia podczas porównywania.</param>
        <summary>Wyszukuje całe posortowane <see cref="T:System.ReadOnlySpan`1" /> dla określonej wartości przy użyciu <typeparamref name="TComparer" /> określonego typu ogólnego.</summary>
        <returns>Indeks <paramref name="value" /> (liczony od zera) w sortowaniu <paramref name="span" />, jeśli <paramref name="value" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="value" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.ReadOnlySpan`1.Length" />bitowe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparer" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparer&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparer&gt; (this Span&lt;T&gt; span, T value, TComparer comparer) where TComparer : System.Collections.Generic.IComparer&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.Collections.Generic.IComparer`1&lt;!!T&gt;) TComparer&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value, !!TComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparer) (span As Span(Of T), value As T, comparer As TComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparer&gt;&#xA; where TComparer : System::Collections::Generic::IComparer&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(Span&lt;T&gt; span, T value, TComparer comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Span&lt;'T&gt; * 'T * 'Comparer -&gt; int (requires 'Comparer :&gt; System.Collections.Generic.IComparer&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparer">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IComparer&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="TComparer" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementu zakresu.</typeparam>
        <typeparam name="TComparer">Określony typ <see cref="T:System.Collections.Generic.IComparer`1" />.</typeparam>
        <param name="span">Posortowane <see cref="T:System.Span`1" /> do wyszukania.</param>
        <param name="value">Obiekt, który ma zostać zlokalizowany. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <param name="comparer"><typeparamref name="TComparer" /> Do użycia podczas porównywania.</param>
        <summary>Wyszukuje całe posortowane <see cref="T:System.Span`1" /> dla określonej wartości przy użyciu <typeparamref name="TComparer" /> określonego typu ogólnego.</summary>
        <returns>Indeks <paramref name="value" /> (liczony od zera) w sortowaniu <paramref name="span" />, jeśli <paramref name="value" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="value" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.Span`1.Length" />bitowe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparer" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public static int CompareTo (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareTo(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; other, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CompareTo (span As ReadOnlySpan(Of Char), other As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int CompareTo(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member CompareTo : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.MemoryExtensions.CompareTo (span, other, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy.</param>
        <param name="other">Wartość do porównania z zakresem źródłowym.</param>
        <param name="comparisonType">Wartość wyliczenia, która określa, <paramref name="span" /> jak <paramref name="other" /> i są porównywane.</param>
        <summary>Porównuje jeden zakres znaków z innym przy użyciu określonego porównania ciągów i zwraca liczbę całkowitą, która wskazuje ich położenie względne w kolejności sortowania.</summary>
        <returns>Liczba całkowita ze znakiem, która wskazuje względną <paramref name="other" />kolejność dla <paramref name="span" /> i:<br />   -Jeśli jest mniejsza niż 0 <paramref name="span" /> , poprzedza. <paramref name="other" /><br />   -Jeśli 0, <paramref name="span" /> równa <paramref name="other" />się.<br />   -Jeśli jest większa niż 0 <paramref name="span" /> , <paramref name="other" />następuje.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public static bool Contains (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Contains : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.Contains (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy.</param>
        <param name="value">Wartość, która ma być przeszukiwana w zakresie źródłowym.</param>
        <param name="comparisonType">Wartość wyliczenia określająca sposób porównywania znaków w <paramref name="span" /> i <paramref name="value" /> .</param>
        <summary>Wskazuje, czy określona wartość występuje w ramach zakresu znaków tylko do odczytu.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> występuje w obrębie zakresu, <see langword="false" /> w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(ReadOnlySpan&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member Contains : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Contains (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value">Wartość do wyszukania.</param>
        <summary>Wskazuje, czy określona wartość jest znaleziona w zakresie tylko do odczytu. Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</summary>
        <returns><see langword="true" /><see langword="false" /> w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;T&gt; (this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of T As IEquatable(Of T)) (span As Span(Of T), value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(Span&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member Contains : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Contains (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value">Wartość do wyszukania.</param>
        <summary>Wskazuje, czy określona wartość jest znaleziona w zakresie. Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</summary>
        <returns><see langword="true" /><see langword="false" /> w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopyTo&lt;T&gt; (this T[] source, Memory&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo&lt;T&gt;(!!T[] source, valuetype System.Memory`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo(Of T) (source As T(), destination As Memory(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(cli::array &lt;T&gt; ^ source, Memory&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : 'T[] * Memory&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T[]" RefType="this" />
        <Parameter Name="destination" Type="System.Memory&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="source">Tablica, z której mają zostać skopiowane elementy.</param>
        <param name="destination">Pamięć, do której mają zostać skopiowane elementy.</param>
        <summary>Kopiuje zawartość tablicy do regionu pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Jeśli `source` i`destination` nakładają się, ta metoda zachowuje się tak, jakby oryginalne wartości znajdują się w tymczasowej lokalizacji przed zastąpieniem lokalizacji docelowej.

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Miejsce docelowe jest krótsze niż tablica źródłowa.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopyTo&lt;T&gt; (this T[] source, Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo&lt;T&gt;(!!T[] source, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo(Of T) (source As T(), destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(cli::array &lt;T&gt; ^ source, Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : 'T[] * Span&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T[]" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="source">Tablica, z której mają zostać skopiowane elementy.</param>
        <param name="destination">Zakres, do którego mają zostać skopiowane elementy.</param>
        <summary>Kopiuje zawartość tablicy do zakresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Jeśli `source` i`destination` nakładają się, ta metoda zachowuje się tak, jakby oryginalne wartości znajdują się w tymczasowej lokalizacji przed zastąpieniem lokalizacji docelowej.

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Zakres docelowy jest krótszy niż tablica źródłowa.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public static bool EndsWith (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsWith(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EndsWith (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool EndsWith(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member EndsWith : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.EndsWith (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy.</param>
        <param name="value">Sekwencja do porównania na końcu zakresu źródłowego.</param>
        <param name="comparisonType">Wartość wyliczenia, która określa, <paramref name="span" /> jak <paramref name="value" /> i są porównywane.</param>
        <summary>Określa, czy koniec elementu <paramref name="span" /> pasuje do określonego <paramref name="value" /> w porównaniu z określoną <paramref name="comparisonType" /> opcją.</summary>
        <returns><see langword="true" />w <paramref name="value" /> przypadku dopasowania do <paramref name="span" />końca; w przeciwnym <see langword="false" />razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool EndsWith&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EndsWith(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool EndsWith(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member EndsWith : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.EndsWith (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu.</typeparam>
        <param name="span">Zakres źródłowy.</param>
        <param name="value">Sekwencja do porównania na końcu zakresu źródłowego.</param>
        <summary>Określa, czy określona sekwencja pojawia się na końcu zakresu tylko do odczytu.</summary>
        <returns><see langword="true" />w <paramref name="value" /> przypadku dopasowania do <paramref name="span" />końca; w przeciwnym <see langword="false" />razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool EndsWith&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EndsWith(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool EndsWith(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member EndsWith : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.EndsWith (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu.</typeparam>
        <param name="span">Zakres źródłowy.</param>
        <param name="value">Sekwencja do porównania na końcu zakresu źródłowego.</param>
        <summary>Określa, czy określona sekwencja pojawia się na końcu zakresu.</summary>
        <returns><see langword="true" />w <paramref name="value" /> przypadku dopasowania do <paramref name="span" />końca; w przeciwnym <see langword="false" />razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public static System.Text.SpanRuneEnumerator EnumerateRunes (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.SpanRuneEnumerator EnumerateRunes(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnumerateRunes (span As ReadOnlySpan(Of Char)) As SpanRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Text::SpanRuneEnumerator EnumerateRunes(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member EnumerateRunes : ReadOnlySpan&lt;char&gt; -&gt; System.Text.SpanRuneEnumerator" Usage="System.MemoryExtensions.EnumerateRunes span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.SpanRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy.</param>
        <summary>Zwraca Wyliczenie <see cref="T:System.Text.Rune" /> z podanego zakresu tylko do odczytu.</summary>
        <returns>Moduł wyliczający Rune.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Nieprawidłowe sekwencje będą reprezentowane w wyliczeniu <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>przez.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public static System.Text.SpanRuneEnumerator EnumerateRunes (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.SpanRuneEnumerator EnumerateRunes(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnumerateRunes (span As Span(Of Char)) As SpanRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Text::SpanRuneEnumerator EnumerateRunes(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member EnumerateRunes : Span&lt;char&gt; -&gt; System.Text.SpanRuneEnumerator" Usage="System.MemoryExtensions.EnumerateRunes span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.SpanRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy.</param>
        <summary>Zwraca Wyliczenie <see cref="T:System.Text.Rune" /> z podanego zakresu.</summary>
        <returns>Moduł wyliczający Rune.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Nieprawidłowe sekwencje będą reprezentowane w wyliczeniu <xref:System.Text.Rune.ReplacementChar>przez.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; other, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Equals (span As ReadOnlySpan(Of Char), other As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Equals(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.Equals (span, other, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy.</param>
        <param name="other">Wartość do porównania z zakresem źródłowym.</param>
        <param name="comparisonType">Wartość wyliczenia, która określa, <paramref name="span" /> jak <paramref name="other" /> i są porównywane.</param>
        <summary>Określa, czy <paramref name="span" /> ten i określony <paramref name="other" /> zakres ma te same znaki w porównaniu z określoną <paramref name="comparisonType" /> opcją.</summary>
        <returns><see langword="true" />Jeśli jest równe <see langword="false" /> , w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member IndexOf : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.MemoryExtensions.IndexOf (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy.</param>
        <param name="value">Wartość, która ma być przeszukiwana w zakresie źródłowym.</param>
        <param name="comparisonType">Wartość wyliczenia, która określa, <paramref name="span" /> jak <paramref name="value" /> i są porównywane.</param>
        <summary>Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego <paramref name="value" /> w bieżącym. <paramref name="span" /></summary>
        <returns>Indeks wystąpienia wartości w zakresie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value">Sekwencja do wyszukania.</param>
        <summary>Wyszukuje określoną sekwencję i zwraca indeks pierwszego wystąpienia. Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</summary>
        <returns>Indeks wystąpienia wartości w zakresie. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(ReadOnlySpan&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value">Wartość do wyszukania.</param>
        <summary>Wyszukuje określoną wartość i zwraca indeks pierwszego wystąpienia. Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</summary>
        <returns>Indeks wystąpienia wartości w zakresie. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości..</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value">Sekwencja do wyszukania.</param>
        <summary>Wyszukuje określoną sekwencję i zwraca indeks pierwszego wystąpienia. Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</summary>
        <returns>Indeks wystąpienia wartości w zakresie. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Span&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value">Wartość do wyszukania.</param>
        <summary>Wyszukuje określoną wartość i zwraca indeks pierwszego wystąpienia. Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</summary>
        <returns>Indeks wystąpienia wartości w zakresie. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="values">Zbiór wartości do wyszukania.</param>
        <summary>Wyszukuje pierwszy indeks wszelkich określonych wartości podobne do wywoływania IndexOf kilka razy przy użyciu operatora logicznego OR.</summary>
        <returns>Pierwszy indeks wystąpienia dowolnych wartości z zakresu. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="values">Zbiór wartości do wyszukania.</param>
        <summary>Wyszukuje pierwszy indeks wszelkich określonych wartości podobne do wywoływania IndexOf kilka razy przy użyciu operatora logicznego OR.</summary>
        <returns>Pierwszy indeks wystąpienia dowolnych wartości z zakresu. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value0">Jedna z wartości do wyszukania.</param>
        <param name="value1">Jedna z wartości do wyszukania.</param>
        <summary>Wyszukuje pierwszy indeks wszelkich określonych wartości podobne do wywoływania IndexOf kilka razy przy użyciu operatora logicznego OR.</summary>
        <returns>Pierwszy indeks wystąpienia dowolnych wartości z zakresu. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(Span&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value0">Jedna z wartości do wyszukania.</param>
        <param name="value1">Jedna z wartości do wyszukania.</param>
        <summary>Wyszukuje pierwszy indeks wszelkich określonych wartości podobne do wywoływania IndexOf kilka razy przy użyciu operatora logicznego OR.</summary>
        <returns>Pierwszy indeks wystąpienia dowolnych wartości z zakresu. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value0">Jedna z wartości do wyszukania.</param>
        <param name="value1">Jedna z wartości do wyszukania.</param>
        <param name="value2">Jedna z wartości do wyszukania.</param>
        <summary>Wyszukuje pierwszy indeks wszelkich określonych wartości podobne do wywoływania IndexOf kilka razy przy użyciu operatora logicznego OR.</summary>
        <returns>Pierwszy indeks wystąpienia dowolnych wartości z zakresu. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(Span&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value0">Jedna z wartości do wyszukania.</param>
        <param name="value1">Jedna z wartości do wyszukania.</param>
        <param name="value2">Jedna z wartości do wyszukania.</param>
        <summary>Wyszukuje pierwszy indeks wszelkich określonych wartości podobne do wywoływania IndexOf kilka razy przy użyciu operatora logicznego OR.</summary>
        <returns>Pierwszy indeks wystąpienia dowolnych wartości z zakresu. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsWhiteSpace (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsWhiteSpace(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.MemoryExtensions.IsWhiteSpace span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy.</param>
        <summary>Wskazuje, czy określony zakres zawiera tylko białe znaki.</summary>
        <returns><see langword="true" />Jeśli zakres zawiera tylko białe znaki, <see langword="false" /> w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.MemoryExtensions.LastIndexOf (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy.</param>
        <param name="value">Wartość, która ma być przeszukiwana w zakresie źródłowym.</param>
        <param name="comparisonType">Wartość wyliczenia, która określa, <paramref name="span" /> jak <paramref name="value" /> i są porównywane.</param>
        <summary>Raportuje indeks od zera ostatniego wystąpienia określonego <paramref name="value" /> w bieżącym. <paramref name="span" /></summary>
        <returns>Indeks ostatniego wystąpienia wartości w zakresie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value">Sekwencja do wyszukania.</param>
        <summary>Wyszukuje określoną sekwencję i zwraca indeks ostatniego wystąpienia. Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</summary>
        <returns>Indeks ostatniego wystąpienia wartości w zakresie. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(ReadOnlySpan&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value">Wartość do wyszukania.</param>
        <summary>Wyszukuje określoną wartość i zwraca indeks ostatniego wystąpienia. Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</summary>
        <returns>Indeks ostatniego wystąpienia wartości w zakresie. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value">Sekwencja do wyszukania.</param>
        <summary>Wyszukuje określoną sekwencję i zwraca indeks ostatniego wystąpienia. Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</summary>
        <returns>Indeks ostatniego wystąpienia wartości w zakresie. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(Span&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value">Wartość do wyszukania.</param>
        <summary>Wyszukuje określoną wartość i zwraca indeks ostatniego wystąpienia. Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</summary>
        <returns>Indeks ostatniego wystąpienia wartości w zakresie. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="values">Zbiór wartości do wyszukania.</param>
        <summary>Wyszukuje ostatni indeks wszelkich określonych wartości podobnie do wywoływania LastIndexOf kilka razy przy użyciu operatora logicznego OR.</summary>
        <returns>Indeks ostatnich wystąpień dowolnych wartości w zakresie. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="values">Zbiór wartości do wyszukania.</param>
        <summary>Wyszukuje ostatni indeks wszelkich określonych wartości podobnie do wywoływania LastIndexOf kilka razy przy użyciu operatora logicznego OR.</summary>
        <returns>Indeks ostatnich wystąpień dowolnych wartości w zakresie. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value0">Jedna z wartości do wyszukania.</param>
        <param name="value1">Jedna z wartości do wyszukania.</param>
        <summary>Wyszukuje ostatni indeks wszelkich określonych wartości podobnie do wywoływania LastIndexOf kilka razy przy użyciu operatora logicznego OR.</summary>
        <returns>Indeks ostatnich wystąpień dowolnych wartości w zakresie. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(Span&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value0">Jedna z wartości do wyszukania.</param>
        <param name="value1">Jedna z wartości do wyszukania.</param>
        <summary>Wyszukuje ostatni indeks wszelkich określonych wartości podobnie do wywoływania LastIndexOf kilka razy przy użyciu operatora logicznego OR.</summary>
        <returns>Indeks ostatnich wystąpień dowolnych wartości w zakresie. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value0">Jedna z wartości do wyszukania.</param>
        <param name="value1">Jedna z wartości do wyszukania.</param>
        <param name="value2">Jedna z wartości do wyszukania.</param>
        <summary>Wyszukuje ostatni indeks wszelkich określonych wartości podobnie do wywoływania LastIndexOf kilka razy przy użyciu operatora logicznego OR.</summary>
        <returns>Indeks ostatnich wystąpień dowolnych wartości w zakresie. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(Span&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zakresu i wartości.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value0">Jedna z wartości do wyszukania.</param>
        <param name="value1">Jedna z wartości do wyszukania.</param>
        <param name="value2">Jedna z wartości do wyszukania.</param>
        <summary>Wyszukuje ostatni indeks wszelkich określonych wartości podobnie do wywoływania LastIndexOf kilka razy przy użyciu operatora logicznego OR.</summary>
        <returns>Indeks ostatnich wystąpień dowolnych wartości w zakresie. Jeśli nie zostanie znaleziony, zwraca-1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member Overlaps : ReadOnlySpan&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elmeents w sekwencji tylko do odczytu.</typeparam>
        <param name="span">Pierwsza sekwencja.</param>
        <param name="other">Druga sekwencja.</param>
        <summary>Określa, czy dwie sekwencje tylko do odczytu nakładają się na pamięć.</summary>
        <returns><see langword="true" />Jeśli dwie sekwencje nakładają się; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As Span(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member Overlaps : Span&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie.</typeparam>
        <param name="span">Zakres do porównania.</param>
        <param name="other">Zakres tylko do odczytu do porównania.</param>
        <summary>Określa, czy zakres i zakres tylko do odczytu nakładają się na pamięć.</summary>
        <returns><see langword="true" />Jeśli dwie sekwencje nakładają się; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, out int elementOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other, [out] int32&amp; elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T), ByRef elementOffset As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, [Runtime::InteropServices::Out] int % elementOffset);" />
      <MemberSignature Language="F#" Value="static member Overlaps : ReadOnlySpan&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; *  -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other, elementOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="elementOffset" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie.</typeparam>
        <param name="span">Pierwsza sekwencja.</param>
        <param name="other">Druga sekwencja.</param>
        <param name="elementOffset">To be added.</param>
        <summary>Określa, czy dwie sekwencje tylko do odczytu nakładają się na pamięć i wyprowadzają przesunięcie elementu.</summary>
        <returns><see langword="true" />Jeśli dwie sekwencje nakładają się; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, out int elementOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other, [out] int32&amp; elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As Span(Of T), other As ReadOnlySpan(Of T), ByRef elementOffset As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, [Runtime::InteropServices::Out] int % elementOffset);" />
      <MemberSignature Language="F#" Value="static member Overlaps : Span&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; *  -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other, elementOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="elementOffset" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie.</typeparam>
        <param name="span">Pierwsza sekwencja do porównania.</param>
        <param name="other">Druga sekwencja do porównania.</param>
        <param name="elementOffset">Gdy metoda zwraca, zawiera przesunięcie między <paramref name="span" /> i. <paramref name="other" /></param>
        <summary>Określa, czy zakres i zakres tylko do odczytu nakładają się na pamięć i wyprowadzają przesunięcie elementu.</summary>
        <returns><see langword="true" />Jeśli dwie sekwencje nakładają się; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (this Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Reverse``1(System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Reverse(Of T) (span As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Reverse(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member Reverse : Span&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.Reverse span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie.</typeparam>
        <param name="span">Zakres do odwrócenia.</param>
        <summary>Odwraca sekwencję elementów w całym zakresie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceCompareTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SequenceCompareTo&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IComparable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SequenceCompareTo&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceCompareTo(Of T As IComparable(Of T)) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int SequenceCompareTo(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceCompareTo : ReadOnlySpan&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceCompareTo (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w sekwencji.</typeparam>
        <param name="span">Pierwsza sekwencja do porównania.</param>
        <param name="other">Druga sekwencja do porównania.</param>
        <summary>Określa względną kolejność dwóch sekwencji tylko do odczytu, porównując ich elementy przy użyciu obiektu IComparable {T}. CompareTo (T).</summary>
        <returns>Liczba całkowita ze znakiem, która wskazuje względną <paramref name="other" />kolejność dla <paramref name="span" /> i:<br />   -Jeśli jest mniejsza niż 0 <paramref name="span" /> , poprzedza. <paramref name="other" /><br />   -Jeśli 0, <paramref name="span" /> równa <paramref name="other" />się.<br />   -Jeśli jest większa niż 0 <paramref name="span" /> , <paramref name="other" />następuje.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceCompareTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SequenceCompareTo&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IComparable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SequenceCompareTo&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceCompareTo(Of T As IComparable(Of T)) (span As Span(Of T), other As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int SequenceCompareTo(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceCompareTo : Span&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceCompareTo (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie.</typeparam>
        <param name="span">Zakres do porównania.</param>
        <param name="other">Zakres tylko do odczytu do porównania.</param>
        <summary>Określa względną kolejność zakresu i przedział tylko do odczytu, porównując elementy przy użyciu elementu IComparable {T}. CompareTo (T).</summary>
        <returns>Liczba całkowita ze znakiem, która wskazuje względną <paramref name="other" />kolejność dla <paramref name="span" /> i:<br />   -Jeśli jest mniejsza niż 0 <paramref name="span" /> , poprzedza. <paramref name="other" /><br />   -Jeśli 0, <paramref name="span" /> równa <paramref name="other" />się.<br />   -Jeśli jest większa niż 0 <paramref name="span" /> , <paramref name="other" />następuje.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceEqual (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w sekwencji.</typeparam>
        <param name="span">Pierwsza sekwencja do porównania.</param>
        <param name="other">Druga sekwencja do porównania.</param>
        <summary>Określa, czy dwie sekwencje tylko do odczytu są równe, porównując elementy przy użyciu IEquatable {T}. Equals (T).</summary>
        <returns><see langword="true" />Jeśli dwie sekwencje są równe; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of T As IEquatable(Of T)) (span As Span(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceEqual (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w sekwencji.</typeparam>
        <param name="span">Zakres do porównania.</param>
        <param name="other">Zakres tylko do odczytu do porównania.</param>
        <summary>Określa, czy zakres i zakres tylko do odczytu są równe, porównując elementy przy użyciu IEquatable {T}. Equals (T).</summary>
        <returns><see langword="true" />Jeśli dwie sekwencje są równe; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public static bool StartsWith (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool StartsWith(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartsWith (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool StartsWith(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member StartsWith : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.StartsWith (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy.</param>
        <param name="value">Sekwencja do porównania na początku zakresu źródłowego.</param>
        <param name="comparisonType">Wartość wyliczenia, która określa, <paramref name="span" /> jak <paramref name="value" /> i są porównywane.</param>
        <summary>Określa, czy zakres znaków tylko do odczytu rozpoczyna się od określonej wartości w porównaniu z użyciem określonej <see cref="T:System.StringComparison" /> wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest zgodny z <paramref name="span" />początkiem; w <see langword="false" />przeciwnym razie,.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool StartsWith&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool StartsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartsWith(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool StartsWith(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member StartsWith : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.StartsWith (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie.</typeparam>
        <param name="span">Zakres znaków tylko do odczytu do wyszukania.</param>
        <param name="value">Sekwencja wyszukiwania na początku <paramref name="span" />.</param>
        <summary>Określa, czy określona sekwencja pojawia się na początku zakresu tylko do odczytu.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest zgodny z <paramref name="span" />początkiem; w <see langword="false" />przeciwnym razie,.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool StartsWith&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool StartsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartsWith(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool StartsWith(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member StartsWith : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.StartsWith (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie.</typeparam>
        <param name="span">Zakres, który ma zostać wyszukany.</param>
        <param name="value">Sekwencja wyszukiwania na początku <paramref name="span" />.</param>
        <summary>Określa, czy określona sekwencja pojawia się na początku zakresu.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest zgodny z <paramref name="span" />początkiem; w <see langword="false" />przeciwnym razie,.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static int ToLower (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToLower(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLower (source As ReadOnlySpan(Of Char), destination As Span(Of Char), culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToLower(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToLower : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * System.Globalization.CultureInfo -&gt; int" Usage="System.MemoryExtensions.ToLower (source, destination, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="source">Zakres źródłowy.</param>
        <param name="destination">Zakres docelowy, który zawiera przekształcone znaki.</param>
        <param name="culture">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</param>
        <summary>Kopiuje znaki z zakresu źródłowego do lokalizacji docelowej, konwertując każdy znak na małe litery, używając reguł wielkości liter w określonej kulturze.</summary>
        <returns>Liczba znaków zapisanych do zakresu docelowego. Jeśli miejsce docelowe jest zbyt małe, zwraca wartość-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `culture` jest `null` ,<xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> zostanie użyty.

            ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bufory źródłowe i docelowe nakładają się na siebie.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public static int ToLowerInvariant (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToLowerInvariant(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLowerInvariant (source As ReadOnlySpan(Of Char), destination As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToLowerInvariant(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="F#" Value="static member ToLowerInvariant : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; -&gt; int" Usage="System.MemoryExtensions.ToLowerInvariant (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Zakres źródłowy.</param>
        <param name="destination">Zakres docelowy, który zawiera przekształcone znaki.</param>
        <summary>Kopiuje znaki z zakresu źródłowego do lokalizacji docelowej, konwertując każdy znak na małe litery, używając reguł wielkości liter kultury niezmiennej.</summary>
        <returns>Liczba znaków zapisanych do zakresu docelowego. Jeśli miejsce docelowe jest zbyt małe, zwraca wartość-1.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Bufory źródłowe i docelowe nakładają się na siebie.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static int ToUpper (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToUpper(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUpper (source As ReadOnlySpan(Of Char), destination As Span(Of Char), culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToUpper(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToUpper : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * System.Globalization.CultureInfo -&gt; int" Usage="System.MemoryExtensions.ToUpper (source, destination, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="source">Zakres źródłowy.</param>
        <param name="destination">Zakres docelowy, który zawiera przekształcone znaki.</param>
        <param name="culture">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</param>
        <summary>Kopiuje znaki z zakresu źródłowego do lokalizacji docelowej, konwertując każdy znak na wielkie litery przy użyciu reguł wielkości liter w określonej kulturze.</summary>
        <returns>Liczba znaków zapisanych do zakresu docelowego. Jeśli miejsce docelowe jest zbyt małe, zwraca wartość-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `culture` jest `null` ,<xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> zostanie użyty.

            ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bufory źródłowe i docelowe nakładają się na siebie.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public static int ToUpperInvariant (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToUpperInvariant(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUpperInvariant (source As ReadOnlySpan(Of Char), destination As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToUpperInvariant(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="F#" Value="static member ToUpperInvariant : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; -&gt; int" Usage="System.MemoryExtensions.ToUpperInvariant (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Zakres źródłowy.</param>
        <param name="destination">Zakres docelowy, który zawiera przekształcone znaki.</param>
        <summary>Kopiuje znaki z zakresu źródłowego do lokalizacji docelowej, konwertując każdy znak na wielkie litery przy użyciu reguł wielkości liter kultury niezmiennej.</summary>
        <returns>Liczba znaków zapisanych do zakresu docelowego. Jeśli miejsce docelowe jest zbyt małe, zwraca wartość-1.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Bufory źródłowe i docelowe nakładają się na siebie.</exception>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static Memory&lt;char&gt; Trim (this Memory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;char&gt; Trim(valuetype System.Memory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.Memory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (memory As Memory(Of Char)) As Memory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;char&gt; Trim(Memory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member Trim : Memory&lt;char&gt; -&gt; Memory&lt;char&gt;" Usage="System.MemoryExtensions.Trim memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="memory">Pamięć źródłowa, z której są usuwane znaki.</param>
        <summary>Usuwa wszystkie spacje wiodące i końcowe z regionu pamięci znaku.</summary>
        <returns>Przycięty region pamięci.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; Trim (this ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; Trim(valuetype System.ReadOnlyMemory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (memory As ReadOnlyMemory(Of Char)) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; Trim(ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlyMemory&lt;char&gt; -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.Trim memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="memory">Pamięć źródłowa, z której są usuwane znaki.</param>
        <summary>Usuwa wszystkie spacje wiodące i końcowe z obszaru pamięci tylko do odczytu.</summary>
        <returns>Przycięty region pamięci.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; Trim (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; Trim(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; Trim(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.Trim span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy, z którego znaki są usuwane.</param>
        <summary>Usuwa wszystkie spacje wiodące i końcowe z zakresu znaków tylko do odczytu.</summary>
        <returns>Przycięty zakres znaków tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static Span&lt;char&gt; Trim (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;char&gt; Trim(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As Span(Of Char)) As Span(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;char&gt; Trim(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member Trim : Span&lt;char&gt; -&gt; Span&lt;char&gt;" Usage="System.MemoryExtensions.Trim span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy, z którego znaki są usuwane.</param>
        <summary>Usuwa wszystkie spacje wiodące i końcowe z zakresu znaków.</summary>
        <returns>Przycięty zakres znaków.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; Trim (this ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; Trim(valuetype System.ReadOnlySpan`1&lt;char&gt; span, char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As ReadOnlySpan(Of Char), trimChar As Char) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; Trim(ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;char&gt; * char -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.Trim (span, trimChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy, z którego jest usuwany znak.</param>
        <param name="trimChar">Określony znak, który ma być wyszukiwany i usunięty.</param>
        <summary>Usuwa wszystkie wystąpienia wiodące i końcowe określonego znaku z zakresu znaków tylko do odczytu.</summary>
        <returns>Przycięty zakres znaków tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; Trim (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; Trim(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As ReadOnlySpan(Of Char), trimChars As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; Trim(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.Trim (span, trimChars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy, z którego znaki są usuwane.</param>
        <param name="trimChars">Zakres, który zawiera zestaw znaków do usunięcia.</param>
        <summary>Usuwa wszystkie wystąpienia wiodące i końcowe zestawu znaków określone w okresie tylko do odczytu z zakresu znaków tylko do odczytu.</summary>
        <returns>Przycięty zakres znaków tylko do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimChars` jest pusty, zamiast tego są usuwane znaki odstępu.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; Trim&lt;T&gt; (this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElements As ReadOnlySpan(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; Trim(Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w regionie pamięci.</typeparam>
        <param name="memory">Pamięć źródłowa, z której zostaną usunięte elementy.</param>
        <param name="trimElements">Zakres, który zawiera zestaw elementów do usunięcia.</param>
        <summary>Usuwa wszystkie początkowe i końcowe wystąpienia zestawu elementów określonych w zakresie tylko do odczytu z regionu pamięci.</summary>
        <returns>Przycięty region pamięci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimElements` jest pusty, pamięć jest zwracana bez zmian.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; Trim&lt;T&gt; (this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElement As T) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; Trim(Memory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w regionie pamięci.</typeparam>
        <param name="memory">Pamięć źródłowa, z której element jest usuwany.</param>
        <param name="trimElement">Określony element do wyszukania i usunięcia.</param>
        <summary>Usuwa wszystkie wystąpienia wiodące i końcowe określonego elementu z regionu pamięci.</summary>
        <returns>Przycięty region pamięci.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; Trim&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; Trim(ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w regionie pamięci tylko do odczytu.</typeparam>
        <param name="memory">Pamięć źródłowa, z której zostaną usunięte elementy.</param>
        <param name="trimElements">Zakres, który zawiera zestaw elementów do usunięcia.</param>
        <summary>Usuwa wszystkie wystąpienia wiodące i końcowe zestawu elementów określonych w obszarze tylko do odczytu z obszaru pamięci tylko do odczytu.</summary>
        <returns>Przycięty region pamięci tylko do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimElements` jest pusty, pamięć jest zwracana bez zmian.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; Trim&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElement As T) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; Trim(ReadOnlyMemory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w regionie pamięci tylko do odczytu.</typeparam>
        <param name="memory">Pamięć źródłowa, z której element jest usuwany.</param>
        <param name="trimElement">Określony element do wyszukania i usunięcia.</param>
        <summary>Usuwa wszystkie wystąpienia wiodące i końcowe określonego elementu z obszaru pamięci tylko do odczytu.</summary>
        <returns>Przycięty region pamięci tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; Trim&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; Trim(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie tylko do odczytu.</typeparam>
        <param name="span">Zakres źródłowy, z którego elementy są usuwane.</param>
        <param name="trimElements">Zakres, który zawiera zestaw elementów do usunięcia.</param>
        <summary>Usuwa wszystkie wystąpienia wiodące i końcowe zestawu elementów określonych w zakresie tylko do odczytu z zakresu tylko do odczytu.</summary>
        <returns>Przycięty zakres tylko do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimElements` jest pusty, zakres jest zwracany bez zmian.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; Trim&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElement As T) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; Trim(ReadOnlySpan&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie tylko do odczytu.</typeparam>
        <param name="span">Zakres źródłowy, z którego element jest usuwany.</param>
        <param name="trimElement">Określony element do wyszukania i usunięcia.</param>
        <summary>Usuwa wszystkie wystąpienia wiodące i końcowe określonego elementu z zakresu tylko do odczytu.</summary>
        <returns>Przycięty zakres tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Trim&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As Span(Of T), trimElements As ReadOnlySpan(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; Trim(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie.</typeparam>
        <param name="span">Zakres źródłowy, z którego elementy są usuwane.</param>
        <param name="trimElements">Zakres, który zawiera zestaw elementów do usunięcia.</param>
        <summary>Usuwa wszystkie wystąpienia wiodące i końcowe zestawu elementów określonych w zakresie tylko do odczytu z zakresu.</summary>
        <returns>Przycięty zakres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimElements` jest pusty, zakres jest zwracany bez zmian.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Trim&lt;T&gt; (this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As Span(Of T), trimElement As T) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; Trim(Span&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie.</typeparam>
        <param name="span">Zakres źródłowy, z którego element jest usuwany.</param>
        <param name="trimElement">Określony element do wyszukania i usunięcia.</param>
        <summary>Usuwa wszystkie wystąpienia wiodące i końcowe określonego elementu z zakresu.</summary>
        <returns>Przycięty zakres.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static Memory&lt;char&gt; TrimEnd (this Memory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;char&gt; TrimEnd(valuetype System.Memory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (memory As Memory(Of Char)) As Memory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;char&gt; TrimEnd(Memory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Memory&lt;char&gt; -&gt; Memory&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="memory">Pamięć źródłowa, z której są usuwane znaki.</param>
        <summary>Usuwa wszystkie końcowe znaki odstępu z regionu pamięci znaku.</summary>
        <returns>Przycięty region pamięci.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; TrimEnd (this ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlyMemory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (memory As ReadOnlyMemory(Of Char)) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; TrimEnd(ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlyMemory&lt;char&gt; -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="memory">Pamięć źródłowa, z której są usuwane znaki.</param>
        <summary>Usuwa wszystkie końcowe znaki odstępu z obszaru pamięci tylko do odczytu.</summary>
        <returns>Przycięty zakres znaków tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEnd (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimEnd(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy, z którego znaki są usuwane.</param>
        <summary>Usuwa wszystkie końcowe znaki odstępu z zakresu znaków tylko do odczytu.</summary>
        <returns>Przycięty zakres znaków tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static Span&lt;char&gt; TrimEnd (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;char&gt; TrimEnd(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As Span(Of Char)) As Span(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;char&gt; TrimEnd(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Span&lt;char&gt; -&gt; Span&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy, z którego znaki są usuwane.</param>
        <summary>Usuwa wszystkie końcowe znaki odstępu z zakresu znaków.</summary>
        <returns>Przycięty zakres znaków.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEnd (this ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlySpan`1&lt;char&gt; span, char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As ReadOnlySpan(Of Char), trimChar As Char) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimEnd(ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;char&gt; * char -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd (span, trimChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy, z którego jest usuwany znak.</param>
        <param name="trimChar">Określony znak, który ma być wyszukiwany i usunięty.</param>
        <summary>Usuwa wszystkie końcowe wystąpienia określonego znaku z zakresu tylko do odczytu.</summary>
        <returns>Przycięty zakres znaków tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEnd (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As ReadOnlySpan(Of Char), trimChars As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimEnd(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd (span, trimChars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy, z którego znaki są usuwane.</param>
        <param name="trimChars">Zakres, który zawiera zestaw znaków do usunięcia.</param>
        <summary>Usuwa wszystkie końcowe wystąpienia zestawu znaków określone w zakresie tylko do odczytu z zakresu znaków tylko do odczytu.</summary>
        <returns>Przycięty zakres znaków tylko do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimChars` jest pusty, zamiast tego są usuwane znaki odstępu.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; TrimEnd&lt;T&gt; (this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElements As ReadOnlySpan(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimEnd(Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w regionie pamięci.</typeparam>
        <param name="memory">Pamięć źródłowa, z której zostaną usunięte elementy.</param>
        <param name="trimElements">Zakres, który zawiera zestaw elementów do usunięcia.</param>
        <summary>Usuwa wszystkie końcowe wystąpienia zestawu elementów określone w ramach obszaru pamięci tylko do odczytu.</summary>
        <returns>Przycięty region pamięci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimElements` jest pusty, pamięć jest zwracana bez zmian.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; TrimEnd&lt;T&gt; (this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElement As T) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimEnd(Memory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w regionie pamięci.</typeparam>
        <param name="memory">Pamięć źródłowa, z której element jest usuwany.</param>
        <param name="trimElement">Określony element do wyszukania i usunięcia.</param>
        <summary>Usuwa wszystkie końcowe wystąpienia określonego elementu z obszaru pamięci znaku.</summary>
        <returns>Przycięty region pamięci.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; TrimEnd&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimEnd(ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w regionie pamięci tylko do odczytu.</typeparam>
        <param name="memory">Pamięć źródłowa, z której zostaną usunięte elementy.</param>
        <param name="trimElements">Zakres, który zawiera zestaw elementów do usunięcia.</param>
        <summary>Usuwa wszystkie końcowe wystąpienia zestawu elementów określonego w obszarze tylko do odczytu z obszaru pamięci tylko do odczytu.</summary>
        <returns>Przycięty region pamięci tylko do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimElements` jest pusty, pamięć jest zwracana bez zmian.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; TrimEnd&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElement As T) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimEnd(ReadOnlyMemory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w regionie pamięci tylko do odczytu.</typeparam>
        <param name="memory">Pamięć źródłowa, z której element jest usuwany.</param>
        <param name="trimElement">Określony element do wyszukania i usunięcia.</param>
        <summary>Usuwa wszystkie końcowe wystąpienia określonego elementu z obszaru pamięci tylko do odczytu.</summary>
        <returns>Przycięty region pamięci tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; TrimEnd&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimEnd(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie tylko do odczytu.</typeparam>
        <param name="span">Zakres źródłowy, z którego elementy są usuwane.</param>
        <param name="trimElements">Zakres, który zawiera zestaw elementów do usunięcia.</param>
        <summary>Usuwa wszystkie końcowe wystąpienia zestawu elementów określone w zakresie tylko do odczytu z zakresu tylko do odczytu.</summary>
        <returns>Przycięty zakres tylko do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimElements` jest pusty, zakres jest zwracany bez zmian.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; TrimEnd&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElement As T) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimEnd(ReadOnlySpan&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie tylko do odczytu.</typeparam>
        <param name="span">Zakres źródłowy, z którego element jest usuwany.</param>
        <param name="trimElement">Określony element do wyszukania i usunięcia.</param>
        <summary>Usuwa wszystkie końcowe wystąpienia określonego elementu z zakresu tylko do odczytu.</summary>
        <returns>Przycięty zakres tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; TrimEnd&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As Span(Of T), trimElements As ReadOnlySpan(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimEnd(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie.</typeparam>
        <param name="span">Zakres źródłowy, z którego elementy są usuwane.</param>
        <param name="trimElements">Zakres, który zawiera zestaw elementów do usunięcia.</param>
        <summary>Usuwa wszystkie końcowe wystąpienia zestawu elementów określone w zakresie tylko do odczytu z zakresu.</summary>
        <returns>Przycięty zakres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimElements` jest pusty, zakres jest zwracany bez zmian.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; TrimEnd&lt;T&gt; (this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As Span(Of T), trimElement As T) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimEnd(Span&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie.</typeparam>
        <param name="span">Zakres źródłowy, z którego element jest usuwany.</param>
        <param name="trimElement">Określony element do wyszukania i usunięcia.</param>
        <summary>Usuwa wszystkie końcowe wystąpienia określonego elementu z zakresu.</summary>
        <returns>Przycięty zakres.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static Memory&lt;char&gt; TrimStart (this Memory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;char&gt; TrimStart(valuetype System.Memory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (memory As Memory(Of Char)) As Memory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;char&gt; TrimStart(Memory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Memory&lt;char&gt; -&gt; Memory&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="memory">Pamięć źródłowa, z której są usuwane znaki.</param>
        <summary>Usuwa wszystkie wiodące znaki odstępu z regionu pamięci.</summary>
        <returns>Przycięty region pamięci.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; TrimStart (this ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; TrimStart(valuetype System.ReadOnlyMemory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (memory As ReadOnlyMemory(Of Char)) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; TrimStart(ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlyMemory&lt;char&gt; -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="memory">Pamięć źródłowa, z której są usuwane znaki.</param>
        <summary>Usuwa wszystkie wiodące znaki odstępu z obszaru pamięci tylko do odczytu.</summary>
        <returns>Przycięty region pamięci tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimStart (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimStart(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimStart(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy, z którego znaki są usuwane.</param>
        <summary>Usuwa wszystkie wiodące znaki odstępu z zakresu tylko do odczytu.</summary>
        <returns>Przycięty zakres znaków tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static Span&lt;char&gt; TrimStart (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;char&gt; TrimStart(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As Span(Of Char)) As Span(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;char&gt; TrimStart(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Span&lt;char&gt; -&gt; Span&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy, z którego znaki są usuwane.</param>
        <summary>Usuwa wszystkie wiodące znaki odstępu z zakresu.</summary>
        <returns>Przycięty zakres znaków.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimStart (this ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimStart(valuetype System.ReadOnlySpan`1&lt;char&gt; span, char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As ReadOnlySpan(Of Char), trimChar As Char) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimStart(ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;char&gt; * char -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart (span, trimChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy, z którego jest usuwany znak.</param>
        <param name="trimChar">Określony znak, który ma być wyszukiwany i usunięty.</param>
        <summary>Usuwa wszystkie wiodące wystąpienia określonego znaku z zakresu.</summary>
        <returns>Przycięty zakres znaków tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimStart (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimStart(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As ReadOnlySpan(Of Char), trimChars As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimStart(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart (span, trimChars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">Zakres źródłowy, z którego znaki są usuwane.</param>
        <param name="trimChars">Zakres, który zawiera zestaw znaków do usunięcia.</param>
        <summary>Usuwa wszystkie wiodące wystąpienia zestawu znaków określone w zakresie tylko do odczytu z zakresu.</summary>
        <returns>Przycięty zakres znaków tylko do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimChars` jest pusty, zamiast tego są usuwane znaki odstępu.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; TrimStart&lt;T&gt; (this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElements As ReadOnlySpan(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimStart(Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w regionie pamięci.</typeparam>
        <param name="memory">Pamięć źródłowa, z której zostaną usunięte elementy.</param>
        <param name="trimElements">Zakres, który zawiera zestaw elementów do usunięcia.</param>
        <summary>Usuwa wszystkie wiodące wystąpienia zestawu elementów określonego w ramach obszaru pamięci tylko do odczytu.</summary>
        <returns>Przycięty region pamięci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimElements` jest pusty, pamięć jest zwracana bez zmian.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; TrimStart&lt;T&gt; (this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElement As T) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimStart(Memory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w regionie pamięci.</typeparam>
        <param name="memory">Region pamięci źródłowej, z którego element jest usuwany.</param>
        <param name="trimElement">Określony element do wyszukania i usunięcia.</param>
        <summary>Usuwa wszystkie wiodące wystąpienia określonego elementu z regionu pamięci.</summary>
        <returns>Przycięty region pamięci.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; TrimStart&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimStart(ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w regionie pamięci tylko do odczytu.</typeparam>
        <param name="memory">Pamięć źródłowa, z której zostaną usunięte elementy.</param>
        <param name="trimElements">Zakres, który zawiera zestaw elementów do usunięcia.</param>
        <summary>Usuwa wszystkie wiodące wystąpienia zestawu elementów określonego w ramach obszaru pamięci tylko do odczytu.</summary>
        <returns>Przycięty region pamięci tylko do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimElements` jest pusty, pamięć jest zwracana bez zmian.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; TrimStart&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElement As T) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimStart(ReadOnlyMemory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w regionie pamięci tylko do odczytu.</typeparam>
        <param name="memory">Pamięć źródłowa, z której element jest usuwany.</param>
        <param name="trimElement">Określony element do wyszukania i usunięcia.</param>
        <summary>Usuwa wszystkie wiodące wystąpienia określonego elementu z regionu pamięci.</summary>
        <returns>Przycięty region pamięci tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; TrimStart&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimStart(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie tylko do odczytu.</typeparam>
        <param name="span">Zakres źródłowy, z którego elementy są usuwane.</param>
        <param name="trimElements">Zakres, który zawiera zestaw elementów do usunięcia.</param>
        <summary>Usuwa wszystkie wiodące wystąpienia zestawu elementów określonego w zakresie tylko do odczytu z zakresu.</summary>
        <returns>Przycięty zakres tylko do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimElements` jest pusty, zakres jest zwracany bez zmian.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; TrimStart&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElement As T) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimStart(ReadOnlySpan&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie tylko do odczytu.</typeparam>
        <param name="span">Zakres źródłowy, z którego element jest usuwany.</param>
        <param name="trimElement">Określony element do wyszukania i usunięcia.</param>
        <summary>Usuwa wszystkie wiodące wystąpienia określonego elementu z zakresu.</summary>
        <returns>Przycięty zakres tylko do odczytu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; TrimStart&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As Span(Of T), trimElements As ReadOnlySpan(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimStart(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie.</typeparam>
        <param name="span">Zakres źródłowy, z którego elementy są usuwane.</param>
        <param name="trimElements">Zakres, który zawiera zestaw elementów do usunięcia.</param>
        <summary>Usuwa wszystkie wiodące wystąpienia zestawu elementów określonego w zakresie tylko do odczytu z zakresu.</summary>
        <returns>Przycięty zakres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jeśli `trimElements` jest pusty, zakres jest zwracany bez zmian.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; TrimStart&lt;T&gt; (this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As Span(Of T), trimElement As T) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimStart(Span&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów w zakresie.</typeparam>
        <param name="span">Zakres źródłowy, z którego element jest usuwany.</param>
        <param name="trimElement">Określony element do wyszukania i usunięcia.</param>
        <summary>Usuwa wszystkie wiodące wystąpienia określonego elementu z zakresu.</summary>
        <returns>Przycięty zakres.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

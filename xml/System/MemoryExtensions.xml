<Type Name="MemoryExtensions" FullName="System.MemoryExtensions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9426dda9b1422045a6ade7998bd844c352f4df8b" /><Meta Name="ms.sourcegitcommit" Value="634678f7ccd2928c6b2cf792a301b079b63639af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/26/2019" /><Meta Name="ms.locfileid" Value="68539262" /></Metadata><TypeSignature Language="C#" Value="public static class MemoryExtensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit MemoryExtensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MemoryExtensions" />
  <TypeSignature Language="VB.NET" Value="Public Module MemoryExtensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryExtensions abstract sealed" />
  <TypeSignature Language="F#" Value="type MemoryExtensions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="3d729-101">Zapewnia metody rozszerzające dla typów pamięci i powiązanej z zakresem, takich jak <see cref="T:System.Memory`1" /> <see cref="T:System.Span`1" />, <see cref="T:System.ReadOnlyMemory`1" />, i <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-101">Provides extension methods for for the memory- and span-related types, such as <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" />, and <see cref="T:System.ReadOnlySpan`1" />.</span></span></summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="3d729-102">Ciąg docelowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-102">The target string.</span></span></param>
        <summary><span data-ttu-id="3d729-103">Tworzy nowy <see langword="ReadOnlyMemory&lt;Char&gt;" /> element względem części ciągu docelowego.</span><span class="sxs-lookup"><span data-stu-id="3d729-103">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over the portion of the target string.</span></span></summary>
        <returns><span data-ttu-id="3d729-104">Reprezentacja ciągu z pamięcią tylko do odczytu lub <see langword="default" /> Jeśli <paramref name="text" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-104">The read-only character memory representation of the string, or <see langword="default" /> if <paramref name="text" /> is <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String, startIndex As Index) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * Index -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="3d729-105">Ciąg docelowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-105">The target string.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d729-106">Indeks, w którym ma zostać umieszczony ten plasterek.</span><span class="sxs-lookup"><span data-stu-id="3d729-106">The index at which to begin this slice.</span></span></param>
        <summary><span data-ttu-id="3d729-107">Tworzy nową <see langword="ReadOnlyMemory&lt;Char&gt;" /> wartość dla części ciągu docelowego, zaczynając od określonego indeksu.</span><span class="sxs-lookup"><span data-stu-id="3d729-107">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over a portion of the target string starting at a specified index.</span></span></summary>
        <returns><span data-ttu-id="3d729-108">Reprezentacja ciągu z pamięcią tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-108">The read-only character memory representation of the string.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String, start As Integer) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, int start);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * int -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="3d729-109">Ciąg docelowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-109">The target string.</span></span></param>
        <param name="start"><span data-ttu-id="3d729-110">Indeks, w którym ma zostać umieszczony ten plasterek.</span><span class="sxs-lookup"><span data-stu-id="3d729-110">The index at which to begin this slice.</span></span></param>
        <summary><span data-ttu-id="3d729-111">Tworzy nową <see langword="ReadOnlyMemory&lt;Char&gt;" /> dla części ciągu docelowego, zaczynając od określonej pozycji znaku.</span><span class="sxs-lookup"><span data-stu-id="3d729-111">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over a portion of the target string starting at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="3d729-112">Reprezentacja ciągu z pamięcią tylko do odczytu lub <see langword="default" /> Jeśli <paramref name="text" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-112">The read-only character memory representation of the string, or <see langword="default" /> if <paramref name="text" /> is <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d729-113"><paramref name="start" />nie znajduje się w <paramref name="text" /> zakresie (<paramref name="start" /> is &lt; 0 lub &gt; Text) <c>. Długość</c>).</span><span class="sxs-lookup"><span data-stu-id="3d729-113"><paramref name="start" /> is not in the range of <paramref name="text" /> (<paramref name="start" /> is &lt; 0 or &gt; <c>text.Length</c>).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, Range range);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * Range -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="3d729-114">Ciąg docelowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-114">The target string.</span></span></param>
        <param name="range"><span data-ttu-id="3d729-115">Zakres, który wskazuje początek i długość ciągu z wycinkami.</span><span class="sxs-lookup"><span data-stu-id="3d729-115">The range that indicates the start and length of the sliced string.</span></span></param>
        <summary><span data-ttu-id="3d729-116">Tworzy nową <see langword="ReadOnlyMemory&lt;Char&gt;" /> wartość powyżej określonego zakresu ciągu docelowego.</span><span class="sxs-lookup"><span data-stu-id="3d729-116">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over a specified range of the target string.</span></span></summary>
        <returns><span data-ttu-id="3d729-117">Reprezentacja ciągu z pamięcią tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-117">The read-only character memory representation of the string.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String, start As Integer, length As Integer) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * int * int -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="3d729-118">Ciąg docelowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-118">The target string.</span></span></param>
        <param name="start"><span data-ttu-id="3d729-119">Indeks, w którym ma zostać umieszczony ten plasterek.</span><span class="sxs-lookup"><span data-stu-id="3d729-119">The index at which to begin this slice.</span></span></param>
        <param name="length"><span data-ttu-id="3d729-120">Wymagana długość wycinka.</span><span class="sxs-lookup"><span data-stu-id="3d729-120">The desired length for the slice.</span></span></param>
        <summary><span data-ttu-id="3d729-121">Tworzy nową <see langword="ReadOnlyMemory&lt;Char&gt;" /> wartość dla części ciągu docelowego, zaczynając od określonej pozycji o długości.</span><span class="sxs-lookup"><span data-stu-id="3d729-121">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over a portion of the target string beginning at a specified position with a length.</span></span></summary>
        <returns><span data-ttu-id="3d729-122">Reprezentacja ciągu z pamięcią tylko do odczytu lub <see langword="default" /> Jeśli <paramref name="text" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-122">The read-only character memory representation of the string, or <see langword="default" /> if <paramref name="text" /> is <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d729-123"><paramref name="start" />, <paramref name="length" />, lub <paramref name="start" /> nienależydo +  zakresu .<paramref name="text" /> <paramref name="length" /></span><span class="sxs-lookup"><span data-stu-id="3d729-123"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="text" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (segment As ArraySegment(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="F#" Value="static member AsMemory : ArraySegment&lt;'T&gt; -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-124">Typ segmentu.</span><span class="sxs-lookup"><span data-stu-id="3d729-124">The type of the segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="3d729-125">Segment do przekonwertowania.</span><span class="sxs-lookup"><span data-stu-id="3d729-125">The segment to convert.</span></span></param>
        <summary><span data-ttu-id="3d729-126">Tworzy nowy region pamięci na części docelowego segmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-126">Creates a new memory region over the portion of the target array segment.</span></span></summary>
        <returns><span data-ttu-id="3d729-127">Reprezentacja segmentu w pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-127">The memory representation of the segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T()) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-128">Typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-128">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d729-129">Tablica do przekonwertowania.</span><span class="sxs-lookup"><span data-stu-id="3d729-129">The array to convert.</span></span></param>
        <summary><span data-ttu-id="3d729-130">Tworzy nowy region pamięci na tablicy docelowej.</span><span class="sxs-lookup"><span data-stu-id="3d729-130">Creates a new memory region over the target array.</span></span></summary>
        <returns><span data-ttu-id="3d729-131">Reprezentacja pamięci całości lub części tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-131">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (segment As ArraySegment(Of T), start As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(ArraySegment&lt;T&gt; segment, int start);" />
      <MemberSignature Language="F#" Value="static member AsMemory : ArraySegment&lt;'T&gt; * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (segment, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-132">Typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-132">The type of the array.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="3d729-133">Docelowy segment tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-133">The target array segment.</span></span></param>
        <param name="start"><span data-ttu-id="3d729-134">Indeks, w którym ma zostać rozpoczęta pamięć.</span><span class="sxs-lookup"><span data-stu-id="3d729-134">The index at which to begin the memory.</span></span></param>
        <summary><span data-ttu-id="3d729-135">Tworzy nowy region pamięci nad częścią docelowego segmentu tablicy, zaczynając od określonej pozycji do końca segmentu.</span><span class="sxs-lookup"><span data-stu-id="3d729-135">Creates a new memory region over the portion of the target array segment starting at a specified position to the end of the segment.</span></span></summary>
        <returns><span data-ttu-id="3d729-136">Reprezentacja pamięci całości lub części tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-136">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-137">Zwraca `default` wartość `segment` , `null`gdy is.</span><span class="sxs-lookup"><span data-stu-id="3d729-137">Returns `default` when `segment` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="3d729-138"><paramref name="segment" />jest współwariantem, a typ <paramref name="segment" /> nie jest dokładnie. <see langword="T[]" /></span><span class="sxs-lookup"><span data-stu-id="3d729-138"><paramref name="segment" /> is covariant, and the type of <paramref name="segment" /> is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d729-139"><paramref name="start" />jest mniejsza niż 0 lub większa niż <see langword="segment.Count" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-139"><paramref name="start" /> is less than 0 or greater than <see langword="segment.Count" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T(), startIndex As Index) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * Index -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-140">Typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-140">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d729-141">Tablica do przekonwertowania.</span><span class="sxs-lookup"><span data-stu-id="3d729-141">The array to convert.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d729-142">Pierwsza pozycja tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-142">The first position of the array.</span></span></param>
        <summary><span data-ttu-id="3d729-143">Tworzy nowy region pamięci na części tablicy docelowej, zaczynając od określonego indeksu do końca tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-143">Creates a new memory region over the portion of the target array starting at a specified index to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="3d729-144">Reprezentacja pamięci całości lub części tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-144">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T(), start As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, int start);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-145">Typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-145">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d729-146">Tablica docelowa.</span><span class="sxs-lookup"><span data-stu-id="3d729-146">The target array.</span></span></param>
        <param name="start"><span data-ttu-id="3d729-147">Indeks, w którym ma zostać rozpoczęta pamięć.</span><span class="sxs-lookup"><span data-stu-id="3d729-147">The index at which to begin the memory.</span></span></param>
        <summary><span data-ttu-id="3d729-148">Tworzy nowy region pamięci na części tablicy docelowej, zaczynając od określonej pozycji do końca tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-148">Creates a new memory region over the portion of the target array starting at a specified position to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="3d729-149">Reprezentacja pamięci całości lub części tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-149">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-150">Zwraca `default` wartość `array` , `null`gdy is.</span><span class="sxs-lookup"><span data-stu-id="3d729-150">Returns `default` when `array` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="3d729-151"><paramref name="array" />jest współwariantem, a typ tablicy nie jest dokładnie <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-151"><paramref name="array" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d729-152"><paramref name="start" />indeks jest mniejszy niż 0 lub większy <see langword="array.Length" />niż.</span><span class="sxs-lookup"><span data-stu-id="3d729-152"><paramref name="start" /> index less than 0 or greater than <see langword="array.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, Range range);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * Range -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-153">Typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-153">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d729-154">Tablica do przekonwertowania.</span><span class="sxs-lookup"><span data-stu-id="3d729-154">The array to convert.</span></span></param>
        <param name="range"><span data-ttu-id="3d729-155">Zakres, który ma zostać przekonwertowany z tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-155">The range to convert from the array.</span></span></param>
        <summary><span data-ttu-id="3d729-156">Tworzy nowy region pamięci nad częścią tablicy docelowej, rozpoczynając od indeksu początkowy zakres i kończąc na wyłącznym indeksie końcowym zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-156">Creates a new memory region over the portion of the target array beginning at inclusive start index of the range and ending at the exclusive end index of the range.</span></span></summary>
        <returns><span data-ttu-id="3d729-157">Reprezentacja pamięci całości lub części tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-157">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (segment As ArraySegment(Of T), start As Integer, length As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(ArraySegment&lt;T&gt; segment, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsMemory : ArraySegment&lt;'T&gt; * int * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (segment, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-158">Typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-158">The type of the array.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="3d729-159">Docelowy segment tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-159">The target array segment.</span></span></param>
        <param name="start"><span data-ttu-id="3d729-160">Indeks, w którym ma zostać rozpoczęta pamięć.</span><span class="sxs-lookup"><span data-stu-id="3d729-160">The index at which to begin the memory.</span></span></param>
        <param name="length"><span data-ttu-id="3d729-161">Liczba elementów w pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-161">The number of items in the memory.</span></span></param>
        <summary><span data-ttu-id="3d729-162">Tworzy nowy region pamięci na części docelowego segmentu tablicy, zaczynając od określonej pozycji o określonej długości.</span><span class="sxs-lookup"><span data-stu-id="3d729-162">Creates a new memory region over the portion of the target array segment beginning at a specified position with a specified length.</span></span></summary>
        <returns><span data-ttu-id="3d729-163">Reprezentacja pamięci całości lub części tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-163">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-164">Zwraca `default` wartość `segment` , `null`gdy is.</span><span class="sxs-lookup"><span data-stu-id="3d729-164">Returns `default` when `segment` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="3d729-165"><paramref name="segment" />jest współwariantem, a typ tablicy nie jest dokładnie <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-165"><paramref name="segment" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d729-166"><paramref name="start" />, <paramref name="length" />, lub <paramref name="start" /> nienależydo +  zakresu .<paramref name="segment" /> <paramref name="length" /></span><span class="sxs-lookup"><span data-stu-id="3d729-166"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="segment" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T(), start As Integer, length As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * int * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-167">Typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-167">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d729-168">Tablica docelowa.</span><span class="sxs-lookup"><span data-stu-id="3d729-168">The target array.</span></span></param>
        <param name="start"><span data-ttu-id="3d729-169">Indeks, w którym ma zostać rozpoczęty region pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-169">The index at which to begin the memory region.</span></span></param>
        <param name="length"><span data-ttu-id="3d729-170">Liczba elementów w regionie pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-170">The number of items in the memory region.</span></span></param>
        <summary><span data-ttu-id="3d729-171">Tworzy nowy region pamięci na części tablicy docelowej, zaczynając od określonej pozycji o określonej długości.</span><span class="sxs-lookup"><span data-stu-id="3d729-171">Creates a new memory region over the portion of the target array beginning at a specified position with a specified length.</span></span></summary>
        <returns><span data-ttu-id="3d729-172">Reprezentacja pamięci całości lub części tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-172">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-173">Zwraca `default` wartość `array` , `null`gdy is.</span><span class="sxs-lookup"><span data-stu-id="3d729-173">Returns `default` when `array` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="3d729-174"><paramref name="array" />jest współwariantem, a typ tablicy nie jest dokładnie <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-174"><paramref name="array" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d729-175"><paramref name="start" />, <paramref name="length" />, lub <paramref name="start" /> nienależydo +  zakresu .<paramref name="array" /> <paramref name="length" /></span><span class="sxs-lookup"><span data-stu-id="3d729-175"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; AsSpan(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan(System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan (text As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; AsSpan(System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member AsSpan : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.AsSpan text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="3d729-176">Ciąg docelowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-176">The target string.</span></span></param>
        <summary><span data-ttu-id="3d729-177">Tworzy nowy zakres tylko do odczytu dla części ciągu docelowego z określonego położenia dla określonej liczby znaków.</span><span class="sxs-lookup"><span data-stu-id="3d729-177">Creates a new read-only span over a portion of the target string from a specified position for a specified number of characters.</span></span></summary>
        <returns><span data-ttu-id="3d729-178">Reprezentacja ciągu w trybie tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-178">The read-only span representation of the string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-179">Zwraca `default` wartość `text` , `null`gdy is.</span><span class="sxs-lookup"><span data-stu-id="3d729-179">Returns `default` when `text` is `null`.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string text, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; AsSpan(string text, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan (text As String, start As Integer) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; AsSpan(System::String ^ text, int start);" />
      <MemberSignature Language="F#" Value="static member AsSpan : string * int -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.AsSpan (text, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="3d729-180">Ciąg docelowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-180">The target string.</span></span></param>
        <param name="start"><span data-ttu-id="3d729-181">Indeks, w którym ma zostać umieszczony ten plasterek.</span><span class="sxs-lookup"><span data-stu-id="3d729-181">The index at which to begin this slice.</span></span></param>
        <summary><span data-ttu-id="3d729-182">Tworzy nowy zakres tylko do odczytu dla części ciągu docelowego od określonego położenia do końca ciągu.</span><span class="sxs-lookup"><span data-stu-id="3d729-182">Creates a new read-only span over a portion of the target string from a specified position to the end of the string.</span></span></summary>
        <returns><span data-ttu-id="3d729-183">Reprezentacja ciągu w trybie tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-183">The read-only span representation of the string.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3d729-184"><paramref name="text" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-184"><paramref name="text" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d729-185"><paramref name="start" />jest mniejsza niż 0 lub większa niż <see langword="text.Length" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-185"><paramref name="start" /> is less than 0 or greater than <see langword="text.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string text, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; AsSpan(string text, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan (text As String, start As Integer, length As Integer) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; AsSpan(System::String ^ text, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsSpan : string * int * int -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.AsSpan (text, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="3d729-186">Ciąg docelowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-186">The target string.</span></span></param>
        <param name="start"><span data-ttu-id="3d729-187">Indeks, w którym ma zostać umieszczony ten plasterek.</span><span class="sxs-lookup"><span data-stu-id="3d729-187">The index at which to begin this slice.</span></span></param>
        <param name="length"><span data-ttu-id="3d729-188">Wymagana długość wycinka.</span><span class="sxs-lookup"><span data-stu-id="3d729-188">The desired length for the slice.</span></span></param>
        <summary><span data-ttu-id="3d729-189">Tworzy nowy zakres tylko do odczytu w ciągu.</span><span class="sxs-lookup"><span data-stu-id="3d729-189">Creates a new read-only span over a string.</span></span></summary>
        <returns><span data-ttu-id="3d729-190">Reprezentacja ciągu w trybie tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-190">The read-only span representation of the string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-191">Zwraca `default` wartość `text` , `null`gdy is.</span><span class="sxs-lookup"><span data-stu-id="3d729-191">Returns `default` when `text` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d729-192"><paramref name="start" />, <paramref name="length" />, lub <paramref name="start" /> nienależydo +  zakresu .<paramref name="text" /> <paramref name="length" /></span><span class="sxs-lookup"><span data-stu-id="3d729-192"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="text" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-193">Typ segmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-193">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="3d729-194">Segment tablicy do przekonwertowania.</span><span class="sxs-lookup"><span data-stu-id="3d729-194">The array segment to convert.</span></span></param>
        <summary><span data-ttu-id="3d729-195">Tworzy nowy zakres dla docelowego segmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-195">Creates a new span over a target array segment.</span></span></summary>
        <returns><span data-ttu-id="3d729-196">Reprezentacja ogniw segmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-196">The span representation of the array segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T()) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-197">Typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-197">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d729-198">Tablica do przekonwertowania.</span><span class="sxs-lookup"><span data-stu-id="3d729-198">The array to convert.</span></span></param>
        <summary><span data-ttu-id="3d729-199">Tworzy nowy zakres na tablicy docelowej.</span><span class="sxs-lookup"><span data-stu-id="3d729-199">Creates a new span over a target array.</span></span></summary>
        <returns><span data-ttu-id="3d729-200">Reprezentacja zakresu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-200">The span representation of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T), startIndex As Index) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * Index -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-201">Typ segmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-201">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="3d729-202">Docelowy segment tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-202">The target array segment.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d729-203">Indeks, w którym ma zostać rozpoczęty zakres.</span><span class="sxs-lookup"><span data-stu-id="3d729-203">The index at which to begin the Span.</span></span></param>
        <summary><span data-ttu-id="3d729-204">Tworzy nowy zakres na części docelowego segmentu tablicy, zaczynając od określonego indeksu i kończąc na końcu segmentu.</span><span class="sxs-lookup"><span data-stu-id="3d729-204">Creates a new span over a portion of the target array segment beginning at a specified index and ending at the end of the segment.</span></span></summary>
        <returns><span data-ttu-id="3d729-205">Reprezentacja ogniw segmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-205">The span representation of the array segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T), start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, int start);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-206">Typ segmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-206">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="3d729-207">Docelowy segment tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-207">The target array segment.</span></span></param>
        <param name="start"><span data-ttu-id="3d729-208">Indeks, w którym ma zostać rozpoczęta sieć San.</span><span class="sxs-lookup"><span data-stu-id="3d729-208">The index at which to begin the san.</span></span></param>
        <summary><span data-ttu-id="3d729-209">Tworzy nowy zakres na części docelowego segmentu tablicy od określonego położenia do końca segmentu.</span><span class="sxs-lookup"><span data-stu-id="3d729-209">Creates a new span over a portion of a target array segment from a specified position to the end of the segment.</span></span></summary>
        <returns><span data-ttu-id="3d729-210">Reprezentacja ogniw segmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-210">The span representation of the array segment.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-211">Zwraca `default` wartość `segment` , `null`gdy is.</span><span class="sxs-lookup"><span data-stu-id="3d729-211">Returns `default` when `segment` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="3d729-212"><paramref name="segment" />jest współwariantem, a typ tablicy nie jest dokładnie <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-212"><paramref name="segment" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d729-213"><paramref name="start" />jest mniejsza niż 0 lub większa niż <see langword="segment.Count" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-213"><paramref name="start" /> is less than 0 or greater than <see langword="segment.Count" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, Range range);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * Range -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-214">Typ segmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-214">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="3d729-215">Docelowy segment tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-215">The target array segment.</span></span></param>
        <param name="range"><span data-ttu-id="3d729-216">Zakres, który ma indeksy początkowe i końcowe do użycia w celu odtworzenia wycinków tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-216">The range which has start and end indexes to use for slicing the array.</span></span></param>
        <summary><span data-ttu-id="3d729-217">Tworzy nowy zakres dla części docelowego segmentu tablicy przy użyciu zakresu początkowego i końcowego indeksu</span><span class="sxs-lookup"><span data-stu-id="3d729-217">Creates a new span over a portion of a target array segment using the range start and end indexes</span></span></summary>
        <returns><span data-ttu-id="3d729-218">Reprezentacja ogniw segmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-218">The span representation of the array segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T(), startIndex As Index) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * Index -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-219">Typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-219">The array type.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d729-220">Tablica do przekonwertowania.</span><span class="sxs-lookup"><span data-stu-id="3d729-220">The array to convert.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d729-221">Indeks początkowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-221">The starting index.</span></span></param>
        <summary><span data-ttu-id="3d729-222">Tworzy nowy zakres na podstawie części tablicy docelowej zdefiniowanej przez <see cref="T:System.Index" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="3d729-222">Creates a new span over the portion of the target array defined by an <see cref="T:System.Index" /> value.</span></span></summary>
        <returns><span data-ttu-id="3d729-223">Reprezentacja zakresu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-223">The span representation of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T(), start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, int start);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-224">Typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-224">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d729-225">Tablica do przekonwertowania.</span><span class="sxs-lookup"><span data-stu-id="3d729-225">The array to convert.</span></span></param>
        <param name="start"><span data-ttu-id="3d729-226">Początkowy indeks, z którego tablica zostanie przekonwertowana.</span><span class="sxs-lookup"><span data-stu-id="3d729-226">The initial index from which the array will be converted.</span></span></param>
        <summary><span data-ttu-id="3d729-227">Tworzy nowy zakres na części tablicy docelowej, zaczynając od określonej pozycji do końca tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-227">Creates a new span over a portion of the target array starting at a specified position to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="3d729-228">Reprezentacja zakresu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-228">The span representation of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, Range range);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * Range -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-229">Typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-229">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d729-230">Tablica do przekonwertowania.</span><span class="sxs-lookup"><span data-stu-id="3d729-230">The array to convert.</span></span></param>
        <param name="range"><span data-ttu-id="3d729-231">Zakres tablicy do przekonwertowania.</span><span class="sxs-lookup"><span data-stu-id="3d729-231">The range of the array to convert.</span></span></param>
        <summary><span data-ttu-id="3d729-232">Tworzy nowy zakres dla części tablicy docelowej zdefiniowanej przez <see cref="T:System.Range" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="3d729-232">Creates a new span over a portion of a target array defined by a <see cref="T:System.Range" /> value.</span></span></summary>
        <returns><span data-ttu-id="3d729-233">Reprezentacja zakresu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-233">The span representation of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T), start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * int * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-234">Typ segmentu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-234">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="3d729-235">Docelowy segment tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-235">The target array segment.</span></span></param>
        <param name="start"><span data-ttu-id="3d729-236">Indeks, w którym ma zostać rozpoczęty zakres.</span><span class="sxs-lookup"><span data-stu-id="3d729-236">The index at which to begin the span.</span></span></param>
        <param name="length"><span data-ttu-id="3d729-237">Liczba elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-237">The number of items in the span.</span></span></param>
        <summary><span data-ttu-id="3d729-238">Tworzy nowy zakres dla części docelowego segmentu tablicy z określonego położenia dla określonej długości.</span><span class="sxs-lookup"><span data-stu-id="3d729-238">Creates a new span over a portion of a target array segment from a specified position for a specified length.</span></span></summary>
        <returns><span data-ttu-id="3d729-239">Reprezentacja zakresu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-239">The span representation of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-240">Zwraca `default` wartość `segment` , `null`gdy is.</span><span class="sxs-lookup"><span data-stu-id="3d729-240">Returns `default` when `segment` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="3d729-241"><paramref name="segment" />jest współwariantem, a typ tablicy nie jest dokładnie <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-241"><paramref name="segment" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d729-242"><paramref name="start" />, <paramref name="length" />, lub <paramref name="start" /> nienależydo +  zakresu .<paramref name="segment" /> <paramref name="length" /></span><span class="sxs-lookup"><span data-stu-id="3d729-242"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="segment" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T(), start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * int * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-243">Typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-243">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d729-244">Tablica docelowa.</span><span class="sxs-lookup"><span data-stu-id="3d729-244">The target array.</span></span></param>
        <param name="start"><span data-ttu-id="3d729-245">Indeks, w którym ma zostać rozpoczęty zakres.</span><span class="sxs-lookup"><span data-stu-id="3d729-245">The index at which to begin the span.</span></span></param>
        <param name="length"><span data-ttu-id="3d729-246">Liczba elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-246">The number of items in the span.</span></span></param>
        <summary><span data-ttu-id="3d729-247">Tworzy nowy zakres względem części tablicy docelowej, zaczynając od określonej pozycji dla określonej długości.</span><span class="sxs-lookup"><span data-stu-id="3d729-247">Creates a new span over the portion of the target array beginning at a specified position for a specified length.</span></span></summary>
        <returns><span data-ttu-id="3d729-248">Reprezentacja zakresu tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-248">The span representation of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-249">Zwraca `default` wartość `array` , `null`gdy is.</span><span class="sxs-lookup"><span data-stu-id="3d729-249">Returns `default` when `array` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="3d729-250"><paramref name="array" />jest współwariantem, a typ tablicy nie jest dokładnie <see langword="T[]" />".</span><span class="sxs-lookup"><span data-stu-id="3d729-250"><paramref name="array" /> is covariant, and the array's type is not exactly <see langword="T[]" />".</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d729-251"><paramref name="start" />, <paramref name="length" />, lub <paramref name="start" /> nienależydo +  zakresu .<paramref name="text" /> <paramref name="length" /></span><span class="sxs-lookup"><span data-stu-id="3d729-251"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="text" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, IComparable&lt;T&gt; comparable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, class System.IComparable`1&lt;!!T&gt; comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T) (span As ReadOnlySpan(Of T), comparable As IComparable(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(ReadOnlySpan&lt;T&gt; span, IComparable&lt;T&gt; ^ comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : ReadOnlySpan&lt;'T&gt; * IComparable&lt;'T&gt; -&gt; int" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="System.IComparable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-252">Typ elementu zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-252">The element type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-253">Posortowane <see cref="T:System.ReadOnlySpan`1" /> do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-253">The sorted <see cref="T:System.ReadOnlySpan`1" /> to search.</span></span></param>
        <param name="comparable"><span data-ttu-id="3d729-254"><see cref="T:System.IComparable`1" /> Do użycia podczas porównywania.</span><span class="sxs-lookup"><span data-stu-id="3d729-254">The <see cref="T:System.IComparable`1" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="3d729-255">Wyszukuje cały posortowane <see cref="T:System.ReadOnlySpan`1" /> wartości przy użyciu określonego <see cref="T:System.IComparable`1" /> interfejsu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="3d729-255">Searches an entire sorted <see cref="T:System.ReadOnlySpan`1" /> for a value using the specified <see cref="T:System.IComparable`1" /> generic interface.</span></span></summary>
        <returns><span data-ttu-id="3d729-256">Indeks <paramref name="comparable" /> (liczony od zera) w sortowaniu <paramref name="span" />, jeśli <paramref name="comparable" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="comparable" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.ReadOnlySpan`1.Length" />bitowe.</span><span class="sxs-lookup"><span data-stu-id="3d729-256">The zero-based index of <paramref name="comparable" /> in the sorted <paramref name="span" />, if <paramref name="comparable" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="comparable" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3d729-257"><paramref name="comparable" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-257"><paramref name="comparable" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (this Span&lt;T&gt; span, IComparable&lt;T&gt; comparable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span, class System.IComparable`1&lt;!!T&gt; comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T) (span As Span(Of T), comparable As IComparable(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(Span&lt;T&gt; span, IComparable&lt;T&gt; ^ comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Span&lt;'T&gt; * IComparable&lt;'T&gt; -&gt; int" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="System.IComparable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-258">Typ elementu zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-258">The element type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-259">Posortowane <see cref="T:System.Span`1" /> do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-259">The sorted <see cref="T:System.Span`1" /> to search.</span></span></param>
        <param name="comparable"><span data-ttu-id="3d729-260"><see cref="T:System.IComparable`1" /> Do użycia podczas porównywania.</span><span class="sxs-lookup"><span data-stu-id="3d729-260">The <see cref="T:System.IComparable`1" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="3d729-261">Wyszukuje cały posortowane <see cref="T:System.Span`1" /> wartości przy użyciu określonego <see cref="T:System.IComparable`1" /> interfejsu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="3d729-261">Searches an entire sorted <see cref="T:System.Span`1" /> for a value using the specified <see cref="T:System.IComparable`1" /> generic interface.</span></span></summary>
        <returns><span data-ttu-id="3d729-262">Indeks <paramref name="comparable" /> (liczony od zera) w sortowaniu <paramref name="span" />, jeśli <paramref name="comparable" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="comparable" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.Span`1.Length" />bitowe.</span><span class="sxs-lookup"><span data-stu-id="3d729-262">The zero-based index of <paramref name="comparable" /> in the sorted <paramref name="span" />, if <paramref name="comparable" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="comparable" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.Span`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3d729-263"><paramref name="comparable" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-263"><paramref name="comparable" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparable&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparable&gt; (this ReadOnlySpan&lt;T&gt; span, TComparable comparable) where TComparable : IComparable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.IComparable`1&lt;!!T&gt;) TComparable&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!TComparable comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparable) (span As ReadOnlySpan(Of T), comparable As TComparable) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparable&gt;&#xA; where TComparable : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(ReadOnlySpan&lt;T&gt; span, TComparable comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : ReadOnlySpan&lt;'T&gt; * 'Comparable -&gt; int (requires 'Comparable :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparable">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="TComparable" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-264">Typ elementu zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-264">The element type of the span.</span></span></typeparam>
        <typeparam name="TComparable"><span data-ttu-id="3d729-265">Określony typ <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-265">The specific type of <see cref="T:System.IComparable`1" />.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-266">Posortowane <see cref="T:System.ReadOnlySpan`1" /> do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-266">The sorted <see cref="T:System.ReadOnlySpan`1" /> to search.</span></span></param>
        <param name="comparable"><span data-ttu-id="3d729-267"><typeparamref name="TComparable" /> Do użycia podczas porównywania.</span><span class="sxs-lookup"><span data-stu-id="3d729-267">The <typeparamref name="TComparable" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="3d729-268">Wyszukuje cały posortowane <see cref="T:System.ReadOnlySpan`1" /> wartości przy użyciu określonego <typeparamref name="TComparable" /> typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="3d729-268">Searches an entire sorted <see cref="T:System.ReadOnlySpan`1" /> for a value using the specified <typeparamref name="TComparable" /> generic type.</span></span></summary>
        <returns><span data-ttu-id="3d729-269">Indeks <paramref name="comparable" /> (liczony od zera) w sortowaniu <paramref name="span" />, jeśli <paramref name="comparable" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="comparable" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.ReadOnlySpan`1.Length" />bitowe.</span><span class="sxs-lookup"><span data-stu-id="3d729-269">The zero-based index of <paramref name="comparable" /> in the sorted <paramref name="span" />, if <paramref name="comparable" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="comparable" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3d729-270"><paramref name="comparable" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-270"><paramref name="comparable" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparable&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparable&gt; (this Span&lt;T&gt; span, TComparable comparable) where TComparable : IComparable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.IComparable`1&lt;!!T&gt;) TComparable&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!TComparable comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparable) (span As Span(Of T), comparable As TComparable) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparable&gt;&#xA; where TComparable : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(Span&lt;T&gt; span, TComparable comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Span&lt;'T&gt; * 'Comparable -&gt; int (requires 'Comparable :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparable">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="TComparable" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-271">Typ elementu zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-271">The element type of the span.</span></span></typeparam>
        <typeparam name="TComparable"><span data-ttu-id="3d729-272">Określony typ <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-272">The specific type of <see cref="T:System.IComparable`1" />.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-273">Posortowane <see cref="T:System.Span`1" /> do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-273">The sorted <see cref="T:System.Span`1" /> to search.</span></span></param>
        <param name="comparable"><span data-ttu-id="3d729-274"><typeparamref name="TComparable" /> Do użycia podczas porównywania.</span><span class="sxs-lookup"><span data-stu-id="3d729-274">The <typeparamref name="TComparable" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="3d729-275">Wyszukuje cały posortowane <see cref="T:System.Span`1" /> wartości przy użyciu określonego <typeparamref name="TComparable" /> typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="3d729-275">Searches an entire sorted <see cref="T:System.Span`1" /> for a value using the specified <typeparamref name="TComparable" /> generic type.</span></span></summary>
        <returns><span data-ttu-id="3d729-276">Indeks <paramref name="comparable" /> (liczony od zera) w sortowaniu <paramref name="span" />, jeśli <paramref name="comparable" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="comparable" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.Span`1.Length" />bitowe.</span><span class="sxs-lookup"><span data-stu-id="3d729-276">The zero-based index of <paramref name="comparable" /> in the sorted <paramref name="span" />, if <paramref name="comparable" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="comparable" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.Span`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3d729-277"><paramref name="comparable" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-277"><paramref name="comparable" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparer&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparer&gt; (this ReadOnlySpan&lt;T&gt; span, T value, TComparer comparer) where TComparer : System.Collections.Generic.IComparer&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.Collections.Generic.IComparer`1&lt;!!T&gt;) TComparer&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value, !!TComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparer) (span As ReadOnlySpan(Of T), value As T, comparer As TComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparer&gt;&#xA; where TComparer : System::Collections::Generic::IComparer&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(ReadOnlySpan&lt;T&gt; span, T value, TComparer comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : ReadOnlySpan&lt;'T&gt; * 'T * 'Comparer -&gt; int (requires 'Comparer :&gt; System.Collections.Generic.IComparer&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparer">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IComparer&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="TComparer" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-278">Typ elementu zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-278">The element type of the span.</span></span></typeparam>
        <typeparam name="TComparer"><span data-ttu-id="3d729-279">Określony typ <see cref="T:System.Collections.Generic.IComparer`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-279">The specific type of <see cref="T:System.Collections.Generic.IComparer`1" />.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-280">Posortowane <see cref="T:System.ReadOnlySpan`1" /> do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-280">The sorted <see cref="T:System.ReadOnlySpan`1" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-281">Obiekt, który ma zostać zlokalizowany.</span><span class="sxs-lookup"><span data-stu-id="3d729-281">The object to locate.</span></span> <span data-ttu-id="3d729-282">Wartość może być <see langword="null" /> dla typów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="3d729-282">The value can be <see langword="null" /> for reference types.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d729-283"><typeparamref name="TComparer" /> Do użycia podczas porównywania.</span><span class="sxs-lookup"><span data-stu-id="3d729-283">The <typeparamref name="TComparer" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="3d729-284">Wyszukuje całe posortowane <see cref="T:System.ReadOnlySpan`1" /> dla określonej wartości przy użyciu <typeparamref name="TComparer" /> określonego typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="3d729-284">Searches an entire sorted <see cref="T:System.ReadOnlySpan`1" /> for a specified value using the specified <typeparamref name="TComparer" /> generic type.</span></span></summary>
        <returns><span data-ttu-id="3d729-285">Indeks <paramref name="value" /> (liczony od zera) w sortowaniu <paramref name="span" />, jeśli <paramref name="value" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="value" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.ReadOnlySpan`1.Length" />bitowe.</span><span class="sxs-lookup"><span data-stu-id="3d729-285">The zero-based index of <paramref name="value" /> in the sorted <paramref name="span" />, if <paramref name="value" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="value" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3d729-286"><paramref name="comparer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-286"><paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparer&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparer&gt; (this Span&lt;T&gt; span, T value, TComparer comparer) where TComparer : System.Collections.Generic.IComparer&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.Collections.Generic.IComparer`1&lt;!!T&gt;) TComparer&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value, !!TComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparer) (span As Span(Of T), value As T, comparer As TComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparer&gt;&#xA; where TComparer : System::Collections::Generic::IComparer&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(Span&lt;T&gt; span, T value, TComparer comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Span&lt;'T&gt; * 'T * 'Comparer -&gt; int (requires 'Comparer :&gt; System.Collections.Generic.IComparer&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparer">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IComparer&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="TComparer" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-287">Typ elementu zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-287">The element type of the span.</span></span></typeparam>
        <typeparam name="TComparer"><span data-ttu-id="3d729-288">Określony typ <see cref="T:System.Collections.Generic.IComparer`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-288">The specific type of <see cref="T:System.Collections.Generic.IComparer`1" />.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-289">Posortowane <see cref="T:System.Span`1" /> do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-289">The sorted <see cref="T:System.Span`1" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-290">Obiekt, który ma zostać zlokalizowany.</span><span class="sxs-lookup"><span data-stu-id="3d729-290">The object to locate.</span></span> <span data-ttu-id="3d729-291">Wartość może być <see langword="null" /> dla typów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="3d729-291">The value can be <see langword="null" /> for reference types.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d729-292"><typeparamref name="TComparer" /> Do użycia podczas porównywania.</span><span class="sxs-lookup"><span data-stu-id="3d729-292">The <typeparamref name="TComparer" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="3d729-293">Wyszukuje całe posortowane <see cref="T:System.Span`1" /> dla określonej wartości przy użyciu <typeparamref name="TComparer" /> określonego typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="3d729-293">Searches an entire sorted <see cref="T:System.Span`1" /> for a specified value using the specified <typeparamref name="TComparer" /> generic type.</span></span></summary>
        <returns><span data-ttu-id="3d729-294">Indeks <paramref name="value" /> (liczony od zera) w sortowaniu <paramref name="span" />, jeśli <paramref name="value" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="value" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.Span`1.Length" />bitowe.</span><span class="sxs-lookup"><span data-stu-id="3d729-294">The zero-based index of <paramref name="value" /> in the sorted <paramref name="span" />, if <paramref name="value" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="value" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.Span`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3d729-295"><paramref name="comparer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-295"><paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public static int CompareTo (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareTo(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; other, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CompareTo (span As ReadOnlySpan(Of Char), other As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int CompareTo(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member CompareTo : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.MemoryExtensions.CompareTo (span, other, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-296">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-296">The source span.</span></span></param>
        <param name="other"><span data-ttu-id="3d729-297">Wartość do porównania z zakresem źródłowym.</span><span class="sxs-lookup"><span data-stu-id="3d729-297">The value to compare with the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3d729-298">Wartość wyliczenia, która określa, <paramref name="span" /> jak <paramref name="other" /> i są porównywane.</span><span class="sxs-lookup"><span data-stu-id="3d729-298">An enumeration value that determines how <paramref name="span" /> and <paramref name="other" /> are compared.</span></span></param>
        <summary><span data-ttu-id="3d729-299">Porównuje jeden zakres znaków z innym przy użyciu określonego porównania ciągów i zwraca liczbę całkowitą, która wskazuje ich położenie względne w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="3d729-299">Compares one character span with another using a specified string comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="3d729-300">Liczba całkowita ze znakiem, która wskazuje względną <paramref name="other" />kolejność dla <paramref name="span" /> i:</span><span class="sxs-lookup"><span data-stu-id="3d729-300">A signed integer that indicates the relative order of <paramref name="span" /> and <paramref name="other" />:</span></span><br />   <span data-ttu-id="3d729-301">-Jeśli jest mniejsza niż 0 <paramref name="span" /> , poprzedza. <paramref name="other" /></span><span class="sxs-lookup"><span data-stu-id="3d729-301">- If less than 0, <paramref name="span" /> precedes than <paramref name="other" />.</span></span><br />   <span data-ttu-id="3d729-302">-Jeśli 0, <paramref name="span" /> równa <paramref name="other" />się.</span><span class="sxs-lookup"><span data-stu-id="3d729-302">- If 0, <paramref name="span" /> equals <paramref name="other" />.</span></span><br />   <span data-ttu-id="3d729-303">-Jeśli jest większa niż 0 <paramref name="span" /> , <paramref name="other" />następuje.</span><span class="sxs-lookup"><span data-stu-id="3d729-303">- If greater than 0, <paramref name="span" /> follows <paramref name="other" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public static bool Contains (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Contains : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.Contains (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-304">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-304">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-305">Wartość, która ma być przeszukiwana w zakresie źródłowym.</span><span class="sxs-lookup"><span data-stu-id="3d729-305">The value to seek within the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3d729-306">Wartość wyliczenia określająca sposób porównywania znaków w <paramref name="span" /> i <paramref name="value" /> .</span><span class="sxs-lookup"><span data-stu-id="3d729-306">An enumeration value that determines how the characters in <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="3d729-307">Wskazuje, czy określona wartość występuje w ramach zakresu znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-307">Indicates whether a specified value occurs within a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="3d729-308"><see langword="true" />Jeśli <paramref name="value" /> występuje w obrębie zakresu, <see langword="false" /> w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="3d729-308"><see langword="true" /> if <paramref name="value" /> occurs within the span, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(ReadOnlySpan&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member Contains : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Contains (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-309">Typ zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-309">The type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-310">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-310">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-311">Wartość do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-311">The value to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-312">Wskazuje, czy określona wartość jest znaleziona w zakresie tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-312">Indicates whether a specified value is found in a read-only span.</span></span> <span data-ttu-id="3d729-313">Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</span><span class="sxs-lookup"><span data-stu-id="3d729-313">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="3d729-314"><see langword="true" /><see langword="false" /> w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="3d729-314"><see langword="true" /> if found, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;T&gt; (this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of T As IEquatable(Of T)) (span As Span(Of T), value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(Span&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member Contains : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Contains (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-315">Typ elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-315">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-316">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-316">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-317">Wartość do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-317">The value to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-318">Wskazuje, czy określona wartość jest znaleziona w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-318">Indicates whether a specified value is found in a span.</span></span> <span data-ttu-id="3d729-319">Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</span><span class="sxs-lookup"><span data-stu-id="3d729-319">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="3d729-320"><see langword="true" /><see langword="false" /> w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="3d729-320"><see langword="true" /> if found, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopyTo&lt;T&gt; (this T[] source, Memory&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo&lt;T&gt;(!!T[] source, valuetype System.Memory`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo(Of T) (source As T(), destination As Memory(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(cli::array &lt;T&gt; ^ source, Memory&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : 'T[] * Memory&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T[]" RefType="this" />
        <Parameter Name="destination" Type="System.Memory&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-321">Typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-321">The type of the array.</span></span></typeparam>
        <param name="source"><span data-ttu-id="3d729-322">Tablica, z której mają zostać skopiowane elementy.</span><span class="sxs-lookup"><span data-stu-id="3d729-322">The array to copy items from.</span></span></param>
        <param name="destination"><span data-ttu-id="3d729-323">Pamięć, do której mają zostać skopiowane elementy.</span><span class="sxs-lookup"><span data-stu-id="3d729-323">The memory to copy items into.</span></span></param>
        <summary><span data-ttu-id="3d729-324">Kopiuje zawartość tablicy do regionu pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-324">Copies the contents of the array into a memory region.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="3d729-325">Jeśli `source` i`destination` nakładają się, ta metoda zachowuje się tak, jakby oryginalne wartości znajdują się w tymczasowej lokalizacji przed zastąpieniem lokalizacji docelowej.</span><span class="sxs-lookup"><span data-stu-id="3d729-325">If `source` and `destination` overlap, this method behaves as if the original values are in a temporary location before the destination is overwritten.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d729-326">Miejsce docelowe jest krótsze niż tablica źródłowa.</span><span class="sxs-lookup"><span data-stu-id="3d729-326">The destination is shorter than the source array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopyTo&lt;T&gt; (this T[] source, Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo&lt;T&gt;(!!T[] source, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo(Of T) (source As T(), destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(cli::array &lt;T&gt; ^ source, Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : 'T[] * Span&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T[]" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-327">Typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="3d729-327">The type of the array.</span></span></typeparam>
        <param name="source"><span data-ttu-id="3d729-328">Tablica, z której mają zostać skopiowane elementy.</span><span class="sxs-lookup"><span data-stu-id="3d729-328">The array to copy items from.</span></span></param>
        <param name="destination"><span data-ttu-id="3d729-329">Zakres, do którego mają zostać skopiowane elementy.</span><span class="sxs-lookup"><span data-stu-id="3d729-329">The span to copy items into.</span></span></param>
        <summary><span data-ttu-id="3d729-330">Kopiuje zawartość tablicy do zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-330">Copies the contents of the array into the span.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="3d729-331">Jeśli `source` i`destination` nakładają się, ta metoda zachowuje się tak, jakby oryginalne wartości znajdują się w tymczasowej lokalizacji przed zastąpieniem lokalizacji docelowej.</span><span class="sxs-lookup"><span data-stu-id="3d729-331">If `source` and `destination` overlap, this method behaves as if the original values are in a temporary location before the destination is overwritten.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d729-332">Zakres docelowy jest krótszy niż tablica źródłowa.</span><span class="sxs-lookup"><span data-stu-id="3d729-332">The destination Span is shorter than the source array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public static bool EndsWith (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsWith(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EndsWith (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool EndsWith(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member EndsWith : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.EndsWith (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-333">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-333">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-334">Sekwencja do porównania na końcu zakresu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="3d729-334">The sequence to compare to the end of the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3d729-335">Wartość wyliczenia, która określa, <paramref name="span" /> jak <paramref name="value" /> i są porównywane.</span><span class="sxs-lookup"><span data-stu-id="3d729-335">An enumeration value that determines how <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="3d729-336">Określa, czy koniec elementu <paramref name="span" /> pasuje do określonego <paramref name="value" /> w porównaniu z określoną <paramref name="comparisonType" /> opcją.</span><span class="sxs-lookup"><span data-stu-id="3d729-336">Determines whether the end of the <paramref name="span" /> matches the specified <paramref name="value" /> when compared using the specified <paramref name="comparisonType" /> option.</span></span></summary>
        <returns><span data-ttu-id="3d729-337"><see langword="true" />w <paramref name="value" /> przypadku dopasowania do <paramref name="span" />końca; w przeciwnym <see langword="false" />razie.</span><span class="sxs-lookup"><span data-stu-id="3d729-337"><see langword="true" /> if <paramref name="value" /> matches the end of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool EndsWith&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EndsWith(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool EndsWith(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member EndsWith : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.EndsWith (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-338">Typ zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-338">The type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-339">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-339">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-340">Sekwencja do porównania na końcu zakresu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="3d729-340">The sequence to compare to the end of the source span.</span></span></param>
        <summary><span data-ttu-id="3d729-341">Określa, czy określona sekwencja pojawia się na końcu zakresu tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-341">Determines whether the specified sequence appears at the end of a read-only span.</span></span></summary>
        <returns><span data-ttu-id="3d729-342"><see langword="true" />w <paramref name="value" /> przypadku dopasowania do <paramref name="span" />końca; w przeciwnym <see langword="false" />razie.</span><span class="sxs-lookup"><span data-stu-id="3d729-342"><see langword="true" /> if <paramref name="value" /> matches the end of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool EndsWith&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EndsWith(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool EndsWith(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member EndsWith : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.EndsWith (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-343">Typ zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-343">The type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-344">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-344">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-345">Sekwencja do porównania na końcu zakresu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="3d729-345">The sequence to compare to the end of the source span.</span></span></param>
        <summary><span data-ttu-id="3d729-346">Określa, czy określona sekwencja pojawia się na końcu zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-346">Determines whether the specified sequence appears at the end of a span.</span></span></summary>
        <returns><span data-ttu-id="3d729-347"><see langword="true" />w <paramref name="value" /> przypadku dopasowania do <paramref name="span" />końca; w przeciwnym <see langword="false" />razie.</span><span class="sxs-lookup"><span data-stu-id="3d729-347"><see langword="true" /> if <paramref name="value" /> matches the end of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public static System.Text.SpanRuneEnumerator EnumerateRunes (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.SpanRuneEnumerator EnumerateRunes(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnumerateRunes (span As ReadOnlySpan(Of Char)) As SpanRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Text::SpanRuneEnumerator EnumerateRunes(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member EnumerateRunes : ReadOnlySpan&lt;char&gt; -&gt; System.Text.SpanRuneEnumerator" Usage="System.MemoryExtensions.EnumerateRunes span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.SpanRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-348">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-348">The source span.</span></span></param>
        <summary><span data-ttu-id="3d729-349">Zwraca Wyliczenie <see cref="T:System.Text.Rune" /> z podanego zakresu tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-349">Returns an enumeration of <see cref="T:System.Text.Rune" /> from the provided read-only span.</span></span></summary>
        <returns><span data-ttu-id="3d729-350">Moduł wyliczający Rune.</span><span class="sxs-lookup"><span data-stu-id="3d729-350">A rune enumerator.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-351">Nieprawidłowe sekwencje będą reprezentowane w wyliczeniu <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>przez.</span><span class="sxs-lookup"><span data-stu-id="3d729-351">Invalid sequences will be represented in the enumeration by <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public static System.Text.SpanRuneEnumerator EnumerateRunes (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.SpanRuneEnumerator EnumerateRunes(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnumerateRunes (span As Span(Of Char)) As SpanRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Text::SpanRuneEnumerator EnumerateRunes(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member EnumerateRunes : Span&lt;char&gt; -&gt; System.Text.SpanRuneEnumerator" Usage="System.MemoryExtensions.EnumerateRunes span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.SpanRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-352">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-352">The source span.</span></span></param>
        <summary><span data-ttu-id="3d729-353">Zwraca Wyliczenie <see cref="T:System.Text.Rune" /> z podanego zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-353">Returns an enumeration of <see cref="T:System.Text.Rune" /> from the provided span.</span></span></summary>
        <returns><span data-ttu-id="3d729-354">Moduł wyliczający Rune.</span><span class="sxs-lookup"><span data-stu-id="3d729-354">A rune enumerator.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-355">Nieprawidłowe sekwencje będą reprezentowane w wyliczeniu <xref:System.Text.Rune.ReplacementChar>przez.</span><span class="sxs-lookup"><span data-stu-id="3d729-355">Invalid sequences will be represented in the enumeration by <xref:System.Text.Rune.ReplacementChar>.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; other, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Equals (span As ReadOnlySpan(Of Char), other As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Equals(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.Equals (span, other, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-356">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-356">The source span.</span></span></param>
        <param name="other"><span data-ttu-id="3d729-357">Wartość do porównania z zakresem źródłowym.</span><span class="sxs-lookup"><span data-stu-id="3d729-357">The value to compare with the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3d729-358">Wartość wyliczenia, która określa, <paramref name="span" /> jak <paramref name="other" /> i są porównywane.</span><span class="sxs-lookup"><span data-stu-id="3d729-358">An enumeration value that determines how <paramref name="span" /> and <paramref name="other" /> are compared.</span></span></param>
        <summary><span data-ttu-id="3d729-359">Określa, czy <paramref name="span" /> ten i określony <paramref name="other" /> zakres ma te same znaki w porównaniu z określoną <paramref name="comparisonType" /> opcją.</span><span class="sxs-lookup"><span data-stu-id="3d729-359">Determines whether this <paramref name="span" /> and the specified <paramref name="other" /> span have the same characters when compared using the specified <paramref name="comparisonType" /> option.</span></span></summary>
        <returns><span data-ttu-id="3d729-360"><see langword="true" />Jeśli jest równe <see langword="false" /> , w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="3d729-360"><see langword="true" /> if equal, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member IndexOf : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.MemoryExtensions.IndexOf (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-361">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-361">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-362">Wartość, która ma być przeszukiwana w zakresie źródłowym.</span><span class="sxs-lookup"><span data-stu-id="3d729-362">The value to seek within the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3d729-363">Wartość wyliczenia, która określa, <paramref name="span" /> jak <paramref name="value" /> i są porównywane.</span><span class="sxs-lookup"><span data-stu-id="3d729-363">An enumeration value that determines how <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="3d729-364">Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego <paramref name="value" /> w bieżącym. <paramref name="span" /></span><span class="sxs-lookup"><span data-stu-id="3d729-364">Reports the zero-based index of the first occurrence of the specified <paramref name="value" /> in the current <paramref name="span" />.</span></span></summary>
        <returns><span data-ttu-id="3d729-365">Indeks wystąpienia wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-365">The index of the occurrence of the value in the span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-366">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-366">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-367">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-367">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-368">Sekwencja do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-368">The sequence to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-369">Wyszukuje określoną sekwencję i zwraca indeks pierwszego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="3d729-369">Searches for the specified sequence and returns the index of its first occurrence.</span></span> <span data-ttu-id="3d729-370">Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</span><span class="sxs-lookup"><span data-stu-id="3d729-370">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="3d729-371">Indeks wystąpienia wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-371">The index of the occurrence of the value in the span.</span></span> <span data-ttu-id="3d729-372">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-372">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(ReadOnlySpan&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-373">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-373">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-374">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-374">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-375">Wartość do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-375">The value to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-376">Wyszukuje określoną wartość i zwraca indeks pierwszego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="3d729-376">Searches for the specified value and returns the index of its first occurrence.</span></span> <span data-ttu-id="3d729-377">Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</span><span class="sxs-lookup"><span data-stu-id="3d729-377">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="3d729-378">Indeks wystąpienia wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-378">The index of the occurrence of the value in the span.</span></span> <span data-ttu-id="3d729-379">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-379">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-380">Typ zakresu i wartości..</span><span class="sxs-lookup"><span data-stu-id="3d729-380">The type of the span and value..</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-381">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-381">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-382">Sekwencja do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-382">The sequence to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-383">Wyszukuje określoną sekwencję i zwraca indeks pierwszego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="3d729-383">Searches for the specified sequence and returns the index of its first occurrence.</span></span> <span data-ttu-id="3d729-384">Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</span><span class="sxs-lookup"><span data-stu-id="3d729-384">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="3d729-385">Indeks wystąpienia wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-385">The index of the occurrence of the value in the span.</span></span> <span data-ttu-id="3d729-386">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-386">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Span&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-387">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-387">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-388">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-388">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-389">Wartość do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-389">The value to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-390">Wyszukuje określoną wartość i zwraca indeks pierwszego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="3d729-390">Searches for the specified value and returns the index of its first occurrence.</span></span> <span data-ttu-id="3d729-391">Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</span><span class="sxs-lookup"><span data-stu-id="3d729-391">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="3d729-392">Indeks wystąpienia wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-392">The index of the occurrence of the value in the span.</span></span> <span data-ttu-id="3d729-393">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-393">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-394">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-394">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-395">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-395">The span to search.</span></span></param>
        <param name="values"><span data-ttu-id="3d729-396">Zbiór wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-396">The set of values to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-397">Wyszukuje pierwszy indeks wszelkich określonych wartości podobne do wywoływania IndexOf kilka razy przy użyciu operatora logicznego OR.</span><span class="sxs-lookup"><span data-stu-id="3d729-397">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="3d729-398">Pierwszy indeks wystąpienia dowolnych wartości z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-398">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="3d729-399">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-399">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-400">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-400">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-401">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-401">The span to search.</span></span></param>
        <param name="values"><span data-ttu-id="3d729-402">Zbiór wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-402">The set of values to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-403">Wyszukuje pierwszy indeks wszelkich określonych wartości podobne do wywoływania IndexOf kilka razy przy użyciu operatora logicznego OR.</span><span class="sxs-lookup"><span data-stu-id="3d729-403">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="3d729-404">Pierwszy indeks wystąpienia dowolnych wartości z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-404">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="3d729-405">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-405">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-406">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-406">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-407">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-407">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="3d729-408">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-408">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="3d729-409">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-409">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-410">Wyszukuje pierwszy indeks wszelkich określonych wartości podobne do wywoływania IndexOf kilka razy przy użyciu operatora logicznego OR.</span><span class="sxs-lookup"><span data-stu-id="3d729-410">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="3d729-411">Pierwszy indeks wystąpienia dowolnych wartości z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-411">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="3d729-412">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-412">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(Span&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-413">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-413">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-414">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-414">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="3d729-415">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-415">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="3d729-416">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-416">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-417">Wyszukuje pierwszy indeks wszelkich określonych wartości podobne do wywoływania IndexOf kilka razy przy użyciu operatora logicznego OR.</span><span class="sxs-lookup"><span data-stu-id="3d729-417">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="3d729-418">Pierwszy indeks wystąpienia dowolnych wartości z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-418">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="3d729-419">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-419">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-420">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-420">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-421">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-421">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="3d729-422">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-422">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="3d729-423">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-423">One of the values to search for.</span></span></param>
        <param name="value2"><span data-ttu-id="3d729-424">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-424">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-425">Wyszukuje pierwszy indeks wszelkich określonych wartości podobne do wywoływania IndexOf kilka razy przy użyciu operatora logicznego OR.</span><span class="sxs-lookup"><span data-stu-id="3d729-425">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="3d729-426">Pierwszy indeks wystąpienia dowolnych wartości z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-426">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="3d729-427">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-427">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(Span&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-428">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-428">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-429">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-429">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="3d729-430">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-430">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="3d729-431">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-431">One of the values to search for.</span></span></param>
        <param name="value2"><span data-ttu-id="3d729-432">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-432">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-433">Wyszukuje pierwszy indeks wszelkich określonych wartości podobne do wywoływania IndexOf kilka razy przy użyciu operatora logicznego OR.</span><span class="sxs-lookup"><span data-stu-id="3d729-433">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="3d729-434">Pierwszy indeks wystąpienia dowolnych wartości z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-434">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="3d729-435">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-435">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsWhiteSpace (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsWhiteSpace(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.MemoryExtensions.IsWhiteSpace span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-436">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-436">The source span.</span></span></param>
        <summary><span data-ttu-id="3d729-437">Wskazuje, czy określony zakres zawiera tylko białe znaki.</span><span class="sxs-lookup"><span data-stu-id="3d729-437">Indicates whether the specified span contains only whitespace characters.</span></span></summary>
        <returns><span data-ttu-id="3d729-438"><see langword="true" />Jeśli zakres zawiera tylko białe znaki, <see langword="false" /> w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="3d729-438"><see langword="true" /> if the span contains only whitespace characters, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.MemoryExtensions.LastIndexOf (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-439">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-439">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-440">Wartość, która ma być przeszukiwana w zakresie źródłowym.</span><span class="sxs-lookup"><span data-stu-id="3d729-440">The value to seek within the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3d729-441">Wartość wyliczenia, która określa, <paramref name="span" /> jak <paramref name="value" /> i są porównywane.</span><span class="sxs-lookup"><span data-stu-id="3d729-441">An enumeration value that determines how <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="3d729-442">Raportuje indeks od zera ostatniego wystąpienia określonego <paramref name="value" /> w bieżącym. <paramref name="span" /></span><span class="sxs-lookup"><span data-stu-id="3d729-442">Reports the zero-based index of the last occurrence of the specified <paramref name="value" /> in the current <paramref name="span" />.</span></span></summary>
        <returns><span data-ttu-id="3d729-443">Indeks ostatniego wystąpienia wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-443">The index of the last occurrence of the value in the span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-444">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-444">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-445">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-445">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-446">Sekwencja do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-446">The sequence to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-447">Wyszukuje określoną sekwencję i zwraca indeks ostatniego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="3d729-447">Searches for the specified sequence and returns the index of its last occurrence.</span></span> <span data-ttu-id="3d729-448">Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</span><span class="sxs-lookup"><span data-stu-id="3d729-448">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="3d729-449">Indeks ostatniego wystąpienia wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-449">The index of the last occurrence of the value in the span.</span></span> <span data-ttu-id="3d729-450">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-450">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(ReadOnlySpan&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-451">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-451">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-452">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-452">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-453">Wartość do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-453">The value to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-454">Wyszukuje określoną wartość i zwraca indeks ostatniego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="3d729-454">Searches for the specified value and returns the index of its last occurrence.</span></span> <span data-ttu-id="3d729-455">Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</span><span class="sxs-lookup"><span data-stu-id="3d729-455">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="3d729-456">Indeks ostatniego wystąpienia wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-456">The index of the last occurrence of the value in the span.</span></span> <span data-ttu-id="3d729-457">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-457">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-458">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-458">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-459">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-459">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-460">Sekwencja do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-460">The sequence to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-461">Wyszukuje określoną sekwencję i zwraca indeks ostatniego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="3d729-461">Searches for the specified sequence and returns the index of its last occurrence.</span></span> <span data-ttu-id="3d729-462">Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</span><span class="sxs-lookup"><span data-stu-id="3d729-462">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="3d729-463">Indeks ostatniego wystąpienia wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-463">The index of the last occurrence of the value in the span.</span></span> <span data-ttu-id="3d729-464">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-464">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(Span&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-465">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-465">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-466">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-466">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-467">Wartość do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-467">The value to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-468">Wyszukuje określoną wartość i zwraca indeks ostatniego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="3d729-468">Searches for the specified value and returns the index of its last occurrence.</span></span> <span data-ttu-id="3d729-469">Wartości są porównywane przy użyciu IEquatable {T}. Equals (T).</span><span class="sxs-lookup"><span data-stu-id="3d729-469">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="3d729-470">Indeks ostatniego wystąpienia wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-470">The index of the last occurrence of the value in the span.</span></span> <span data-ttu-id="3d729-471">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-471">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-472">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-472">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-473">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-473">The span to search.</span></span></param>
        <param name="values"><span data-ttu-id="3d729-474">Zbiór wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-474">The set of values to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-475">Wyszukuje ostatni indeks wszelkich określonych wartości podobnie do wywoływania LastIndexOf kilka razy przy użyciu operatora logicznego OR.</span><span class="sxs-lookup"><span data-stu-id="3d729-475">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="3d729-476">Indeks ostatnich wystąpień dowolnych wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-476">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="3d729-477">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-477">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-478">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-478">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-479">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-479">The span to search.</span></span></param>
        <param name="values"><span data-ttu-id="3d729-480">Zbiór wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-480">The set of values to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-481">Wyszukuje ostatni indeks wszelkich określonych wartości podobnie do wywoływania LastIndexOf kilka razy przy użyciu operatora logicznego OR.</span><span class="sxs-lookup"><span data-stu-id="3d729-481">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="3d729-482">Indeks ostatnich wystąpień dowolnych wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-482">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="3d729-483">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-483">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-484">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-484">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-485">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-485">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="3d729-486">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-486">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="3d729-487">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-487">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-488">Wyszukuje ostatni indeks wszelkich określonych wartości podobnie do wywoływania LastIndexOf kilka razy przy użyciu operatora logicznego OR.</span><span class="sxs-lookup"><span data-stu-id="3d729-488">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="3d729-489">Indeks ostatnich wystąpień dowolnych wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-489">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="3d729-490">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-490">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(Span&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-491">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-491">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-492">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-492">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="3d729-493">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-493">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="3d729-494">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-494">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-495">Wyszukuje ostatni indeks wszelkich określonych wartości podobnie do wywoływania LastIndexOf kilka razy przy użyciu operatora logicznego OR.</span><span class="sxs-lookup"><span data-stu-id="3d729-495">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="3d729-496">Indeks ostatnich wystąpień dowolnych wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-496">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="3d729-497">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-497">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-498">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-498">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-499">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-499">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="3d729-500">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-500">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="3d729-501">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-501">One of the values to search for.</span></span></param>
        <param name="value2"><span data-ttu-id="3d729-502">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-502">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-503">Wyszukuje ostatni indeks wszelkich określonych wartości podobnie do wywoływania LastIndexOf kilka razy przy użyciu operatora logicznego OR.</span><span class="sxs-lookup"><span data-stu-id="3d729-503">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="3d729-504">Indeks ostatnich wystąpień dowolnych wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-504">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="3d729-505">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-505">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(Span&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-506">Typ zakresu i wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-506">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-507">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-507">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="3d729-508">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-508">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="3d729-509">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-509">One of the values to search for.</span></span></param>
        <param name="value2"><span data-ttu-id="3d729-510">Jedna z wartości do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-510">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="3d729-511">Wyszukuje ostatni indeks wszelkich określonych wartości podobnie do wywoływania LastIndexOf kilka razy przy użyciu operatora logicznego OR.</span><span class="sxs-lookup"><span data-stu-id="3d729-511">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="3d729-512">Indeks ostatnich wystąpień dowolnych wartości w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-512">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="3d729-513">Jeśli nie zostanie znaleziony, zwraca-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-513">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member Overlaps : ReadOnlySpan&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-514">Typ elmeents w sekwencji tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-514">The type of elmeents in the read-only sequence.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-515">Pierwsza sekwencja.</span><span class="sxs-lookup"><span data-stu-id="3d729-515">The first sequence.</span></span></param>
        <param name="other"><span data-ttu-id="3d729-516">Druga sekwencja.</span><span class="sxs-lookup"><span data-stu-id="3d729-516">The second sequence.</span></span></param>
        <summary><span data-ttu-id="3d729-517">Określa, czy dwie sekwencje tylko do odczytu nakładają się na pamięć.</span><span class="sxs-lookup"><span data-stu-id="3d729-517">Determines whether two read-only sequences overlap in memory.</span></span></summary>
        <returns><span data-ttu-id="3d729-518"><see langword="true" />Jeśli dwie sekwencje nakładają się; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="3d729-518"><see langword="true" /> if the two sequences overlap; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As Span(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member Overlaps : Span&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-519">Typ elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-519">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-520">Zakres do porównania.</span><span class="sxs-lookup"><span data-stu-id="3d729-520">The span to compare.</span></span></param>
        <param name="other"><span data-ttu-id="3d729-521">Zakres tylko do odczytu do porównania.</span><span class="sxs-lookup"><span data-stu-id="3d729-521">The read-only span to compare.</span></span></param>
        <summary><span data-ttu-id="3d729-522">Określa, czy zakres i zakres tylko do odczytu nakładają się na pamięć.</span><span class="sxs-lookup"><span data-stu-id="3d729-522">Determines whether a span and a read-only span overlap in memory.</span></span></summary>
        <returns><span data-ttu-id="3d729-523"><see langword="true" />Jeśli dwie sekwencje nakładają się; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="3d729-523"><see langword="true" /> if the two sequences overlap; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, out int elementOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other, [out] int32&amp; elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T), ByRef elementOffset As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, [Runtime::InteropServices::Out] int % elementOffset);" />
      <MemberSignature Language="F#" Value="static member Overlaps : ReadOnlySpan&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; *  -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other, elementOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="elementOffset" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-524">Typ elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-524">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-525">Pierwsza sekwencja.</span><span class="sxs-lookup"><span data-stu-id="3d729-525">The first sequence.</span></span></param>
        <param name="other"><span data-ttu-id="3d729-526">Druga sekwencja.</span><span class="sxs-lookup"><span data-stu-id="3d729-526">The second sequence.</span></span></param>
        <param name="elementOffset">To be added.</param>
        <summary><span data-ttu-id="3d729-527">Określa, czy dwie sekwencje tylko do odczytu nakładają się na pamięć i wyprowadzają przesunięcie elementu.</span><span class="sxs-lookup"><span data-stu-id="3d729-527">Determines whether two read-only sequences overlap in memory and outputs the element offset.</span></span></summary>
        <returns><span data-ttu-id="3d729-528"><see langword="true" />Jeśli dwie sekwencje nakładają się; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="3d729-528"><see langword="true" /> if the two sequences overlap; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, out int elementOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other, [out] int32&amp; elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As Span(Of T), other As ReadOnlySpan(Of T), ByRef elementOffset As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, [Runtime::InteropServices::Out] int % elementOffset);" />
      <MemberSignature Language="F#" Value="static member Overlaps : Span&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; *  -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other, elementOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="elementOffset" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-529">Typ elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-529">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-530">Pierwsza sekwencja do porównania.</span><span class="sxs-lookup"><span data-stu-id="3d729-530">The first sequence to compare.</span></span></param>
        <param name="other"><span data-ttu-id="3d729-531">Druga sekwencja do porównania.</span><span class="sxs-lookup"><span data-stu-id="3d729-531">The second sequence to compare.</span></span></param>
        <param name="elementOffset"><span data-ttu-id="3d729-532">Gdy metoda zwraca, zawiera przesunięcie między <paramref name="span" /> i. <paramref name="other" /></span><span class="sxs-lookup"><span data-stu-id="3d729-532">When the method returns, contains the offset between <paramref name="span" /> and <paramref name="other" />.</span></span></param>
        <summary><span data-ttu-id="3d729-533">Określa, czy zakres i zakres tylko do odczytu nakładają się na pamięć i wyprowadzają przesunięcie elementu.</span><span class="sxs-lookup"><span data-stu-id="3d729-533">Determines whether a span and a read-only span overlap in memory and outputs the element offset.</span></span></summary>
        <returns><span data-ttu-id="3d729-534"><see langword="true" />Jeśli dwie sekwencje nakładają się; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="3d729-534"><see langword="true" /> if the two sequences overlap; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (this Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Reverse``1(System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Reverse(Of T) (span As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Reverse(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member Reverse : Span&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.Reverse span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-535">Typ elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-535">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-536">Zakres do odwrócenia.</span><span class="sxs-lookup"><span data-stu-id="3d729-536">The span to reverse.</span></span></param>
        <summary><span data-ttu-id="3d729-537">Odwraca sekwencję elementów w całym zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-537">Reverses the sequence of the elements in the entire span.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceCompareTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SequenceCompareTo&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IComparable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SequenceCompareTo&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceCompareTo(Of T As IComparable(Of T)) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int SequenceCompareTo(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceCompareTo : ReadOnlySpan&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceCompareTo (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-538">Typ elementów w sekwencji.</span><span class="sxs-lookup"><span data-stu-id="3d729-538">The type of elements in the sequence.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-539">Pierwsza sekwencja do porównania.</span><span class="sxs-lookup"><span data-stu-id="3d729-539">The first sequence to compare.</span></span></param>
        <param name="other"><span data-ttu-id="3d729-540">Druga sekwencja do porównania.</span><span class="sxs-lookup"><span data-stu-id="3d729-540">The second sequence to compare.</span></span></param>
        <summary><span data-ttu-id="3d729-541">Określa względną kolejność dwóch sekwencji tylko do odczytu, porównując ich elementy przy użyciu obiektu IComparable {T}. CompareTo (T).</span><span class="sxs-lookup"><span data-stu-id="3d729-541">Determines the relative order of two read-only sequences by comparing their elements using IComparable{T}.CompareTo(T).</span></span></summary>
        <returns><span data-ttu-id="3d729-542">Liczba całkowita ze znakiem, która wskazuje względną <paramref name="other" />kolejność dla <paramref name="span" /> i:</span><span class="sxs-lookup"><span data-stu-id="3d729-542">A signed integer that indicates the relative order of <paramref name="span" /> and <paramref name="other" />:</span></span><br />   <span data-ttu-id="3d729-543">-Jeśli jest mniejsza niż 0 <paramref name="span" /> , poprzedza. <paramref name="other" /></span><span class="sxs-lookup"><span data-stu-id="3d729-543">- If less than 0, <paramref name="span" /> precedes than <paramref name="other" />.</span></span><br />   <span data-ttu-id="3d729-544">-Jeśli 0, <paramref name="span" /> równa <paramref name="other" />się.</span><span class="sxs-lookup"><span data-stu-id="3d729-544">- If 0, <paramref name="span" /> equals <paramref name="other" />.</span></span><br />   <span data-ttu-id="3d729-545">-Jeśli jest większa niż 0 <paramref name="span" /> , <paramref name="other" />następuje.</span><span class="sxs-lookup"><span data-stu-id="3d729-545">- If greater than 0, <paramref name="span" /> follows <paramref name="other" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceCompareTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SequenceCompareTo&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IComparable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SequenceCompareTo&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceCompareTo(Of T As IComparable(Of T)) (span As Span(Of T), other As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int SequenceCompareTo(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceCompareTo : Span&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceCompareTo (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-546">Typ elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-546">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-547">Zakres do porównania.</span><span class="sxs-lookup"><span data-stu-id="3d729-547">The span to compare.</span></span></param>
        <param name="other"><span data-ttu-id="3d729-548">Zakres tylko do odczytu do porównania.</span><span class="sxs-lookup"><span data-stu-id="3d729-548">The read-only span to compare.</span></span></param>
        <summary><span data-ttu-id="3d729-549">Określa względną kolejność zakresu i przedział tylko do odczytu, porównując elementy przy użyciu elementu IComparable {T}. CompareTo (T).</span><span class="sxs-lookup"><span data-stu-id="3d729-549">Determines the relative order of a span and a read-only span by comparing the elements using IComparable{T}.CompareTo(T).</span></span></summary>
        <returns><span data-ttu-id="3d729-550">Liczba całkowita ze znakiem, która wskazuje względną <paramref name="other" />kolejność dla <paramref name="span" /> i:</span><span class="sxs-lookup"><span data-stu-id="3d729-550">A signed integer that indicates the relative order of <paramref name="span" /> and <paramref name="other" />:</span></span><br />   <span data-ttu-id="3d729-551">-Jeśli jest mniejsza niż 0 <paramref name="span" /> , poprzedza. <paramref name="other" /></span><span class="sxs-lookup"><span data-stu-id="3d729-551">- If less than 0, <paramref name="span" /> precedes than <paramref name="other" />.</span></span><br />   <span data-ttu-id="3d729-552">-Jeśli 0, <paramref name="span" /> równa <paramref name="other" />się.</span><span class="sxs-lookup"><span data-stu-id="3d729-552">- If 0, <paramref name="span" /> equals <paramref name="other" />.</span></span><br />   <span data-ttu-id="3d729-553">-Jeśli jest większa niż 0 <paramref name="span" /> , <paramref name="other" />następuje.</span><span class="sxs-lookup"><span data-stu-id="3d729-553">- If greater than 0, <paramref name="span" /> follows <paramref name="other" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceEqual (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-554">Typ elementów w sekwencji.</span><span class="sxs-lookup"><span data-stu-id="3d729-554">The type of elements in the sequence.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-555">Pierwsza sekwencja do porównania.</span><span class="sxs-lookup"><span data-stu-id="3d729-555">The first sequence to compare.</span></span></param>
        <param name="other"><span data-ttu-id="3d729-556">Druga sekwencja do porównania.</span><span class="sxs-lookup"><span data-stu-id="3d729-556">The second sequence to compare.</span></span></param>
        <summary><span data-ttu-id="3d729-557">Określa, czy dwie sekwencje tylko do odczytu są równe, porównując elementy przy użyciu IEquatable {T}. Equals (T).</span><span class="sxs-lookup"><span data-stu-id="3d729-557">Determines whether two read-only sequences are equal by comparing the elements using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="3d729-558"><see langword="true" />Jeśli dwie sekwencje są równe; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="3d729-558"><see langword="true" /> if the two sequences are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of T As IEquatable(Of T)) (span As Span(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceEqual (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-559">Typ elementów w sekwencji.</span><span class="sxs-lookup"><span data-stu-id="3d729-559">The type of elements in the sequence.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-560">Zakres do porównania.</span><span class="sxs-lookup"><span data-stu-id="3d729-560">The span to compare.</span></span></param>
        <param name="other"><span data-ttu-id="3d729-561">Zakres tylko do odczytu do porównania.</span><span class="sxs-lookup"><span data-stu-id="3d729-561">The read-only span to compare.</span></span></param>
        <summary><span data-ttu-id="3d729-562">Określa, czy zakres i zakres tylko do odczytu są równe, porównując elementy przy użyciu IEquatable {T}. Equals (T).</span><span class="sxs-lookup"><span data-stu-id="3d729-562">Determines whether a span and a read-only span are equal by comparing the elements using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="3d729-563"><see langword="true" />Jeśli dwie sekwencje są równe; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="3d729-563"><see langword="true" /> if the two sequences are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public static bool StartsWith (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool StartsWith(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartsWith (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool StartsWith(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member StartsWith : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.StartsWith (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-564">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-564">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-565">Sekwencja do porównania na początku zakresu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="3d729-565">The sequence to compare to the beginning of the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3d729-566">Wartość wyliczenia, która określa, <paramref name="span" /> jak <paramref name="value" /> i są porównywane.</span><span class="sxs-lookup"><span data-stu-id="3d729-566">An enumeration value that determines how <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="3d729-567">Określa, czy zakres znaków tylko do odczytu rozpoczyna się od określonej wartości w porównaniu z użyciem określonej <see cref="T:System.StringComparison" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="3d729-567">Determines whether a read-only character span begins with a specified value when compared using a specified <see cref="T:System.StringComparison" /> value.</span></span></summary>
        <returns><span data-ttu-id="3d729-568"><see langword="true" />Jeśli <paramref name="value" /> jest zgodny z <paramref name="span" />początkiem; w <see langword="false" />przeciwnym razie,.</span><span class="sxs-lookup"><span data-stu-id="3d729-568"><see langword="true" /> if <paramref name="value" /> matches the beginning of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool StartsWith&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool StartsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartsWith(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool StartsWith(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member StartsWith : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.StartsWith (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-569">Typ elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-569">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-570">Zakres znaków tylko do odczytu do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="3d729-570">The read-only character span to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-571">Sekwencja wyszukiwania na początku <paramref name="span" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-571">A sequence to search for at the start of <paramref name="span" />.</span></span></param>
        <summary><span data-ttu-id="3d729-572">Określa, czy określona sekwencja pojawia się na początku zakresu tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-572">Determines whether a specified sequence appears at the start of a read-only span.</span></span></summary>
        <returns><span data-ttu-id="3d729-573"><see langword="true" />Jeśli <paramref name="value" /> jest zgodny z <paramref name="span" />początkiem; w <see langword="false" />przeciwnym razie,.</span><span class="sxs-lookup"><span data-stu-id="3d729-573"><see langword="true" /> if <paramref name="value" /> matches the beginning of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool StartsWith&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool StartsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartsWith(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool StartsWith(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member StartsWith : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.StartsWith (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-574">Typ elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-574">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-575">Zakres, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="3d729-575">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d729-576">Sekwencja wyszukiwania na początku <paramref name="span" />.</span><span class="sxs-lookup"><span data-stu-id="3d729-576">A sequence to search for at the start of <paramref name="span" />.</span></span></param>
        <summary><span data-ttu-id="3d729-577">Określa, czy określona sekwencja pojawia się na początku zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-577">Determines whether a specified sequence appears at the start of a span.</span></span></summary>
        <returns><span data-ttu-id="3d729-578"><see langword="true" />Jeśli <paramref name="value" /> jest zgodny z <paramref name="span" />początkiem; w <see langword="false" />przeciwnym razie,.</span><span class="sxs-lookup"><span data-stu-id="3d729-578"><see langword="true" /> if <paramref name="value" /> matches the beginning of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static int ToLower (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToLower(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLower (source As ReadOnlySpan(Of Char), destination As Span(Of Char), culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToLower(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToLower : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * System.Globalization.CultureInfo -&gt; int" Usage="System.MemoryExtensions.ToLower (source, destination, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3d729-579">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-579">The source span.</span></span></param>
        <param name="destination"><span data-ttu-id="3d729-580">Zakres docelowy, który zawiera przekształcone znaki.</span><span class="sxs-lookup"><span data-stu-id="3d729-580">The destination span which contains the transformed characters.</span></span></param>
        <param name="culture"><span data-ttu-id="3d729-581">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="3d729-581">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="3d729-582">Kopiuje znaki z zakresu źródłowego do lokalizacji docelowej, konwertując każdy znak na małe litery, używając reguł wielkości liter w określonej kulturze.</span><span class="sxs-lookup"><span data-stu-id="3d729-582">Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="3d729-583">Liczba znaków zapisanych do zakresu docelowego.</span><span class="sxs-lookup"><span data-stu-id="3d729-583">The number of characters written into the destination span.</span></span> <span data-ttu-id="3d729-584">Jeśli miejsce docelowe jest zbyt małe, zwraca wartość-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-584">If the destination is too small, returns -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-585">Jeśli `culture` jest `null` ,<xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> zostanie użyty.</span><span class="sxs-lookup"><span data-stu-id="3d729-585">If `culture` is `null`, <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> will be used.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3d729-586">Bufory źródłowe i docelowe nakładają się na siebie.</span><span class="sxs-lookup"><span data-stu-id="3d729-586">The source and destination buffers overlap.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public static int ToLowerInvariant (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToLowerInvariant(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLowerInvariant (source As ReadOnlySpan(Of Char), destination As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToLowerInvariant(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="F#" Value="static member ToLowerInvariant : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; -&gt; int" Usage="System.MemoryExtensions.ToLowerInvariant (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3d729-587">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-587">The source span.</span></span></param>
        <param name="destination"><span data-ttu-id="3d729-588">Zakres docelowy, który zawiera przekształcone znaki.</span><span class="sxs-lookup"><span data-stu-id="3d729-588">The destination span which contains the transformed characters.</span></span></param>
        <summary><span data-ttu-id="3d729-589">Kopiuje znaki z zakresu źródłowego do lokalizacji docelowej, konwertując każdy znak na małe litery, używając reguł wielkości liter kultury niezmiennej.</span><span class="sxs-lookup"><span data-stu-id="3d729-589">Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="3d729-590">Liczba znaków zapisanych do zakresu docelowego.</span><span class="sxs-lookup"><span data-stu-id="3d729-590">The number of characters written into the destination span.</span></span> <span data-ttu-id="3d729-591">Jeśli miejsce docelowe jest zbyt małe, zwraca wartość-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-591">If the destination is too small, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3d729-592">Bufory źródłowe i docelowe nakładają się na siebie.</span><span class="sxs-lookup"><span data-stu-id="3d729-592">The source and destination buffers overlap.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static int ToUpper (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToUpper(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUpper (source As ReadOnlySpan(Of Char), destination As Span(Of Char), culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToUpper(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToUpper : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * System.Globalization.CultureInfo -&gt; int" Usage="System.MemoryExtensions.ToUpper (source, destination, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3d729-593">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-593">The source span.</span></span></param>
        <param name="destination"><span data-ttu-id="3d729-594">Zakres docelowy, który zawiera przekształcone znaki.</span><span class="sxs-lookup"><span data-stu-id="3d729-594">The destination span which contains the transformed characters.</span></span></param>
        <param name="culture"><span data-ttu-id="3d729-595">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="3d729-595">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="3d729-596">Kopiuje znaki z zakresu źródłowego do lokalizacji docelowej, konwertując każdy znak na wielkie litery przy użyciu reguł wielkości liter w określonej kulturze.</span><span class="sxs-lookup"><span data-stu-id="3d729-596">Copies the characters from the source span into the destination, converting each character to uppercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="3d729-597">Liczba znaków zapisanych do zakresu docelowego.</span><span class="sxs-lookup"><span data-stu-id="3d729-597">The number of characters written into the destination span.</span></span> <span data-ttu-id="3d729-598">Jeśli miejsce docelowe jest zbyt małe, zwraca wartość-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-598">If the destination is too small, returns -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-599">Jeśli `culture` jest `null` ,<xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> zostanie użyty.</span><span class="sxs-lookup"><span data-stu-id="3d729-599">If `culture` is `null`, <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> will be used.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3d729-600">Bufory źródłowe i docelowe nakładają się na siebie.</span><span class="sxs-lookup"><span data-stu-id="3d729-600">The source and destination buffers overlap.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public static int ToUpperInvariant (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToUpperInvariant(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUpperInvariant (source As ReadOnlySpan(Of Char), destination As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToUpperInvariant(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="F#" Value="static member ToUpperInvariant : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; -&gt; int" Usage="System.MemoryExtensions.ToUpperInvariant (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3d729-601">Zakres źródłowy.</span><span class="sxs-lookup"><span data-stu-id="3d729-601">The source span.</span></span></param>
        <param name="destination"><span data-ttu-id="3d729-602">Zakres docelowy, który zawiera przekształcone znaki.</span><span class="sxs-lookup"><span data-stu-id="3d729-602">The destination span which contains the transformed characters.</span></span></param>
        <summary><span data-ttu-id="3d729-603">Kopiuje znaki z zakresu źródłowego do lokalizacji docelowej, konwertując każdy znak na wielkie litery przy użyciu reguł wielkości liter kultury niezmiennej.</span><span class="sxs-lookup"><span data-stu-id="3d729-603">Copies the characters from the source span into the destination, converting each character to uppercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="3d729-604">Liczba znaków zapisanych do zakresu docelowego.</span><span class="sxs-lookup"><span data-stu-id="3d729-604">The number of characters written into the destination span.</span></span> <span data-ttu-id="3d729-605">Jeśli miejsce docelowe jest zbyt małe, zwraca wartość-1.</span><span class="sxs-lookup"><span data-stu-id="3d729-605">If the destination is too small, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3d729-606">Bufory źródłowe i docelowe nakładają się na siebie.</span><span class="sxs-lookup"><span data-stu-id="3d729-606">The source and destination buffers overlap.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static Memory&lt;char&gt; Trim (this Memory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;char&gt; Trim(valuetype System.Memory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.Memory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (memory As Memory(Of Char)) As Memory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;char&gt; Trim(Memory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member Trim : Memory&lt;char&gt; -&gt; Memory&lt;char&gt;" Usage="System.MemoryExtensions.Trim memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="3d729-607">Pamięć źródłowa, z której są usuwane znaki.</span><span class="sxs-lookup"><span data-stu-id="3d729-607">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="3d729-608">Usuwa wszystkie spacje wiodące i końcowe z regionu pamięci znaku.</span><span class="sxs-lookup"><span data-stu-id="3d729-608">Removes all leading and trailing whitespace characters from a character memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-609">Przycięty region pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-609">The trimmed character memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; Trim (this ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; Trim(valuetype System.ReadOnlyMemory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (memory As ReadOnlyMemory(Of Char)) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; Trim(ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlyMemory&lt;char&gt; -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.Trim memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="3d729-610">Pamięć źródłowa, z której są usuwane znaki.</span><span class="sxs-lookup"><span data-stu-id="3d729-610">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="3d729-611">Usuwa wszystkie spacje wiodące i końcowe z obszaru pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-611">Removes all leading and trailing whitespace characters from a read-only character memory region.</span></span></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; Trim (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; Trim(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; Trim(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.Trim span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-612">Zakres źródłowy, z którego znaki są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-612">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="3d729-613">Usuwa wszystkie spacje wiodące i końcowe z zakresu znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-613">Removes all leading and trailing whitespace characters from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="3d729-614">Przycięty zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-614">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static Span&lt;char&gt; Trim (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;char&gt; Trim(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As Span(Of Char)) As Span(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;char&gt; Trim(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member Trim : Span&lt;char&gt; -&gt; Span&lt;char&gt;" Usage="System.MemoryExtensions.Trim span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-615">Zakres źródłowy, z którego znaki są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-615">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="3d729-616">Usuwa wszystkie spacje wiodące i końcowe z zakresu znaków.</span><span class="sxs-lookup"><span data-stu-id="3d729-616">Removes all leading and trailing whitespace characters from a character span.</span></span></summary>
        <returns><span data-ttu-id="3d729-617">Przycięty zakres znaków.</span><span class="sxs-lookup"><span data-stu-id="3d729-617">The trimmed character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; Trim (this ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; Trim(valuetype System.ReadOnlySpan`1&lt;char&gt; span, char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As ReadOnlySpan(Of Char), trimChar As Char) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; Trim(ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;char&gt; * char -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.Trim (span, trimChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-618">Zakres źródłowy, z którego jest usuwany znak.</span><span class="sxs-lookup"><span data-stu-id="3d729-618">The source span from which the character is removed.</span></span></param>
        <param name="trimChar"><span data-ttu-id="3d729-619">Określony znak, który ma być wyszukiwany i usunięty.</span><span class="sxs-lookup"><span data-stu-id="3d729-619">The specified character to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-620">Usuwa wszystkie wystąpienia wiodące i końcowe określonego znaku z zakresu znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-620">Removes all leading and trailing occurrences of a specified character from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="3d729-621">Przycięty zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-621">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; Trim (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; Trim(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As ReadOnlySpan(Of Char), trimChars As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; Trim(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.Trim (span, trimChars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-622">Zakres źródłowy, z którego znaki są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-622">The source span from which the characters are removed.</span></span></param>
        <param name="trimChars"><span data-ttu-id="3d729-623">Zakres, który zawiera zestaw znaków do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-623">The span which contains the set of characters to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-624">Usuwa wszystkie wystąpienia wiodące i końcowe zestawu znaków określone w okresie tylko do odczytu z zakresu znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-624">Removes all leading and trailing occurrences of a set of characters specified in a read-only span from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="3d729-625">Przycięty zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-625">The trimmed read-only character span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-626">Jeśli `trimChars` jest pusty, zamiast tego są usuwane znaki odstępu.</span><span class="sxs-lookup"><span data-stu-id="3d729-626">If `trimChars` is empty, whitespace characters are removed instead.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; Trim&lt;T&gt; (this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElements As ReadOnlySpan(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; Trim(Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-627">Typ elementów w regionie pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-627">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="3d729-628">Pamięć źródłowa, z której zostaną usunięte elementy.</span><span class="sxs-lookup"><span data-stu-id="3d729-628">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="3d729-629">Zakres, który zawiera zestaw elementów do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-629">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-630">Usuwa wszystkie początkowe i końcowe wystąpienia zestawu elementów określonych w zakresie tylko do odczytu z regionu pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-630">Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-631">Przycięty region pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-631">The trimmed memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-632">Jeśli `trimElements` jest pusty, pamięć jest zwracana bez zmian.</span><span class="sxs-lookup"><span data-stu-id="3d729-632">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; Trim&lt;T&gt; (this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElement As T) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; Trim(Memory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-633">Typ elementów w regionie pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-633">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="3d729-634">Pamięć źródłowa, z której element jest usuwany.</span><span class="sxs-lookup"><span data-stu-id="3d729-634">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="3d729-635">Określony element do wyszukania i usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-635">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-636">Usuwa wszystkie wystąpienia wiodące i końcowe określonego elementu z regionu pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-636">Removes all leading and trailing occurrences of a specified element from a memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-637">Przycięty region pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-637">The trimmed memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; Trim&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; Trim(ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-638">Typ elementów w regionie pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-638">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="3d729-639">Pamięć źródłowa, z której zostaną usunięte elementy.</span><span class="sxs-lookup"><span data-stu-id="3d729-639">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="3d729-640">Zakres, który zawiera zestaw elementów do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-640">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-641">Usuwa wszystkie wystąpienia wiodące i końcowe zestawu elementów określonych w obszarze tylko do odczytu z obszaru pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-641">Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-642">Przycięty region pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-642">The trimmed read-only memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-643">Jeśli `trimElements` jest pusty, pamięć jest zwracana bez zmian.</span><span class="sxs-lookup"><span data-stu-id="3d729-643">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; Trim&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElement As T) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; Trim(ReadOnlyMemory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-644">Typ elementów w regionie pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-644">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="3d729-645">Pamięć źródłowa, z której element jest usuwany.</span><span class="sxs-lookup"><span data-stu-id="3d729-645">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="3d729-646">Określony element do wyszukania i usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-646">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-647">Usuwa wszystkie wystąpienia wiodące i końcowe określonego elementu z obszaru pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-647">Removes all leading and trailing occurrences of a specified element from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-648">Przycięty region pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-648">The trimmed read-only memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; Trim&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; Trim(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-649">Typ elementów w zakresie tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-649">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-650">Zakres źródłowy, z którego elementy są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-650">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="3d729-651">Zakres, który zawiera zestaw elementów do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-651">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-652">Usuwa wszystkie wystąpienia wiodące i końcowe zestawu elementów określonych w zakresie tylko do odczytu z zakresu tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-652">Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="3d729-653">Przycięty zakres tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-653">The trimmed read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-654">Jeśli `trimElements` jest pusty, zakres jest zwracany bez zmian.</span><span class="sxs-lookup"><span data-stu-id="3d729-654">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; Trim&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElement As T) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; Trim(ReadOnlySpan&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-655">Typ elementów w zakresie tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-655">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-656">Zakres źródłowy, z którego element jest usuwany.</span><span class="sxs-lookup"><span data-stu-id="3d729-656">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="3d729-657">Określony element do wyszukania i usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-657">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-658">Usuwa wszystkie wystąpienia wiodące i końcowe określonego elementu z zakresu tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-658">Removes all leading and trailing occurrences of a specified element from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="3d729-659">Przycięty zakres tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-659">The trimmed read-only span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Trim&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As Span(Of T), trimElements As ReadOnlySpan(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; Trim(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-660">Typ elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-660">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-661">Zakres źródłowy, z którego elementy są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-661">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="3d729-662">Zakres, który zawiera zestaw elementów do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-662">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-663">Usuwa wszystkie wystąpienia wiodące i końcowe zestawu elementów określonych w zakresie tylko do odczytu z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-663">Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a span.</span></span></summary>
        <returns><span data-ttu-id="3d729-664">Przycięty zakres.</span><span class="sxs-lookup"><span data-stu-id="3d729-664">The trimmed span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-665">Jeśli `trimElements` jest pusty, zakres jest zwracany bez zmian.</span><span class="sxs-lookup"><span data-stu-id="3d729-665">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Trim&lt;T&gt; (this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As Span(Of T), trimElement As T) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; Trim(Span&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-666">Typ elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-666">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-667">Zakres źródłowy, z którego element jest usuwany.</span><span class="sxs-lookup"><span data-stu-id="3d729-667">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="3d729-668">Określony element do wyszukania i usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-668">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-669">Usuwa wszystkie wystąpienia wiodące i końcowe określonego elementu z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-669">Removes all leading and trailing occurrences of a specified element from a span.</span></span></summary>
        <returns><span data-ttu-id="3d729-670">Przycięty zakres.</span><span class="sxs-lookup"><span data-stu-id="3d729-670">The trimmed span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static Memory&lt;char&gt; TrimEnd (this Memory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;char&gt; TrimEnd(valuetype System.Memory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (memory As Memory(Of Char)) As Memory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;char&gt; TrimEnd(Memory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Memory&lt;char&gt; -&gt; Memory&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="3d729-671">Pamięć źródłowa, z której są usuwane znaki.</span><span class="sxs-lookup"><span data-stu-id="3d729-671">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="3d729-672">Usuwa wszystkie końcowe znaki odstępu z regionu pamięci znaku.</span><span class="sxs-lookup"><span data-stu-id="3d729-672">Removes all trailing whitespace characters from a character memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-673">Przycięty region pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-673">The trimmed character memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; TrimEnd (this ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlyMemory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (memory As ReadOnlyMemory(Of Char)) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; TrimEnd(ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlyMemory&lt;char&gt; -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="3d729-674">Pamięć źródłowa, z której są usuwane znaki.</span><span class="sxs-lookup"><span data-stu-id="3d729-674">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="3d729-675">Usuwa wszystkie końcowe znaki odstępu z obszaru pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-675">Removes all trailing whitespace characters from a read-only character memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-676">Przycięty zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-676">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEnd (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimEnd(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-677">Zakres źródłowy, z którego znaki są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-677">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="3d729-678">Usuwa wszystkie końcowe znaki odstępu z zakresu znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-678">Removes all trailing whitespace characters from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="3d729-679">Przycięty zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-679">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static Span&lt;char&gt; TrimEnd (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;char&gt; TrimEnd(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As Span(Of Char)) As Span(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;char&gt; TrimEnd(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Span&lt;char&gt; -&gt; Span&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-680">Zakres źródłowy, z którego znaki są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-680">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="3d729-681">Usuwa wszystkie końcowe znaki odstępu z zakresu znaków.</span><span class="sxs-lookup"><span data-stu-id="3d729-681">Removes all trailing whitespace characters from a character span.</span></span></summary>
        <returns><span data-ttu-id="3d729-682">Przycięty zakres znaków.</span><span class="sxs-lookup"><span data-stu-id="3d729-682">The trimmed character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEnd (this ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlySpan`1&lt;char&gt; span, char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As ReadOnlySpan(Of Char), trimChar As Char) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimEnd(ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;char&gt; * char -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd (span, trimChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-683">Zakres źródłowy, z którego jest usuwany znak.</span><span class="sxs-lookup"><span data-stu-id="3d729-683">The source span from which the character is removed.</span></span></param>
        <param name="trimChar"><span data-ttu-id="3d729-684">Określony znak, który ma być wyszukiwany i usunięty.</span><span class="sxs-lookup"><span data-stu-id="3d729-684">The specified character to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-685">Usuwa wszystkie końcowe wystąpienia określonego znaku z zakresu tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-685">Removes all trailing occurrences of a specified character from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="3d729-686">Przycięty zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-686">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEnd (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As ReadOnlySpan(Of Char), trimChars As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimEnd(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd (span, trimChars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-687">Zakres źródłowy, z którego znaki są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-687">The source span from which the characters are removed.</span></span></param>
        <param name="trimChars"><span data-ttu-id="3d729-688">Zakres, który zawiera zestaw znaków do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-688">The span which contains the set of characters to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-689">Usuwa wszystkie końcowe wystąpienia zestawu znaków określone w zakresie tylko do odczytu z zakresu znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-689">Removes all trailing occurrences of a set of characters specified in a read-only span from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="3d729-690">Przycięty zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-690">The trimmed read-only character span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-691">Jeśli `trimChars` jest pusty, zamiast tego są usuwane znaki odstępu.</span><span class="sxs-lookup"><span data-stu-id="3d729-691">If `trimChars` is empty, whitespace characters are removed instead.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; TrimEnd&lt;T&gt; (this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElements As ReadOnlySpan(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimEnd(Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-692">Typ elementów w regionie pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-692">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="3d729-693">Pamięć źródłowa, z której zostaną usunięte elementy.</span><span class="sxs-lookup"><span data-stu-id="3d729-693">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="3d729-694">Zakres, który zawiera zestaw elementów do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-694">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-695">Usuwa wszystkie końcowe wystąpienia zestawu elementów określone w ramach obszaru pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-695">Removes all trailing occurrences of a set of elements specified in a read-only span from a memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-696">Przycięty region pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-696">The trimmed memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-697">Jeśli `trimElements` jest pusty, pamięć jest zwracana bez zmian.</span><span class="sxs-lookup"><span data-stu-id="3d729-697">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; TrimEnd&lt;T&gt; (this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElement As T) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimEnd(Memory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-698">Typ elementów w regionie pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-698">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="3d729-699">Pamięć źródłowa, z której element jest usuwany.</span><span class="sxs-lookup"><span data-stu-id="3d729-699">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="3d729-700">Określony element do wyszukania i usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-700">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-701">Usuwa wszystkie końcowe wystąpienia określonego elementu z obszaru pamięci znaku.</span><span class="sxs-lookup"><span data-stu-id="3d729-701">Removes all trailing occurrences of a specified element from a character memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-702">Przycięty region pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-702">The trimmed memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; TrimEnd&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimEnd(ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-703">Typ elementów w regionie pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-703">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="3d729-704">Pamięć źródłowa, z której zostaną usunięte elementy.</span><span class="sxs-lookup"><span data-stu-id="3d729-704">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="3d729-705">Zakres, który zawiera zestaw elementów do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-705">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-706">Usuwa wszystkie końcowe wystąpienia zestawu elementów określonego w obszarze tylko do odczytu z obszaru pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-706">Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-707">Przycięty region pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-707">The trimmed read-only memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-708">Jeśli `trimElements` jest pusty, pamięć jest zwracana bez zmian.</span><span class="sxs-lookup"><span data-stu-id="3d729-708">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; TrimEnd&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElement As T) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimEnd(ReadOnlyMemory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-709">Typ elementów w regionie pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-709">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="3d729-710">Pamięć źródłowa, z której element jest usuwany.</span><span class="sxs-lookup"><span data-stu-id="3d729-710">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="3d729-711">Określony element do wyszukania i usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-711">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-712">Usuwa wszystkie końcowe wystąpienia określonego elementu z obszaru pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-712">Removes all trailing occurrences of a specified element from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-713">Przycięty region pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-713">The trimmed read-only memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; TrimEnd&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimEnd(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-714">Typ elementów w zakresie tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-714">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-715">Zakres źródłowy, z którego elementy są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-715">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="3d729-716">Zakres, który zawiera zestaw elementów do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-716">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-717">Usuwa wszystkie końcowe wystąpienia zestawu elementów określone w zakresie tylko do odczytu z zakresu tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-717">Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="3d729-718">Przycięty zakres tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-718">The trimmed read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-719">Jeśli `trimElements` jest pusty, zakres jest zwracany bez zmian.</span><span class="sxs-lookup"><span data-stu-id="3d729-719">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; TrimEnd&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElement As T) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimEnd(ReadOnlySpan&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-720">Typ elementów w zakresie tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-720">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-721">Zakres źródłowy, z którego element jest usuwany.</span><span class="sxs-lookup"><span data-stu-id="3d729-721">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="3d729-722">Określony element do wyszukania i usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-722">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-723">Usuwa wszystkie końcowe wystąpienia określonego elementu z zakresu tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-723">Removes all trailing occurrences of a specified element from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="3d729-724">Przycięty zakres tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-724">The trimmed read-only span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; TrimEnd&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As Span(Of T), trimElements As ReadOnlySpan(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimEnd(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-725">Typ elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-725">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-726">Zakres źródłowy, z którego elementy są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-726">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="3d729-727">Zakres, który zawiera zestaw elementów do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-727">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-728">Usuwa wszystkie końcowe wystąpienia zestawu elementów określone w zakresie tylko do odczytu z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-728">Removes all trailing occurrences of a set of elements specified in a read-only span from a span.</span></span></summary>
        <returns><span data-ttu-id="3d729-729">Przycięty zakres.</span><span class="sxs-lookup"><span data-stu-id="3d729-729">The trimmed span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-730">Jeśli `trimElements` jest pusty, zakres jest zwracany bez zmian.</span><span class="sxs-lookup"><span data-stu-id="3d729-730">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; TrimEnd&lt;T&gt; (this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As Span(Of T), trimElement As T) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimEnd(Span&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-731">Typ elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-731">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-732">Zakres źródłowy, z którego element jest usuwany.</span><span class="sxs-lookup"><span data-stu-id="3d729-732">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="3d729-733">Określony element do wyszukania i usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-733">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-734">Usuwa wszystkie końcowe wystąpienia określonego elementu z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-734">Removes all trailing occurrences of a specified element from a span.</span></span></summary>
        <returns><span data-ttu-id="3d729-735">Przycięty zakres.</span><span class="sxs-lookup"><span data-stu-id="3d729-735">The trimmed span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static Memory&lt;char&gt; TrimStart (this Memory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;char&gt; TrimStart(valuetype System.Memory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (memory As Memory(Of Char)) As Memory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;char&gt; TrimStart(Memory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Memory&lt;char&gt; -&gt; Memory&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="3d729-736">Pamięć źródłowa, z której są usuwane znaki.</span><span class="sxs-lookup"><span data-stu-id="3d729-736">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="3d729-737">Usuwa wszystkie wiodące znaki odstępu z regionu pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-737">Removes all leading whitespace characters from a memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-738">Przycięty region pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-738">The trimmed character memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; TrimStart (this ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; TrimStart(valuetype System.ReadOnlyMemory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (memory As ReadOnlyMemory(Of Char)) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; TrimStart(ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlyMemory&lt;char&gt; -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="3d729-739">Pamięć źródłowa, z której są usuwane znaki.</span><span class="sxs-lookup"><span data-stu-id="3d729-739">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="3d729-740">Usuwa wszystkie wiodące znaki odstępu z obszaru pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-740">Removes all leading whitespace characters from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-741">Przycięty region pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-741">The trimmed read-only character memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimStart (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimStart(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimStart(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-742">Zakres źródłowy, z którego znaki są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-742">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="3d729-743">Usuwa wszystkie wiodące znaki odstępu z zakresu tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-743">Removes all leading whitespace characters from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="3d729-744">Przycięty zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-744">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static Span&lt;char&gt; TrimStart (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;char&gt; TrimStart(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As Span(Of Char)) As Span(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;char&gt; TrimStart(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Span&lt;char&gt; -&gt; Span&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-745">Zakres źródłowy, z którego znaki są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-745">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="3d729-746">Usuwa wszystkie wiodące znaki odstępu z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-746">Removes all leading whitespace characters from a span.</span></span></summary>
        <returns><span data-ttu-id="3d729-747">Przycięty zakres znaków.</span><span class="sxs-lookup"><span data-stu-id="3d729-747">The trimmed character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimStart (this ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimStart(valuetype System.ReadOnlySpan`1&lt;char&gt; span, char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As ReadOnlySpan(Of Char), trimChar As Char) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimStart(ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;char&gt; * char -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart (span, trimChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-748">Zakres źródłowy, z którego jest usuwany znak.</span><span class="sxs-lookup"><span data-stu-id="3d729-748">The source span from which the character is removed.</span></span></param>
        <param name="trimChar"><span data-ttu-id="3d729-749">Określony znak, który ma być wyszukiwany i usunięty.</span><span class="sxs-lookup"><span data-stu-id="3d729-749">The specified character to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-750">Usuwa wszystkie wiodące wystąpienia określonego znaku z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-750">Removes all leading occurrences of a specified character from the span.</span></span></summary>
        <returns><span data-ttu-id="3d729-751">Przycięty zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-751">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimStart (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimStart(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As ReadOnlySpan(Of Char), trimChars As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimStart(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart (span, trimChars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="3d729-752">Zakres źródłowy, z którego znaki są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-752">The source span from which the characters are removed.</span></span></param>
        <param name="trimChars"><span data-ttu-id="3d729-753">Zakres, który zawiera zestaw znaków do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-753">The span which contains the set of characters to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-754">Usuwa wszystkie wiodące wystąpienia zestawu znaków określone w zakresie tylko do odczytu z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-754">Removes all leading occurrences of a set of characters specified in a read-only span from the span.</span></span></summary>
        <returns><span data-ttu-id="3d729-755">Przycięty zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-755">The trimmed read-only character span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-756">Jeśli `trimChars` jest pusty, zamiast tego są usuwane znaki odstępu.</span><span class="sxs-lookup"><span data-stu-id="3d729-756">If `trimChars` is empty, whitespace characters are removed instead.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; TrimStart&lt;T&gt; (this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElements As ReadOnlySpan(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimStart(Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-757">Typ elementów w regionie pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-757">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="3d729-758">Pamięć źródłowa, z której zostaną usunięte elementy.</span><span class="sxs-lookup"><span data-stu-id="3d729-758">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="3d729-759">Zakres, który zawiera zestaw elementów do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-759">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-760">Usuwa wszystkie wiodące wystąpienia zestawu elementów określonego w ramach obszaru pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-760">Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-761">Przycięty region pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-761">The trimmed memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-762">Jeśli `trimElements` jest pusty, pamięć jest zwracana bez zmian.</span><span class="sxs-lookup"><span data-stu-id="3d729-762">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; TrimStart&lt;T&gt; (this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElement As T) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimStart(Memory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-763">Typ elementów w regionie pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-763">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="3d729-764">Region pamięci źródłowej, z którego element jest usuwany.</span><span class="sxs-lookup"><span data-stu-id="3d729-764">The source memory region from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="3d729-765">Określony element do wyszukania i usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-765">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-766">Usuwa wszystkie wiodące wystąpienia określonego elementu z regionu pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-766">Removes all leading occurrences of a specified element from a memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-767">Przycięty region pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-767">The trimmed memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; TrimStart&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimStart(ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-768">Typ elementów w regionie pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-768">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="3d729-769">Pamięć źródłowa, z której zostaną usunięte elementy.</span><span class="sxs-lookup"><span data-stu-id="3d729-769">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="3d729-770">Zakres, który zawiera zestaw elementów do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-770">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-771">Usuwa wszystkie wiodące wystąpienia zestawu elementów określonego w ramach obszaru pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-771">Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-772">Przycięty region pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-772">The trimmed read-only memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-773">Jeśli `trimElements` jest pusty, pamięć jest zwracana bez zmian.</span><span class="sxs-lookup"><span data-stu-id="3d729-773">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; TrimStart&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElement As T) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimStart(ReadOnlyMemory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-774">Typ elementów w regionie pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-774">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="3d729-775">Pamięć źródłowa, z której element jest usuwany.</span><span class="sxs-lookup"><span data-stu-id="3d729-775">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="3d729-776">Określony element do wyszukania i usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-776">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-777">Usuwa wszystkie wiodące wystąpienia określonego elementu z regionu pamięci.</span><span class="sxs-lookup"><span data-stu-id="3d729-777">Removes all leading occurrences of a specified element from a memory region.</span></span></summary>
        <returns><span data-ttu-id="3d729-778">Przycięty region pamięci tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-778">The trimmed read-only memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; TrimStart&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimStart(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-779">Typ elementów w zakresie tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-779">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-780">Zakres źródłowy, z którego elementy są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-780">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="3d729-781">Zakres, który zawiera zestaw elementów do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-781">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-782">Usuwa wszystkie wiodące wystąpienia zestawu elementów określonego w zakresie tylko do odczytu z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-782">Removes all leading occurrences of a set of elements specified in a read-only span from the span.</span></span></summary>
        <returns><span data-ttu-id="3d729-783">Przycięty zakres tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-783">The trimmed read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-784">Jeśli `trimElements` jest pusty, zakres jest zwracany bez zmian.</span><span class="sxs-lookup"><span data-stu-id="3d729-784">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; TrimStart&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElement As T) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimStart(ReadOnlySpan&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-785">Typ elementów w zakresie tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-785">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-786">Zakres źródłowy, z którego element jest usuwany.</span><span class="sxs-lookup"><span data-stu-id="3d729-786">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="3d729-787">Określony element do wyszukania i usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-787">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-788">Usuwa wszystkie wiodące wystąpienia określonego elementu z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-788">Removes all leading occurrences of a specified element from the span.</span></span></summary>
        <returns><span data-ttu-id="3d729-789">Przycięty zakres tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3d729-789">The trimmed read-only span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; TrimStart&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As Span(Of T), trimElements As ReadOnlySpan(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimStart(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-790">Typ elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-790">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-791">Zakres źródłowy, z którego elementy są usuwane.</span><span class="sxs-lookup"><span data-stu-id="3d729-791">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="3d729-792">Zakres, który zawiera zestaw elementów do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-792">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="3d729-793">Usuwa wszystkie wiodące wystąpienia zestawu elementów określonego w zakresie tylko do odczytu z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-793">Removes all leading occurrences of a set of elements specified in a read-only span from the span.</span></span></summary>
        <returns><span data-ttu-id="3d729-794">Przycięty zakres.</span><span class="sxs-lookup"><span data-stu-id="3d729-794">The trimmed span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3d729-795">Jeśli `trimElements` jest pusty, zakres jest zwracany bez zmian.</span><span class="sxs-lookup"><span data-stu-id="3d729-795">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; TrimStart&lt;T&gt; (this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As Span(Of T), trimElement As T) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimStart(Span&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d729-796">Typ elementów w zakresie.</span><span class="sxs-lookup"><span data-stu-id="3d729-796">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="3d729-797">Zakres źródłowy, z którego element jest usuwany.</span><span class="sxs-lookup"><span data-stu-id="3d729-797">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="3d729-798">Określony element do wyszukania i usunięcia.</span><span class="sxs-lookup"><span data-stu-id="3d729-798">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="3d729-799">Usuwa wszystkie wiodące wystąpienia określonego elementu z zakresu.</span><span class="sxs-lookup"><span data-stu-id="3d729-799">Removes all leading occurrences of a specified element from the span.</span></span></summary>
        <returns><span data-ttu-id="3d729-800">Przycięty zakres.</span><span class="sxs-lookup"><span data-stu-id="3d729-800">The trimmed span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
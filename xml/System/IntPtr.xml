<Type Name="IntPtr" FullName="System.IntPtr">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="63f4a1755f8d61ad935003e6b4d1d67365feef10" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37480682" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct IntPtr : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit native int extends System.ValueType implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.IntPtr" />
  <TypeSignature Language="VB.NET" Value="Public Structure IntPtr&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public value class IntPtr : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type nativeint = struct&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="9d5f2-101">Typ specyficzny dla platformy, który jest używany do reprezentowania wskaźnika lub uchwytu.</span>
      <span class="sxs-lookup">
        <span data-stu-id="9d5f2-101">A platform-specific type that is used to represent a pointer or a handle.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d5f2-102"><xref:System.IntPtr> Typu została zaprojektowana jako liczba całkowita, które są specyficzne dla platformy.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-102">The <xref:System.IntPtr> type is designed to be an integer whose size is platform-specific.</span></span> <span data-ttu-id="9d5f2-103">Oznacza to, że wystąpienia tego typu powinien być 32-bitowy, systemach operacyjnych i sprzętu 32-bitowych i 64-bitowego na 64-bitowym sprzęcie oraz systemach operacyjnych.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-103">That is, an instance of this type is expected to be 32-bits on 32-bit hardware and operating systems, and 64-bits on 64-bit hardware and operating systems.</span></span>  
  
 <span data-ttu-id="9d5f2-104"><xref:System.IntPtr> Typ może być używany przez języki, które obsługują wskaźników i jako typowe metody odwołujące się do danych między językami, które nie obsługują wskaźników i.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-104">The <xref:System.IntPtr> type can be used by languages that support pointers, and as a common means of referring to data between languages that do and do not support pointers.</span></span>  
  
 <span data-ttu-id="9d5f2-105"><xref:System.IntPtr> obiekty mogą również do przechowywania dojść.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-105"><xref:System.IntPtr> objects can also be used to hold handles.</span></span> <span data-ttu-id="9d5f2-106">Na przykład wystąpień <xref:System.IntPtr> są używane w szerokim zakresie w <xref:System.IO.FileStream?displayProperty=nameWithType> klasy utrzymującej dojścia do plików.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-106">For example, instances of <xref:System.IntPtr> are used extensively in the <xref:System.IO.FileStream?displayProperty=nameWithType> class to hold file handles.</span></span>  
  
 <span data-ttu-id="9d5f2-107"><xref:System.IntPtr> Typ jest zgodny ze specyfikacją CLS, podczas gdy <xref:System.UIntPtr> typ jest niezgodny.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-107">The <xref:System.IntPtr> type is CLS-compliant, while the <xref:System.UIntPtr> type is not.</span></span> <span data-ttu-id="9d5f2-108">Tylko <xref:System.IntPtr> typ jest używany w środowisko uruchomieniowe języka wspólnego.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-108">Only the <xref:System.IntPtr> type is used in the common language runtime.</span></span> <span data-ttu-id="9d5f2-109"><xref:System.UIntPtr> Typu znajduje się przede wszystkim do obsługi architektury symetrii z <xref:System.IntPtr> typu.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-109">The <xref:System.UIntPtr> type is provided mostly to maintain architectural symmetry with the <xref:System.IntPtr> type.</span></span>  
  
 <span data-ttu-id="9d5f2-110">Ten typ implementuje <xref:System.Runtime.Serialization.ISerializable> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-110">This type implements the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9d5f2-111">W poniższym przykładzie użyto wskaźnikami zarządzanymi, aby odwrócić znaków w tablicy.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-111">The following example uses managed pointers to reverse the characters in an array.</span></span> <span data-ttu-id="9d5f2-112">Po inicjuje <xref:System.String> obiektu i pobiera jego długość go wykonuje następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="9d5f2-112">After it initializes a <xref:System.String> object and gets its length, it does the following:</span></span>  
  
1.  <span data-ttu-id="9d5f2-113">Wywołania <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> metodę, aby skopiować ciąg Unicode do niezarządzanej pamięci jako znak ANSI (jednobajtowych).</span><span class="sxs-lookup"><span data-stu-id="9d5f2-113">Calls the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> method to copy the Unicode string to unmanaged memory as an ANSI (one-byte) character.</span></span> <span data-ttu-id="9d5f2-114">Metoda ta zwraca <xref:System.IntPtr> obiektu, który wskazuje na początku ciągu niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-114">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged string.</span></span> <span data-ttu-id="9d5f2-115">W przykładzie w języku Visual Basic używa tego wskaźnika bezpośrednio; w przykładach C++ i C# jest rzutowany na wskaźnik do typu byte.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-115">The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</span></span>  
  
2.  <span data-ttu-id="9d5f2-116">Wywołania <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> metodę, aby przydzielić taką samą liczbę bajtów, ponieważ zajmuje niezarządzanego ciągu.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-116">Calls the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> method to allocate the same number of bytes as the unmanaged string occupies.</span></span> <span data-ttu-id="9d5f2-117">Metoda ta zwraca <xref:System.IntPtr> obiektu, który wskazuje na początku bloku niezarządzanej pamięci.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-117">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged block of memory.</span></span> <span data-ttu-id="9d5f2-118">W przykładzie w języku Visual Basic używa tego wskaźnika bezpośrednio; w przykładach C++ i C# jest rzutowany na wskaźnik do typu byte.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-118">The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</span></span>  
  
3.  <span data-ttu-id="9d5f2-119">W przykładzie w języku Visual Basic definiuje zmienną o nazwie `offset` jest równa długości ciągów ANSI.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-119">The Visual Basic example defines a variable named `offset` that is equal to the length of the ANSI string.</span></span> <span data-ttu-id="9d5f2-120">Służy do określenia przesunięcie do niezarządzanej pamięci, do której są kopiowane dalej karty w ciągu ANSI.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-120">It is used to determine the offset into unmanaged memory to which the next charter in the ANSI string is copied.</span></span> <span data-ttu-id="9d5f2-121">Ponieważ jej wartość początkową długość ciągu, operacji kopiowania skopiuj znaku od początku ciągu znaków na końcu bloku pamięci.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-121">Because its starting value is the length of the string, the copy operation will copy a character from the start of the string to the end of the memory block.</span></span>  
  
     <span data-ttu-id="9d5f2-122">Wywołanie przykłady C# i C++ <xref:System.IntPtr.ToPointer%2A> metodę, aby uzyskać niezarządzanym wskaźnikiem do adres początkowy ciąg i niezarządzane bloku pamięci, i Dodaj jeden mniejsza niż długość ciągu na ciąg ANSI adres początkowy.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-122">The C# and C++ examples call the <xref:System.IntPtr.ToPointer%2A> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and they add one less than the length of the string to the starting address of the ANSI string.</span></span> <span data-ttu-id="9d5f2-123">Ponieważ wskaźnik niezarządzanego ciągu teraz wskazuje na końcu ciągu znaków, operacji kopiowania skopiuj znaków od końca ciągu na początku bloku pamięci.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-123">Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</span></span>  
  
4.  <span data-ttu-id="9d5f2-124">Wykorzystuje pętlę do skopiowania każdego znaku z ciągu do niezarządzanego bloku pamięci.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-124">Uses a loop to copy each character from the string to the unmanaged block of memory.</span></span>  
  
     <span data-ttu-id="9d5f2-125">Przykład wywołuje języka Visual Basic <xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType> metodę w celu odczytania bajtów (lub znaków jednobajtowych) na określone przesunięcie od wskaźnika zarządzanych na ciąg ANSI.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-125">The Visual Basic example calls the <xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType> method to read the byte (or one-byte character) at a specified offset from the managed pointer to the ANSI string.</span></span> <span data-ttu-id="9d5f2-126">Przesunięcie jest zwiększany z każdą iteracją pętli.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-126">The offset is incremented with each iteration of the loop.</span></span> <span data-ttu-id="9d5f2-127">Następnie wywołuje <xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType> metodę, aby zapisać bajt adres pamięci, zdefiniowane przez adres początkowy niezarządzanych bloku pamięci oraz `offset`.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-127">It then calls the <xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType> method to write the byte to the memory address defined by the starting address of the unmanaged block of memory plus `offset`.</span></span> <span data-ttu-id="9d5f2-128">Następnie zmniejsza `offset`.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-128">It then decrements `offset`.</span></span>  
  
     <span data-ttu-id="9d5f2-129">C# i C++ przykłady wykonać operację kopiowania, a następnie dekrementacja wskaźnik na adres następnej pozycji w niezarządzanych ciąg ANSI i zwiększyć wskaźnik do następnego adresu w bloku niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-129">The C# and C++ examples perform the copy operation, then decrement the pointer to the address of the next location in the unmanaged ANSI string and increment the pointer to the next address in the unmanaged block.</span></span>  
  
5.  <span data-ttu-id="9d5f2-130">Wszystkie przykłady, wywołanie <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> można przekonwertować bloku niezarządzanej pamięci, zawierający skopiowany ciąg ANSI, Unicode zarządzanych <xref:System.String> obiektu.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-130">All examples call the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <xref:System.String> object.</span></span>  
  
6.  <span data-ttu-id="9d5f2-131">Po wyświetleniu ciągi oryginalnego i wycofane, wywołaj wszystkie przykłady <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> metodę, aby zwolnić pamięć przydzielona dla niezarządzanego ciągu ANSI i niezarządzane bloku pamięci.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-131">After displaying the original and reversed strings, all examples call the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</span></span>  
  
 [!code-cpp[System.IntPtr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.intptr/cpp/topointer.cpp#1)]
 [!code-csharp[System.IntPtr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr/cs/topointer.cs#1)]
 [!code-vb[System.IntPtr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr/vb/topointer.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="9d5f2-132">Ten typ jest bezpieczny wątkowo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="9d5f2-132">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.UIntPtr" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9d5f2-133">Inicjuje nowe wystąpienie klasy <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-133">Initializes a new instance of <see cref="T:System.IntPtr" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(int value);" />
      <MemberSignature Language="F#" Value="new nativeint : int -&gt; nativeint" Usage="new System.nativeint value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="9d5f2-134">Wskaźnik lub uchwyt zawarte w całkowita 32-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-134">A pointer or handle contained in a 32-bit signed integer.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-135">Inicjuje nowe wystąpienie klasy <see cref="T:System.IntPtr" /> przy użyciu określonego wskaźnika 32-bitowego lub uchwyt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-135">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified 32-bit pointer or handle.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(long value);" />
      <MemberSignature Language="F#" Value="new nativeint : int64 -&gt; nativeint" Usage="new System.nativeint value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="9d5f2-136">Wskaźnik lub uchwyt zawarte w całkowita 64-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-136">A pointer or handle contained in a 64-bit signed integer.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-137">Inicjuje nowe wystąpienie klasy <see cref="T:System.IntPtr" /> przy użyciu określonego wskaźnika 64-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-137">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified 64-bit pointer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d5f2-138">Wyjątek jest generowany tylko, jeśli wartość `value` wymaga więcej bity niż bieżąca obsługuje platformy.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-138">An exception is only thrown if the value of `value` requires more bits than the current platform supports.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="9d5f2-139">Na platformie 32-bitowych <paramref name="value" /> jest za duży lub za mały, aby przedstawić jako <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-139">On a 32-bit platform, <paramref name="value" /> is too large or too small to represent as an <see cref="T:System.IntPtr" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (void* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Void*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(void* value);" />
      <MemberSignature Language="F#" Value="new nativeint : nativeptr&lt;unit&gt; -&gt; nativeint" Usage="new System.nativeint value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Void*" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="9d5f2-140">Wskaźnik do nieokreślonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-140">A pointer to an unspecified type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-141">Inicjuje nowe wystąpienie klasy <see cref="T:System.IntPtr" /> przy użyciu określonego wskaźnik do nieokreślonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-141">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified pointer to an unspecified type.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="9d5f2-142">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-142">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="9d5f2-143">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-143">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Void" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static IntPtr Add (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Add(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Add(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Add(IntPtr pointer, int offset);" />
      <MemberSignature Language="F#" Value="static member Add : nativeint * int -&gt; nativeint" Usage="System.nativeint.Add (pointer, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="9d5f2-144">Wskaźnik, aby dodać przesunięcie do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-144">The pointer to add the offset to.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="9d5f2-145">Przesunięcie do dodania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-145">The offset to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-146">Dodaje wartość przesunięcia do wartości wskaźnika.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-146">Adds an offset to the value of a pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-147">Nowy wskaźnik, który odzwierciedla dodanie <paramref name="offset" /> do <paramref name="pointer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-147">A new pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d5f2-148"><xref:System.IntPtr.Add%2A> Metoda zgłasza wyjątku, jeśli wynik jest za duży, aby przedstawić jako wskaźnik na określonej platformie.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-148">The <xref:System.IntPtr.Add%2A> method does not throw an exception if the result is too large to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="9d5f2-149">Zamiast tego w kontekście niesprawdzanym wykonywana jest operacja dodawania.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-149">Instead, the addition operation is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="9d5f2-150">Języki, które nie obsługują przeciążanie operatora lub niestandardowych operatorów można użyć tej metody można dodać przesunięcie do wartości wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-150">Languages that do not support operator overloading or custom operators can use this method to add an offset to the value of a pointer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9d5f2-151">Poniższy przykład tworzy wystąpienie <xref:System.IntPtr> obiekt, który wskazuje na początku 10 elementowej tablicy, a następnie wywołuje <xref:System.IntPtr.Add%2A> metody w celu wykonania iteracji elementów w tablicy.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-151">The following example instantiates an <xref:System.IntPtr> object that points to the beginning of a ten-element array, and then calls the <xref:System.IntPtr.Add%2A> method to iterate the elements in the array.</span></span>  
  
 [!code-csharp[System.IntPtr.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.add/cs/add1.cs#1)]
 [!code-vb[System.IntPtr.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="nativeint.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="9d5f2-152">Obiekt do porównania z tym wystąpieniem lub <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-152">An object to compare with this instance or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-153">Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-153">Returns a value indicating whether this instance is equal to a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-154">
            <see langword="true" /> Jeśli <paramref name="obj" /> jest wystąpieniem <see cref="T:System.IntPtr" /> i równości wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-154">
              <see langword="true" /> if <paramref name="obj" /> is an instance of <see cref="T:System.IntPtr" /> and equals the value of this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="nativeint.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d5f2-155">Zwraca kod skrótu dla tego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-155">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-156">Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-156">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static IntPtr operator + (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Addition(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr operator +(IntPtr pointer, int offset);" />
      <MemberSignature Language="F#" Value="static member ( + ) : nativeint * int -&gt; nativeint" Usage="pointer + offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="9d5f2-157">Wskaźnik, aby dodać przesunięcie do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-157">The pointer to add the offset to.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="9d5f2-158">Przesunięcie do dodania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-158">The offset to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-159">Dodaje wartość przesunięcia do wartości wskaźnika.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-159">Adds an offset to the value of a pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-160">Nowy wskaźnik, który odzwierciedla dodanie <paramref name="offset" /> do <paramref name="pointer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-160">A new pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d5f2-161"><xref:System.IntPtr.op_Addition%2A> Metoda definiuje operacja dodawania dla <xref:System.IntPtr> obiektów.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-161">The <xref:System.IntPtr.op_Addition%2A> method defines the addition operation for <xref:System.IntPtr> objects.</span></span> <span data-ttu-id="9d5f2-162">Dzięki niej poniższy kod.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-162">It enables code such as the following.</span></span>  
  
 [!code-csharp[System.IntPtr.op_Addition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.op_addition/cs/addition1.cs#1)]
 [!code-vb[System.IntPtr.op_Addition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.op_addition/vb/addition1.vb#1)]  
  
 <span data-ttu-id="9d5f2-163">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.IntPtr.Add%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-163">Languages that do not support custom operators can call the <xref:System.IntPtr.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="9d5f2-164">Operacja dodawania nie zgłosi wyjątek, jeśli wynik jest za duży, aby przedstawić jako wskaźnik na określonej platformie.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-164">The addition operation does not throw an exception if the result is too large to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="9d5f2-165">Zamiast tego jest wykonywane w kontekście niesprawdzanym.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-165">Instead, it is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="9d5f2-166">Jest równoważne metodę dla tego operatora <xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="9d5f2-166">The equivalent method for this operator is <xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.Add(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(native int value1, native int value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (value1 As IntPtr, value2 As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : nativeint * nativeint -&gt; bool" Usage="value1 = value2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value1" Type="System.IntPtr" />
        <Parameter Name="value2" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value1">
          <span data-ttu-id="9d5f2-167">Pierwszy wskaźnik lub uchwyt do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-167">The first pointer or handle to compare.</span>
          </span>
        </param>
        <param name="value2">
          <span data-ttu-id="9d5f2-168">Drugi wskaźnik lub uchwyt do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-168">The second pointer or handle to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-169">Określa, czy dwa określone wystąpienia elementu <see cref="T:System.IntPtr" /> są takie same.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-169">Determines whether two specified instances of <see cref="T:System.IntPtr" /> are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-170">
            <see langword="true" /> Jeśli <paramref name="value1" /> jest równa <paramref name="value2" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-170">
              <see langword="true" /> if <paramref name="value1" /> equals <paramref name="value2" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="9d5f2-171">Jest równoważne metodę dla tego operatora <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="9d5f2-171">The equivalent method for this operator is <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9d5f2-172">Konwertuje określony typ danych do <see cref="T:System.IntPtr" /> wartość lub <see cref="T:System.IntPtr" /> wartość na określony typ danych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-172">Converts a specified data type to an <see cref="T:System.IntPtr" /> value, or an <see cref="T:System.IntPtr" /> value to a specified data type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Int32)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(int value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : int -&gt; nativeint" Usage="System.nativeint.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="9d5f2-173">Całkowita 32-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-173">A 32-bit signed integer.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-174">Konwertuje wartość całkowita 32-bitowego do <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-174">Converts the value of a 32-bit signed integer to an <see cref="T:System.IntPtr" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-175">Nowe wystąpienie klasy <see cref="T:System.IntPtr" /> inicjowane <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-175">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks></remarks>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Long) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(long value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : int64 -&gt; nativeint" Usage="System.nativeint.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="9d5f2-176">Całkowita 64-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-176">A 64-bit signed integer.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-177">Konwertuje wartość całkowita 64-bitowego do <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-177">Converts the value of a 64-bit signed integer to an <see cref="T:System.IntPtr" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-178">Nowe wystąpienie klasy <see cref="T:System.IntPtr" /> inicjowane <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-178">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks></remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="9d5f2-179">Na platformie 32-bitowych <paramref name="value" /> jest zbyt duży, aby reprezentowały <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-179">On a 32-bit platform, <paramref name="value" /> is too large to represent as an <see cref="T:System.IntPtr" />.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(IntPtr value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : nativeint -&gt; int" Usage="System.nativeint.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="9d5f2-180">Wskaźnik lub uchwyt, które można przekonwertować.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-180">The pointer or handle to convert.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-181">Konwertuje wartość określonego <see cref="T:System.IntPtr" /> do całkowita 32-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-181">Converts the value of the specified <see cref="T:System.IntPtr" /> to a 32-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-182">Zawartość <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-182">The contents of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d5f2-183">Wyjątek jest generowany tylko, jeśli wartość `value` wymaga więcej bity niż bieżąca obsługuje platformy.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-183">An exception is only thrown if the value of `value` requires more bits than the current platform supports.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="9d5f2-184">Na platformie 64-bitowych wartości <paramref name="value" /> jest zbyt duży, aby reprezentowały całkowita 32-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-184">On a 64-bit platform, the value of <paramref name="value" /> is too large to represent as a 32-bit signed integer.</span>
          </span>
        </exception>
        <altmember cref="M:System.IntPtr.ToInt32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(IntPtr value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : nativeint -&gt; int64" Usage="System.nativeint.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="9d5f2-185">Wskaźnik lub uchwyt, które można przekonwertować.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-185">The pointer or handle to convert.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-186">Konwertuje wartość określonego <see cref="T:System.IntPtr" /> do całkowita 64-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-186">Converts the value of the specified <see cref="T:System.IntPtr" /> to a 64-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-187">Zawartość <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-187">The contents of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks></remarks>
        <altmember cref="M:System.IntPtr.ToInt64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator void* (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname void* op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator void*(IntPtr value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : nativeint -&gt; nativeptr&lt;unit&gt;" Usage="System.nativeint.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="9d5f2-188">Wskaźnik lub uchwyt, które można przekonwertować.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-188">The pointer or handle to convert.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-189">Konwertuje wartość określonego <see cref="T:System.IntPtr" /> na wskaźnik do nieokreślonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-189">Converts the value of the specified <see cref="T:System.IntPtr" /> to a pointer to an unspecified type.</span>
          </span>
          <span data-ttu-id="9d5f2-190">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-190">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-191">Zawartość <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-191">The contents of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks></remarks>
        <altmember cref="M:System.IntPtr.ToPointer" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (void* value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(void* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(void* value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : nativeptr&lt;unit&gt; -&gt; nativeint" Usage="System.nativeint.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Void*" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="9d5f2-192">Wskaźnik do nieokreślonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-192">A pointer to an unspecified type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-193">Konwertuje określony wskaźnik nieokreślonego typu do <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-193">Converts the specified pointer to an unspecified type to an <see cref="T:System.IntPtr" />.</span>
          </span>
          <span data-ttu-id="9d5f2-194">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-194">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-195">Nowe wystąpienie klasy <see cref="T:System.IntPtr" /> inicjowane <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-195">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks></remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="9d5f2-196">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-196">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="9d5f2-197">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-197">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(native int value1, native int value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (value1 As IntPtr, value2 As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : nativeint * nativeint -&gt; bool" Usage="System.nativeint.op_Inequality (value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value1" Type="System.IntPtr" />
        <Parameter Name="value2" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value1">
          <span data-ttu-id="9d5f2-198">Pierwszy wskaźnik lub uchwyt do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-198">The first pointer or handle to compare.</span>
          </span>
        </param>
        <param name="value2">
          <span data-ttu-id="9d5f2-199">Drugi wskaźnik lub uchwyt do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-199">The second pointer or handle to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-200">Określa, czy dwa określone wystąpienia elementu <see cref="T:System.IntPtr" /> nie są takie same.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-200">Determines whether two specified instances of <see cref="T:System.IntPtr" /> are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-201">
            <see langword="true" /> Jeśli <paramref name="value1" /> nie jest równa <paramref name="value2" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-201">
              <see langword="true" /> if <paramref name="value1" /> does not equal <paramref name="value2" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="9d5f2-202">Jest równoważne metodę dla tego operatora <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="9d5f2-202">The equivalent method for this operator is <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static IntPtr operator - (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Subtraction(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr operator -(IntPtr pointer, int offset);" />
      <MemberSignature Language="F#" Value="static member ( - ) : nativeint * int -&gt; nativeint" Usage="pointer - offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="9d5f2-203">Wskaźnik na potrzeby odejmowania przesunięcie od.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-203">The pointer to subtract the offset from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="9d5f2-204">Przesunięcie do odjęcia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-204">The offset to subtract.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-205">Odejmuje przesunięcie od wartości wskaźnika.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-205">Subtracts an offset from the value of a pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-206">Nowy wskaźnik, który odzwierciedla odejmowania <paramref name="offset" /> z <paramref name="pointer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-206">A new pointer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d5f2-207"><xref:System.IntPtr.op_Subtraction%2A> Metoda określa operację odejmowania <xref:System.IntPtr> obiektów.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-207">The <xref:System.IntPtr.op_Subtraction%2A> method defines the subtraction operation for <xref:System.IntPtr> objects.</span></span> <span data-ttu-id="9d5f2-208">Dzięki niej poniższy kod.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-208">It enables code such as the following.</span></span>  
  
 [!code-csharp[System.IntPtr.op_Addition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.op_addition/cs/op_subtraction1.cs#2)]
 [!code-vb[System.IntPtr.op_Addition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.op_addition/vb/op_subtraction1.vb#2)]  
  
 <span data-ttu-id="9d5f2-209">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.IntPtr.Subtract%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-209">Languages that do not support custom operators can call the <xref:System.IntPtr.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="9d5f2-210">Operacja odejmowania nie zgłosi wyjątek, jeśli wynik jest za mały, aby przedstawić jako wskaźnik na określonej platformie.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-210">The subtraction operation does not throw an exception if the result is too small to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="9d5f2-211">Zamiast tego jest wykonywane w kontekście niesprawdzanym.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-211">Instead, it is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="9d5f2-212">Jest równoważne metodę dla tego operatora <xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="9d5f2-212">The equivalent method for this operator is <xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public static int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.IntPtr.Size" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int Size { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Size : int" Usage="System.nativeint.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9d5f2-213">Pobiera rozmiar tego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-213">Gets the size of this instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9d5f2-214">Wyrażony w bajtach rozmiar wskaźnika lub uchwytu w ramach tego procesu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-214">The size of a pointer or handle in this process, measured in bytes.</span>
          </span>
          <span data-ttu-id="9d5f2-215">Wartość tej właściwości jest 4 w procesie 32-bitowym i 8 w procesie 64-bitowym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-215">The value of this property is 4 in a 32-bit process, and 8 in a 64-bit process.</span>
          </span>
          <span data-ttu-id="9d5f2-216">Można zdefiniować typ procesu, ustawiając <see langword="/platform" /> Przełącz podczas kompilowania kodu za pomocą kompilatorów języków C# i Visual Basic.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-216">You can define the process type by setting the <see langword="/platform" /> switch when you compile your code with the C# and Visual Basic compilers.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static IntPtr Subtract (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Subtract(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Subtract(IntPtr pointer, int offset);" />
      <MemberSignature Language="F#" Value="static member Subtract : nativeint * int -&gt; nativeint" Usage="System.nativeint.Subtract (pointer, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="9d5f2-217">Wskaźnik na potrzeby odejmowania przesunięcie od.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-217">The pointer to subtract the offset from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="9d5f2-218">Przesunięcie do odjęcia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-218">The offset to subtract.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-219">Odejmuje przesunięcie od wartości wskaźnika.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-219">Subtracts an offset from the value of a pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-220">Nowy wskaźnik, który odzwierciedla odejmowania <paramref name="offset" /> z <paramref name="pointer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-220">A new pointer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d5f2-221"><xref:System.IntPtr.Subtract%2A> Metoda zgłasza wyjątku, jeśli wynik jest za mały, aby przedstawić jako wskaźnik na określonej platformie.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-221">The <xref:System.IntPtr.Subtract%2A> method does not throw an exception if the result is too small to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="9d5f2-222">Zamiast tego w kontekście niesprawdzanym wykonywana jest operacja odejmowania.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-222">Instead, the subtraction operation is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="9d5f2-223">Języki, które nie obsługują przeciążanie operatora lub operatorów niestandardowych, można użyć tej metody na potrzeby odejmowania przesunięcie od wartości wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-223">Languages that do not support operator overloading or custom operators can use this method to subtract an offset from the value of a pointer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9d5f2-224">Poniższy przykład tworzy wystąpienie <xref:System.IntPtr> obiekt, który wskazuje na końcu 10 elementowej tablicy, a następnie wywołuje <xref:System.IntPtr.Subtract%2A> metody do iteracji w odwrotnej kolejności elementów w tablicy.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-224">The following example instantiates an <xref:System.IntPtr> object that points to the end of a ten-element array, and then calls the <xref:System.IntPtr.Subtract%2A> method to iterate the elements in the array in reverse order.</span></span>  
  
 [!code-csharp[System.IntPtr.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.IntPtr.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.IEquatable&lt;System.IntPtr&gt;.Equals">
      <MemberSignature Language="C#" Value="bool IEquatable&lt;IntPtr&gt;.Equals (IntPtr other);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IEquatable&lt;System.IntPtr&gt;.Equals(native int other) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.System#IEquatable&lt;System#IntPtr&gt;#Equals(System.IntPtr)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As IntPtr) As Boolean Implements IEquatable(Of IntPtr).Equals" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IEquatable&lt;System.IntPtr&gt;.Equals(IntPtr other) = IEquatable&lt;IntPtr&gt;::Equals;" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="9d5f2-225">
            <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Obiektu do wypełniania danymi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-225">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object to populate with data.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="9d5f2-226">Miejsce docelowe dla serializacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-226">The destination for this serialization.</span>
          </span>
          <span data-ttu-id="9d5f2-227">(Ten parametr nie jest używany; określ <see langword="null" />.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-227">(This parameter is not used; specify <see langword="null" />.)</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-228">Wypełnia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiektu z dane potrzebne do serializacji bieżącego <see cref="T:System.IntPtr" /> obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-228">Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data needed to serialize the current <see cref="T:System.IntPtr" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d5f2-229">Ta metoda wypełni `info` parametru z wartością bieżącego <xref:System.IntPtr> obiektu.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-229">This method populates the `info` parameter with the value of the current <xref:System.IntPtr> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9d5f2-230">
            <paramref name="info" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-230">
              <paramref name="info" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="9d5f2-231">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-231">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="9d5f2-232">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-232">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public int ToInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ToInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function ToInt32 () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ToInt32();" />
      <MemberSignature Language="F#" Value="member this.ToInt32 : unit -&gt; int" Usage="nativeint.ToInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d5f2-233">Konwertuje wartość tego wystąpienia całkowita 32-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-233">Converts the value of this instance to a 32-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-234">32-bitowych całkowita równą wartości tego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-234">A 32-bit signed integer equal to the value of this instance.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="9d5f2-235">Na platformie 64-bitowych wartość tego wystąpienia jest za duży lub za mały, aby przedstawić jako całkowita 32-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-235">On a 64-bit platform, the value of this instance is too large or too small to represent as a 32-bit signed integer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public long ToInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function ToInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToInt64();" />
      <MemberSignature Language="F#" Value="member this.ToInt64 : unit -&gt; int64" Usage="nativeint.ToInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d5f2-236">Konwertuje wartość tego wystąpienia całkowita 64-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-236">Converts the value of this instance to a 64-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-237">64-bitowych całkowita równą wartości tego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-237">A 64-bit signed integer equal to the value of this instance.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToPointer">
      <MemberSignature Language="C#" Value="public void* ToPointer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void* ToPointer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void* ToPointer();" />
      <MemberSignature Language="F#" Value="member this.ToPointer : unit -&gt; nativeptr&lt;unit&gt;" Usage="nativeint.ToPointer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d5f2-238">Konwertuje wartość tego wystąpienia na wskaźnik do nieokreślonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-238">Converts the value of this instance to a pointer to an unspecified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-239">Wskaźnik do <see cref="T:System.Void" />; oznacza to, wskaźnik do pamięci zawierający dane nieokreślonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-239">A pointer to <see cref="T:System.Void" />; that is, a pointer to memory containing data of an unspecified type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9d5f2-240">W poniższym przykładzie użyto wskaźnikami zarządzanymi, aby odwrócić znaków w tablicy.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-240">The following example uses managed pointers to reverse the characters in an array.</span></span> <span data-ttu-id="9d5f2-241">Po inicjuje <xref:System.String> obiektu i pobiera jego długość go wykonuje następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="9d5f2-241">After it initializes a <xref:System.String> object and gets its length, it does the following:</span></span>  
  
-   <span data-ttu-id="9d5f2-242">Wywołania <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> metodę, aby skopiować jako (ANSI jednobajtowe) znaki ciągu Unicode do niezarządzanej pamięci.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-242">Calls the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> method to copy the Unicode string to unmanaged memory as ANSI (one-byte) characters.</span></span> <span data-ttu-id="9d5f2-243">Metoda ta zwraca <xref:System.IntPtr> obiektu, który wskazuje na początku ciągu niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-243">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged string.</span></span>  
  
-   <span data-ttu-id="9d5f2-244">Wywołania <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> metodę, aby przydzielić taką samą liczbę bajtów, ponieważ zajmuje niezarządzanego ciągu.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-244">Calls the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> method to allocate the same number of bytes as the unmanaged string occupies.</span></span> <span data-ttu-id="9d5f2-245">Metoda ta zwraca <xref:System.IntPtr> obiektu, który wskazuje na początku bloku niezarządzanej pamięci.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-245">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged block of memory.</span></span>  
  
-   <span data-ttu-id="9d5f2-246">Wywołania <xref:System.IntPtr.ToPointer%2A> metodę, aby uzyskać niezarządzanym wskaźnikiem do adres początkowy ciąg i niezarządzane bloku pamięci i dodaje jeden mniejsza niż długość ciągu na ciąg ANSI adres początkowy.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-246">Calls the <xref:System.IntPtr.ToPointer%2A> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and adds one less than the length of the string to the starting address of the ANSI string.</span></span> <span data-ttu-id="9d5f2-247">Ponieważ wskaźnik niezarządzanego ciągu teraz wskazuje na końcu ciągu znaków, operacji kopiowania skopiuj znaków od końca ciągu na początku bloku pamięci.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-247">Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</span></span>  
  
-   <span data-ttu-id="9d5f2-248">Wykorzystuje pętlę do skopiowania każdego znaku z ciągu do niezarządzanego bloku pamięci.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-248">Uses a loop to copy each character from the string to the unmanaged block of memory.</span></span> <span data-ttu-id="9d5f2-249">Po zakończeniu każdej operacji kopiowania go zmniejsza wskaźnik na adres następnej pozycji w niezarządzanych ciąg ANSI i zwiększa wskaźnik do następnego adresu w bloku niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-249">After each copy operation, it decrements the pointer to the address of the next location in the unmanaged ANSI string and increments the pointer to the next address in the unmanaged block.</span></span>  
  
-   <span data-ttu-id="9d5f2-250">Wywołania <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> można przekonwertować bloku niezarządzanej pamięci, zawierający skopiowany ciąg ANSI, Unicode zarządzanych <xref:System.String> obiektu.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-250">Calls the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <xref:System.String> object.</span></span>  
  
-   <span data-ttu-id="9d5f2-251">Po wyświetleniu ciągi oryginalnego i wycofane, wywołuje <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType> metodę, aby zwolnić pamięć przydzielona dla niezarządzanego ciągu ANSI i niezarządzane bloku pamięci.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-251">After displaying the original and reversed strings, calls the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</span></span>  
  
 [!code-cpp[System.IntPtr.ToPointer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.IntPtr.ToPointer/cpp/topointer.cpp#1)]
 [!code-csharp[System.IntPtr.ToPointer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.IntPtr.ToPointer/cs/topointer.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9d5f2-252">Konwertuje wartość liczbową bieżącego <see cref="T:System.IntPtr" /> obiektu na jego reprezentację ciągu równoważnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-252">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="nativeint.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d5f2-253">Konwertuje wartość liczbową bieżącego <see cref="T:System.IntPtr" /> obiektu na jego reprezentację ciągu równoważnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-253">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-254">Ciąg reprezentujący wartość tego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-254">The string representation of the value of this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d5f2-255">Jeśli wartość <xref:System.IntPtr.Size%2A> właściwość dla tego wystąpienia wynosi 4, a następnie ta metoda jest odpowiednikiem <xref:System.Int32.ToString%2A?displayProperty=nameWithType>; w przeciwnym razie metoda ta jest odpowiednikiem <xref:System.Int64.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-255">If the value of the <xref:System.IntPtr.Size%2A> property for this instance is 4, then this method is equivalent to <xref:System.Int32.ToString%2A?displayProperty=nameWithType>; otherwise, this method is equivalent to <xref:System.Int64.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="nativeint.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="9d5f2-256">Specyfikacja formatu, które regulują sposób bieżącego <see cref="T:System.IntPtr" /> obiekt jest konwertowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-256">A format specification that governs how the current <see cref="T:System.IntPtr" /> object is converted.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d5f2-257">Konwertuje wartość liczbową bieżącego <see cref="T:System.IntPtr" /> obiektu na jego reprezentację ciągu równoważnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-257">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d5f2-258">Ciąg reprezentujący wartość bieżącej <see cref="T:System.IntPtr" /> obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-258">The string representation of the value of the current <see cref="T:System.IntPtr" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d5f2-259">Jeśli `format` parametr jest `null` ani być pustym ciągiem (""), wartość zwracana jest formatowana przy użyciu specyfikatora formatu ogólnego ("G").</span><span class="sxs-lookup"><span data-stu-id="9d5f2-259">If the `format` parameter is `null` or an empty string (""), the return value is formatted with the general format specifier ("G").</span></span> <span data-ttu-id="9d5f2-260">Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) tematu.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-260">For more information about numeric format specifiers, see the [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) topic.</span></span>  
  
 <span data-ttu-id="9d5f2-261">Wartość zwracana jest formatowana przy użyciu niezmiennej kultury.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-261">The return value is formatted using the invariant culture.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly IntPtr Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly native int Zero" />
      <MemberSignature Language="DocId" Value="F:System.IntPtr.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly IntPtr Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : nativeint" Usage="System.nativeint.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9d5f2-262">Pole tylko do odczytu, który reprezentuje wskaźnik lub uchwyt, który został zainicjowany do zera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d5f2-262">A read-only field that represents a pointer or handle that has been initialized to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d5f2-263">Wartość tego pola nie jest odpowiednikiem `null`.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-263">The value of this field is not equivalent to `null`.</span></span> <span data-ttu-id="9d5f2-264">Użyj tego pola, aby efektywnie ustalić, czy wystąpienie <xref:System.IntPtr> została ustawiona na wartość inną niż zero.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-264">Use this field to efficiently determine whether an instance of <xref:System.IntPtr> has been set to a value other than zero.</span></span>  
  
 <span data-ttu-id="9d5f2-265">Załóżmy na przykład zmiennej, adres ip, to wystąpienie <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-265">For example, assume the variable, ip, is an instance of <xref:System.IntPtr>.</span></span> <span data-ttu-id="9d5f2-266">Można określić, jeśli została ustawiona przez porównanie z wartością zwróconą przez konstruktora, na przykład: " `if ip != new IntPtr(0)...` ".</span><span class="sxs-lookup"><span data-stu-id="9d5f2-266">You can determine if it has been set by comparing it to the value returned by a constructor, for example: " `if ip != new IntPtr(0)...` ".</span></span> <span data-ttu-id="9d5f2-267">Jednak wywoływania konstruktora uzyskać niezainicjowane wskaźnika jest nieefektywne.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-267">However, invoking a constructor to get an unintialized pointer is inefficient.</span></span> <span data-ttu-id="9d5f2-268">Zaleca się kodu albo " `if ip != IntPtr.Zero...` ", lub " `if !IntPtr.Zero.Equals(ip)...` ".</span><span class="sxs-lookup"><span data-stu-id="9d5f2-268">It is better to code either " `if ip != IntPtr.Zero...` ", or " `if !IntPtr.Zero.Equals(ip)...` ".</span></span>  
  
 <span data-ttu-id="9d5f2-269">Podczas wywoływania interfejsu API Windows z kodu zarządzanego, można przekazać <xref:System.IntPtr.Zero?displayProperty=nameWithType> zamiast `null` Jeśli argument powinien być albo wskaźnik lub `null`.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-269">When calling the Windows API from managed code, you can pass <xref:System.IntPtr.Zero?displayProperty=nameWithType> instead of `null` if an argument is expected to be either a pointer or a `null`.</span></span> <span data-ttu-id="9d5f2-270">Na przykład, następujące wywołania do Windows `CreateFile` funkcji wyczerpania <xref:System.IntPtr.Zero?displayProperty=nameWithType> dla `pSecurityAttributes` i `hTemplateFile` wartości argumentu.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-270">For example, the following call to the Windows `CreateFile` function supplies <xref:System.IntPtr.Zero?displayProperty=nameWithType> for the `pSecurityAttributes` and `hTemplateFile` argument values.</span></span>  
  
 [!code-csharp[System.IntPtr.Zero#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.zero/cs/zero4.cs#2)]
 [!code-vb[System.IntPtr.Zero#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.zero/vb/zero4.vb#2)]  
  
> [!NOTE]
>  <span data-ttu-id="9d5f2-271">Mimo że <xref:System.IntPtr.Zero> jest odpowiednikiem `null` dla funkcji Windows API przy użyciu parametrów lub wartości zwracanych, które mogą być albo wskaźników lub `null`, <xref:System.IntPtr.Zero> nie jest odpowiednikiem `null`.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-271">Although <xref:System.IntPtr.Zero> is equivalent to `null` for Windows API functions with parameters or return values that can be either pointers or `null`, <xref:System.IntPtr.Zero> is not equivalent to `null`.</span></span> <span data-ttu-id="9d5f2-272">Przekazywanie `null` do `IntPtr.Zero.Equals` metoda zawsze zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-272">Passing `null` to the `IntPtr.Zero.Equals` method always returns `false`.</span></span>  
  
 <span data-ttu-id="9d5f2-273">Możesz również sprawdzić `null` wartość zwracana z wywołania funkcji Windows API, które zwracają wskaźnik albo lub `null` przez porównanie wartości zwróconych z <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-273">You can also test for a `null` return value from Windows API function calls that return either a pointer or a `null` by comparing the returned value with <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9d5f2-274">Na przykład, wywołanie `GetWindow` funkcji w poniższym przykładzie podejmie próbę pobrania uchwyt okna nie istnieje.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-274">For example, the call to the `GetWindow` function in the following example tries to retrieve the handle of a non-existent window.</span></span> <span data-ttu-id="9d5f2-275">Jeśli wartość były wywoływane z niezarządzanego kodu, funkcja zwróci `null`, ale gdy jest wywoływana z kodu zarządzanego, zwraca <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9d5f2-275">If it were called from unmanaged code, the function would return `null`, but when it is called from managed code, it returns <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.IntPtr.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.zero/cs/zero2.cs#1)]
 [!code-vb[System.IntPtr.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.zero/vb/zero2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
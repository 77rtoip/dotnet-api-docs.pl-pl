<Type Name="Action&lt;T1,T2&gt;" FullName="System.Action&lt;T1,T2&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="dbf5594979f355dc5ad7caf7a0115434bd967b81" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36433526" />
  </Metadata>
  <TypeSignature Language="C#" Value="public delegate void Action&lt;in T1,in T2&gt;(T1 arg1, T2 arg2);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Action`2&lt;- T1, - T2&gt; extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Action`2" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Sub Action(Of In T1, In T2)(arg1 As T1, arg2 As T2)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T1, typename T2&gt;&#xA;public delegate void Action(T1 arg1, T2 arg2);" />
  <TypeSignature Language="F#" Value="type Action&lt;'T1, 'T2&gt; = delegate of 'T1 * 'T2 -&gt; unit" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T1">
      <Constraints>
        <ParameterAttribute>Contravariant</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="T2">
      <Constraints>
        <ParameterAttribute>Contravariant</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")</AttributeName>
    </Attribute>
  </Attributes>
  <Parameters>
    <Parameter Name="arg1" Type="T1" />
    <Parameter Name="arg2" Type="T2" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Void</ReturnType>
  </ReturnValue>
  <Docs>
    <typeparam name="T1">Typ pierwszego parametru metody, która hermetyzuje tego delegata.</typeparam>
    <typeparam name="T2">Typ drugiego parametru metody, która hermetyzuje tego delegata.</typeparam>
    <param name="arg1">Pierwszy parametr metody, która hermetyzuje tego delegata.</param>
    <param name="arg2">Drugi parametr metody, która hermetyzuje tego delegata.</param>
    <summary>Hermetyzuje metodę, która ma dwa parametry i nie zwraca wartości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Action%602> pełnomocnika, aby przekazać metody jako parametr bez jawnie deklarowanie niestandardowego obiektu delegowanego. Metoda hermetyzowany musi odpowiadać podpis metody jest definiowana za pomocą tego delegata. Oznacza to, że metoda hermetyzowany musi mieć dwa parametry zarówno przekazywane do niej przez wartość i nie może zwracać wartości. (W języku C#, metoda musi zwracać `void`. W języku Visual Basic, musi być zdefiniowany przez `Sub`...`End Sub` konstrukcja. Może również być metodę, która zwraca wartość, która jest ignorowana.) Zazwyczaj taka metoda jest używany do wykonania operacji.  
  
> [!NOTE]
>  Aby odwołać się do metody, która ma dwa parametry i zwraca wartość używać ogólnych <xref:System.Func%603> zamiast tego delegata.  
  
 Jeśli używasz <xref:System.Action%602> delegata, nie trzeba jawnie definiować delegata, który hermetyzuje metody dwa parametry. Na przykład następujący kod jawnie deklaruje delegata o nazwie `ConcatStrings`. Następnie przypisuje odwołanie do jednej z dwóch metod do jego wystąpienia obiektu delegowanego. Jedna z metod zapisuje dwa ciągi do konsoli; drugi zapisuje dwa ciągi do pliku.  
  
 [!code-csharp[System.Action~2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action~2/cs/Delegate.cs#1)]
 [!code-vb[System.Action~2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action~2/vb/Delegate.vb#1)]  
  
 Poniższy przykład ułatwiają ten kod przy uruchamianiu <xref:System.Action%602> delegata zamiast jawnie nowe delegowanie definiowanie i przypisywanie metodę o nazwie.  
  
 [!code-csharp[System.Action~2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action~2/cs/Action2.cs#2)]
 [!code-vb[System.Action~2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action~2/vb/action2.vb#2)]  
  
 Można również użyć <xref:System.Action%602> delegata z metody anonimowe w języku C#, jak pokazano w poniższym przykładzie. (Wprowadzenie do metod anonimowych, zobacz [metod anonimowych](~/docs/csharp/programming-guide/statements-expressions-operators/anonymous-methods.md).)  
  
 [!code-csharp[System.Action~2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action~2/cs/Anon.cs#3)]  
  
 Można także przypisać wyrażenia lambda do <xref:System.Action%602> delegować wystąpienia, jak pokazano w poniższym przykładzie. (Wprowadzenie do wyrażenia lambda, zobacz [wyrażenia Lambda](~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).)  
  
 [!code-csharp[System.Action~2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action~2/cs/Lambda.cs#4)]
 [!code-vb[System.Action~2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action~2/vb/lambda.vb#4)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Func`3" />
  </Docs>
</Type>
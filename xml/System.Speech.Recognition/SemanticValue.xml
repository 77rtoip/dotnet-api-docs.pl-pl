<Type Name="SemanticValue" FullName="System.Speech.Recognition.SemanticValue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cb3d2251c8bf68e25fad874effc116040eea9461" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36608210" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SemanticValue : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;string,System.Speech.Recognition.SemanticValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit SemanticValue extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.SemanticValue" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SemanticValue&#xA;Implements ICollection(Of KeyValuePair(Of String, SemanticValue)), IDictionary(Of String, SemanticValue), IEnumerable(Of KeyValuePair(Of String, SemanticValue))" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemanticValue sealed : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;, System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type SemanticValue = class&#xA;    interface IDictionary&lt;string, SemanticValue&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;string, SemanticValue&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;string, SemanticValue&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("'{_keyName}'= {Value}  -  Children = {_dictionary.Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Speech.Recognition.SemanticValue/SemanticValueDebugDisplay))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje semantycznego organizacji rozpoznaną frazę.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.SemanticValue> jest podstawowy obiekt, który implementuje semantycznego technologii w System.Speech. Interpretacji semantyki umożliwia gramatyki do zdefiniowania reguł do użycia przez aparat rozpoznawania, aby poprawnie zinterpretować wejście audio. Interpretacji semantyki umożliwia również aparatów rozpoznawania do organizowania ich wyników, aby mogą być łatwo przetworzone, zamiast zwracanie tylko rozpoznany słów i sekwencji słów.  
  
 Na przykład aparat rozpoznawania wyjściowej "Zmień tło czerwony" musi zostać przeanalizowany i interpretowane przez aplikację przed jej mogą być przetwarzane. A <xref:System.Speech.Recognition.Grammar> obiektu można określić interpretacji semantyki aby przetwarzania doprecyzowania, określając, że wyrażenie ma dwa podstruktury semantycznego jednego wyboru tła i pierwszego planu (reprezentowane przez tekst "tła"), a drugi wybierania kolor (reprezentowane przez tekst "red").  
  
 System.Speech reprezentuje semantykę operacji rozpoznawania w drzewie <xref:System.Speech.Recognition.SemanticValue> obiektów.  
  
 Każdy <xref:System.Speech.Recognition.SemanticValue> wystąpienia obejmuje następujące elementy:  
  
-   <xref:System.Object>, Dostępu za pomocą klasy <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość używana do klucza wystąpienia <xref:System.Speech.Recognition.SemanticValue>.  
  
-   Miara dokładność semantyczny analizy zwrócony przez <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> właściwości.  
  
-   Kolekcja par nazwa/wartość (<xref:System.Collections.Generic.KeyValuePair%602>) obiektów podrzędnych, które są również <xref:System.Speech.Recognition.SemanticValue> wystąpień. Węzły podrzędne są dostępne za pośrednictwem <xref:System.Speech.Recognition.SemanticValue> implementacja <xref:System.Collections.Generic.IDictionary%602> przy użyciu klucza ciągu wyszukiwania i <xref:System.Speech.Recognition.SemanticValue> wystąpienia, jak w poniższym przykładzie.  
  
    ```csharp  
    foreach (KeyValuePair<String, SemanticValue> child in semantics)   
    {  
      Utils.CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
    }  
    ```  
  
 Aparatów rozpoznawania w oparciu o System.Speech Podaj prawidłowy wystąpienia <xref:System.Speech.Recognition.SemanticValue> dla wszystkich danych wyjściowych z rozpoznawania, nawet w przypadku wyrażeń z jawne struktury semantycznego.  
  
 <xref:System.Speech.Recognition.SemanticValue> Wystąpienia dla wyrażenia są uzyskiwane przy użyciu <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> właściwość <xref:System.Speech.Recognition.RecognizedPhrase> obiektu (lub obiektów, które dziedziczą po niej, takich jak <xref:System.Speech.Recognition.RecognitionResult>).  
  
 <xref:System.Speech.Recognition.SemanticValue> obiekty uzyskać fraz rozpoznany bez struktury semantycznego charakteryzują się:  
  
-   Brak elementów podrzędnych (<xref:System.Speech.Recognition.SemanticValue.Count%2A> wynosi 0).  
  
-   <xref:System.Speech.Recognition.SemanticValue.Value%2A> Jest właściwość `null`.  
  
-   Sztuczne semantycznego ufności 1.0 (zwrócony przez <xref:System.Speech.Recognition.SemanticValue.Confidence%2A>).  
  
 Zazwyczaj tworzenie aplikacji <xref:System.Speech.Recognition.SemanticValue> wystąpienia pośrednio, dodanie ich do <xref:System.Speech.Recognition.Grammar> obiektów przy użyciu <xref:System.Speech.Recognition.SemanticResultValue> i <xref:System.Speech.Recognition.SemanticResultKey> wystąpień w połączeniu z <xref:System.Speech.Recognition.Choices> i <xref:System.Speech.Recognition.GrammarBuilder> obiektów.  
  
 Bezpośrednie konstrukcja <xref:System.Speech.Recognition.SemanticValue> wystąpienie jest przydatne podczas tworzenia jednoznacznie gramatyki.  
  
 <xref:System.Speech.Recognition.SemanticValue> implementuje <xref:System.Collections.Generic.IDictionary%602>, <xref:System.Collections.Generic.ICollection%601>, i <xref:System.Collections.Generic.IEnumerable%601> interfejsów.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono obsługi dla <xref:System.Speech.Recognition.Grammar.SpeechRecognized> zdarzeń, przeznaczone do obsługi poleceń, aby zmienić kolor pierwszego planu i tła.  
  
 Program obsługi identyfikuje rozpoznawaną frazy, które mają nie wewnętrzna struktura semantycznego został określony poprzez wykrycie <xref:System.Speech.Recognition.SemanticValue.Count%2A> o wartości zero i <xref:System.Speech.Recognition.SemanticValue.Value%2A> z `null`. Te dane wyjściowe rozpoznawania jest przetwarzany bezpośrednio przez analizowanie tekstu raw.  
  
 W pozostałych przypadkach program obsługi używa kluczy do uzyskania składników RGB nazwy kolorami, w celu ustalenia, czy polecenie zmieni się na pierwszym planie lub w tle, lub aby wskazać, że żaden prawidłowy klucz został znaleziony.  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        // and search for "background" or "foreground" in the input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
  
      // Make sure that text is readable regardless of the background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.SemanticValue" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj nie można utworzyć <xref:System.Speech.Recognition.SemanticValue> obiekty jawnie, z wyjątkiem przypadków, aby obsługiwać budynku jednoznacznie gramatyki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemanticValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemanticValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.SemanticValue : obj -&gt; System.Speech.Recognition.SemanticValue" Usage="new System.Speech.Recognition.SemanticValue value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Informacje, które mają być przechowywane w <see cref="T:System.Speech.Recognition.SemanticValue" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.SemanticValue" /> , określa wartość semantyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie ma żadnych ograniczeń na typ `value` mają być przechowywane.  
  
 Aplikacja może pobrać `value` za pomocą <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> wystąpienia.  
  
 Wartość <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> wystąpienie zostanie ustawiona na wartość -1.  
  
 A <xref:System.Speech.Recognition.SemanticValue> skonstruowany ta metoda nie może odwoływać się nazwę klucza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemanticValue (string keyName, object value, float confidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string keyName, object value, float32 confidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.#ctor(System.String,System.Object,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (keyName As String, value As Object, confidence As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemanticValue(System::String ^ keyName, System::Object ^ value, float confidence);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.SemanticValue : string * obj * single -&gt; System.Speech.Recognition.SemanticValue" Usage="new System.Speech.Recognition.SemanticValue (keyName, value, confidence)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="confidence" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="keyName">Klucz, który może służyć do niej odwoływać <see cref="T:System.Speech.Recognition.SemanticValue" /> wystąpienia.</param>
        <param name="value">Obiekt zawierający informacje mają być przechowywane w <see cref="T:System.Speech.Recognition.SemanticValue" /> obiektu.</param>
        <param name="confidence">A <see langword="float" /> zawierający szacunkową pewności semantyczny analizy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.SemanticValue" /> , określa wartość semantyki, nazwę klucza i poziomie zaufania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie ma żadnych ograniczeń na typ `value` mają być przechowywane.  
  
 Aplikacja może pobrać `value` za pomocą <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> wystąpienia.  
  
 `confidence` Parametr (zwrócony przez <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> wystąpienia), powinna należeć do zakresu od 0,0 do 1,0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Confidence">
      <MemberSignature Language="C#" Value="public float Confidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 Confidence" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Confidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Confidence As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float Confidence { float get(); };" />
      <MemberSignature Language="F#" Value="member this.Confidence : single" Usage="System.Speech.Recognition.SemanticValue.Confidence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca względną miarę pewności co do poprawności semantycznego analizy, który zwrócił bieżące wystąpienie klasy <see cref="T:System.Speech.Recognition.SemanticValue" />.</summary>
        <value>Zwraca <see langword="float" /> czyli względną miarę pewności semantyczny analizy zwróconą bieżące wystąpienie klasy <see cref="T:System.Speech.Recognition.SemanticValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.SemanticValue.Confidence%2A?displayProperty=nameWithType> Właściwość, która zwraca miarę prawidłowości semantyczny analizy, nie należy mylić z <xref:System.Speech.Recognition.RecognizedPhrase.Confidence%2A?displayProperty=nameWithType> właściwość, która zwraca miarę dokładność rozpoznawania mowy.  
  
   
  
## Examples  
 Poniższy przykład służy do przechodzenia rekursywnie, a następnie wyświetlić informacje (w tym zaufania) jako <xref:System.Windows.Forms.TreeNodeCollection>, lub jako węzły tworzących strukturę drzewa semantykę używane do rozpoznawania frazę.  
  
```csharp  
internal static void CreateSemanticsTreeNodes(  
        TreeNodeCollection nodes,  
        SemanticValue semantics,  
        String name)   
{  
  string semanticsText =   
      String.Format("  {0}  (Confidence {1})", name,semantics.Confidence);  
  
  // Format integers as hexadecimal.  
  if (semantics.Value == null )  
  {  
    semanticsText = semanticsText + " = null";  
  }  
  else if (semantics.Value.GetType() == typeof(int))   
  {  
    semanticsText = String.Format("{0} = {1:X} ", semanticsText, semantics.Value);  
  }   
  else   
  {  
    semanticsText = semanticsText + " = " + semantics.Value.ToString();  
  }  
  
  TreeNode semanticsNode = new TreeNode(semanticsText);  
  foreach (KeyValuePair<String, SemanticValue> child in semantics)   
  {  
    CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
  }  
  nodes.Add(semanticsNode);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As KeyValuePair(Of String, SemanticValue)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt; item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : System.Collections.Generic.KeyValuePair&lt;string, System.Speech.Recognition.SemanticValue&gt; -&gt; bool&#xA;override this.Contains : System.Collections.Generic.KeyValuePair&lt;string, System.Speech.Recognition.SemanticValue&gt; -&gt; bool" Usage="semanticValue.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Wystąpienie <see cref="T:System.Collections.Generic.KeyValuePair`2" /> wystąpienia dla danej wartości ciągu kluczy i <see cref="T:System.Speech.Recognition.SemanticValue" /> wystąpienia.</param>
        <summary>Wskazuje, czy bieżący <see cref="T:System.Speech.Recognition.SemanticValue" /> wystąpienia kolekcja zawiera określony klucz i konkretne wystąpienie <see cref="T:System.Speech.Recognition.SemanticValue" /> wyrażonej w postaci pary klucza/wartości.</summary>
        <returns>Zwraca <see langword="bool" /> czyli <see langword="true" /> Jeśli bieżące <see cref="T:System.Speech.Recognition.SemanticValue" /> zawiera wystąpienie <c>KeyValuePair&lt;ciąg, SemanticValue&gt; </c> dla określonej wartości ciągu kluczy i <see cref="T:System.Speech.Recognition.SemanticValue" />. W przeciwnym razie <see langword="false" /> jest zwracany.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.ContainsKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::String ^ key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : string -&gt; bool&#xA;override this.ContainsKey : string -&gt; bool" Usage="semanticValue.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.String" /> zawierające ciąg klucza używana do identyfikacji wystąpienia podrzędnych <see cref="T:System.Speech.Recognition.SemanticValue" /> w obszarze bieżącego <see cref="T:System.Speech.Recognition.SemanticValue" />.</param>
        <summary>Wskazuje, czy bieżący <see cref="T:System.Speech.Recognition.SemanticValue" /> wystąpienia kolekcja zawiera element podrzędny <see cref="T:System.Speech.Recognition.SemanticValue" /> wystąpienia z danego ciągu kluczy.</summary>
        <returns>Zwraca <see langword="bool" />, <see langword="true" /> Jeśli wystąpienie podrzędne <see cref="T:System.Speech.Recognition.SemanticValue" /> oznaczone ciągiem <paramref name="key" /> zostanie znaleziony, <see langword="false" /> , jeśli nie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dostępne są tylko dane według wartości klucza w czasie wykonywania, na przykład w celu sprawdzenia *semantycznego ["klucze"]. Wartość*, i generuje wyjątek. Zaleca się, że zapytania do obiektu o <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> przed użyciem <xref:System.Speech.Recognition.SemanticValue.Item%2A> z podanym wystąpieniu <xref:System.Speech.Recognition.SemanticValue>.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono obsługi dla <xref:System.Speech.Recognition.Grammar.SpeechRecognized> zdarzeń, przeznaczone do obsługi poleceń, aby zmienić kolor pierwszego planu i tła.  
  
 Po obsługi wyrażeń, które są rozpoznawane, ale nie semantycznego struktury, program obsługi sprawdza obecność odpowiednich kluczy przy użyciu <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> (`applyChgToBackground`, `colorRGBValueList`, lub `colorStringList)`i przetwarza je semantycznie zorganizowany.  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        // searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Speech.Recognition.SemanticValue.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca liczbę podrzędnych <see cref="T:System.Speech.Recognition.SemanticValue" /> obiekty w ramach bieżącej <see cref="T:System.Speech.Recognition.SemanticValue" /> wystąpienia.</summary>
        <value>Liczba podrzędnych <see cref="T:System.Speech.Recognition.SemanticValue" /> obiekty w ramach bieżącej <see cref="T:System.Speech.Recognition.SemanticValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie semantyczny analizy rozpoznawania, które nie mają zawsze <xref:System.Speech.Recognition.SemanticValue.Count%2A> wartość zero, a także <xref:System.Speech.Recognition.SemanticValue.Value%2A> z `null`.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono obsługi dla <xref:System.Speech.Recognition.Grammar.SpeechRecognized> zdarzeń, przeznaczone do obsługi poleceń, aby zmienić kolor pierwszego planu i tła.  
  
 Program obsługi identyfikuje rozpoznawaną frazy, które mają nie wewnętrzna struktura semantycznego został określony poprzez wykrycie <xref:System.Speech.Recognition.SemanticValue.Count%2A> o wartości zero i <xref:System.Speech.Recognition.SemanticValue.Value%2A> z `null`. Te dane wyjściowe rozpoznawania jest przetwarzany bezpośrednio przez analizowanie tekstu raw.  
  
 W pozostałych przypadkach program obsługi używa kluczy do uzyskania składników RGB nazwy kolorami, w celu ustalenia, czy polecenie zmieni się na pierwszym planie lub w tle, lub aby wskazać, że żaden prawidłowy klucz został znaleziony.  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        //  searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="semanticValue.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do obliczenia.</param>
        <summary>Określa, czy określony obiekt jest wystąpienie <c>SemanticValue</c> i taki sam, jak bieżące wystąpienie klasy <c>SemanticValue</c>.</summary>
        <returns>
          <see langword="true" /> Jeśli określony obiekt jest taki sam jak bieżący obiekt; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="semanticValue.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Udostępnia wartość skrótu dla <c>SemanticValue</c> obiektu.</summary>
        <returns>Wartość skrótu dla bieżącego <see cref="T:System.Speech.Recognition.SemanticValue" /> obiektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Speech.Recognition.SemanticValue this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Speech.Recognition.SemanticValue Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As String) As SemanticValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Speech::Recognition::SemanticValue ^ default[System::String ^] { System::Speech::Recognition::SemanticValue ^ get(System::String ^ key); void set(System::String ^ key, System::Speech::Recognition::SemanticValue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.Speech.Recognition.SemanticValue with get, set" Usage="System.Speech.Recognition.SemanticValue.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.SemanticValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz dla <see langword="KeyValuePair&lt;String, SemanticValue&gt;" /> zawarte w bieżącym wystąpieniu <see cref="T:System.Speech.Recognition.SemanticValue" />.</param>
        <summary>Zwraca podrzędny <see cref="T:System.Speech.Recognition.SemanticValue" /> wystąpień, które należą do bieżącej <see cref="T:System.Speech.Recognition.SemanticValue" />.</summary>
        <value>Zwraca podrzędny bieżącego <see cref="T:System.Speech.Recognition.SemanticValue" /> mogą być indeksowane jako część para klucz-wartość: <c>KeyValuePair&lt;ciągu</c><c>SemanticValue&gt;</c>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.SemanticValue.Item%2A> Jest tylko do odczytu i generuje wyjątków, jeśli elementy członkowskie zostaną zmodyfikowane.  
  
 Dostępne są tylko dane według wartości klucza w czasie wykonywania, nie podczas kompilacji, na przykład w celu sprawdzenia `semantic["myKey"].Value`. Określanie klucza, którego nie ma generuje wyjątek.  
  
 Aby wykryć obecności danego klucza, użyj <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> wystąpienia.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono obsługi dla <xref:System.Speech.Recognition.Grammar.SpeechRecognized> zdarzeń, przeznaczone do obsługi poleceń, aby zmienić kolor pierwszego planu i tła.  
  
 Po obsługi rozpoznanym frazy, które mają semantycznego struktury, program obsługi sprawdza obecność odpowiednich kluczy przy użyciu <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> (`applyChgToBackground`, `colorRGBValueList`, lub `colorStringList)`, a następnie używa <xref:System.Speech.Recognition.SemanticValue.Item%2A> właściwości uzyskanie węzłów wymagane informacje.  
  
 Korzystanie z <xref:System.Speech.Recognition.SemanticValue.Item%2A> jest ukończona.  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        //  searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantic keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of the foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Element zgłaszany, gdy podrzędny element członkowski bieżącego wystąpienia elementu <see cref="T:System.Speech.Recognition.SemanticValue" /> ma kluczowe dopasowanie <paramref name="key" /> parametru.</exception>
        <exception cref="T:System.InvalidOperationException">Element zgłaszany, gdy próbuje zmienić kod <see cref="T:System.Speech.Recognition.SemanticValue" /> pod danym indeksem.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As KeyValuePair(Of String, SemanticValue)) Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt; key) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Clear">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Clear() = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As KeyValuePair(Of String, SemanticValue)(), index As Integer) Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt; ^ array, int index) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Speech.Recognition.SemanticValue.System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (key As KeyValuePair(Of String, SemanticValue)) As Boolean Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt; key) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Add">
      <MemberSignature Language="C#" Value="void IDictionary&lt;string,SemanticValue&gt;.Add (string key, System.Speech.Recognition.SemanticValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Add(string key, class System.Speech.Recognition.SemanticValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Add(System.String,System.Speech.Recognition.SemanticValue)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As String, value As SemanticValue) Implements IDictionary(Of String, SemanticValue).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Add(System::String ^ key, System::Speech::Recognition::SemanticValue ^ value) = System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;string&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;string&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection(Of String) Implements IDictionary(Of String, SemanticValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys { System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Speech.Recognition.SemanticValue.System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Remove">
      <MemberSignature Language="C#" Value="bool IDictionary&lt;string,SemanticValue&gt;.Remove (string key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Remove(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (key As String) As Boolean Implements IDictionary(Of String, SemanticValue).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Remove(System::String ^ key) = System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.TryGetValue">
      <MemberSignature Language="C#" Value="bool IDictionary&lt;string,SemanticValue&gt;.TryGetValue (string key, out System.Speech.Recognition.SemanticValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.TryGetValue(string key, [out] class System.Speech.Recognition.SemanticValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#TryGetValue(System.String,System.Speech.Recognition.SemanticValue@)" />
      <MemberSignature Language="VB.NET" Value="Function TryGetValue (key As String, ByRef value As SemanticValue) As Boolean Implements IDictionary(Of String, SemanticValue).TryGetValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.TryGetValue(System::String ^ key, [Runtime::InteropServices::Out] System::Speech::Recognition::SemanticValue ^ % value) = System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;::TryGetValue;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;System.Speech.Recognition.SemanticValue&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class System.Speech.Recognition.SemanticValue&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection(Of SemanticValue) Implements IDictionary(Of String, SemanticValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;System::Speech::Recognition::SemanticValue ^&gt; ^ System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values { System::Collections::Generic::ICollection&lt;System::Speech::Recognition::SemanticValue ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Speech.Recognition.SemanticValue.System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Speech.Recognition.SemanticValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, SemanticValue)) Implements IEnumerable(Of KeyValuePair(Of String, SemanticValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj" Usage="System.Speech.Recognition.SemanticValue.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Właściwości tylko do odczytu, która zwraca informacje znajdujące się w bieżącym <see cref="T:System.Speech.Recognition.SemanticValue" />.</summary>
        <value>Zwraca <see cref="T:System.Object" /> zawierający informacje przechowywane w bieżącym wystąpieniu <see cref="T:System.Speech.Recognition.SemanticValue" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie semantyczny analizy rozpoznawania, których nie należy wprowadzać zawsze mieć <xref:System.Speech.Recognition.SemanticValue.Value%2A> z `null` i <xref:System.Speech.Recognition.SemanticValue.Count%2A> właściwości zero.  
  
   
  
## Examples  
 Poniższy przykład służy do przechodzenia rekursywnie, a następnie wyświetlić informacje (w tym zaufania) jako <xref:System.Windows.Forms.TreeNodeCollection>, lub jako węzły tworzących strukturę drzewa semantykę używane do rozpoznawania frazę.  
  
```csharp  
internal static void CreateSemanticsTreeNodes(  
          TreeNodeCollection nodes,  
          SemanticValue semantics,  
          String name)   
{  
  string semanticsText =   
      String.Format("  {0} ( Confidence {1})", name,semantics.Confidence);  
  
  // Format integers as hexadecimal.  
  if (semantics.Value == null )  
  {  
    semanticsText = semanticsText + " = null";  
  }  
  else if (semantics.Value.GetType() == typeof(int))   
  {  
    semanticsText = String.Format("{0} = {1:X} ", semanticsText, semantics.Value);  
  }  
  else   
  {  
    semanticsText = semanticsText + " = " + semantics.Value.ToString();  
  }  
  
  TreeNode semanticsNode = new TreeNode(semanticsText);  
  foreach (KeyValuePair<String, SemanticValue> child in semantics)   
  {  
    CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
  }  
  nodes.Add(semanticsNode);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
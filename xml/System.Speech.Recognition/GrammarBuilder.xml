<Type Name="GrammarBuilder" FullName="System.Speech.Recognition.GrammarBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="98da164e53b40a45073d60c360d0897674bf1959" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30580024" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class GrammarBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GrammarBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.GrammarBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class GrammarBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class GrammarBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebugSummary}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia mechanizm do programowego tworzenia ograniczenia dla gramatyki rozpoznawania mowy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gramatyki rozpoznawania mowy często są tworzone w formacie XML, zdefiniowane przez [mowy rozpoznawania gramatyki specyfikacji (SRGS) w wersji 1.0](http://go.microsoft.com/fwlink/?LinkId=201761). Jeśli znasz SRGS, ale chcesz wygenerować gramatyki programowo, możesz użyć <xref:System.Speech.Recognition.SrgsGrammar> przestrzeni nazw, której członkami są odpowiednie elementy i atrybuty zdefiniowane przez SRGS. Jeśli użytkownik nie zna SRGS lub ma niewielka, programistyczny sposobem tworzenia gramatyki, z których można efektywnie wykonywać wielu typowych scenariuszy; można użyć <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> klasy.  
  
 Użyj <xref:System.Speech.Recognition.GrammarBuilder> obiektów do kompilacji hierarchiczne drzewo składa się z <xref:System.Speech.Recognition.Choices> z powrotem do obiektów zawierających fraz oraz preambuły i po amble fraz w każdym węźle i rozpoczęta wartościami semantycznego zmienić znaczenie aplikacja.  
  
 Aby użyć <xref:System.Speech.Recognition.GrammarBuilder> utworzyć <xref:System.Speech.Recognition.Grammar> obiektów, wykonaj następujące kroki.  
  
1.  Utwórz <xref:System.Speech.Recognition.GrammarBuilder> obiektu.  
  
2.  Dołącz ograniczeń do <xref:System.Speech.Recognition.GrammarBuilder>, takich jak <xref:System.String> obiektów, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, <xref:System.Speech.Recognition.DictationGrammar>oraz inne <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które należy zdefiniować ograniczenia dla gramatyki.  
  
3.  Użyj jednej z <xref:System.Speech.Recognition.Grammar.%23ctor%2A> konstruktorów, aby utworzyć <xref:System.Speech.Recognition.Grammar> obiektu z ukończonej <xref:System.Speech.Recognition.GrammarBuilder> gramatyki.  
  
 Tworzenie z <xref:System.Speech.Recognition.GrammarBuilder> najlepiej nadaje się dla gramatyk zawierających jedną regułę zawierających listy lub prawdopodobnie listy list. Aby programowo kompilacji gramatyki, które mają wiele reguł lub wymagają wewnętrzna zasada odwołuje się, należy użyć klasy <xref:System.Speech.Recognition.SrgsGrammar> przestrzeni nazw.  
  
 Wystąpienia <xref:System.Speech.Recognition.GrammarBuilder> również można uzyskać przez niejawną konwersję z niektórych innych klas lub łącząc <xref:System.Speech.Recognition.GrammarBuilder> z drugi obiekt, który zawiera ograniczenia dla gramatyki. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatory i <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metody.  
  
 Aby dodać do istniejącej reguły <xref:System.Speech.Recognition.GrammarBuilder>, użyj <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, i <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> metody.  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek, używając gramatyki rozpoznawania mowy, który zawiera zduplikowane elementy semantycznego o takiej samej nazwie klucza lub wielu elementów semantyczne, które wielokrotnie można zmodyfikować wartości tego samego elementu semantycznego. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [przy użyciu SemanticResultKey i obiekty SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 Aby pomóc w debugowaniu, <xref:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases%2A> właściwość zwraca bieżący stan <xref:System.Speech.Recognition.GrammarBuilder> jako ciąg.  
  
 Aby uzyskać więcej informacji na temat tworzenia i używania gramatyki rozpoznawania mowy, zobacz [rozpoznawania mowy](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) i [tworzenie gramatyki GrammarBuilder](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty do skonstruowania gramatyki, która może rozpoznać jednej z dwóch wyrażeń "tło *colorChoice*" lub "ustawioną tła *colorChoice*".  
  
 W przykładzie użyto <xref:System.Speech.Recognition.Choices> obiekt, aby utworzyć listę dopuszczalne wartości *colorChoice* z tablicy <xref:System.String> obiektów. A <xref:System.Speech.Recognition.Choices> obiektu jest odpowiednikiem `one-of` elementu w specyfikacji SRGS i zawiera zestaw fraz, które mogą być rozpoznawane, gdy jest używany. Funkcja <xref:System.Speech.Recognition.Choices> obiektu do grupy macierzy dwa <xref:System.Speech.Recognition.GrammarBuilder> obiektów do pary alternatywnych wyrażeń, które może rozpoznać wynikowe gramatyki. Alternatywne słów ani fraz wchodzą w skład większości gramatyki i <xref:System.Speech.Recognition.Choices> obiekt zapewnia tę funkcję dla gramatyk skonstruowany przy <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 W przykładzie jest tworzony na koniec <xref:System.Speech.Recognition.Grammar> obiekt z <xref:System.Speech.Recognition.GrammarBuilder> utworzone na podstawie <xref:System.Speech.Recognition.Choices> obiektu.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.Choices" />
    <altmember cref="T:System.Speech.Recognition.Grammar" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawne konwersje z innych klas lub łącząc można także uzyskać wystąpienia tej klasy <xref:System.Speech.Recognition.GrammarBuilder> obiektu o drugi obiekt do z nową <xref:System.Speech.Recognition.GrammarBuilder>. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> metody.  
  
 Aby dodać ograniczeń do istniejącej <xref:System.Speech.Recognition.GrammarBuilder>, użyj <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, i <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> metod i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatora.  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek, używając gramatyki rozpoznawania mowy, który zawiera zduplikowane elementy semantycznego o takiej samej nazwie klucza lub wielu elementów semantyczne, które wielokrotnie można zmodyfikować wartości tego samego elementu semantycznego. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [przy użyciu SemanticResultKey i obiekty SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 Aby uzyskać więcej informacji na temat tworzenia i używania gramatyki rozpoznawania mowy, zobacz [rozpoznawania mowy](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) i [tworzenie gramatyki GrammarBuilder](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nową, pustą wystąpienie <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby dodać do istniejącej reguły <xref:System.Speech.Recognition.GrammarBuilder> obiektów, użyj <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, i <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> metod i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatora.  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek, używając gramatyki rozpoznawania mowy, który zawiera zduplikowane elementy semantycznego o takiej samej nazwie klucza lub wielu elementów semantyczne, które wielokrotnie można zmodyfikować wartości tego samego elementu semantycznego. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [przy użyciu SemanticResultKey i obiekty SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty do skonstruowania gramatyki, która może rozpoznać jednej z dwóch wyrażeń "tło *colorChoice*" lub "ustawioną tła *colorChoice*".  
  
 W przykładzie użyto <xref:System.Speech.Recognition.Choices> obiekt, aby utworzyć listę dopuszczalne wartości *colorChoice* z tablicy <xref:System.String> obiektów. A <xref:System.Speech.Recognition.Choices> obiektu jest odpowiednikiem `one-of` elementu w specyfikacji SRGS i zawiera zestaw fraz jedno z nich mogą być rozpoznawane, gdy jest używany. Funkcja <xref:System.Speech.Recognition.Choices> obiektu do grupy macierzy dwa <xref:System.Speech.Recognition.GrammarBuilder> obiektów do pary alternatywnych wyrażeń, które może rozpoznać wynikowe gramatyki. Alternatywne słów ani fraz wchodzą w skład większości gramatyki i <xref:System.Speech.Recognition.Choices> obiekt zapewnia tę funkcję dla gramatyk skonstruowany przy <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 W przykładzie jest tworzony na koniec <xref:System.Speech.Recognition.Grammar> obiekt z <xref:System.Speech.Recognition.GrammarBuilder> utworzone na podstawie <xref:System.Speech.Recognition.Choices> obiektu.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  GrammarBuilder bothPhrases = new GrammarBuilder();  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  bothPhrases.Append(bothChoices);  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Zestaw alternatyw.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z zestawu alternatyw.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, która zawiera opis rozwiązań alternatywnych, zobacz [przy użyciu opcji do utworzenia gramatyki GrammarBuilder](http://msdn.microsoft.com/library/5b18db18-a5f6-46a3-aa77-6d3141544efd).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty do skonstruowania gramatyki, która może rozpoznać jednej z dwóch wyrażeń "tło *colorChoice*" lub "ustawioną tła *colorChoice*".  
  
 W przykładzie użyto <xref:System.Speech.Recognition.Choices> obiekt, aby utworzyć listę dopuszczalne wartości *colorChoice* z tablicy <xref:System.String> obiektów. A <xref:System.Speech.Recognition.Choices> obiektu jest odpowiednikiem `one-of` elementu w specyfikacji SRGS i zawiera zestaw fraz, które mogą być rozpoznawane, gdy jest używany. Funkcja <xref:System.Speech.Recognition.Choices> obiektu do grupy macierzy dwa <xref:System.Speech.Recognition.GrammarBuilder> obiektów do pary alternatywnych wyrażeń, które może rozpoznać wynikowe gramatyki. Alternatywne słów ani fraz wchodzą w skład większości gramatyki i <xref:System.Speech.Recognition.Choices> obiekt zapewnia tę funkcję dla gramatyk skonstruowany przy <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 W przykładzie jest tworzony na koniec <xref:System.Speech.Recognition.Grammar> obiekt z <xref:System.Speech.Recognition.GrammarBuilder> utworzone na podstawie <xref:System.Speech.Recognition.Choices> obiektu.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz semantyki.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z klucz semantyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu <xref:System.Speech.Recognition.GrammarBuilder> wystąpienia z <xref:System.Speech.Recognition.SemanticResultValue> obiektu, Dodaj informacje semantyczne do gramatyki, które mogą być zwrócone w wyniku rozpoznawania. Są dostępne informacje semantyczne w wyniku rozpoznawania przy użyciu <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> właściwość <xref:System.Speech.Recognition.RecognizedPhrase>, która jest dostępna dla programu obsługi `SpeechRecognized` zdarzeń. Jeśli <xref:System.Speech.Recognition.GrammarBuilder> definiuje <xref:System.Speech.Recognition.SemanticResultKey>, to może służyć do pobierania informacje semantyczne w wyniku rozpoznawania, który jest skojarzony z kluczem. Zobacz przykład <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>i również wyświetlany <xref:System.Speech.Recognition.SemanticResultValue> i <xref:System.Speech.Recognition.SemanticResultKey>.  
  
> [!IMPORTANT]
>  Podczas konstruowania <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia, upewnij się, że można uniknąć tworzenia zduplikowane elementy semantycznego z tej samej nazwy klucza i wielu semantycznego elementy, które można zmodyfikować wielokrotnie <xref:System.Speech.Recognition.SemanticValue.Value%2A> Właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, w przypadku wykrycia takiej sytuacji. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [przy użyciu SemanticResultKey i obiekty SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, która może rozpoznać dwóch wyrażeń "tło *colorChoice*" i "ustawioną tła *colorChoice*", gdzie * colorChoice* wybrano zestaw kolorów. Gramatyka umożliwia użytkownikowi współpracuje z żadnym z kilku nazwy kolorów i zwraca semantycznego informacji o nazwie rozpoznanym kolorów do aplikacji.  
  
 W przykładzie użyto pojedynczy <xref:System.Speech.Recognition.SemanticResultKey> z można pobrać <xref:System.Speech.Recognition.SemanticValue> , który jest powiązany z kolor używany przez użytkownika. Na przykład, jeśli dane wejściowe zawierają wyrażenie "Set tła czerwony" wyników rozpoznawania zawiera wartość semantyki "#ff0000", który można pobrać przy użyciu programu obsługi dla `SpeechRecognized` zdarzeń.  
  
 W przykładzie użyto <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, i <xref:System.Speech.Recognition.GrammarBuilder> obiektów do kompilacji zawarte w ciągu ostatnich ograniczenia <xref:System.Speech.Recognition.GrammarBuilder> obiektu `bothPhrases`. Na koniec przykład tworzy <xref:System.Speech.Recognition.Grammar> obiektu z ukończonej <xref:System.Speech.Recognition.GrammarBuilder>.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices object for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the Grammar object from the GrammarBuilder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Semantycznego pary wartości lub nazwa/wartość.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy ze wartość semantyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu <xref:System.Speech.Recognition.GrammarBuilder> wystąpienia z <xref:System.Speech.Recognition.SemanticResultValue> obiektu, Dodaj informacje semantyczne do gramatyki, które mogą być zwrócone w wyniku rozpoznawania. Są dostępne informacje semantyczne w wyniku rozpoznawania przy użyciu <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> właściwość <xref:System.Speech.Recognition.RecognizedPhrase>, która jest dostępna dla programu obsługi `SpeechRecognized` zdarzeń. Jeśli <xref:System.Speech.Recognition.GrammarBuilder> definiuje <xref:System.Speech.Recognition.SemanticResultKey>, to może służyć do pobierania informacje semantyczne w wyniku rozpoznawania, który jest skojarzony z kluczem. Zobacz przykład <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>i również wyświetlany <xref:System.Speech.Recognition.SemanticResultValue> i <xref:System.Speech.Recognition.SemanticResultKey>.  
  
> [!IMPORTANT]
>  Podczas konstruowania <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia, upewnij się, że można uniknąć tworzenia zduplikowane elementy semantycznego z tej samej nazwy klucza i wielu semantycznego elementy, które można zmodyfikować wielokrotnie <xref:System.Speech.Recognition.SemanticValue.Value%2A> Właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, w przypadku wykrycia takiej sytuacji. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [przy użyciu SemanticResultKey i obiekty SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, która może rozpoznać dwóch wyrażeń "tło *colorChoice*" i "ustawioną tła *colorChoice*", gdzie * colorChoice* wybrano zestaw kolorów. Gramatyka umożliwia użytkownikowi współpracuje z żadnym z kilku nazwy kolorów i zwraca semantycznego informacji o nazwie rozpoznanym kolorów do aplikacji.  
  
 W przykładzie użyto pojedynczy <xref:System.Speech.Recognition.SemanticResultKey> z można pobrać <xref:System.Speech.Recognition.SemanticValue> , który jest powiązany z kolor używany przez użytkownika. Na przykład, jeśli dane wejściowe zawierają wyrażenie "Set tła czerwony" wyników rozpoznawania zawiera wartość semantyki "#ff0000", który można pobrać przy użyciu programu obsługi dla `SpeechRecognized` zdarzeń.  
  
 W przykładzie użyto <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, i <xref:System.Speech.Recognition.GrammarBuilder> obiektów do kompilacji zawarte w ciągu ostatnich ograniczenia <xref:System.Speech.Recognition.GrammarBuilder> obiektu `bothPhrases`. Na koniec przykład tworzy <xref:System.Speech.Recognition.Grammar> obiektu z ukończonej <xref:System.Speech.Recognition.GrammarBuilder>.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the grammar from the grammar builder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Sekwencja słów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z sekwencję słów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyrażenie reprezentuje dokładną frazę rozmowy rozpoznającego gramatyki rozpoznawania mowy. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, która zawiera ciągi, zobacz [przy użyciu ciągów można utworzyć gramatyki GrammarBuilder](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty do skonstruowania gramatyki, która może rozpoznać jednej z dwóch wyrażeń "tło *colorChoice*" lub "ustawioną tła *colorChoice*".  
  
 Po utworzeniu listy dopuszczalne wartości *colorChoice* przy użyciu <xref:System.Speech.Recognition.Choices> obiektu, w przykładzie są inicjowane dwa <xref:System.Speech.Recognition.GrammarBuilder> obiektów, `makePhrase` i `setPhrase`, za pomocą ciągu jako argument.  
  
 W przykładzie jest tworzony na koniec <xref:System.Speech.Recognition.Grammar> obiekt z <xref:System.Speech.Recognition.Choices> rzutować obiektu na <xref:System.Speech.Recognition.GrammarBuilder> obiektu.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">Sekwencja słów.</param>
        <param name="subsetMatchingCriteria">Zgodnym trybem gramatyki rozpoznawania mowy używany do rozpoznawania wyrażenie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy dla podzbioru sekwencję słów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase` Parametr reprezentuje frazę, które rozpoznają gramatyki rozpoznawania mowy. `subsetMatchingMode` Parametr określa podzestaw frazę, które można używany do osiągnięcia pomyślne rozpoznawanie całej frazy. To umożliwia utworzenie gramatyki z listą wpisów, które mają długie nazwy, bez konieczności mowy całą nazwę w celu dopasowania elementu.  
  
 Aby uzyskać więcej informacji na temat trybów dopasowania, zobacz <xref:System.Speech.Recognition.SubsetMatchingMode>. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, która zawiera ciągi, zobacz [przy użyciu ciągów można utworzyć gramatyki GrammarBuilder](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 Gramatyka rozpoznawanie mowy w poniższym przykładzie jest tworzony dla każdego <xref:System.Speech.Recognition.SubsetMatchingMode> wartość i gramatyki dotyczące wybierania pomiędzy pasującego gramatyki tryb. Jeśli wartość `phrase` jest "jeden dwa trzy cztery pięć sześć siedem", gramatyki Podsekwencji rozpoznaje dane wejściowe, a następnie "dwa trzy cztery", ale nie dane wejściowe "co trzy pięć". Jednak uporządkowane podzbiór gramatyki rozpoznaje obu tych danych wejściowych.  
  
```csharp  
  
private static IEnumerable<Grammar>  
  CreateMatchingModeGrammars(string phrase)  
{  
  List<Grammar> grammars = new List<Grammar>(5);  
  
  Choices modeChoice = new Choices();  
  Type enumType = typeof(SubsetMatchingMode);  
  foreach (SubsetMatchingMode mode in Enum.GetValues(enumType))  
  {  
    string modeName = Enum.GetName(enumType, mode);  
    modeName = BreakAtCaps(modeName);  
  
    GrammarBuilder builder = new GrammarBuilder(phrase, mode);  
    Grammar modeGrammar = new Grammar(builder);  
    modeGrammar.Name = modeName;  
    modeGrammar.Enabled = false;  
    grammars.Add(modeGrammar);  
  
    modeChoice.Add(modeName);  
  }  
  
  Grammar choiceGrammar = new Grammar(modeChoice);  
  choiceGrammar.Name = "choice";  
  grammars.Add(choiceGrammar);  
  
  return grammars;  
}  
  
// Insert spaces preceding each uppercase letter in a string.   
private static string BreakAtCaps(string item)  
{  
  if (item == null || item.Length == 0)  
  {  
    return item;  
  }  
  
  StringBuilder sb = new StringBuilder(item[0].ToString());  
  for (int i = 1; i < item.Length; i++)  
  {  
    char c = item[i];  
    if (char.IsUpper(c))  
    {  
      sb.Append(" ");  
    }  
    sb.Append(c);  
  }  
  
  return sb.ToString();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SubsetMatchingMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Powtórzony element.</param>
        <param name="minRepeat">Minimalna liczba uruchomień wejściowych dopasowania zdefiniowany przez element <c>konstruktora</c> musi wystąpić stanowić dopasowania.</param>
        <param name="maxRepeat">Maksymalną liczbę razy wejściowych dopasowania zdefiniowany przez element <c>konstruktora</c> może wystąpić stanowić dopasowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy elementu powtarzanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość `minRepeat` jest 0, a następnie nowe <xref:System.Speech.Recognition.GrammarBuilder> reprezentuje element opcjonalny.  
  
 Wartość `minRepeat` musi być większa lub równa 0 i mniejsza niż wartość `maxRepeat`.  
  
> [!IMPORTANT]
>  Po określeniu powtarza dla <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia, upewnij się, że można uniknąć tworzenia zduplikowane elementy semantycznego z tej samej nazwy klucza i wielu semantycznego elementy, które można zmodyfikować wielokrotnie <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, w przypadku wykrycia takiej sytuacji. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [przy użyciu SemanticResultKey i obiekty SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 Poniższy przykład tworzy porządkowania pizza gramatyki rozpoznawania mowy. Rozpoczyna się od wyrażenie opcjonalne, otwierając przez toppings 1 do 4, a zamyka się słowem "pizza".  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object from a string array of alternative toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">Powtórzony sekwencję słów.</param>
        <param name="minRepeat">Minimalna liczba przypadków, wprowadź wyrażenie dopasowania musi nastąpić stanowić dopasowania.</param>
        <param name="maxRepeat">Maksymalną liczbę razy wprowadź wyrażenie dopasowania może wystąpić stanowić dopasowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z sekwencji wyrazów w <see cref="T:System.String" /> i określa, ile razy <see cref="T:System.String" /> można powtarzać.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość `minRepeat` jest 0, a następnie nowe <xref:System.Speech.Recognition.GrammarBuilder> reprezentuje element opcjonalny.  
  
 Wartość `minRepeat` musi być większa lub równa 0 i mniejsza niż wartość `maxRepeat`. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, która zawiera ciągi, zobacz [przy użyciu ciągów można utworzyć gramatyki GrammarBuilder](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 Poniższy przykład tworzy porządkowania pizza gramatyki rozpoznawania mowy. Rozpoczyna się od wyrażenie opcjonalne, otwierając przez toppings 1 do 4, a zamyka się słowem "pizza".  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierającego sekwencję dwóch elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statycznych <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metody Podaj inny mechanizm, za pomocą którego można łączyć różnych typów, aby utworzyć różnorodności i elastyczność w gramatykach skompilowanej za pomocą <xref:System.Speech.Recognition.GrammarBuilder>. Te metody odpowiadają statycznych <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> metody, które także są zdefiniowane w <xref:System.Speech.Recognition.GrammarBuilder> klasy. Kolejność parametrów określa kolejność elementów w nowej <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 A <xref:System.Speech.Recognition.GrammarBuilder> również można uzyskać z <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, i [ciąg](http://go.microsoft.com/fwlink/?LinkId=159733) obiektów. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatorów.  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek, używając gramatyki rozpoznawania mowy, który zawiera zduplikowane elementy semantycznego o takiej samej nazwie klucza lub wielu elementów semantyczne, które wielokrotnie można zmodyfikować wartości tego samego elementu semantycznego. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [przy użyciu SemanticResultKey i obiekty SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 Aby uzyskać więcej informacji na temat tworzenia i używania gramatyki rozpoznawania mowy, zobacz [rozpoznawania mowy](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) i [tworzenie gramatyki GrammarBuilder](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">Pierwszy gramatyki element, który reprezentuje zestaw alternatyw.</param>
        <param name="builder">Drugi element gramatyki.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający <see cref="T:System.Speech.Recognition.Choices" /> obiektu, a następnie <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> sekwencji <paramref name="choices" /> następuje element <paramref name="builder" /> elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje niejawną konwersję z następujących klas:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektami wymienionymi powyżej dla `builder` parametru.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatorów.  
  
> [!IMPORTANT]
>  Podczas łączenia <xref:System.Speech.Recognition.Choices> i <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia, upewnij się, że można uniknąć tworzenia zduplikowane elementy semantycznego z tej samej nazwy klucza i wielu semantycznego elementy, które można zmodyfikować wielokrotnie <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, w przypadku wykrycia takiej sytuacji. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [dodać semantyki do gramatyki GrammarBuilder](https://msdn.microsoft.com/library/hh361581.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">Pierwszy element gramatyki.</param>
        <param name="choices">Drugi gramatyki element, który reprezentuje zestaw alternatyw.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu, a następnie <see cref="T:System.Speech.Recognition.Choices" /> obiektu.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> sekwencji <paramref name="builder" /> następuje element <paramref name="choices" /> elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje niejawną konwersję z następujących klas:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektami wymienionymi powyżej dla `builder` parametru.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatorów.  
  
> [!IMPORTANT]
>  Podczas łączenia <xref:System.Speech.Recognition.Choices> i <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia z innymi elementami gramatyki, upewnij się, że można uniknąć tworzenia zduplikowane elementy semantycznego o takiej samej nazwie klucza lub wiele elementów semantycznych można zmodyfikować wielokrotnie <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, w przypadku wykrycia takiej sytuacji. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [przy użyciu SemanticResultKey i obiekty SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, która może rozpoznać dwóch wyrażeń, "tło *kolor*" i "ustawioną tła *kolor*", gdzie *kolor* Wybrano zestaw kolorów. Różne typy są używane do tworzenia końcowego gramatyki, takich jak [ciąg](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiektów. Operatory rzutowania jawnego w wywołaniach <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metody są opcjonalne.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">Pierwszy element gramatyki.</param>
        <param name="builder2">Drugi element gramatyki.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierającego sekwencję dwóch <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektów.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> sekwencji <paramref name="builder1" /> następuje element <paramref name="builder2" /> elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje niejawną konwersję z następujących klas:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektami wymienionymi powyżej dla `builder1` lub `builder2` parametru.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatorów.  
  
> [!IMPORTANT]
>  Podczas łączenia <xref:System.Speech.Recognition.Choices> i <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia z innymi elementami gramatyki, upewnij się, że można uniknąć tworzenia zduplikowane elementy semantycznego o takiej samej nazwie klucza lub wiele elementów semantycznych można zmodyfikować wielokrotnie <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, w przypadku wykrycia takiej sytuacji. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [przy użyciu SemanticResultKey i obiekty SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, która może rozpoznać dwóch wyrażeń, "tło *kolor*" i "ustawioną tła *kolor*", gdzie *kolor* Wybrano zestaw kolorów. Różne typy są używane do tworzenia końcowego gramatyki, takich jak [ciąg](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiektów. Operatory rzutowania jawnego w wywołaniach <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metody są opcjonalne.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">Pierwszy element gramatyki.</param>
        <param name="phrase">Drugi gramatyki element, który reprezentuje sekwencję słów.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający <see cref="T:System.Speech.Recognition.GrammarBuilder" /> następuje wyrażenie obiektu.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> sekwencji <paramref name="builder" /> następuje element <paramref name="phrase" /> elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje niejawną konwersję z następujących klas:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektami wymienionymi powyżej dla `builder` parametru.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatorów.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, która może rozpoznać dwóch wyrażeń, "tło *kolor*" i "ustawioną tła *kolor*", gdzie *kolor* Wybrano zestaw kolorów. Różne typy są używane do tworzenia końcowego gramatyki, takich jak [ciąg](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiektów. Operatory rzutowania jawnego w wywołaniach <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metody są opcjonalne.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">Pierwszy gramatyki element, który reprezentuje sekwencję słów.</param>
        <param name="builder">Drugi element gramatyki.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający frazę następują <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> sekwencji <paramref name="phrase" /> następuje element <paramref name="builder" /> elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje niejawną konwersję z następujących klas:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektami wymienionymi powyżej dla `builder` parametru.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatorów.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, która może rozpoznać dwóch wyrażeń, "tło *kolor*" i "ustawioną tła *kolor*", gdzie *kolor* Wybrano zestaw kolorów. Różne typy są używane do tworzenia końcowego gramatyki, takich jak [ciąg](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiektów. Operatory rzutowania jawnego w wywołaniach <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metody są opcjonalne.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza element gramatyki do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tych metod do dołączenia elementy gramatyki do istniejącej <xref:System.Speech.Recognition.GrammarBuilder>. Jak utworzyć elementy gramatyki, można je dołączyć do istniejącego konstruktora stopniowo tworzenia ograniczenia dla gramatyki rozpoznawania mowy. Każdy element jest dodawany do końca bieżącego sekwencji elementów.  
  
 Ta metoda ma przeciążeń dołączania <xref:System.Speech.Recognition.GrammarBuilder>, <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, i <xref:System.Speech.Recognition.SemanticResultValue> obiektów.  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek, używając gramatyki rozpoznawania mowy, który zawiera zduplikowane elementy semantycznego o takiej samej nazwie klucza lub wielu elementów semantyczne, które wielokrotnie można zmodyfikować wartości tego samego elementu semantycznego. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [przy użyciu SemanticResultKey i obiekty SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 Aby uzyskać więcej informacji na temat tworzenia i używania gramatyki rozpoznawania mowy, zobacz [rozpoznawania mowy](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) i [tworzenie gramatyki GrammarBuilder](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Zestaw alternatyw do dołączenia.</param>
        <summary>Dołącza zestaw alternatywy dla bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `alternateChoices` jest dodawany do końca bieżącego sekwencji elementów.  
  
> [!IMPORTANT]
>  Po dołączeniu <xref:System.Speech.Recognition.Choices> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień do <xref:System.Speech.Recognition.GrammarBuilder> obiektów, upewnij się, że można uniknąć tworzenia zduplikowane elementy semantycznego o takiej samej nazwie klucza lub wiele elementów semantyczne, które można wielokrotnie modyfikowanie <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, w przypadku wykrycia takiej sytuacji. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [SemanticResultValue zrozumienia i obiekty SemanticResultKey](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy zwrotów, takie jak "Kuba wywołanie w miejscu pracy" i "Anna wywołania na jego telefon komórkowy", gdzie jest opcjonalne słowo "phone". Przykład prezentuje użycie <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> metody.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Element gramatyki do dołączenia.</param>
        <summary>Dołącza element gramatyki do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `builder` jest dodawany do końca bieżącego sekwencji elementów gramatyki.  
  
> [!NOTE]
>  Po dołączeniu <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień do <xref:System.Speech.Recognition.GrammarBuilder> obiektów, upewnij się, że można uniknąć tworzenia zduplikowane elementy semantycznego o takiej samej nazwie klucza lub wiele elementów semantyczne, które można wielokrotnie modyfikowanie <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, w przypadku wykrycia takiej sytuacji. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [przy użyciu SemanticResultKey i obiekty SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy zwrotów, takie jak "Kuba wywołanie w miejscu pracy" i "Anna wywołania na jego telefon komórkowy", gdzie jest opcjonalne słowo "phone". <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty służą do utworzenia gramatyki. Przykład prezentuje użycie <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> metody.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz semantyki do dołączenia.</param>
        <summary>Dołącza klucz semantyki do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `key` jest dodawany do końca bieżącego sekwencji elementów.  
  
> [!IMPORTANT]
>  Po dołączeniu <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień do <xref:System.Speech.Recognition.GrammarBuilder> obiektów, upewnij się, że można uniknąć tworzenia zduplikowane elementy semantycznego z tej samej nazwy klucza i wielu semantycznego elementy, które można zmodyfikować wielokrotnie <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwości <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, w przypadku wykrycia takiej sytuacji. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [SemanticResultValue zrozumienia i obiekty SemanticResultKey](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 Poniższy przykład jest częścią aplikacji konsoli dotyczące wybierania miast źródło i miejsce docelowe w locie. Aplikacja rozpoznaje fraz, takie jak "Chcę udać z Miami do Chicago." Programu obsługi <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> używa zdarzeń <xref:System.Speech.Recognition.SemanticResultKey> wyodrębnić kodu lotnisku określone w <xref:System.Speech.Recognition.SemanticResultValue> dla miejscowości źródło i miejsce docelowe.  
  
```csharp  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create a Choices object and add  cities and airport codes  
        // using SemanticResultValue objects.  
        Choices cities = new Choices();  
        cities.Add(new SemanticResultValue("Chicago", "ORD"));  
        cities.Add(new SemanticResultValue("Boston", "BOS"));  
        cities.Add(new SemanticResultValue("Miami", "MIA"));  
        cities.Add(new SemanticResultValue("Dallas", "DFW"));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Wartość semantyki do dołączenia.</param>
        <summary>Dołącza wartość semantyki do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` jest dodawany do końca bieżącego sekwencji elementów.  
  
> [!IMPORTANT]
>  Po dołączeniu <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień do <xref:System.Speech.Recognition.GrammarBuilder> obiektów, upewnij się, że można uniknąć tworzenia zduplikowane elementy semantycznego z tej samej nazwy klucza i wielu semantycznego elementy, które można zmodyfikować wielokrotnie <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwości <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, w przypadku wykrycia takiej sytuacji. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [SemanticResultValue zrozumienia i obiekty SemanticResultKey](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 Poniższy przykład jest częścią aplikacji konsoli dotyczące wybierania miast źródło i miejsce docelowe w locie. Aplikacja rozpoznaje fraz, takie jak "Chcę udać z Miami do Chicago." Programu obsługi <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> używa zdarzeń <xref:System.Speech.Recognition.SemanticResultKey> wyodrębnić kodu lotnisku określone w <xref:System.Speech.Recognition.SemanticResultValue> dla miejscowości źródło i miejsce docelowe.  
  
```csharp  
  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create GrammarBuilder objects and append SemanticResultValue objects   
        // that contain cities and airport codes.  
  
        GrammarBuilder chicago = new GrammarBuilder();  
        chicago.Append(new SemanticResultValue("Chicago", "ORD"));  
  
        GrammarBuilder boston = new GrammarBuilder();  
        boston.Append(new SemanticResultValue("Boston", "BOS"));  
  
        GrammarBuilder miami = new GrammarBuilder();  
        miami.Append(new SemanticResultValue("Miami", "MIA"));  
  
        GrammarBuilder dallas = new GrammarBuilder();  
        dallas.Append(new SemanticResultValue("Dallas", "DFW"));  
  
        // Create a Choices object and add the cities using implicit conversion from   
        // SemanticResultValue to GrammarBuilder.  
        Choices cities = new Choices();  
        cities.Add(new Choices(new GrammarBuilder[] { chicago, boston, miami, dallas }));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Sekwencja wyrazy, które mają zostać dołączone.</param>
        <summary>Dołącza frazę do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase` jest dodawany do końca bieżącego sekwencji elementów.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">Sekwencja wyrazy, które mają zostać dołączone.</param>
        <param name="subsetMatchingCriteria">Zgodnym trybem gramatyki jest używany do rozpoznawania wyrażenie.</param>
        <summary>Dołącza element dla podzbioru frazę do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element podzestawu zostanie dodany na końcu aktualnie sekwencji elementów. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy używania ciągów, zobacz [przy użyciu ciągów można utworzyć gramatyki GrammarBuilder](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
 Aby uzyskać szczegółowe informacje na stronie Użyj podzestawu dopasowania tryby, zobacz <xref:System.Speech.Recognition.SubsetMatchingMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Gramatyka rozpoznawanie mowy w poniższym przykładzie jest tworzony dla każdego <xref:System.Speech.Recognition.SubsetMatchingMode> wartość. Na przykład wygenerowanego gramatyki `OrderedSubset` rozpoznaje wyrażeń, "trzy cztery pięć" i "co trzy pięć" i gramatyki `Subsequence` rozpoznaje frazę "trzy cztery pięć", ale nie hasło "co trzy pięć".  
  
```csharp  
  
private Grammar[] CreateSubsetMatchTest()  
{  
  List<Grammar> grammars = new List<Grammar>(4);  
  
  string phrase = "one two three four five six";  
  foreach (SubsetMatchingMode mode in  
    Enum.GetValues(typeof(SubsetMatchingMode)))  
  {  
    GrammarBuilder gb = new GrammarBuilder();  
    gb.Append(phrase, mode);  
  
    Grammar grammar = new Grammar(gb);  
    grammar.Name = mode.ToString();  
    grammars.Add(grammar);  
  }  
  
  return grammars.ToArray();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Element powtórzony gramatyki do dołączenia.</param>
        <param name="minRepeat">Minimalna liczba uruchomień wejściowych dopasowania zdefiniowany przez element <c>konstruktora</c> musi wystąpić stanowić dopasowania.</param>
        <param name="maxRepeat">Maksymalną liczbę razy wejściowych dopasowania zdefiniowany przez element <c>konstruktora</c> może wystąpić stanowić dopasowania.</param>
        <summary>Dołącza element powtórzony gramatyki do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `minRepeat` musi być większa lub równa 0 i mniejsza niż wartość `maxRepeat`.  
  
> [!IMPORTANT]
>  Po dołączeniu <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień do <xref:System.Speech.Recognition.GrammarBuilder> obiektów, upewnij się, że można uniknąć tworzenia zduplikowane elementy semantycznego o takiej samej nazwie klucza lub wiele elementów semantyczne, które można wielokrotnie modyfikowanie <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, w przypadku wykrycia takiej sytuacji. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [SemanticResultValue zrozumienia i obiekty SemanticResultKey](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy zwrotów, takie jak "Kuba wywołanie w miejscu pracy" i "Anna wywołania na jego telefon komórkowy", gdzie jest opcjonalne słowo "phone". <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty służą do utworzenia gramatyki. Przykład prezentuje użycie <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> metody.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">Sekwencja powtarzane wyrazy, które mają zostać dołączone.</param>
        <param name="minRepeat">Minimalną liczbę razy wejściowych dopasowania <c>frazy</c> musi wystąpić stanowić dopasowania.</param>
        <param name="maxRepeat">Maksymalną liczbę razy wejściowych dopasowania <c>frazy</c> może wystąpić stanowić dopasowania.</param>
        <summary>Dołącza powtarzane frazę do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `minRepeat` musi być większa lub równa 0 i mniejsza niż wartość `maxRepeat`.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy zwrotów, takie jak "Kuba wywołanie w miejscu pracy" i "Anna wywołania na jego telefon komórkowy", gdzie jest opcjonalne słowo "phone". <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty służą do utworzenia gramatyki. Przykład prezentuje użycie <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> metody.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendDictation">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza gramatyki dyktowania do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A> Metody umożliwiają dołączanie gramatyki dyktowania jako zasadę, aby <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Aby uzyskać więcej informacji na dyktowania gramatyki, zobacz <xref:System.Speech.Recognition.DictationGrammar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dołącza gramatyki dyktowania domyślne do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na dyktowania gramatyki, zobacz <xref:System.Speech.Recognition.DictationGrammar>.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, która będzie zawierała dyktowania.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation();  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation (string category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation(string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation (category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation(System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="category">Kategoria gramatyki dyktowania do dołączenia.</param>
        <summary>Dołącza gramatyki dyktowania określony do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby używać gramatyki dyktowania pisowni, ustaw `category` do `spelling`.  
  
 Aby uzyskać więcej informacji na dyktowania gramatyki, zobacz <xref:System.Speech.Recognition.DictationGrammar>.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, która zawiera reguły pisowni dyktowania gramatyki.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation("spelling");  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendRuleReference">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza pliku gramatyki lub reguła gramatyki do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> Metod można dołączyć pliku gramatyki lub reguła gramatyki z pliku. Te metody umożliwiają aplikacjom należy używać reguł wstępnie wdrożonego lub publicznie dostępnych gramatyki. Aplikacja musi mieć dostęp do odczytu do lokalizacji plików określony gramatyki.  
  
 Te metody mogą odczytywać gramatyki rozpoznawanie mowy w następujących formatach.  
  
-   Pliki w formacie XML, zgodnych ze standardami W3C [mowy rozpoznawania gramatyki specyfikacji (SRGS) w wersji 1.0](http://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Pliki binarne, zgodnych ze standardami firmy Microsoft mowy rozpoznawania gramatyki formatu binarnego (rozszerzenie pliku .cfg)  
  
 Kompilowanie SRGS XML format pliku gramatyki do pliku z rozszerzeniem .cfg gramatyka binarna może skrócić czas używane przez wyszukuje dopasowania, zwłaszcza jeśli gramatyki wymaga rozpoznawania dużą liczbą słów i wyrażeń. Aby dowiedzieć się, jak kompilowanie gramatykach SRGS na format binarny CFG, zobacz <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka lub Universal zasobów Identifier (URI) pliku, który zawiera opis gramatyki rozpoznawanie mowy w obsługiwanym formacie.</param>
        <summary>Dołącza plik definicji gramatyki do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dostarczony przez identyfikator URI `path` argument może być lokalnym lub zdalnym. Aplikacja musi mieć dostęp do odczytu do lokalizacji plików określony gramatyki.  
  
 Reprezentacja W3C mowy rozpoznawania gramatyki specyfikacji (SRGS) można zdefiniować reguły głównego. Ta metoda dołącza gramatyki, począwszy od jej główna reguła do bieżącej sekwencji elementów gramatyki. Aby dołączyć reguła gramatyki określonych, użyj <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie C# tworzy gramatyki rozpoznawania mowy, który używa reguły o nazwie `Cities` w pliku lokalnym SRGS cities.grxml. Zawartość pliku cities.grxml pojawia się poniżej przykładowy kod C#.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar1()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.AppendRuleReference("file://c:/temp/cities.grxml");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 1";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-16" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path, string rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path, string rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String, rule As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path, System::String ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rule" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku lub Universal zasobów Identifier (URI) pliku, który zawiera opis gramatyki rozpoznawanie mowy w obsługiwanym formacie.</param>
        <param name="rule">Identyfikator reguły do dołączenia, lub <see langword="null" /> do dołączenia domyślna reguła głównego pliku gramatyki.</param>
        <summary>Dołącza określony reguła gramatyki pliku definicji do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dostarczony przez identyfikator URI `path` argument może być lokalnym lub zdalnym. Aplikacja musi mieć dostęp do odczytu do lokalizacji plików określony gramatyki.  
  
 Umożliwia użycie <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> metodę, aby dołączyć zaczyna się jej główna reguła od pliku gramatyki.  
  
   
  
## Examples  
 W poniższym przykładzie C# tworzy gramatyki rozpoznawania mowy, który używa reguły o nazwie `Cities` w pliku lokalnym SRGS cities.grxml. Zawartość pliku cities.grxml pojawia się poniżej przykładowy kod C#.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar2()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.Append("Does");  
  builder.AppendRuleReference(@"c:\temp\cities.grxml", "Cities");  
  builder.Append("have a shuttle");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendWildcard">
      <MemberSignature Language="C#" Value="public void AppendWildcard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendWildcard() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendWildcard ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendWildcard();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dołącza element gramatyki rozpoznawania, który pasuje do żadnych danych do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element symbolu wieloznacznego zostanie dodany na końcu aktualnie sekwencji elementów.  
  
 Elemencie symbolu wieloznacznego dopasowuje dowolny rozmowy wyraz. Nie odpowiada hałas w tle lub wyciszenia.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki, która akceptuje dane wejściowe hasło jako symbolu wieloznacznego. Dołącza przykładzie <xref:System.Speech.Recognition.Grammar.SpeechRecognized?displayProperty=nameWithType> program obsługi zdarzeń do gramatyki, która weryfikuje wprowadzania hasła.  
  
```csharp  
private Grammar CreatePasswordGrammar()  
{  
  GrammarBuilder wildcardBuilder = new GrammarBuilder();  
  wildcardBuilder.AppendWildcard();  
  SemanticResultKey passwordKey =  
    new SemanticResultKey("Password", wildcardBuilder);  
  
  GrammarBuilder passwordBuilder =  
    new GrammarBuilder("My Password is");  
  passwordBuilder.Append(passwordKey);  
  
  Grammar passwordGrammar = new Grammar(passwordBuilder);  
  passwordGrammar.Name = "Password input";  
  
  passwordGrammar.SpeechRecognized +=  
    new EventHandler<SpeechRecognizedEventArgs>(  
      PasswordInputHandler);  
  
  return passwordGrammar;  
}  
  
// Handle the SpeechRecognized event for the password grammar.  
private void PasswordInputHandler(object sender, SpeechRecognizedEventArgs e)  
{  
  if (e.Result == null) return;  
  
  RecognitionResult result = e.Result;  
  SemanticValue semantics = e.Result.Semantics;  
  
  if (semantics.ContainsKey("Password"))  
  {  
    RecognizedAudio passwordAudio =  
      result.GetAudioForWordRange(  
        result.Words[3], result.Words[result.Words.Count - 1]);  
  
    if (IsValidPassword(passwordAudio))  
    {  
      Console.WriteLine("Password accepted.");  
  
      // Add code to handle a valid password here.  
    }  
    else  
    {  
      Console.WriteLine("Invalid password.");  
  
      // Add code to handle an invalid password here.  
    }  
  }  
}  
  
// Validate the password input.   
private bool IsValidPassword(RecognizedAudio passwordAudio)  
{  
  Console.WriteLine("Validating password.");  
  
  // Add password validation code here.  
  
  return false;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kulturę gramatyki rozpoznawania mowy.</summary>
        <value>Kultura <see cref="T:System.Speech.Recognition.GrammarBuilder" />. Wartość domyślna to wykonywanie wątku <see cref="P:System.Threading.Thread.CurrentUICulture" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> Konstruktor tworzy <xref:System.Speech.Recognition.Grammar> obiekt, który mogą być używane przez aparat rozpoznawania mowy odpowiedniego kultury. Tylko <xref:System.Speech.Recognition.GrammarBuilder.Culture%2A> właściwość <xref:System.Speech.Recognition.GrammarBuilder> podano jako parametr do konstruktora gramatyki jest używana do ustawiania kultura wynikowy gramatyki rozpoznawania mowy.  
  
 Microsoft Windows i interfejsu API System.Speech zaakceptować wszystkie prawidłowe kody języka kraju. Aby przeprowadzić rozpoznawanie mowy przy użyciu języka określonego w `Culture` właściwości, który obsługuje kod kraju język musi być zainstalowany aparatu rozpoznawania mowy. Aparatów rozpoznawania mowy dostarczonych z programem Microsoft Windows 7 skontaktować się z następujących kodów kraju języka.  
  
-   en-GB. Angielski (brytyjski)  
  
-   en-US. Angielski (Stany Zjednoczone)  
  
-   de-DE. Niemiecki (Niemcy)  
  
-   es-ES. Hiszpański (Hiszpania)  
  
-   fr-FR. Francuski (Francja)  
  
-   ja-JP. Japoński (Japonia)  
  
-   zh-CN. Chiński (Chiny)  
  
-   zh-TW. Chiński (Tajwan)  
  
 Język dwuliterowych kodów przykład "en", "fr" lub "es" również są dozwolone.  
  
   
  
## Examples  
 Poniższy przykład tworzy porządkowania pizza z maksymalnie cztery toppings gramatyki rozpoznawania mowy. W szczególności ustawia <xref:System.Speech.Recognition.GrammarBuilder> kultury obiektu język angielski (Stany Zjednoczone).  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.RecognizerInfo" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
      </Docs>
    </Member>
    <Member MemberName="DebugShowPhrases">
      <MemberSignature Language="C#" Value="public string DebugShowPhrases { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DebugShowPhrases" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DebugShowPhrases As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DebugShowPhrases { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg, który zawiera zawartość i struktura gramatyki zawarty w <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <value>Bieżący zawartości i struktury <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy porządkowania pizza z maksymalnie cztery toppings gramatyki rozpoznawania mowy. Zapisuje stan <xref:System.Speech.Recognition.GrammarBuilder> konsoli przed utworzeniem gramatyki. Ta metoda generuje następujące dane wyjściowe:  
  
-   `GrammarBuilder status: I would like a [cheese,mushroom,tomato,onion,anchovy,chic ken,pepperoni] and [cheese,mushroom,tomato,onion,anchovy,chicken,pepperoni] pizza`  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Write the contents and structure of the GrammarBuilder to the console.  
  Console.WriteLine("Grammar content and structure: {0}", gb.DebugShowPhrases);  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> odpowiadający sekwencję dwóch elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność argumentów operacji określa kolejność elementów w nowej <xref:System.Speech.Recognition.GrammarBuilder>.  
  
> [!IMPORTANT]
>  Ostrożność jest zalecane w przypadku łączenia <xref:System.Speech.Recognition.Choices> lub <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia z innymi elementami gramatyki. Aparat rozpoznawania mowy może zgłosić wyjątek, używając gramatyki rozpoznawania mowy, który zawiera zduplikowane elementy semantycznego o takiej samej nazwie klucza lub wielu elementów semantyczne, które wielokrotnie można zmodyfikować wartości tego samego elementu semantycznego. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [przy użyciu SemanticResultKey i obiekty SemanticResultValue](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 Aby uzyskać więcej informacji na temat tworzenia i używania gramatyki rozpoznawania mowy, zobacz [rozpoznawania mowy](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) i [tworzenie gramatyki GrammarBuilder](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">Pierwszy gramatyki element, który reprezentuje zestaw alternatyw.</param>
        <param name="builder">Drugi element gramatyki.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający <see cref="T:System.Speech.Recognition.Choices" /> obiektu, a następnie <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu.</summary>
        <returns>Zwraca <see cref="T:System.Speech.Recognition.GrammarBuilder" /> sekwencji <paramref name="choices" /> następuje parametru <paramref name="builder" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje konwersję z następujących klas.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektami wymienionymi powyżej dla `builder` parametru. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatorów.  
  
> [!IMPORTANT]
>  Podczas łączenia <xref:System.Speech.Recognition.Choices> i <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia, upewnij się, że można uniknąć tworzenia zduplikowane elementy semantycznego z tej samej nazwy klucza i wielu semantycznego elementy, które można zmodyfikować wielokrotnie <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, w przypadku wykrycia takiej sytuacji. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [SemanticResultValue zrozumienia i obiekty SemanticResultKey](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.Choices%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">Pierwszy element gramatyki.</param>
        <param name="choices">Drugi gramatyki element, który reprezentuje zestaw elementów alternatywnych.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający <see cref="T:System.Speech.Recognition.GrammarBuilder" /> następuje <see cref="T:System.Speech.Recognition.Choices" />.</summary>
        <returns>Zwraca <see cref="T:System.Speech.Recognition.GrammarBuilder" /> sekwencji <paramref name="builder" /> następuje parametru <paramref name="choices" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje konwersję z następujących klas:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektami wymienionymi powyżej dla `builder` parametru. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatorów.  
  
> [!IMPORTANT]
>  Podczas łączenia <xref:System.Speech.Recognition.Choices> i <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia, upewnij się, że można uniknąć tworzenia zduplikowane elementy semantycznego z tej samej nazwy klucza i wielu semantycznego elementy, które można zmodyfikować wielokrotnie <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, w przypadku wykrycia takiej sytuacji. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [SemanticResultValue zrozumienia i obiekty SemanticResultKey](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, która może rozpoznać dwóch wyrażeń, "tło *kolor*" i "ustawioną tła *kolor*", gdzie *kolor* Wybrano zestaw kolorów. Różne typy są używane do tworzenia końcowego gramatyki, takich jak [ciąg](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiektów.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">Pierwszy element gramatyki.</param>
        <param name="builder2">Drugi element gramatyki.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierającego sekwencję dwóch <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektów.</summary>
        <returns>Zwraca <see cref="T:System.Speech.Recognition.GrammarBuilder" /> sekwencji <paramref name="builder1" /> następuje parametru <paramref name="builder2" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje konwersję z następujących klas.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektami wymienionymi powyżej dla `builder1` i `builder2` parametrów. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatorów.  
  
> [!IMPORTANT]
>  Podczas łączenia <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia, upewnij się, że można uniknąć tworzenia zduplikowane elementy semantycznego z tej samej nazwy klucza i wielu semantycznego elementy, które można zmodyfikować wielokrotnie <xref:System.Speech.Recognition.SemanticValue.Value%2A> Właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, w przypadku wykrycia takiej sytuacji. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [SemanticResultValue zrozumienia i obiekty SemanticResultKey](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c).  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">Pierwszy element gramatyki.</param>
        <param name="phrase">Drugi gramatyki element, który reprezentuje sekwencję słów.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający <see cref="T:System.Speech.Recognition.GrammarBuilder" /> następuje frazę.</summary>
        <returns>Zwraca <see cref="T:System.Speech.Recognition.GrammarBuilder" /> sekwencji <paramref name="builder" /> następuje parametru <paramref name="phrase" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje konwersję z następujących klas.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektami wymienionymi powyżej dla `builder` parametru. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatorów.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.String%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">Pierwszy gramatyki element, który reprezentuje sekwencję słów.</param>
        <param name="builder">Drugi element gramatyki.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający frazę następują <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Zwraca <see cref="T:System.Speech.Recognition.GrammarBuilder" /> sekwencji <paramref name="phrase" /> następuje parametru <paramref name="builder" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje konwersję z następujących klas.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektami wymienionymi powyżej dla `builder` parametru. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatorów.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.String%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, która może rozpoznać dwóch wyrażeń, "tło *kolor*" i "ustawioną tła *kolor*", gdzie *kolor* Wybrano zestaw kolorów. Różne typy są używane do tworzenia końcowego gramatyki, takich jak [ciąg](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiektów.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje inny typ do <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie klasy <xref:System.Speech.Recognition.GrammarBuilder>. Można rzutować następujących klas do <xref:System.Speech.Recognition.GrammarBuilder>.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Każdy z niejawnego rzutowania jest odpowiednikiem wywoływania konstruktora.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::Choices ^ choices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="choices">Zestaw alternatyw do konwersji.</param>
        <summary>Konwertuje <see cref="T:System.Speech.Recognition.Choices" /> do obiektu <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu.</summary>
        <returns>Skonwertowany <see cref="T:System.Speech.Recognition.Choices" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie klasy <xref:System.Speech.Recognition.GrammarBuilder>. Tego operatora konwersji jest odpowiednikiem wywołania <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> i określając `choices` dla `alternateChoices`.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, która może rozpoznać odpowiedź na "tak" lub "no" zapytania. Operator niejawnej konwersji jest używany do budowy <xref:System.Speech.Recognition.SemanticResultValue> obiekt z <xref:System.Speech.Recognition.Choices> obiektu w konstrukcji <xref:System.Speech.Recognition.Choices> obiektu z dwóch <xref:System.Speech.Recognition.SemanticResultValue> obiektów i w konstrukcji <xref:System.Speech.Recognition.Grammar> obiektu <xref:System.Speech.Recognition.SemanticResultKey> obiektu.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultKey semanticKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultKey semanticKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultKey)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticKey As SemanticResultKey) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultKey ^ semanticKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticKey" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="semanticKey">Klucz semantyki do konwersji.</param>
        <summary>Konwertuje <see cref="T:System.Speech.Recognition.SemanticResultKey" /> do obiektu <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu.</summary>
        <returns>Skonwertowany <see cref="T:System.Speech.Recognition.SemanticResultKey" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie klasy <xref:System.Speech.Recognition.GrammarBuilder>. Tego operatora konwersji jest odpowiednikiem wywołania <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> i określając `semanticKey` dla `key`.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultKey%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, która może rozpoznać odpowiedź na "tak" lub "no" zapytania. Operator niejawnej konwersji jest używany do budowy <xref:System.Speech.Recognition.SemanticResultValue> obiekt z <xref:System.Speech.Recognition.Choices> obiektu w konstrukcji <xref:System.Speech.Recognition.Choices> obiektu z dwóch <xref:System.Speech.Recognition.SemanticResultValue> obiektów i w konstrukcji <xref:System.Speech.Recognition.Grammar> obiektu <xref:System.Speech.Recognition.SemanticResultKey> obiektu.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultValue semanticValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultValue semanticValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultValue)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticValue As SemanticResultValue) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultValue ^ semanticValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticValue" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="semanticValue">
          <see cref="T:System.Speech.Recognition.SemanticResultValue" /> Obiektu do skonwertowania.</param>
        <summary>Konwertuje <see cref="T:System.Speech.Recognition.SemanticResultValue" /> do obiektu <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu.</summary>
        <returns>Skonwertowany <see cref="T:System.Speech.Recognition.SemanticResultValue" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie klasy <xref:System.Speech.Recognition.GrammarBuilder>. Tego operatora konwersji jest odpowiednikiem wywołania <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> i określając `semanticValue` dla `value`.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultValue%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, która może rozpoznać odpowiedź na "tak" lub "no" zapytania. Operator niejawnej konwersji jest używany do budowy <xref:System.Speech.Recognition.SemanticResultValue> obiekt z <xref:System.Speech.Recognition.Choices>obiektu w konstrukcji <xref:System.Speech.Recognition.Choices> obiektu z dwóch <xref:System.Speech.Recognition.SemanticResultValue> obiektów i w konstrukcji <xref:System.Speech.Recognition.Grammar> obiektu <xref:System.Speech.Recognition.SemanticResultKey> obiektu.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.String)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::String ^ phrase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Ciąg do konwersji.</param>
        <summary>Konwertuje ciąg na <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu.</summary>
        <returns>Skonwertowany ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie klasy <xref:System.Speech.Recognition.GrammarBuilder>. Tego operatora konwersji jest odpowiednikiem wywołania <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> i określając takie same `phrase`.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.String%29?displayProperty=nameWithType>  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty do skonstruowania gramatyki, która może rozpoznać jednej z dwóch wyrażeń "tło *colorChoice*" lub "ustawioną tła *colorChoice*".  
  
 Po utworzeniu listy dopuszczalne wartości *colorChoice* przy użyciu <xref:System.Speech.Recognition.Choices> obiektu, w przykładzie są inicjowane dwa <xref:System.Speech.Recognition.GrammarBuilder> obiektów, `makePhrase` i `setPhrase`, przy użyciu niejawna konwersja z ciągu obiekty.  
  
 W przykładzie jest tworzony na koniec <xref:System.Speech.Recognition.Grammar> obiekt z <xref:System.Speech.Recognition.Choices> rzutować obiektu na <xref:System.Speech.Recognition.GrammarBuilder> obiektu.  
  
```csharp  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="GrammarBuilder" FullName="System.Speech.Recognition.GrammarBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="125094cd1fd2efc74ce799d2503892290b372592" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48736810" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class GrammarBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GrammarBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.GrammarBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class GrammarBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class GrammarBuilder" />
  <TypeSignature Language="F#" Value="type GrammarBuilder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebugSummary}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia mechanizm do programowego tworzenia ograniczenia dla gramatyki rozpoznawania mowy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gramatyki rozpoznawania mowy często są tworzone w formacie XML zdefiniowane przez [mowy rozpoznawania gramatyki specyfikacji (SRGS) w wersji 1.0](http://go.microsoft.com/fwlink/?LinkId=201761). Jeśli znasz SRGS, ale chcesz wygenerować gramatyki programowo, można użyć <xref:System.Speech.Recognition.SrgsGrammar> przestrzeni nazw, w której członkowie są odpowiednie elementy i atrybuty zdefiniowane przez SRGS. Jeśli nie jesteś zaznajomiony z SRGS lub ma programowego, uproszczone podejście do tworzenia gramatyki, za pomocą których można efektywnie wykonać wielu typowych scenariuszy; Możesz użyć <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> klasy.  
  
 Użyj <xref:System.Speech.Recognition.GrammarBuilder> obiektów do tworzenia drzewa hierarchicznego składa się z <xref:System.Speech.Recognition.Choices> obiektów, które zawierają fraz grupową preambuły i wyrażeń po amble w każdym węźle, a zasilany z semantyki wartościami w przekazaniu znaczenia z powrotem do aplikacja.  
  
 Aby użyć <xref:System.Speech.Recognition.GrammarBuilder> utworzyć <xref:System.Speech.Recognition.Grammar> obiektu, wykonaj następujące kroki.  
  
1.  Tworzy obiekt <xref:System.Speech.Recognition.GrammarBuilder>.  
  
2.  Dołącz ograniczenia do <xref:System.Speech.Recognition.GrammarBuilder>, takich jak <xref:System.String> obiektów <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, <xref:System.Speech.Recognition.DictationGrammar>i inne <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które należy zdefiniować ograniczenia dla gramatyki.  
  
3.  Użyj jednej z <xref:System.Speech.Recognition.Grammar.%23ctor%2A> konstruktorów do tworzenia <xref:System.Speech.Recognition.Grammar> obiekt z ukończoną <xref:System.Speech.Recognition.GrammarBuilder> gramatyki.  
  
 Tworzenie za pomocą <xref:System.Speech.Recognition.GrammarBuilder> najlepiej nadaje się do gramatyki, które mają jedną regułę zawierających listy lub może być listę list. Aby programowo utworzyć gramatyki, które mają wiele reguł lub wymagają odwołuje się wewnętrzna zasada, należy użyć klas <xref:System.Speech.Recognition.SrgsGrammar> przestrzeni nazw.  
  
 Wystąpienia elementu <xref:System.Speech.Recognition.GrammarBuilder> dostępne są także niejawne konwersje z niektórych innych klas lub łącząc <xref:System.Speech.Recognition.GrammarBuilder> z drugi obiekt, który zawiera ograniczeń dla gramatyki... Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatorów i <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metody.  
  
 Aby dodać reguły do istniejącego <xref:System.Speech.Recognition.GrammarBuilder>, użyj <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, i <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> metody.  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek, korzystając z gramatyki rozpoznawania mowy, który zawiera zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie może modyfikować wartości tego samego elementu semantycznego. 
  
 Aby pomóc w debugowaniu, <xref:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases%2A> właściwość zwraca bieżący stan <xref:System.Speech.Recognition.GrammarBuilder> jako ciąg.  
  
 Aby uzyskać więcej informacji na temat tworzenia i używania gramatyki rozpoznawania mowy, zobacz [rozpoznawania mowy](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) i [tworzenia gramatyki GrammarBuilder](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty do konstruowania gramatyki, który jest w stanie rozpoznać jednego z dwóch wyrażeń, "tło *colorChoice*" lub "Ustawianie tła *colorChoice*".  
  
 W przykładzie użyto <xref:System.Speech.Recognition.Choices> obiekt, aby utworzyć listę dopuszczalnymi wartościami *colorChoice* z tablicy <xref:System.String> obiektów. A <xref:System.Speech.Recognition.Choices> obiektu jest odpowiednikiem `one-of` elementu w specyfikacji SRGS i zawiera zbiór fraz, które mogą być rozpoznawane podczas używany. W przykładzie użyto również <xref:System.Speech.Recognition.Choices> obiektu do grupy tablicę dwa <xref:System.Speech.Recognition.GrammarBuilder> obiektów w parę alternatywnych fraz, które gramatyki wynikowy może rozpoznać. Alternatywne słów i fraz są składnikiem większość gramatyki i <xref:System.Speech.Recognition.Choices> obiektu oferuje tę funkcję dla gramatyki skonstruowany przy użyciu <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 W przykładzie jest tworzony na koniec <xref:System.Speech.Recognition.Grammar> obiektu z <xref:System.Speech.Recognition.GrammarBuilder> skonstruowany na podstawie <xref:System.Speech.Recognition.Choices> obiektu.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.Choices" />
    <altmember cref="T:System.Speech.Recognition.Grammar" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienia tej klasy można uzyskać również niejawne konwersje z innych klas lub łącząc <xref:System.Speech.Recognition.GrammarBuilder> obiektu z drugi obiekt do z nową <xref:System.Speech.Recognition.GrammarBuilder>. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> metody.  
  
 Można dodać ograniczeń do istniejącego <xref:System.Speech.Recognition.GrammarBuilder>, użyj <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, i <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> metod i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatora.  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek, korzystając z gramatyki rozpoznawania mowy, który zawiera zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie może modyfikować wartości tego samego elementu semantycznego.
  
 Aby uzyskać więcej informacji na temat tworzenia i używania gramatyki rozpoznawania mowy, zobacz [rozpoznawania mowy](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) i [tworzenia gramatyki GrammarBuilder](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe puste wystąpienie elementu <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby dodać reguły do istniejącego <xref:System.Speech.Recognition.GrammarBuilder> obiektu, należy użyć <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, i <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> metod i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatora.  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek, korzystając z gramatyki rozpoznawania mowy, który zawiera zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie może modyfikować wartości tego samego elementu semantycznego.
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty do konstruowania gramatyki, który jest w stanie rozpoznać jednego z dwóch wyrażeń, "tło *colorChoice*" lub "Ustawianie tła *colorChoice*".  
  
 W przykładzie użyto <xref:System.Speech.Recognition.Choices> obiekt, aby utworzyć listę dopuszczalnymi wartościami *colorChoice* z tablicy <xref:System.String> obiektów. A <xref:System.Speech.Recognition.Choices> obiektu jest odpowiednikiem `one-of` elementu w specyfikacji SRGS i zawiera zbiór fraz, jednym z nich mogą być rozpoznawane podczas używany. W przykładzie użyto również <xref:System.Speech.Recognition.Choices> obiektu do grupy tablicę dwa <xref:System.Speech.Recognition.GrammarBuilder> obiektów w parę alternatywnych fraz, które gramatyki wynikowy może rozpoznać. Alternatywne słów i fraz są składnikiem większość gramatyki i <xref:System.Speech.Recognition.Choices> obiektu oferuje tę funkcję dla gramatyki skonstruowany przy użyciu <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 W przykładzie jest tworzony na koniec <xref:System.Speech.Recognition.Grammar> obiektu z <xref:System.Speech.Recognition.GrammarBuilder> skonstruowany na podstawie <xref:System.Speech.Recognition.Choices> obiektu.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  GrammarBuilder bothPhrases = new GrammarBuilder();  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  bothPhrases.Append(bothChoices);  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder alternateChoices" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Zestaw alternatyw.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z zestawu możliwości wyboru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, zawierający rozwiązań alternatywnych, zobacz [przy użyciu opcji, aby utworzyć gramatyki GrammarBuilder](http://msdn.microsoft.com/library/5b18db18-a5f6-46a3-aa77-6d3141544efd).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty do konstruowania gramatyki, który jest w stanie rozpoznać jednego z dwóch wyrażeń, "tło *colorChoice*" lub "Ustawianie tła *colorChoice*".  
  
 W przykładzie użyto <xref:System.Speech.Recognition.Choices> obiekt, aby utworzyć listę dopuszczalnymi wartościami *colorChoice* z tablicy <xref:System.String> obiektów. A <xref:System.Speech.Recognition.Choices> obiektu jest odpowiednikiem `one-of` elementu w specyfikacji SRGS i zawiera zbiór fraz, które mogą być rozpoznawane podczas używany. W przykładzie użyto również <xref:System.Speech.Recognition.Choices> obiektu do grupy tablicę dwa <xref:System.Speech.Recognition.GrammarBuilder> obiektów w parę alternatywnych fraz, które gramatyki wynikowy może rozpoznać. Alternatywne słów i fraz są składnikiem większość gramatyki i <xref:System.Speech.Recognition.Choices> obiektu oferuje tę funkcję dla gramatyki skonstruowany przy użyciu <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 W przykładzie jest tworzony na koniec <xref:System.Speech.Recognition.Grammar> obiektu z <xref:System.Speech.Recognition.GrammarBuilder> skonstruowany na podstawie <xref:System.Speech.Recognition.Choices> obiektu.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder key" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz semantycznego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z kluczem semantycznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu <xref:System.Speech.Recognition.GrammarBuilder> wystąpienia z <xref:System.Speech.Recognition.SemanticResultValue> obiektu, Dodaj informacji semantycznych do gramatyki, które mogą być zwrócone w wyniku rozpoznawania. Dostęp informacji semantycznych do rozpoznawania wyników przy użyciu <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> właściwość <xref:System.Speech.Recognition.RecognizedPhrase>, który jest dostępny w obsłudze dla `SpeechRecognized` zdarzeń. Jeśli <xref:System.Speech.Recognition.GrammarBuilder> definiuje <xref:System.Speech.Recognition.SemanticResultKey>, to może służyć do pobierania informacji semantycznych w wyniku rozpoznawania, który jest skojarzony z kluczem. Zobacz przykład <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>oraz <xref:System.Speech.Recognition.SemanticResultValue> i <xref:System.Speech.Recognition.SemanticResultKey>.  
  
> [!IMPORTANT]
>  Podczas konstruowania <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia, upewnij się, można uniknąć tworzenia zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie można zmodyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> Właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, jeśli wykryje nieważną tych okolicznościach. 
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, który może rozpoznawać dwóch wyrażeń, "tło *colorChoice*" i "Ustawianie tła *colorChoice*", gdzie * colorChoice* wybrano zestaw kolorów. Gramatyka umożliwia użytkownikowi współpracuje z żadnym z kilku nazw kolorów i zwraca semantycznego informacji o nazwie rozpoznawanym kolorów do aplikacji.  
  
 W przykładzie użyto jednego <xref:System.Speech.Recognition.SemanticResultKey> za pomocą którego można pobrać <xref:System.Speech.Recognition.SemanticValue> , która jest skojarzona z kolorem używany przez użytkownika. Na przykład, jeśli dane wejściowe zawierają frazę "Zestaw tła na czerwony," wynik rozpoznawania zawiera semantyczną wartość "#ff0000", który można pobrać przy użyciu programu obsługi dla `SpeechRecognized` zdarzeń.  
  
 W przykładzie użyto <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, i <xref:System.Speech.Recognition.GrammarBuilder> obiekty do kompilacji zawarte w ciągu ostatnich ograniczenia <xref:System.Speech.Recognition.GrammarBuilder> obiektu `bothPhrases`. Na koniec przykład tworzy <xref:System.Speech.Recognition.Grammar> obiekt z ukończoną <xref:System.Speech.Recognition.GrammarBuilder>.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices object for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the Grammar object from the GrammarBuilder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Semantyczne para wartości lub nazwa/wartość.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z wartością semantycznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu <xref:System.Speech.Recognition.GrammarBuilder> wystąpienia z <xref:System.Speech.Recognition.SemanticResultValue> obiektu, Dodaj informacji semantycznych do gramatyki, które mogą być zwrócone w wyniku rozpoznawania. Dostęp informacji semantycznych do rozpoznawania wyników przy użyciu <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> właściwość <xref:System.Speech.Recognition.RecognizedPhrase>, który jest dostępny w obsłudze dla `SpeechRecognized` zdarzeń. Jeśli <xref:System.Speech.Recognition.GrammarBuilder> definiuje <xref:System.Speech.Recognition.SemanticResultKey>, to może służyć do pobierania informacji semantycznych w wyniku rozpoznawania, który jest skojarzony z kluczem. Zobacz przykład <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>oraz <xref:System.Speech.Recognition.SemanticResultValue> i <xref:System.Speech.Recognition.SemanticResultKey>.  
  
> [!IMPORTANT]
>  Podczas konstruowania <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia, upewnij się, można uniknąć tworzenia zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie można zmodyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> Właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, jeśli wykryje nieważną tych okolicznościach. 
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, który może rozpoznawać dwóch wyrażeń, "tło *colorChoice*" i "Ustawianie tła *colorChoice*", gdzie * colorChoice* wybrano zestaw kolorów. Gramatyka umożliwia użytkownikowi współpracuje z żadnym z kilku nazw kolorów i zwraca semantycznego informacji o nazwie rozpoznawanym kolorów do aplikacji.  
  
 W przykładzie użyto jednego <xref:System.Speech.Recognition.SemanticResultKey> za pomocą którego można pobrać <xref:System.Speech.Recognition.SemanticValue> , która jest skojarzona z kolorem używany przez użytkownika. Na przykład, jeśli dane wejściowe zawierają frazę "Zestaw tła na czerwony," wynik rozpoznawania zawiera semantyczną wartość "#ff0000", który można pobrać przy użyciu programu obsługi dla `SpeechRecognized` zdarzeń.  
  
 W przykładzie użyto <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, i <xref:System.Speech.Recognition.GrammarBuilder> obiekty do kompilacji zawarte w ciągu ostatnich ograniczenia <xref:System.Speech.Recognition.GrammarBuilder> obiektu `bothPhrases`. Na koniec przykład tworzy <xref:System.Speech.Recognition.Grammar> obiekt z ukończoną <xref:System.Speech.Recognition.GrammarBuilder>.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the grammar from the grammar builder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder phrase" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Sekwencji wyrazów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z sekwencji wyrazów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyrażenie reprezentuje dokładnej frazy prowadzone rozpoznającego gramatyki rozpoznawania mowy. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, zawiera ciągi, zobacz [przy użyciu parametrów do utworzenia gramatyki GrammarBuilder](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty do konstruowania gramatyki, który jest w stanie rozpoznać jednego z dwóch wyrażeń, "tło *colorChoice*" lub "Ustawianie tła *colorChoice*".  
  
 Po utworzeniu listy dopuszczalnymi wartościami *colorChoice* przy użyciu <xref:System.Speech.Recognition.Choices> obiektu przykład inicjuje dwa <xref:System.Speech.Recognition.GrammarBuilder> obiektów `makePhrase` i `setPhrase`, przy użyciu parametrów jako argumentu.  
  
 W przykładzie jest tworzony na koniec <xref:System.Speech.Recognition.Grammar> obiektu z <xref:System.Speech.Recognition.Choices> obiekt rzutowany <xref:System.Speech.Recognition.GrammarBuilder> obiektu.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * System.Speech.Recognition.SubsetMatchingMode -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, subsetMatchingCriteria)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">Sekwencji wyrazów.</param>
        <param name="subsetMatchingCriteria">Tryb pasującego gramatyki rozpoznawania mowy jest używany do rozpoznawania frazę.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy dla podzbioru sekwencji wyrazów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase` Parametr reprezentuje frazę, która może rozpoznawać gramatyki rozpoznawania mowy. `subsetMatchingMode` Parametr określa podzestaw frazę, która może być wymawiane do osiągnięcia pomyślne rozpoznawanie cała fraza. Możesz użyć tego, aby utworzyć gramatyki z listą wpisów, które mają długie nazwy bez wymagania od użytkowników mówić całą nazwę, aby pasować do elementu.  
  
 Aby uzyskać więcej informacji na temat trybów pasującego zobacz <xref:System.Speech.Recognition.SubsetMatchingMode>. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, zawiera ciągi, zobacz [przy użyciu parametrów do utworzenia gramatyki GrammarBuilder](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, dla każdego <xref:System.Speech.Recognition.SubsetMatchingMode> wartość i gramatyki dotyczące wybierania pomiędzy pasującego gramatyki trybu. Jeśli wartość `phrase` jest "jeden dwa trzy cztery pięć sześć siedem", gramatyki Podsekwencję rozpoznaje dane wejściowe, a następnie "dwóch trzy cztery", ale nie dane wejściowe "co trzy pięć". Jednak gramatyki uporządkowane podzbioru rozpoznaje oba te dane wejściowe.  
  
```csharp  
  
private static IEnumerable<Grammar>  
  CreateMatchingModeGrammars(string phrase)  
{  
  List<Grammar> grammars = new List<Grammar>(5);  
  
  Choices modeChoice = new Choices();  
  Type enumType = typeof(SubsetMatchingMode);  
  foreach (SubsetMatchingMode mode in Enum.GetValues(enumType))  
  {  
    string modeName = Enum.GetName(enumType, mode);  
    modeName = BreakAtCaps(modeName);  
  
    GrammarBuilder builder = new GrammarBuilder(phrase, mode);  
    Grammar modeGrammar = new Grammar(builder);  
    modeGrammar.Name = modeName;  
    modeGrammar.Enabled = false;  
    grammars.Add(modeGrammar);  
  
    modeChoice.Add(modeName);  
  }  
  
  Grammar choiceGrammar = new Grammar(modeChoice);  
  choiceGrammar.Name = "choice";  
  grammars.Add(choiceGrammar);  
  
  return grammars;  
}  
  
// Insert spaces preceding each uppercase letter in a string.   
private static string BreakAtCaps(string item)  
{  
  if (item == null || item.Length == 0)  
  {  
    return item;  
  }  
  
  StringBuilder sb = new StringBuilder(item[0].ToString());  
  for (int i = 1; i < item.Length; i++)  
  {  
    char c = item[i];  
    if (char.IsUpper(c))  
    {  
      sb.Append(" ");  
    }  
    sb.Append(c);  
  }  
  
  return sb.ToString();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SubsetMatchingMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.GrammarBuilder * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (builder, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Powtórzony element.</param>
        <param name="minRepeat">Minimalna liczba przypadków, w których dane wejściowe, dopasowując elementy zdefiniowane przez <c>konstruktora</c> musi wystąpić stanowić dopasowania.</param>
        <param name="maxRepeat">Maksymalną liczbę prób danych wejściowych, dopasowując elementy zdefiniowane przez <c>konstruktora</c> może wystąpić stanowić dopasowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z elementu powtarzanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość `minRepeat` jest 0, a następnie nowe <xref:System.Speech.Recognition.GrammarBuilder> reprezentuje element opcjonalny.  
  
 Wartość `minRepeat` musi być większa lub równa 0 i mniejsza niż wartość `maxRepeat`.  
  
> [!IMPORTANT]
>  Po określeniu powtórzeń dla <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia, upewnij się, można uniknąć tworzenia zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie można zmodyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, jeśli wykryje nieważną tych okolicznościach. 
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy do ustalania kolejności pizza. Rozpoczyna się za pomocą opcjonalnych, otwierając frazy, następuje toppings jednej do czterech i zamyka się wyrazem "głosi".  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object from a string array of alternative toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">Powtórzony sekwencji wyrazów.</param>
        <param name="minRepeat">Minimalna liczba przypadków, które wprowadź frazę do dopasowania musi nastąpić stanowić dopasowania.</param>
        <param name="maxRepeat">Maksymalną liczbę prób wprowadź frazę do dopasowania, może wystąpić stanowić dopasowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z sekwencji wyrazów w <see cref="T:System.String" /> i określa, ile razy <see cref="T:System.String" /> można powtarzać.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość `minRepeat` jest 0, a następnie nowe <xref:System.Speech.Recognition.GrammarBuilder> reprezentuje element opcjonalny.  
  
 Wartość `minRepeat` musi być większa lub równa 0 i mniejsza niż wartość `maxRepeat`. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, zawiera ciągi, zobacz [przy użyciu parametrów do utworzenia gramatyki GrammarBuilder](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy do ustalania kolejności pizza. Rozpoczyna się za pomocą opcjonalnych, otwierając frazy, następuje toppings jednej do czterech i zamyka się wyrazem "głosi".  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierającego sekwencję dwóch elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statyczne <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metody Podaj inny mechanizm, za pomocą którego można łączyć różnych typów, aby utworzyć różnorodność i elastyczność gramatyki utworzonych za pomocą <xref:System.Speech.Recognition.GrammarBuilder>. Te metody odnoszą się do statycznego <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> metody, które również są zdefiniowane na <xref:System.Speech.Recognition.GrammarBuilder> klasy. Kolejność parametrów określa kolejność elementów w nowym <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 A <xref:System.Speech.Recognition.GrammarBuilder> można także uzyskać od <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, i [ciąg](http://go.microsoft.com/fwlink/?LinkId=159733) obiektów. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatorów.  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek, korzystając z gramatyki rozpoznawania mowy, który zawiera zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie może modyfikować wartości tego samego elementu semantycznego. 
  
 Aby uzyskać więcej informacji na temat tworzenia i używania gramatyki rozpoznawania mowy, zobacz [rozpoznawania mowy](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) i [tworzenia gramatyki GrammarBuilder](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (choices, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">Pierwszy gramatyki elementu, który reprezentuje zestaw alternatyw.</param>
        <param name="builder">Drugi element gramatyki.</param>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający <see cref="T:System.Speech.Recognition.Choices" /> obiektu, a następnie <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="choices" /> następuje <paramref name="builder" /> elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje niejawne konwersje z elementu następujące klasy:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektów wymienione powyżej `builder` parametru.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatorów.  
  
> [!IMPORTANT]
>  Łącząc <xref:System.Speech.Recognition.Choices> i <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia, upewnij się, można uniknąć tworzenia zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie można zmodyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, jeśli wykryje nieważną tych okolicznościach. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, który zawiera informacje semantyczne, zobacz [Dodaj semantyki do gramatyki GrammarBuilder](https://msdn.microsoft.com/library/hh361581.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, choices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">Pierwszy element gramatyki.</param>
        <param name="choices">Drugi gramatyki elementu, który reprezentuje zestaw alternatyw.</param>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu, a następnie <see cref="T:System.Speech.Recognition.Choices" /> obiektu.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="builder" /> następuje <paramref name="choices" /> elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje niejawne konwersje z elementu następujące klasy:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektów wymienione powyżej `builder` parametru.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatorów.  
  
> [!IMPORTANT]
>  Łącząc <xref:System.Speech.Recognition.Choices> i <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień z innymi elementami gramatyki, upewnij się, można uniknąć tworzenia zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych wielokrotnie można zmodyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, jeśli wykryje nieważną tych okolicznościach. 
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, który może rozpoznawać dwóch wyrażeń, "tło *kolor*" i "Ustawianie tła *kolor*", gdzie *kolor* Wybrano zestaw kolorów. Różne typy są używane do utworzenia końcowej gramatykę, takich jak [ciąg](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiektów. Operatory rzutowania jawnego w wywołaniach do <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metody są opcjonalne.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder1, builder2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">Pierwszy element gramatyki.</param>
        <param name="builder2">Drugi element gramatyki.</param>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierającego sekwencję dwóch <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektów.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="builder1" /> następuje <paramref name="builder2" /> elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje niejawne konwersje z elementu następujące klasy:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektów wymienione powyżej `builder1` lub `builder2` parametru.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatorów.  
  
> [!IMPORTANT]
>  Łącząc <xref:System.Speech.Recognition.Choices> i <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień z innymi elementami gramatyki, upewnij się, można uniknąć tworzenia zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych wielokrotnie można zmodyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, jeśli wykryje nieważną tych okolicznościach. 
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, który może rozpoznawać dwóch wyrażeń, "tło *kolor*" i "Ustawianie tła *kolor*", gdzie *kolor* Wybrano zestaw kolorów. Różne typy są używane do utworzenia końcowej gramatykę, takich jak [ciąg](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiektów. Operatory rzutowania jawnego w wywołaniach do <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metody są opcjonalne.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, phrase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">Pierwszy element gramatyki.</param>
        <param name="phrase">Drugi gramatyki element, który reprezentuje sekwencję wyrazów.</param>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu następuje frazę.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="builder" /> następuje <paramref name="phrase" /> elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje niejawne konwersje z elementu następujące klasy:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektów wymienione powyżej `builder` parametru.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatorów.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, który może rozpoznawać dwóch wyrażeń, "tło *kolor*" i "Ustawianie tła *kolor*", gdzie *kolor* Wybrano zestaw kolorów. Różne typy są używane do utworzenia końcowej gramatykę, takich jak [ciąg](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiektów. Operatory rzutowania jawnego w wywołaniach do <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metody są opcjonalne.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (phrase, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">Pierwszy gramatyki element, który reprezentuje sekwencji wyrazów.</param>
        <param name="builder">Drugi element gramatyki.</param>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający frazę następuje <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="phrase" /> następuje <paramref name="builder" /> elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje niejawne konwersje z elementu następujące klasy:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektów wymienione powyżej `builder` parametru.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> operatorów.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, który może rozpoznawać dwóch wyrażeń, "tło *kolor*" i "Ustawianie tła *kolor*", gdzie *kolor* Wybrano zestaw kolorów. Różne typy są używane do utworzenia końcowej gramatykę, takich jak [ciąg](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiektów. Operatory rzutowania jawnego w wywołaniach do <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metody są opcjonalne.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza elementu gramatyki do bieżącej sekwencji elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tych metod można dołączyć elementy gramatyki do istniejącego <xref:System.Speech.Recognition.GrammarBuilder>. Jak utworzyć elementy gramatyki, możesz je dołączyć do istniejącego Konstruktor stopniowo tworzenie ograniczeń dla gramatyki rozpoznawania mowy. Każdy element jest dodawany do końca bieżącego sekwencję elementów.  
  
 Ta metoda ma przeciążenia dołączanie <xref:System.Speech.Recognition.GrammarBuilder>, <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, i <xref:System.Speech.Recognition.SemanticResultValue> obiektów.  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek, korzystając z gramatyki rozpoznawania mowy, który zawiera zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie może modyfikować wartości tego samego elementu semantycznego. 
  
 Aby uzyskać więcej informacji na temat tworzenia i używania gramatyki rozpoznawania mowy, zobacz [rozpoznawania mowy](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) i [tworzenia gramatyki GrammarBuilder](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.Choices -&gt; unit" Usage="grammarBuilder.Append alternateChoices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Zestaw rozwiązań alternatywnych, aby dołączyć.</param>
        <summary>Dołącza zbiór alternatywy dla bieżącej sekwencji elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `alternateChoices` zostanie dodany na końcu bieżącego sekwencję elementów.  
  
> [!IMPORTANT]
>  Gdy dołączasz <xref:System.Speech.Recognition.Choices> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień do <xref:System.Speech.Recognition.GrammarBuilder> obiektu, upewnij się, można uniknąć tworzenia zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które można wielokrotnie modyfikowanie <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, jeśli wykryje nieważną tych okolicznościach.
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, zwrotów, takie jak "James wywołania w miejscu pracy" i "Anna wywołania na jej telefonu komórkowego", gdy wyraz "phone" jest opcjonalna. W przykładzie wyróżniono użytkowania <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> metody.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder -&gt; unit" Usage="grammarBuilder.Append builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Element gramatyki do dołączenia.</param>
        <summary>Dołącza elementu gramatyki do bieżącej sekwencji elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `builder` zostanie dodany na końcu aktualna sekwencja elementy gramatyki.  
  
> [!NOTE]
>  Gdy dołączasz <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień do <xref:System.Speech.Recognition.GrammarBuilder> obiektu, upewnij się, można uniknąć tworzenia zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które można wielokrotnie modyfikowanie <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, jeśli wykryje nieważną tych okolicznościach. 
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, zwrotów, takie jak "James wywołania w miejscu pracy" i "Anna wywołania na jej telefonu komórkowego", gdy wyraz "phone" jest opcjonalna. <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty są używane do konstruowania gramatyki. W przykładzie wyróżniono użytkowania <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> metody.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultKey -&gt; unit" Usage="grammarBuilder.Append key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">Semantyczne klucz do dołączenia.</param>
        <summary>Dołącza semantycznego klucza do bieżącej sekwencji elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `key` zostanie dodany na końcu bieżącego sekwencję elementów.  
  
> [!IMPORTANT]
>  Gdy dołączasz <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień do <xref:System.Speech.Recognition.GrammarBuilder> obiektu, upewnij się, można uniknąć tworzenia zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie można zmodyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, jeśli wykryje nieważną tych okolicznościach.
  
   
  
## Examples  
 Poniższy przykład jest częścią aplikacji konsoli dotyczące wybierania początkowe i docelowe miast w locie. Aplikacja rozpoznaje fraz, takie jak "Chcę się z Miami do Chicago". Obsługa <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> zdarzeń używa <xref:System.Speech.Recognition.SemanticResultKey> można wyodrębnić kod lotniska, określone w <xref:System.Speech.Recognition.SemanticResultValue> dla miast początkowego i docelowego.  
  
```csharp  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create a Choices object and add  cities and airport codes  
        // using SemanticResultValue objects.  
        Choices cities = new Choices();  
        cities.Add(new SemanticResultValue("Chicago", "ORD"));  
        cities.Add(new SemanticResultValue("Boston", "BOS"));  
        cities.Add(new SemanticResultValue("Miami", "MIA"));  
        cities.Add(new SemanticResultValue("Dallas", "DFW"));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultValue -&gt; unit" Usage="grammarBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Semantyczne wartość do dołączenia.</param>
        <summary>Dołącza wartość semantycznego aktualna sekwencja elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` zostanie dodany na końcu bieżącego sekwencję elementów.  
  
> [!IMPORTANT]
>  Gdy dołączasz <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień do <xref:System.Speech.Recognition.GrammarBuilder> obiektu, upewnij się, można uniknąć tworzenia zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie można zmodyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, jeśli wykryje nieważną tych okolicznościach.
  
   
  
## Examples  
 Poniższy przykład jest częścią aplikacji konsoli dotyczące wybierania początkowe i docelowe miast w locie. Aplikacja rozpoznaje fraz, takie jak "Chcę się z Miami do Chicago". Obsługa <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> zdarzeń używa <xref:System.Speech.Recognition.SemanticResultKey> można wyodrębnić kod lotniska, określone w <xref:System.Speech.Recognition.SemanticResultValue> dla miast początkowego i docelowego.  
  
```csharp  
  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create GrammarBuilder objects and append SemanticResultValue objects   
        // that contain cities and airport codes.  
  
        GrammarBuilder chicago = new GrammarBuilder();  
        chicago.Append(new SemanticResultValue("Chicago", "ORD"));  
  
        GrammarBuilder boston = new GrammarBuilder();  
        boston.Append(new SemanticResultValue("Boston", "BOS"));  
  
        GrammarBuilder miami = new GrammarBuilder();  
        miami.Append(new SemanticResultValue("Miami", "MIA"));  
  
        GrammarBuilder dallas = new GrammarBuilder();  
        dallas.Append(new SemanticResultValue("Dallas", "DFW"));  
  
        // Create a Choices object and add the cities using implicit conversion from   
        // SemanticResultValue to GrammarBuilder.  
        Choices cities = new Choices();  
        cities.Add(new Choices(new GrammarBuilder[] { chicago, boston, miami, dallas }));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; unit" Usage="grammarBuilder.Append phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Sekwencja słowa do dołączenia.</param>
        <summary>Dołącza frazę do bieżącej sekwencji elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase` zostanie dodany na końcu bieżącego sekwencję elementów.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="member this.Append : string * System.Speech.Recognition.SubsetMatchingMode -&gt; unit" Usage="grammarBuilder.Append (phrase, subsetMatchingCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">Sekwencja słowa do dołączenia.</param>
        <param name="subsetMatchingCriteria">Tryb pasującego gramatyki używany do rozpoznawania frazę.</param>
        <summary>Dołącza element dla podzbioru frazę do bieżącej sekwencji elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element podzbioru zostanie dodany na końcu bieżącego sekwencję elementów. Aby uzyskać więcej informacji o tworzeniu gramatyki rozpoznawania mowy, przy użyciu parametrów, zobacz [przy użyciu parametrów do utworzenia gramatyki GrammarBuilder](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
 Aby uzyskać szczegółowe informacje dotyczące użycia podzbioru dopasowania trybów, zobacz <xref:System.Speech.Recognition.SubsetMatchingMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, dla każdego <xref:System.Speech.Recognition.SubsetMatchingMode> wartość. Na przykład wygenerowanego gramatyki `OrderedSubset` rozpoznaje fraz, "trzy cztery pięć" i "jeden trzy pięć" i gramatyki `Subsequence` rozpoznaje frazę "trzy cztery pięć", ale nie frazę "jeden trzy pięć".  
  
```csharp  
  
private Grammar[] CreateSubsetMatchTest()  
{  
  List<Grammar> grammars = new List<Grammar>(4);  
  
  string phrase = "one two three four five six";  
  foreach (SubsetMatchingMode mode in  
    Enum.GetValues(typeof(SubsetMatchingMode)))  
  {  
    GrammarBuilder gb = new GrammarBuilder();  
    gb.Append(phrase, mode);  
  
    Grammar grammar = new Grammar(gb);  
    grammar.Name = mode.ToString();  
    grammars.Add(grammar);  
  }  
  
  return grammars.ToArray();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder * int * int -&gt; unit" Usage="grammarBuilder.Append (builder, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Element powtarzanych gramatyki do dołączenia.</param>
        <param name="minRepeat">Minimalna liczba przypadków, w których dane wejściowe, dopasowując elementy zdefiniowane przez <c>konstruktora</c> musi wystąpić stanowić dopasowania.</param>
        <param name="maxRepeat">Maksymalną liczbę prób danych wejściowych, dopasowując elementy zdefiniowane przez <c>konstruktora</c> może wystąpić stanowić dopasowania.</param>
        <summary>Dołącza element powtarzanych gramatyki do bieżącej sekwencji elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `minRepeat` musi być większa lub równa 0 i mniejsza niż wartość `maxRepeat`.  
  
> [!IMPORTANT]
>  Gdy dołączasz <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień do <xref:System.Speech.Recognition.GrammarBuilder> obiektu, upewnij się, można uniknąć tworzenia zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które można wielokrotnie modyfikowanie <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, jeśli wykryje nieważną tych okolicznościach.
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, zwrotów, takie jak "James wywołania w miejscu pracy" i "Anna wywołania na jej telefonu komórkowego", gdy wyraz "phone" jest opcjonalna. <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty są używane do konstruowania gramatyki. W przykładzie wyróżniono użytkowania <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> metody.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; unit" Usage="grammarBuilder.Append (phrase, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">Sekwencja powtarzanych słowa do dołączenia.</param>
        <param name="minRepeat">Minimalna liczba przypadków, które wejściowe dopasowania <c>frazy</c> musi wystąpić stanowić dopasowania.</param>
        <param name="maxRepeat">Maksymalną liczbę prób danych wejściowych dopasowania <c>frazy</c> może wystąpić stanowić dopasowania.</param>
        <summary>Dołącza powtarzanych frazę do bieżącej sekwencji elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `minRepeat` musi być większa lub równa 0 i mniejsza niż wartość `maxRepeat`.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, zwrotów, takie jak "James wywołania w miejscu pracy" i "Anna wywołania na jej telefonu komórkowego", gdy wyraz "phone" jest opcjonalna. <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty są używane do konstruowania gramatyki. W przykładzie wyróżniono użytkowania <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> metody.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendDictation">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza gramatyki dyktowanie aktualna sekwencja elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A> Metody umożliwiają dołączanie gramatyki dyktowanie jako zasadę, aby <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Aby uzyskać więcej informacji dotyczących gramatyki dyktowania, zobacz <xref:System.Speech.Recognition.DictationGrammar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation();" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : unit -&gt; unit" Usage="grammarBuilder.AppendDictation " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dołącza gramatyki dyktowanie domyślne do bieżącej sekwencji elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji dotyczących gramatyki dyktowania, zobacz <xref:System.Speech.Recognition.DictationGrammar>.  
  
   
  
## Examples  
 Poniższy przykład tworzy uwzględniająca dyktowanie gramatyki rozpoznawania mowy.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation();  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation (string category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation(string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation (category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation(System::String ^ category);" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : string -&gt; unit" Usage="grammarBuilder.AppendDictation category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="category">Kategoria gramatyki dyktowanie do dołączenia.</param>
        <summary>Dołącza gramatyki dyktowanie określony do bieżącej sekwencji elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby korzystać z Pisownia i gramatyka dyktowania ustaw `category` do `spelling`.  
  
 Aby uzyskać więcej informacji dotyczących gramatyki dyktowania, zobacz <xref:System.Speech.Recognition.DictationGrammar>.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, uwzględniająca reguły gramatyki dyktowanie pisowni.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation("spelling");  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendRuleReference">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza plik gramatyki lub reguły gramatyki do bieżącej sekwencji elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> Metod można dołączyć pliku gramatyki lub reguły gramatyki z pliku. Te metody umożliwiają aplikacjom wprowadzić użycie reguły gramatyki wstępnie wdrożonego lub publicznie dostępne. Aplikacja musi mieć dostęp do odczytu do lokalizacji plików określonego gramatyki.  
  
 Te metody mogą odczytywać gramatyki rozpoznawania mowy w następujących formatach.  
  
-   Pliki w formacie XML, które odpowiadają W3C [mowy rozpoznawania gramatyki specyfikacji (SRGS) w wersji 1.0](http://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Pliki binarne, które są zgodne z Microsoft Speech rozpoznawania gramatyki formatu binarnego (cfg rozszerzenia pliku)  
  
 Kompilowanie SRGS XML format pliku gramatyki do pliku binarnego gramatyki z rozszerzeniem cfg może skrócić czas używane przez wyszukuje zgodny, zwłaszcza, jeśli gramatyki wymaga rozpoznawania dużą liczbę słów i fraz. Aby dowiedzieć się, jak kompilowanie gramatyki SRGS na format binarny CFG, zobacz <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string -&gt; unit" Usage="grammarBuilder.AppendRuleReference path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka lub uniwersalny identyfikator zasobów (URI) pliku, który opisuje gramatykę rozpoznawania mowy w obsługiwanym formacie.</param>
        <summary>Dołącza plik definicji gramatyki do bieżącej sekwencji elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator URI, dostarczone przez `path` argument może być lokalny lub zdalny. Aplikacja musi mieć dostęp do odczytu do lokalizacji plików określonego gramatyki.  
  
 Reprezentacja W3C mowy rozpoznawania gramatyki specyfikacji (SRGS) można zdefiniować reguły głównego. Ta metoda dołącza gramatykę, począwszy od jej regułą głównego do bieżącej sekwencji elementy gramatyki. Aby dołączyć określonej gramatyczny, należy użyć <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład C# tworzy gramatyki rozpoznawania mowy, które używa reguły o nazwie `Cities` w pliku lokalnym SRGS cities.grxml. Zawartość pliku cities.grxml pojawia się w poniższym przykładzie kodu C#.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar1()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.AppendRuleReference("file://c:/temp/cities.grxml");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 1";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-16" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path, string rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path, string rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String, rule As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path, System::String ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string * string -&gt; unit" Usage="grammarBuilder.AppendRuleReference (path, rule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rule" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku lub uniwersalny identyfikator zasobów (URI) pliku, który opisuje gramatykę rozpoznawania mowy w obsługiwanym formacie.</param>
        <param name="rule">Identyfikator reguły do dołączenia, lub <see langword="null" /> dołaczenia domyślną regułę głównego pliku gramatyki.</param>
        <summary>Dołącza określoną regułą pliku definicji gramatyki do bieżącej sekwencji elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator URI, dostarczone przez `path` argument może być lokalny lub zdalny. Aplikacja musi mieć dostęp do odczytu do lokalizacji plików określonego gramatyki.  
  
 Umożliwia użycie <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> metodę, aby dołączyć plik zaczynając od gramatyki z jej regułą głównego.  
  
   
  
## Examples  
 Poniższy przykład C# tworzy gramatyki rozpoznawania mowy, które używa reguły o nazwie `Cities` w pliku lokalnym SRGS cities.grxml. Zawartość pliku cities.grxml pojawia się w poniższym przykładzie kodu C#.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar2()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.Append("Does");  
  builder.AppendRuleReference(@"c:\temp\cities.grxml", "Cities");  
  builder.Append("have a shuttle");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendWildcard">
      <MemberSignature Language="C#" Value="public void AppendWildcard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendWildcard() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendWildcard ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendWildcard();" />
      <MemberSignature Language="F#" Value="member this.AppendWildcard : unit -&gt; unit" Usage="grammarBuilder.AppendWildcard " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dołącza rozpoznawania elementu gramatyki, który pasuje do żadnych danych do bieżącego sekwencji elementy gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element symbol wieloznaczny zostanie dodany na końcu bieżącego sekwencję elementów.  
  
 Element symboli wieloznacznych jest dopasowywany dowolny wyraz wypowiedzenia. Nie jest zgodny, hałas w tle lub wyciszenia.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki, który akceptuje wprowadzania hasła jako symbolu wieloznacznego. Przykład dołącza <xref:System.Speech.Recognition.Grammar.SpeechRecognized?displayProperty=nameWithType> procedurę obsługi zdarzeń do gramatyki, która weryfikuje wprowadzania hasła.  
  
```csharp  
private Grammar CreatePasswordGrammar()  
{  
  GrammarBuilder wildcardBuilder = new GrammarBuilder();  
  wildcardBuilder.AppendWildcard();  
  SemanticResultKey passwordKey =  
    new SemanticResultKey("Password", wildcardBuilder);  
  
  GrammarBuilder passwordBuilder =  
    new GrammarBuilder("My Password is");  
  passwordBuilder.Append(passwordKey);  
  
  Grammar passwordGrammar = new Grammar(passwordBuilder);  
  passwordGrammar.Name = "Password input";  
  
  passwordGrammar.SpeechRecognized +=  
    new EventHandler<SpeechRecognizedEventArgs>(  
      PasswordInputHandler);  
  
  return passwordGrammar;  
}  
  
// Handle the SpeechRecognized event for the password grammar.  
private void PasswordInputHandler(object sender, SpeechRecognizedEventArgs e)  
{  
  if (e.Result == null) return;  
  
  RecognitionResult result = e.Result;  
  SemanticValue semantics = e.Result.Semantics;  
  
  if (semantics.ContainsKey("Password"))  
  {  
    RecognizedAudio passwordAudio =  
      result.GetAudioForWordRange(  
        result.Words[3], result.Words[result.Words.Count - 1]);  
  
    if (IsValidPassword(passwordAudio))  
    {  
      Console.WriteLine("Password accepted.");  
  
      // Add code to handle a valid password here.  
    }  
    else  
    {  
      Console.WriteLine("Invalid password.");  
  
      // Add code to handle an invalid password here.  
    }  
  }  
}  
  
// Validate the password input.   
private bool IsValidPassword(RecognizedAudio passwordAudio)  
{  
  Console.WriteLine("Validating password.");  
  
  // Add password validation code here.  
  
  return false;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo with get, set" Usage="System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kulturę gramatyki rozpoznawania mowy.</summary>
        <value>Kultura <see cref="T:System.Speech.Recognition.GrammarBuilder" />. Wartością domyślną jest wykonywany wątek <see cref="P:System.Threading.Thread.CurrentUICulture" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> Konstruktor tworzy <xref:System.Speech.Recognition.Grammar> obiekt, który może być używany przez aparatu rozpoznawania mowy, odpowiedni kultury. Tylko <xref:System.Speech.Recognition.GrammarBuilder.Culture%2A> właściwość <xref:System.Speech.Recognition.GrammarBuilder> dostarczanym jako parametr do konstruktora gramatyki służy do ustawiania kulturę wynikowy gramatyki rozpoznawania mowy.  
  
 Program Microsoft Windows i interfejsu API System.Speech Zaakceptuj wszystkie prawidłowe kody krajów języka. Aby wykonać rozpoznawanie mowy, przy użyciu języka określonego w `Culture` właściwość, aparatu rozpoznawania mowy, który obsługuje kod kraju języka musi być zainstalowany. Aparatów rozpoznawania mowy, które są dostarczane z programem Microsoft Windows 7 współpracować z poniższych kodów kraju języka.  
  
-   en-GB. Angielski (Wielka Brytania)  
  
-   en-US. Angielski (Stany Zjednoczone)  
  
-   de-DE. Niemiecki (Niemcy)  
  
-   es-ES. Hiszpański (Hiszpania)  
  
-   fr-FR. Francuski (Francja)  
  
-   ja-JP. Japoński (Japonia)  
  
-   zh-CN. Chiński (Chiny)  
  
-   zh-TW. Chiński (Tajwan)  
  
 Kody dwuliterowych języka, takich jak "en", "fr" lub "es" są również dozwolone.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy do ustalania kolejności pizza z maksymalnie cztery toppings. W szczególności ustawia <xref:System.Speech.Recognition.GrammarBuilder> obiektu kultury angielski (Stany Zjednoczone).  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.RecognizerInfo" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
      </Docs>
    </Member>
    <Member MemberName="DebugShowPhrases">
      <MemberSignature Language="C#" Value="public string DebugShowPhrases { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DebugShowPhrases" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DebugShowPhrases As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DebugShowPhrases { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DebugShowPhrases : string" Usage="System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg, który pokazuje zawartości i struktury gramatyki zawartych <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <value>Bieżącej zawartości i struktury <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy do ustalania kolejności pizza z maksymalnie cztery toppings. Zapisuje stan <xref:System.Speech.Recognition.GrammarBuilder> konsoli przed utworzeniem gramatyki. Ta metoda generuje następujące wyniki:  
  
-   `GrammarBuilder status: I would like a [cheese,mushroom,tomato,onion,anchovy,chic ken,pepperoni] and [cheese,mushroom,tomato,onion,anchovy,chicken,pepperoni] pizza`  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Write the contents and structure of the GrammarBuilder to the console.  
  Console.WriteLine("Grammar content and structure: {0}", gb.DebugShowPhrases);  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361640(v%3doffice.14)">Tworzenie przy użyciu GrammarBuilder gramatyki</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> , który odpowiada sekwencję dwóch elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność argumentów określa kolejność elementów w nowym <xref:System.Speech.Recognition.GrammarBuilder>.  
  
> [!IMPORTANT]
>  Ostrzeżenie jest zalecane w przypadku łączenia <xref:System.Speech.Recognition.Choices> lub <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień z innymi elementami gramatyki. Aparat rozpoznawania mowy może zgłosić wyjątek, korzystając z gramatyki rozpoznawania mowy, który zawiera zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie może modyfikować wartości tego samego elementu semantycznego. 
  
 Aby uzyskać więcej informacji na temat tworzenia i używania gramatyki rozpoznawania mowy, zobacz [rozpoznawania mowy](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) i [tworzenia gramatyki GrammarBuilder](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="choices + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">Pierwszy gramatyki elementu, który reprezentuje zestaw alternatyw.</param>
        <param name="builder">Drugi element gramatyki.</param>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający <see cref="T:System.Speech.Recognition.Choices" /> obiektu, a następnie <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu.</summary>
        <returns>Zwraca <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="choices" /> następuje parametr <paramref name="builder" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje konwersje z następujących klas.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektów wymienione powyżej `builder` parametru. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatorów.  
  
> [!IMPORTANT]
>  Łącząc <xref:System.Speech.Recognition.Choices> i <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia, upewnij się, można uniknąć tworzenia zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie można zmodyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, jeśli wykryje nieważną tych okolicznościach.
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.Choices%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">Pierwszy element gramatyki.</param>
        <param name="choices">Drugi gramatyki elementu, który reprezentuje zestaw elementów alternatywne.</param>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający <see cref="T:System.Speech.Recognition.GrammarBuilder" /> następuje <see cref="T:System.Speech.Recognition.Choices" />.</summary>
        <returns>Zwraca <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="builder" /> następuje parametr <paramref name="choices" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> Konwersja obsługuje następujące klasy:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektów wymienione powyżej `builder` parametru. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatorów.  
  
> [!IMPORTANT]
>  Łącząc <xref:System.Speech.Recognition.Choices> i <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia, upewnij się, można uniknąć tworzenia zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie można zmodyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, jeśli wykryje nieważną tych okolicznościach.
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, który może rozpoznawać dwóch wyrażeń, "tło *kolor*" i "Ustawianie tła *kolor*", gdzie *kolor* Wybrano zestaw kolorów. Różne typy są używane do utworzenia końcowej gramatykę, takich jak [ciąg](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiektów.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder1 + builder2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">Pierwszy element gramatyki.</param>
        <param name="builder2">Drugi element gramatyki.</param>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierającego sekwencję dwóch <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektów.</summary>
        <returns>Zwraca <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="builder1" /> następuje parametr <paramref name="builder2" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje konwersje z następujących klas.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektów wymienione powyżej `builder1` i `builder2` parametrów. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatorów.  
  
> [!IMPORTANT]
>  Łącząc <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia, upewnij się, można uniknąć tworzenia zduplikowane elementy semantyki z taką samą nazwę klucza lub wielu elementów semantycznych, które wielokrotnie można zmodyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> Właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, jeśli wykryje nieważną tych okolicznościach.
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">Pierwszy element gramatyki.</param>
        <param name="phrase">Drugi gramatyki element, który reprezentuje sekwencję wyrazów.</param>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający <see cref="T:System.Speech.Recognition.GrammarBuilder" /> następuje frazę.</summary>
        <returns>Zwraca <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="builder" /> następuje parametr <paramref name="phrase" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje konwersje z następujących klas.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektów wymienione powyżej `builder` parametru. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatorów.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.String%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="phrase + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">Pierwszy gramatyki element, który reprezentuje sekwencji wyrazów.</param>
        <param name="builder">Drugi element gramatyki.</param>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawierający frazę następuje <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Zwraca <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="phrase" /> następuje parametr <paramref name="builder" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> obsługuje konwersje z następujących klas.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda przyjmuje obiektów wymienione powyżej `builder` parametru. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatorów.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.String%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, który może rozpoznawać dwóch wyrażeń, "tło *kolor*" i "Ustawianie tła *kolor*", gdzie *kolor* Wybrano zestaw kolorów. Różne typy są używane do utworzenia końcowej gramatykę, takich jak [ciąg](http://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiektów.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje kolejny typ <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie klasy <xref:System.Speech.Recognition.GrammarBuilder>. Można rzutować następujących klas do <xref:System.Speech.Recognition.GrammarBuilder>.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Każdy z niejawne rzutowanie jest odpowiednikiem wywołanie konstruktora.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="choices">Zestaw rozwiązań alternatywnych, aby przekonwertować.</param>
        <summary>Konwertuje <see cref="T:System.Speech.Recognition.Choices" /> obiekt <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu.</summary>
        <returns>Przekonwertowana <see cref="T:System.Speech.Recognition.Choices" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie klasy <xref:System.Speech.Recognition.GrammarBuilder>. Ten operator konwersji jest równoważne z wywoływaniem <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> i określając `choices` dla `alternateChoices`.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, rozpoznającego na odpowiedź na "yes" lub "no" zapytania. Operator niejawnej konwersji jest używany do budowy <xref:System.Speech.Recognition.SemanticResultValue> obiektu z <xref:System.Speech.Recognition.Choices> obiektu w konstrukcji <xref:System.Speech.Recognition.Choices> obiektu z dwóch <xref:System.Speech.Recognition.SemanticResultValue> obiekty i w konstrukcji <xref:System.Speech.Recognition.Grammar> obiekt z <xref:System.Speech.Recognition.SemanticResultKey> obiektu.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultKey semanticKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultKey semanticKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultKey)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticKey As SemanticResultKey) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultKey ^ semanticKey);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticKey" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="semanticKey">Semantyczne klucz do przekonwertowania.</param>
        <summary>Konwertuje <see cref="T:System.Speech.Recognition.SemanticResultKey" /> obiekt <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu.</summary>
        <returns>Przekonwertowana <see cref="T:System.Speech.Recognition.SemanticResultKey" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie klasy <xref:System.Speech.Recognition.GrammarBuilder>. Ten operator konwersji jest równoważne z wywoływaniem <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> i określając `semanticKey` dla `key`.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultKey%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, rozpoznającego na odpowiedź na "yes" lub "no" zapytania. Operator niejawnej konwersji jest używany do budowy <xref:System.Speech.Recognition.SemanticResultValue> obiektu z <xref:System.Speech.Recognition.Choices> obiektu w konstrukcji <xref:System.Speech.Recognition.Choices> obiektu z dwóch <xref:System.Speech.Recognition.SemanticResultValue> obiekty i w konstrukcji <xref:System.Speech.Recognition.Grammar> obiekt z <xref:System.Speech.Recognition.SemanticResultKey> obiektu.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultValue semanticValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultValue semanticValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultValue)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticValue As SemanticResultValue) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultValue ^ semanticValue);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticValue" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="semanticValue">
          <see cref="T:System.Speech.Recognition.SemanticResultValue" /> Obiektu do przekonwertowania.</param>
        <summary>Konwertuje <see cref="T:System.Speech.Recognition.SemanticResultValue" /> obiekt <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu.</summary>
        <returns>Przekonwertowana <see cref="T:System.Speech.Recognition.SemanticResultValue" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie klasy <xref:System.Speech.Recognition.GrammarBuilder>. Ten operator konwersji jest równoważne z wywoływaniem <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> i określając `semanticValue` dla `value`.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultValue%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy gramatyki rozpoznawania mowy, rozpoznającego na odpowiedź na "yes" lub "no" zapytania. Operator niejawnej konwersji jest używany do budowy <xref:System.Speech.Recognition.SemanticResultValue> obiektu z <xref:System.Speech.Recognition.Choices>obiektu w konstrukcji <xref:System.Speech.Recognition.Choices> obiektu z dwóch <xref:System.Speech.Recognition.SemanticResultValue> obiekty i w konstrukcji <xref:System.Speech.Recognition.Grammar> obiekt z <xref:System.Speech.Recognition.SemanticResultKey> obiektu.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.String)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Ciąg do konwersji.</param>
        <summary>Konwertuje ciąg na <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektu.</summary>
        <returns>Przekonwertowany ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie klasy <xref:System.Speech.Recognition.GrammarBuilder>. Ten operator konwersji jest równoważne z wywoływaniem <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> i podając takie same `phrase`.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.String%29?displayProperty=nameWithType>  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Speech.Recognition.GrammarBuilder> i <xref:System.Speech.Recognition.Choices> obiekty do konstruowania gramatyki, który jest w stanie rozpoznać jednego z dwóch wyrażeń, "tło *colorChoice*" lub "Ustawianie tła *colorChoice*".  
  
 Po utworzeniu listy dopuszczalnymi wartościami *colorChoice* przy użyciu <xref:System.Speech.Recognition.Choices> obiektu przykład inicjuje dwa <xref:System.Speech.Recognition.GrammarBuilder> obiektów `makePhrase` i `setPhrase`, za pomocą niejawną konwersję z ciągu obiekty.  
  
 W przykładzie jest tworzony na koniec <xref:System.Speech.Recognition.Grammar> obiektu z <xref:System.Speech.Recognition.Choices> obiekt rzutowany <xref:System.Speech.Recognition.GrammarBuilder> obiektu.  
  
```csharp  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
  </Members>
</Type>
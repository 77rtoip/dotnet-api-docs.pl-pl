<Type Name="GrammarBuilder" FullName="System.Speech.Recognition.GrammarBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e0d9bfa62675c9e59e6fa12e0bf36c839258e976" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69231358" /></Metadata><TypeSignature Language="C#" Value="public class GrammarBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GrammarBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.GrammarBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class GrammarBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class GrammarBuilder" />
  <TypeSignature Language="F#" Value="type GrammarBuilder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebugSummary}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia mechanizm programistycznego tworzenia ograniczeń gramatycznych rozpoznawania mowy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gramatyki rozpoznawania mowy często są tworzone w formacie XML zdefiniowanym w [specyfikacji gramatyki rozpoznawania mowy (SRGS) w wersji 1,0](https://go.microsoft.com/fwlink/?LinkId=201761). Jeśli znasz program SRGS, ale chcesz programowo generować gramatyki, możesz użyć <xref:System.Speech.Recognition.SrgsGrammar> przestrzeni nazw, której elementy członkowskie są ściśle zgodne z elementami i atrybutami zdefiniowanymi przez SRGS. Jeśli nie znasz SRGS lub chcesz uzyskać lekkie, programistyczne podejście do tworzenia gramatyk, z których możesz efektywnie wykonywać wiele typowych scenariuszy; można użyć <xref:System.Speech.Recognition.GrammarBuilder> klas i <xref:System.Speech.Recognition.Choices> .  
  
 Użyj <xref:System.Speech.Recognition.GrammarBuilder> obiektów do skompilowania drzewa hierarchicznego składającego się z <xref:System.Speech.Recognition.Choices> obiektów, które zawierają alternatywne frazy, odplatane z preambuły i frazy Amble w każdym węźle i są umieszczane z wartościami semantycznymi przekazującymi dane zwrotne do Aplikacja.  
  
 Aby użyć <xref:System.Speech.Recognition.GrammarBuilder> do <xref:System.Speech.Recognition.Grammar> utworzenia obiektu, wykonaj następujące czynności.  
  
1.  Tworzy obiekt <xref:System.Speech.Recognition.GrammarBuilder>.  
  
2.  Dołącz ograniczenia <xref:System.Speech.Recognition.GrammarBuilder>do, takie jak <xref:System.Speech.Recognition.Choices> <xref:System.String> <xref:System.Speech.Recognition.GrammarBuilder> obiekty, <xref:System.Speech.Recognition.SemanticResultKey> <xref:System.Speech.Recognition.SemanticResultValue>, ,,iinneobiekty,któredefiniująograniczeniadotyczącegramatyki.<xref:System.Speech.Recognition.DictationGrammar>  
  
3.  Użyj jednego z <xref:System.Speech.Recognition.Grammar.%23ctor%2A> konstruktorów, aby <xref:System.Speech.Recognition.Grammar> utworzyć obiekt z ukończonej <xref:System.Speech.Recognition.GrammarBuilder> gramatyki.  
  
 Tworzenie za <xref:System.Speech.Recognition.GrammarBuilder> pomocą jest najlepszym rozwiązaniem dla gramatyki, które mają jedną regułę zawierającą listy, lub prawdopodobnie listę list. Aby programowo kompilować gramatyki, które mają wiele reguł lub które muszą tworzyć odwołania do reguł wewnętrznych, użyj klas <xref:System.Speech.Recognition.SrgsGrammar> przestrzeni nazw.  
  
 Wystąpienia można także uzyskać przez niejawne konwersje z niektórych innych klas lub przez <xref:System.Speech.Recognition.GrammarBuilder> połączenie z drugim obiektem, który zawiera ograniczenia dotyczące gramatyki. <xref:System.Speech.Recognition.GrammarBuilder> Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatory <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> i i <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metody.  
  
 Aby dodać reguły do istniejącej <xref:System.Speech.Recognition.GrammarBuilder>, <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>Użyj metod, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>,, i <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> .  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek przy użyciu gramatyki rozpoznawania mowy, która zawiera zduplikowane elementy semantyczne o tej samej nazwie klucza lub wielu elementach semantycznych, które mogą wielokrotnie modyfikować wartość tego samego elementu semantycznego. 
  
 Aby ułatwić debugowanie, <xref:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases%2A> Właściwość zwraca bieżący stan w <xref:System.Speech.Recognition.GrammarBuilder> postaci ciągu.  
  
 Aby uzyskać więcej informacji na temat kompilowania i korzystania z gramatyki rozpoznawania mowy, zobacz [rozpoznawanie mowy](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) i [Tworzenie gramatyki GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
   
  
## Examples  
 <xref:System.Speech.Recognition.GrammarBuilder> Poniższy przykład używa <xref:System.Speech.Recognition.Choices> i obiektów do konstruowania gramatyki, która może rozpoznawać jedną z dwóch fraz, " *colorChoice*w tle" lub "Set Background to *colorChoice*".  
  
 W przykładzie zastosowano <xref:System.Speech.Recognition.Choices> obiekt, aby utworzyć listę akceptowalnych wartości dla *colorChoice* <xref:System.String> z tablicy obiektów. Obiekt jest analogiczny `one-of` do elementu w specyfikacji SRGS i zawiera zestaw alternatywnych fraz, które mogą być rozpoznawane podczas wymawiania. <xref:System.Speech.Recognition.Choices> W przykładzie używa <xref:System.Speech.Recognition.Choices> się również obiektu do grupowania tablicy dwóch <xref:System.Speech.Recognition.GrammarBuilder> obiektów w parze alternatywnych fraz, które wynikowa Gramatyka może rozpoznać. Słowa alternatywne lub frazy są składnikiem większości gramatyki, a <xref:System.Speech.Recognition.Choices> obiekt udostępnia tę funkcję dla gramatyki zbudowanych przy użyciu. <xref:System.Speech.Recognition.GrammarBuilder>  
  
 Przykład tworzy <xref:System.Speech.Recognition.Grammar> obiekt na <xref:System.Speech.Recognition.GrammarBuilder> podstawie skonstruowanej z <xref:System.Speech.Recognition.Choices> obiektu.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.Choices" />
    <altmember cref="T:System.Speech.Recognition.Grammar" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienia tej klasy można również uzyskać przez niejawne konwersje z innych klas lub przez połączenie <xref:System.Speech.Recognition.GrammarBuilder> obiektu z drugim obiektem z nowym. <xref:System.Speech.Recognition.GrammarBuilder> Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> i <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> metody.  
  
 Aby dodać <xref:System.Speech.Recognition.GrammarBuilder>ograniczenia do istniejącej, <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>Użyj <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A> metody<xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> ,<xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> ,,, i operatora.  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek przy użyciu gramatyki rozpoznawania mowy, która zawiera zduplikowane elementy semantyczne o tej samej nazwie klucza lub wielu elementach semantycznych, które mogą wielokrotnie modyfikować wartość tego samego elementu semantycznego.
  
 Aby uzyskać więcej informacji na temat kompilowania i korzystania z gramatyki rozpoznawania mowy, zobacz [rozpoznawanie mowy](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) i [Tworzenie gramatyki GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe, puste wystąpienie <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby dodać reguły do istniejącego <xref:System.Speech.Recognition.GrammarBuilder> obiektu, <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>Użyj metod, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A> <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> ,,<xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> i operatora.<xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek przy użyciu gramatyki rozpoznawania mowy, która zawiera zduplikowane elementy semantyczne o tej samej nazwie klucza lub wielu elementach semantycznych, które mogą wielokrotnie modyfikować wartość tego samego elementu semantycznego.
  
   
  
## Examples  
 <xref:System.Speech.Recognition.GrammarBuilder> Poniższy przykład używa <xref:System.Speech.Recognition.Choices> i obiektów do konstruowania gramatyki, która może rozpoznawać jedną z dwóch fraz, " *colorChoice*w tle" lub "Set Background to *colorChoice*".  
  
 W przykładzie zastosowano <xref:System.Speech.Recognition.Choices> obiekt, aby utworzyć listę akceptowalnych wartości dla *colorChoice* <xref:System.String> z tablicy obiektów. Obiekt jest analogiczny `one-of` do elementu w specyfikacji SRGS i zawiera zestaw alternatywnych fraz, z których każdy może zostać rozpoznany podczas wymawiania. <xref:System.Speech.Recognition.Choices> W przykładzie używa <xref:System.Speech.Recognition.Choices> się również obiektu do grupowania tablicy dwóch <xref:System.Speech.Recognition.GrammarBuilder> obiektów w parze alternatywnych fraz, które wynikowa Gramatyka może rozpoznać. Słowa alternatywne lub frazy są składnikiem większości gramatyki, a <xref:System.Speech.Recognition.Choices> obiekt udostępnia tę funkcję dla gramatyki zbudowanych przy użyciu. <xref:System.Speech.Recognition.GrammarBuilder>  
  
 Przykład tworzy <xref:System.Speech.Recognition.Grammar> obiekt na <xref:System.Speech.Recognition.GrammarBuilder> podstawie skonstruowanej z <xref:System.Speech.Recognition.Choices> obiektu.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  GrammarBuilder bothPhrases = new GrammarBuilder();  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  bothPhrases.Append(bothChoices);  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder alternateChoices" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Zestaw wariantów.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z zestawu wariantów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat tworzenia gramatyki rozpoznawania mowy zawierającej alternatywy, zobacz [Używanie opcji do tworzenia gramatyki GrammarBuilder](https://msdn.microsoft.com/library/5b18db18-a5f6-46a3-aa77-6d3141544efd).  
  
   
  
## Examples  
 <xref:System.Speech.Recognition.GrammarBuilder> Poniższy przykład używa <xref:System.Speech.Recognition.Choices> i obiektów do konstruowania gramatyki, która może rozpoznawać jedną z dwóch fraz, " *colorChoice*w tle" lub "Set Background to *colorChoice*".  
  
 W przykładzie zastosowano <xref:System.Speech.Recognition.Choices> obiekt, aby utworzyć listę akceptowalnych wartości dla *colorChoice* <xref:System.String> z tablicy obiektów. Obiekt jest analogiczny `one-of` do elementu w specyfikacji SRGS i zawiera zestaw alternatywnych fraz, które mogą być rozpoznawane podczas wymawiania. <xref:System.Speech.Recognition.Choices> W przykładzie używa <xref:System.Speech.Recognition.Choices> się również obiektu do grupowania tablicy dwóch <xref:System.Speech.Recognition.GrammarBuilder> obiektów w parze alternatywnych fraz, które wynikowa Gramatyka może rozpoznać. Słowa alternatywne lub frazy są składnikiem większości gramatyki, a <xref:System.Speech.Recognition.Choices> obiekt udostępnia tę funkcję dla gramatyki zbudowanych przy użyciu. <xref:System.Speech.Recognition.GrammarBuilder>  
  
 Przykład tworzy <xref:System.Speech.Recognition.Grammar> obiekt na <xref:System.Speech.Recognition.GrammarBuilder> podstawie skonstruowanej z <xref:System.Speech.Recognition.Choices> obiektu.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder key" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz semantyczny.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z klucza semantycznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas tworzenia <xref:System.Speech.Recognition.GrammarBuilder> wystąpienia <xref:System.Speech.Recognition.SemanticResultValue> z obiektu, należy dodać informacje semantyczne do gramatyki, które mogą być zwracane w wyniku rozpoznawania. Dostęp do informacji semantycznych w wyniku rozpoznawania można uzyskać przy użyciu <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> <xref:System.Speech.Recognition.RecognizedPhrase>właściwości, która jest dostępna `SpeechRecognized` w programie obsługi zdarzenia. Jeśli definiuje a <xref:System.Speech.Recognition.SemanticResultKey>, to może służyć do pobierania informacji semantycznych w wyniku rozpoznawania, który jest skojarzony z kluczem. <xref:System.Speech.Recognition.GrammarBuilder> Zapoznaj się z <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>przykładem dla, <xref:System.Speech.Recognition.SemanticResultValue> a <xref:System.Speech.Recognition.SemanticResultKey>także Zobacz i.  
  
> [!IMPORTANT]
>  Podczas konstruowania <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które <xref:System.Speech.Recognition.SemanticResultValue> zawierają <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia lub, upewnij się, że nie utworzysz zduplikowanych elementów semantycznych o takiej samej nazwie klucza lub <xref:System.Speech.Recognition.SemanticValue.Value%2A> wielu elementach semantycznych, które mogą wielokrotnie modyfikować <xref:System.Speech.Recognition.SemanticValue> właściwość obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, Jeśli napotkają te okoliczności. 
  
   
  
## Examples  
 Poniższy przykład tworzy gramatykę rozpoznawania mowy, która może rozpoznawać dwie frazy " *colorChoice*w tle" i "Set Background to *colorChoice*", gdzie *colorChoice* jest wybrane z zestawu kolorów. Gramatyka pozwala użytkownikowi mówić dowolną z kilku nazw kolorów i zwraca informacje semantyczne o rozpoznanej nazwie koloru do aplikacji.  
  
 W przykładzie jest używany pojedynczy <xref:System.Speech.Recognition.SemanticResultKey> element <xref:System.Speech.Recognition.SemanticValue> , za pomocą którego można pobrać obiekt, który jest skojarzony z kolorem wymawianym przez użytkownika. Na przykład, jeśli dane wejściowe zawierają frazę "Ustaw tło na czerwony", wynik rozpoznawania zawiera wartość semantyczną "#FF0000", którą można pobrać przy użyciu procedury obsługi dla `SpeechRecognized` zdarzenia.  
  
 W przykładzie używane <xref:System.String>są <xref:System.Speech.Recognition.Choices>obiekty <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>,, <xref:System.Speech.Recognition.GrammarBuilder> i do tworzenia ograniczeń, które są zawarte w ostatnim <xref:System.Speech.Recognition.GrammarBuilder> obiekcie, `bothPhrases`. Na koniec przykład tworzy <xref:System.Speech.Recognition.Grammar> obiekt od ukończonej. <xref:System.Speech.Recognition.GrammarBuilder>  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices object for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the Grammar object from the GrammarBuilder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Para wartości semantycznych lub nazwa/wartość.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z wartości semantycznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas tworzenia <xref:System.Speech.Recognition.GrammarBuilder> wystąpienia <xref:System.Speech.Recognition.SemanticResultValue> z obiektu, należy dodać informacje semantyczne do gramatyki, które mogą być zwracane w wyniku rozpoznawania. Dostęp do informacji semantycznych w wyniku rozpoznawania można uzyskać przy użyciu <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> <xref:System.Speech.Recognition.RecognizedPhrase>właściwości, która jest dostępna `SpeechRecognized` w programie obsługi zdarzenia. Jeśli definiuje a <xref:System.Speech.Recognition.SemanticResultKey>, to może służyć do pobierania informacji semantycznych w wyniku rozpoznawania, który jest skojarzony z kluczem. <xref:System.Speech.Recognition.GrammarBuilder> Zapoznaj się z <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>przykładem dla, <xref:System.Speech.Recognition.SemanticResultValue> a <xref:System.Speech.Recognition.SemanticResultKey>także Zobacz i.  
  
> [!IMPORTANT]
>  Podczas konstruowania <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które <xref:System.Speech.Recognition.SemanticResultValue> zawierają <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia lub, upewnij się, że nie utworzysz zduplikowanych elementów semantycznych o takiej samej nazwie klucza lub <xref:System.Speech.Recognition.SemanticValue.Value%2A> wielu elementach semantycznych, które mogą wielokrotnie modyfikować <xref:System.Speech.Recognition.SemanticValue> właściwość obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, Jeśli napotkają te okoliczności. 
  
   
  
## Examples  
 Poniższy przykład tworzy gramatykę rozpoznawania mowy, która może rozpoznawać dwie frazy " *colorChoice*w tle" i "Set Background to *colorChoice*", gdzie *colorChoice* jest wybrane z zestawu kolorów. Gramatyka pozwala użytkownikowi mówić dowolną z kilku nazw kolorów i zwraca informacje semantyczne o rozpoznanej nazwie koloru do aplikacji.  
  
 W przykładzie jest używany pojedynczy <xref:System.Speech.Recognition.SemanticResultKey> element <xref:System.Speech.Recognition.SemanticValue> , za pomocą którego można pobrać obiekt, który jest skojarzony z kolorem wymawianym przez użytkownika. Na przykład, jeśli dane wejściowe zawierają frazę "Ustaw tło na czerwony", wynik rozpoznawania zawiera wartość semantyczną "#FF0000", którą można pobrać przy użyciu procedury obsługi dla `SpeechRecognized` zdarzenia.  
  
 W przykładzie używane <xref:System.String>są <xref:System.Speech.Recognition.Choices>obiekty <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>,, <xref:System.Speech.Recognition.GrammarBuilder> i do tworzenia ograniczeń, które są zawarte w ostatnim <xref:System.Speech.Recognition.GrammarBuilder> obiekcie, `bothPhrases`. Na koniec przykład tworzy <xref:System.Speech.Recognition.Grammar> obiekt od ukończonej. <xref:System.Speech.Recognition.GrammarBuilder>  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the grammar from the grammar builder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder phrase" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Sekwencja wyrazów.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z sekwencji wyrazów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fraza reprezentuje dokładną wymawianą frazę, którą może rozpoznać Gramatyka rozpoznawania mowy. Aby uzyskać więcej informacji na temat tworzenia gramatyki rozpoznawania mowy zawierającej ciągi, zobacz [Używanie ciągów do tworzenia gramatyki GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 <xref:System.Speech.Recognition.GrammarBuilder> Poniższy przykład używa <xref:System.Speech.Recognition.Choices> i obiektów do konstruowania gramatyki, która może rozpoznawać jedną z dwóch fraz, " *colorChoice*w tle" lub "Set Background to *colorChoice*".  
  
 Po utworzeniu listy akceptowalnych wartości dla *colorChoice* przy użyciu <xref:System.Speech.Recognition.Choices> obiektu, przykład `makePhrase` inicjuje dwa <xref:System.Speech.Recognition.GrammarBuilder> obiekty i `setPhrase`, przy użyciu ciągu jako argumentu.  
  
 Przykład tworzy <xref:System.Speech.Recognition.Grammar> obiekt na <xref:System.Speech.Recognition.Choices> podstawie rzutowania obiektu na <xref:System.Speech.Recognition.GrammarBuilder> obiekt.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * System.Speech.Recognition.SubsetMatchingMode -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, subsetMatchingCriteria)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">Sekwencja wyrazów.</param>
        <param name="subsetMatchingCriteria">Tryb dopasowania, którego Gramatyka rozpoznawania mowy używa do rozpoznawania frazy.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy dla podzestawu sekwencji wyrazów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase` Parametr reprezentuje frazę, którą może rozpoznać Gramatyka rozpoznawania mowy. `subsetMatchingMode` Parametr określa podzestaw frazy, która może być wymawiana, aby osiągnąć pomyślne rozpoznanie całej frazy. Możesz użyć tego do utworzenia gramatyki z listą wpisów, które mają długie nazwy, bez konieczności, aby użytkownicy wymawiali całą nazwę w celu dopasowania do elementu.  
  
 Aby uzyskać więcej informacji na temat dopasowywania trybów <xref:System.Speech.Recognition.SubsetMatchingMode>, zobacz. Aby uzyskać więcej informacji na temat tworzenia gramatyki rozpoznawania mowy zawierającej ciągi, zobacz [Używanie ciągów do tworzenia gramatyki GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatykę rozpoznawania mowy dla każdej <xref:System.Speech.Recognition.SubsetMatchingMode> wartości i gramatykę do wyboru między gramatykami w trybie dopasowywania. Jeśli wartość `phrase` to "1 2 3 4 5 6 7", wówczas Gramatyka podsekwencji rozpoznaje dane wejściowe "2 3 4", ale nie dane wejściowe "1 3 5". Jednak Gramatyka uporządkowana podzbiór rozpoznaje oba te dane wejściowe.  
  
```csharp  
  
private static IEnumerable<Grammar>  
  CreateMatchingModeGrammars(string phrase)  
{  
  List<Grammar> grammars = new List<Grammar>(5);  
  
  Choices modeChoice = new Choices();  
  Type enumType = typeof(SubsetMatchingMode);  
  foreach (SubsetMatchingMode mode in Enum.GetValues(enumType))  
  {  
    string modeName = Enum.GetName(enumType, mode);  
    modeName = BreakAtCaps(modeName);  
  
    GrammarBuilder builder = new GrammarBuilder(phrase, mode);  
    Grammar modeGrammar = new Grammar(builder);  
    modeGrammar.Name = modeName;  
    modeGrammar.Enabled = false;  
    grammars.Add(modeGrammar);  
  
    modeChoice.Add(modeName);  
  }  
  
  Grammar choiceGrammar = new Grammar(modeChoice);  
  choiceGrammar.Name = "choice";  
  grammars.Add(choiceGrammar);  
  
  return grammars;  
}  
  
// Insert spaces preceding each uppercase letter in a string.   
private static string BreakAtCaps(string item)  
{  
  if (item == null || item.Length == 0)  
  {  
    return item;  
  }  
  
  StringBuilder sb = new StringBuilder(item[0].ToString());  
  for (int i = 1; i < item.Length; i++)  
  {  
    char c = item[i];  
    if (char.IsUpper(c))  
    {  
      sb.Append(" ");  
    }  
    sb.Append(c);  
  }  
  
  return sb.ToString();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SubsetMatchingMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.GrammarBuilder * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (builder, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Powtórzony element.</param>
        <param name="minRepeat">Minimalna liczba przypadków, gdy dane wejściowe zgodne z elementem zdefiniowanym <paramref name="builder" /> przez muszą następować dopasowanie.</param>
        <param name="maxRepeat">Maksymalna liczba przypadków, gdy dane wejściowe zgodne z elementem zdefiniowanym <paramref name="builder" /> przez mogą wystąpić jako dopasowanie.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z Powtórzonego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość `minRepeat` jest równa 0, Nowa <xref:System.Speech.Recognition.GrammarBuilder> reprezentuje element opcjonalny.  
  
 Wartość `minRepeat` musi być większa lub równa 0 i mniejsza lub równa `maxRepeat`wartości.  
  
> [!IMPORTANT]
>  Jeśli określisz powtórzenia dla <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które zawierają <xref:System.Speech.Recognition.SemanticResultValue> wystąpienia lub <xref:System.Speech.Recognition.SemanticResultKey> , upewnij się, że nie utworzysz zduplikowanych elementów semantycznych o tej samej nazwie klucza lub wielu elementach semantycznych, które mogą wielokrotnie modyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> Właściwość obiektu.<xref:System.Speech.Recognition.SemanticValue> Aparat rozpoznawania mowy może zgłosić wyjątek, Jeśli napotkają te okoliczności. 
  
   
  
## Examples  
 Poniższy przykład tworzy gramatykę rozpoznawania mowy do porządkowania Pizza. Zaczyna od opcjonalnej, otwierającej frazy, po której następuje jeden do czterech toppings i zamyka wyraz "Pizza".  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object from a string array of alternative toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">Powtórzona sekwencja wyrazów.</param>
        <param name="minRepeat">Minimalna liczba przypadków, gdy dane wejściowe zgodne z frazą muszą wystąpić, aby stanowić dopasowanie.</param>
        <param name="maxRepeat">Maksymalna liczba przypadków, gdy dane wejściowe pasujące do frazy mogą stanowić dopasowanie.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Speech.Recognition.GrammarBuilder" /> klasy z sekwencji wyrazów <see cref="T:System.String" /> w i <see cref="T:System.String" /> określa, ile razy można powtarzać.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość `minRepeat` jest równa 0, Nowa <xref:System.Speech.Recognition.GrammarBuilder> reprezentuje element opcjonalny.  
  
 Wartość `minRepeat` musi być większa lub równa 0 i mniejsza lub równa `maxRepeat`wartości. Aby uzyskać więcej informacji na temat tworzenia gramatyki rozpoznawania mowy zawierającej ciągi, zobacz [Używanie ciągów do tworzenia gramatyki GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatykę rozpoznawania mowy do porządkowania Pizza. Zaczyna od opcjonalnej, otwierającej frazy, po której następuje jeden do czterech toppings i zamyka wyraz "Pizza".  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> , który zawiera sekwencję dwóch elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody statyczne <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> zapewniają inny mechanizm, za pomocą którego można połączyć różne typy w celu utworzenia różnorodności i elastyczności w gramatykach <xref:System.Speech.Recognition.GrammarBuilder>utworzonych przy użyciu. Metody te odpowiadają metodom <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> statycznym, które są również zdefiniowane <xref:System.Speech.Recognition.GrammarBuilder> w klasie. Kolejność parametrów określa kolejność elementów w nowym <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 <xref:System.Speech.Recognition.Choices> <xref:System.Speech.Recognition.SemanticResultKey> [](https://go.microsoft.com/fwlink/?LinkId=159733) Można również uzyskać z obiektów String,, <xref:System.Speech.Recognition.SemanticResultValue>i. <xref:System.Speech.Recognition.GrammarBuilder> Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatory <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> i.  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek przy użyciu gramatyki rozpoznawania mowy, która zawiera zduplikowane elementy semantyczne o tej samej nazwie klucza lub wielu elementach semantycznych, które mogą wielokrotnie modyfikować wartość tego samego elementu semantycznego. 
  
 Aby uzyskać więcej informacji na temat kompilowania i korzystania z gramatyki rozpoznawania mowy, zobacz [rozpoznawanie mowy](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) i [Tworzenie gramatyki GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (choices, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">Pierwszy element gramatyczny, który reprezentuje zestaw wariantów.</param>
        <param name="builder">Drugi element gramatyki.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> , który <see cref="T:System.Speech.Recognition.Choices" /> zawiera obiekt, po którym następuje <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiekt.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="choices" /> elementu, po którym następuje <paramref name="builder" /> element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>obsługuje konwersje niejawne z następujących klas:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda akceptuje obiekty wymienione powyżej dla `builder` parametru.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatory <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> i.  
  
> [!IMPORTANT]
>  W przypadku łączenia <xref:System.Speech.Recognition.Choices> i <xref:System.Speech.Recognition.GrammarBuilder> obiektów zawierających <xref:System.Speech.Recognition.SemanticResultValue> wystąpienia lub <xref:System.Speech.Recognition.SemanticResultKey> należy pamiętać, aby uniknąć tworzenia zduplikowanych elementów semantycznych o takiej samej nazwie klucza lub wielu elementach semantycznych, które mogą wielokrotnie modyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> Właściwość obiektu.<xref:System.Speech.Recognition.SemanticValue> Aparat rozpoznawania mowy może zgłosić wyjątek, Jeśli napotkają te okoliczności. Aby uzyskać więcej informacji na temat tworzenia gramatyki rozpoznawania mowy zawierającej informacje semantyczne, zobacz [Dodawanie semantyki do GrammarBuilder gramatyki](https://msdn.microsoft.com/library/hh361581.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, choices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">Pierwszy element gramatyki.</param>
        <param name="choices">Drugi element gramatyki, który reprezentuje zestaw wariantów.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> , który <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawiera obiekt, po którym następuje <see cref="T:System.Speech.Recognition.Choices" /> obiekt.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="builder" /> elementu, po którym następuje <paramref name="choices" /> element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>obsługuje konwersje niejawne z następujących klas:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda akceptuje obiekty wymienione powyżej dla `builder` parametru.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatory <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> i.  
  
> [!IMPORTANT]
>  W przypadku łączenia <xref:System.Speech.Recognition.Choices> <xref:System.Speech.Recognition.GrammarBuilder> obiektów zawierających <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień z innymi elementami gramatyki, upewnij się, że nie utworzysz zduplikowanych elementów semantycznych o tej samej nazwie klucza lub wielu elementach semantycznych, które może wielokrotnie modyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> Właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, Jeśli napotkają te okoliczności. 
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono tworzenie gramatyki rozpoznawania mowy, która może rozpoznać dwie frazy: "Ustaw *kolor*tła" i "Ustaw tło na *kolor*", gdzie *kolor* jest wybierany z zestawu kolorów. Różne typy są używane do tworzenia końcowej gramatyki, takiej [](https://go.microsoft.com/fwlink/?LinkId=159733)jak ciąg <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiekty. Jawne Operatory rzutowania w wywołaniach <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metod są opcjonalne.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder1, builder2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">Pierwszy element gramatyki.</param>
        <param name="builder2">Drugi element gramatyki.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> , który zawiera sekwencję dwóch <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektów.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="builder1" /> elementu, po którym następuje <paramref name="builder2" /> element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>obsługuje konwersje niejawne z następujących klas:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda akceptuje obiekty wymienione powyżej dla `builder1` parametru lub. `builder2`  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatory <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> i.  
  
> [!IMPORTANT]
>  W przypadku łączenia <xref:System.Speech.Recognition.Choices> <xref:System.Speech.Recognition.GrammarBuilder> obiektów zawierających <xref:System.Speech.Recognition.SemanticResultValue> lub <xref:System.Speech.Recognition.SemanticResultKey> wystąpień z innymi elementami gramatyki, upewnij się, że nie utworzysz zduplikowanych elementów semantycznych o tej samej nazwie klucza lub wielu elementach semantycznych, które może wielokrotnie modyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> Właściwość <xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, Jeśli napotkają te okoliczności. 
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono tworzenie gramatyki rozpoznawania mowy, która może rozpoznać dwie frazy: "Ustaw *kolor*tła" i "Ustaw tło na *kolor*", gdzie *kolor* jest wybierany z zestawu kolorów. Różne typy są używane do tworzenia końcowej gramatyki, takiej [](https://go.microsoft.com/fwlink/?LinkId=159733)jak ciąg <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiekty. Jawne Operatory rzutowania w wywołaniach <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metod są opcjonalne.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, phrase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">Pierwszy element gramatyki.</param>
        <param name="phrase">Drugi element gramatyki, który reprezentuje sekwencję wyrazów.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> , który <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawiera obiekt, po którym następuje fraza.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="builder" /> elementu, po którym następuje <paramref name="phrase" /> element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>obsługuje konwersje niejawne z następujących klas:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda akceptuje obiekty wymienione powyżej dla `builder` parametru.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatory <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> i.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono tworzenie gramatyki rozpoznawania mowy, która może rozpoznać dwie frazy: "Ustaw *kolor*tła" i "Ustaw tło na *kolor*", gdzie *kolor* jest wybierany z zestawu kolorów. Różne typy są używane do tworzenia końcowej gramatyki, takiej [](https://go.microsoft.com/fwlink/?LinkId=159733)jak ciąg <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiekty. Jawne Operatory rzutowania w wywołaniach <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metod są opcjonalne.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (phrase, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">Pierwszy element gramatyczny, który reprezentuje sekwencję wyrazów.</param>
        <param name="builder">Drugi element gramatyki.</param>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> , która zawiera frazę, a po <see cref="T:System.Speech.Recognition.GrammarBuilder" /> niej obiekt.</summary>
        <returns>A <see cref="T:System.Speech.Recognition.GrammarBuilder" /> dla sekwencji <paramref name="phrase" /> elementu, po którym następuje <paramref name="builder" /> element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>obsługuje konwersje niejawne z następujących klas:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda akceptuje obiekty wymienione powyżej dla `builder` parametru.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatory <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> i.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono tworzenie gramatyki rozpoznawania mowy, która może rozpoznać dwie frazy: "Ustaw *kolor*tła" i "Ustaw tło na *kolor*", gdzie *kolor* jest wybierany z zestawu kolorów. Różne typy są używane do tworzenia końcowej gramatyki, takiej [](https://go.microsoft.com/fwlink/?LinkId=159733)jak ciąg <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiekty. Jawne Operatory rzutowania w wywołaniach <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> metod są opcjonalne.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza element gramatyki do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tych metod, aby dołączyć elementy gramatyki do <xref:System.Speech.Recognition.GrammarBuilder>istniejącej. Podczas tworzenia elementów gramatycznych można je dołączyć do istniejącego konstruktora, aby stopniowo opracowywać ograniczenia dotyczące gramatyki rozpoznawania mowy. Każdy element jest dodawany na końcu bieżącej sekwencji elementów.  
  
 Ta metoda ma przeciążenia <xref:System.Speech.Recognition.GrammarBuilder>dla dołączania <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, i <xref:System.Speech.Recognition.SemanticResultValue> obiektów.  
  
> [!IMPORTANT]
>  Aparat rozpoznawania mowy może zgłosić wyjątek przy użyciu gramatyki rozpoznawania mowy, która zawiera zduplikowane elementy semantyczne o tej samej nazwie klucza lub wielu elementach semantycznych, które mogą wielokrotnie modyfikować wartość tego samego elementu semantycznego. 
  
 Aby uzyskać więcej informacji na temat kompilowania i korzystania z gramatyki rozpoznawania mowy, zobacz [rozpoznawanie mowy](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) i [Tworzenie gramatyki GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.Choices -&gt; unit" Usage="grammarBuilder.Append alternateChoices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Zestaw alternatyw do dołączenia.</param>
        <summary>Dołącza zestaw alternatyw do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `alternateChoices`jest dodawany na końcu bieżącej sekwencji elementów.  
  
> [!IMPORTANT]
>  Po dołączeniu <xref:System.Speech.Recognition.Choices> obiektów, które <xref:System.Speech.Recognition.SemanticResultKey> zawierają <xref:System.Speech.Recognition.SemanticResultValue> wystąpienia lub <xref:System.Speech.Recognition.GrammarBuilder> do obiektu, upewnij się, że nie utworzysz zduplikowanych elementów semantycznych o takiej samej nazwie klucza lub wielu elementach semantycznych, które mogą wielokrotnie <xref:System.Speech.Recognition.SemanticValue.Value%2A> zmodyfikuj Właściwość<xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, Jeśli napotkają te okoliczności.
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono tworzenie gramatyki rozpoznawania mowy dla fraz, takich jak "Wywołaj Kuba w pracy" i "Call Anne na swoim telefonie komórkowym", gdzie wyraz "Phone" jest opcjonalny. W przykładzie pokazano <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> sposób użycia metody.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder -&gt; unit" Usage="grammarBuilder.Append builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Element gramatyki do dołączenia.</param>
        <summary>Dołącza element gramatyki do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `builder`zostanie dodany na końcu bieżącej sekwencji elementów gramatyki.  
  
> [!NOTE]
>  Po dołączeniu <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które <xref:System.Speech.Recognition.SemanticResultKey> zawierają <xref:System.Speech.Recognition.SemanticResultValue> wystąpienia lub <xref:System.Speech.Recognition.GrammarBuilder> do obiektu, upewnij się, że nie utworzysz zduplikowanych elementów semantycznych o takiej samej nazwie klucza lub wielu elementach semantycznych, które mogą wielokrotnie <xref:System.Speech.Recognition.SemanticValue.Value%2A> zmodyfikuj Właściwość<xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, Jeśli napotkają te okoliczności. 
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono tworzenie gramatyki rozpoznawania mowy dla fraz, takich jak "Wywołaj Kuba w pracy" i "Call Anne na swoim telefonie komórkowym", gdzie wyraz "Phone" jest opcjonalny. <xref:System.Speech.Recognition.GrammarBuilder>obiekty <xref:System.Speech.Recognition.Choices> i są używane do konstruowania gramatyki. W przykładzie pokazano <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> sposób użycia metody.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultKey -&gt; unit" Usage="grammarBuilder.Append key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz semantyczny do dołączenia.</param>
        <summary>Dołącza klucz semantyczny do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `key`jest dodawany na końcu bieżącej sekwencji elementów.  
  
> [!IMPORTANT]
>  Po <xref:System.Speech.Recognition.SemanticResultValue> dołączeniu <xref:System.Speech.Recognition.SemanticResultKey> lub wystąpieniu do <xref:System.Speech.Recognition.GrammarBuilder> obiektu upewnij się, że nie utworzysz zduplikowanych elementów semantycznych o tej samej nazwie klucza lub <xref:System.Speech.Recognition.SemanticValue.Value%2A> wielu elementach semantycznych, które mogą wielokrotnie modyfikować Właściwość <xref:System.Speech.Recognition.SemanticValue> obiekt. Aparat rozpoznawania mowy może zgłosić wyjątek, Jeśli napotkają te okoliczności.
  
   
  
## Examples  
 Poniższy przykład jest częścią aplikacji konsolowej służącej do wybierania miejscowości początkowych i docelowych dla lotu. Aplikacja rozpoznaje frazy, takie jak "chcę mieć Miami do Chicago". Procedura obsługi dla <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> zdarzenia <xref:System.Speech.Recognition.SemanticResultKey> używa do wyodrębnienia kodu lotniska określonego w polu <xref:System.Speech.Recognition.SemanticResultValue> dla miejscowości źródłowej i docelowej.  
  
```csharp  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create a Choices object and add  cities and airport codes  
        // using SemanticResultValue objects.  
        Choices cities = new Choices();  
        cities.Add(new SemanticResultValue("Chicago", "ORD"));  
        cities.Add(new SemanticResultValue("Boston", "BOS"));  
        cities.Add(new SemanticResultValue("Miami", "MIA"));  
        cities.Add(new SemanticResultValue("Dallas", "DFW"));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultValue -&gt; unit" Usage="grammarBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Wartość semantyczna do dołączenia.</param>
        <summary>Dołącza wartość semantyczną do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`jest dodawany na końcu bieżącej sekwencji elementów.  
  
> [!IMPORTANT]
>  Po <xref:System.Speech.Recognition.SemanticResultValue> dołączeniu <xref:System.Speech.Recognition.SemanticResultKey> lub wystąpieniu do <xref:System.Speech.Recognition.GrammarBuilder> obiektu upewnij się, że nie utworzysz zduplikowanych elementów semantycznych o tej samej nazwie klucza lub <xref:System.Speech.Recognition.SemanticValue.Value%2A> wielu elementach semantycznych, które mogą wielokrotnie modyfikować Właściwość <xref:System.Speech.Recognition.SemanticValue> obiekt. Aparat rozpoznawania mowy może zgłosić wyjątek, Jeśli napotkają te okoliczności.
  
   
  
## Examples  
 Poniższy przykład jest częścią aplikacji konsolowej służącej do wybierania miejscowości początkowych i docelowych dla lotu. Aplikacja rozpoznaje frazy, takie jak "chcę mieć Miami do Chicago". Procedura obsługi dla <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> zdarzenia <xref:System.Speech.Recognition.SemanticResultKey> używa do wyodrębnienia kodu lotniska określonego w polu <xref:System.Speech.Recognition.SemanticResultValue> dla miejscowości źródłowej i docelowej.  
  
```csharp  
  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create GrammarBuilder objects and append SemanticResultValue objects   
        // that contain cities and airport codes.  
  
        GrammarBuilder chicago = new GrammarBuilder();  
        chicago.Append(new SemanticResultValue("Chicago", "ORD"));  
  
        GrammarBuilder boston = new GrammarBuilder();  
        boston.Append(new SemanticResultValue("Boston", "BOS"));  
  
        GrammarBuilder miami = new GrammarBuilder();  
        miami.Append(new SemanticResultValue("Miami", "MIA"));  
  
        GrammarBuilder dallas = new GrammarBuilder();  
        dallas.Append(new SemanticResultValue("Dallas", "DFW"));  
  
        // Create a Choices object and add the cities using implicit conversion from   
        // SemanticResultValue to GrammarBuilder.  
        Choices cities = new Choices();  
        cities.Add(new Choices(new GrammarBuilder[] { chicago, boston, miami, dallas }));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; unit" Usage="grammarBuilder.Append phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Sekwencja słów do dołączenia.</param>
        <summary>Dołącza frazę do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase`jest dodawany na końcu bieżącej sekwencji elementów.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="member this.Append : string * System.Speech.Recognition.SubsetMatchingMode -&gt; unit" Usage="grammarBuilder.Append (phrase, subsetMatchingCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">Sekwencja słów do dołączenia.</param>
        <param name="subsetMatchingCriteria">Tryb dopasowania, którego Gramatyka używa do rozpoznawania frazy.</param>
        <summary>Dołącza element dla podzestawu frazy do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element podzbiór jest dodawany na końcu bieżącej sekwencji elementów. Aby uzyskać więcej informacji na temat tworzenia gramatyki rozpoznawania mowy przy użyciu ciągów, zobacz [Używanie ciągów do tworzenia gramatyki GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
 Aby uzyskać szczegółowe informacje na temat używania trybów dopasowywania podzestawów, zobacz <xref:System.Speech.Recognition.SubsetMatchingMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatykę rozpoznawania mowy dla każdej <xref:System.Speech.Recognition.SubsetMatchingMode> wartości. Na przykład wygenerowane Gramatyka `OrderedSubset` rozpoznaje frazy "3 4 5" i "1 3 5", a Gramatyka `Subsequence` rozpoznaje frazę "3 4 5", ale nie frazę "1 3 5".  
  
```csharp  
  
private Grammar[] CreateSubsetMatchTest()  
{  
  List<Grammar> grammars = new List<Grammar>(4);  
  
  string phrase = "one two three four five six";  
  foreach (SubsetMatchingMode mode in  
    Enum.GetValues(typeof(SubsetMatchingMode)))  
  {  
    GrammarBuilder gb = new GrammarBuilder();  
    gb.Append(phrase, mode);  
  
    Grammar grammar = new Grammar(gb);  
    grammar.Name = mode.ToString();  
    grammars.Add(grammar);  
  }  
  
  return grammars.ToArray();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder * int * int -&gt; unit" Usage="grammarBuilder.Append (builder, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Powtórzony element gramatyki do dołączenia.</param>
        <param name="minRepeat">Minimalna liczba przypadków, gdy dane wejściowe zgodne z elementem zdefiniowanym <paramref name="builder" /> przez muszą następować dopasowanie.</param>
        <param name="maxRepeat">Maksymalna liczba przypadków, gdy dane wejściowe zgodne z elementem zdefiniowanym <paramref name="builder" /> przez mogą wystąpić jako dopasowanie.</param>
        <summary>Dołącza powtórzony element gramatyki do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `minRepeat` musi być większa lub równa 0 i mniejsza lub równa `maxRepeat`wartości.  
  
> [!IMPORTANT]
>  Po dołączeniu <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które <xref:System.Speech.Recognition.SemanticResultKey> zawierają <xref:System.Speech.Recognition.SemanticResultValue> wystąpienia lub <xref:System.Speech.Recognition.GrammarBuilder> do obiektu, upewnij się, że nie utworzysz zduplikowanych elementów semantycznych o takiej samej nazwie klucza lub wielu elementach semantycznych, które mogą wielokrotnie <xref:System.Speech.Recognition.SemanticValue.Value%2A> zmodyfikuj Właściwość<xref:System.Speech.Recognition.SemanticValue> obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, Jeśli napotkają te okoliczności.
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono tworzenie gramatyki rozpoznawania mowy dla fraz, takich jak "Wywołaj Kuba w pracy" i "Call Anne na swoim telefonie komórkowym", gdzie wyraz "Phone" jest opcjonalny. <xref:System.Speech.Recognition.GrammarBuilder>obiekty <xref:System.Speech.Recognition.Choices> i są używane do konstruowania gramatyki. W przykładzie pokazano <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> sposób użycia metody.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; unit" Usage="grammarBuilder.Append (phrase, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">Powtórzona sekwencja słów do dołączenia.</param>
        <param name="minRepeat">Minimalna liczba przypadków, gdy wymagane jest dopasowanie <paramref name="phrase" /> danych wejściowych w celu utworzenia dopasowania.</param>
        <param name="maxRepeat">Maksymalna liczba przypadków, w których <paramref name="phrase" /> może wystąpić dopasowanie danych wejściowych.</param>
        <summary>Dołącza powtórzoną frazę do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `minRepeat` musi być większa lub równa 0 i mniejsza lub równa `maxRepeat`wartości.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono tworzenie gramatyki rozpoznawania mowy dla fraz, takich jak "Wywołaj Kuba w pracy" i "Call Anne na swoim telefonie komórkowym", gdzie wyraz "Phone" jest opcjonalny. <xref:System.Speech.Recognition.GrammarBuilder>obiekty <xref:System.Speech.Recognition.Choices> i są używane do konstruowania gramatyki. W przykładzie pokazano <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> sposób użycia metody.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendDictation">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza gramatykę dyktowania do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody umożliwiają dołączenie gramatyki dyktowania jako reguły do programu <xref:System.Speech.Recognition.GrammarBuilder>. <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>  
  
 Aby uzyskać więcej informacji na temat gramatyki, zobacz <xref:System.Speech.Recognition.DictationGrammar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation();" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : unit -&gt; unit" Usage="grammarBuilder.AppendDictation " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dołącza domyślną gramatykę dyktowania do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat gramatyki, zobacz <xref:System.Speech.Recognition.DictationGrammar>.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatykę rozpoznawania mowy, która obejmuje dyktowanie.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation();  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation (string category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation(string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation (category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation(System::String ^ category);" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : string -&gt; unit" Usage="grammarBuilder.AppendDictation category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="category">Kategoria gramatyki dyktowania do dołączenia.</param>
        <summary>Dołącza określoną gramatykę dyktowania do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć gramatyki dyktowania, ustaw wartość `category`. `spelling`  
  
 Aby uzyskać więcej informacji na temat gramatyki, zobacz <xref:System.Speech.Recognition.DictationGrammar>.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatykę rozpoznawania mowy, która obejmuje reguły gramatyki dyktowania pisowni.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation("spelling");  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendRuleReference">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza plik gramatyki lub regułę gramatyki do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> Metody mogą dołączać plik gramatyki lub regułę gramatyki z pliku. Te metody umożliwiają aplikacjom korzystanie z wstępnie wdrożonych lub publicznie dostępnych reguł gramatyki. Aplikacja musi mieć dostęp do odczytu do lokalizacji określonych plików gramatyki.  
  
 Metody te mogą odczytywać informacje o gramatyki rozpoznawania mowy przy użyciu następujących formatów.  
  
-   Pliki w formacie XML, które są zgodne ze [specyfikacją SRGS (devisioning Speech Recognition) w wersji 1,0](https://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Pliki binarne, które są zgodne z formatem binarnym gramatycznym rozpoznawania mowy firmy Microsoft (rozszerzenie pliku. cfg)  
  
 Kompilowanie pliku SRGS gramatyki w formacie XML do binarnego pliku gramatyki z rozszerzeniem. cfg może skrócić czas zużyty przez wyszukiwanie dopasowania, zwłaszcza jeśli Gramatyka wymaga rozpoznawania dużej liczby słów i fraz. Aby uzyskać informacje dotyczące kompilowania gramatyk SRGS w formacie binarnym CFG, zobacz <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string -&gt; unit" Usage="grammarBuilder.AppendRuleReference path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka lub uniwersalnego identyfikatora zasobów (URI) pliku opisującego gramatykę rozpoznawania mowy w obsługiwanym formacie.</param>
        <summary>Dołącza plik definicji gramatyki do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator URI podany przez `path` argument może być lokalny lub zdalny. Aplikacja musi mieć dostęp do odczytu do lokalizacji określonych plików gramatyki.  
  
 Reprezentacja W3C rozpoznawania mowy w formacie gramatyki (SRGS) może definiować regułę główną. Ta metoda dołącza gramatykę, zaczynając od jej głównej reguły, do bieżącej sekwencji elementów gramatyki. Aby dołączyć określoną regułę gramatyki, użyj <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> metody.  
  
   
  
## Examples  
 Poniższy C# przykład tworzy gramatykę rozpoznawania mowy, która używa reguły o nazwie `Cities` w lokalnym pliku SRGS, miasta. grxml. Zawartość pliku miejscowości. grxml pojawia się poniżej przykładu C# kodu.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar1()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.AppendRuleReference("file://c:/temp/cities.grxml");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 1";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-16" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path, string rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path, string rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String, rule As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path, System::String ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string * string -&gt; unit" Usage="grammarBuilder.AppendRuleReference (path, rule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rule" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku lub uniwersalnego identyfikatora zasobów (URI) pliku opisującego gramatykę rozpoznawania mowy w obsługiwanym formacie.</param>
        <param name="rule">Identyfikator reguły do dołączenia lub <see langword="null" /> dołączenia domyślnej reguły głównej pliku gramatyki.</param>
        <summary>Dołącza określoną regułę pliku definicji gramatyki do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator URI podany przez `path` argument może być lokalny lub zdalny. Aplikacja musi mieć dostęp do odczytu do lokalizacji określonych plików gramatyki.  
  
 Możesz użyć <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> metody, aby dołączyć plik gramatyki, zaczynając od jego głównej reguły.  
  
   
  
## Examples  
 Poniższy C# przykład tworzy gramatykę rozpoznawania mowy, która używa reguły o nazwie `Cities` w lokalnym pliku SRGS, miasta. grxml. Zawartość pliku miejscowości. grxml pojawia się poniżej przykładu C# kodu.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar2()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.Append("Does");  
  builder.AppendRuleReference(@"c:\temp\cities.grxml", "Cities");  
  builder.Append("have a shuttle");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendWildcard">
      <MemberSignature Language="C#" Value="public void AppendWildcard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendWildcard() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendWildcard ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendWildcard();" />
      <MemberSignature Language="F#" Value="member this.AppendWildcard : unit -&gt; unit" Usage="grammarBuilder.AppendWildcard " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dołącza element gramatyki rozpoznawania, który dopasowuje wszystkie dane wejściowe do bieżącej sekwencji elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element symbol wieloznaczny jest dodawany na końcu bieżącej sekwencji elementów.  
  
 Symbol wieloznaczny dopasowuje dowolny mówiony wyraz. Nie pasuje do szumu lub cisza w tle.  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatykę akceptującą dane wejściowe hasła jako symbol wieloznaczny. Przykład dołącza <xref:System.Speech.Recognition.Grammar.SpeechRecognized?displayProperty=nameWithType> procedurę obsługi zdarzeń do gramatyki, która weryfikuje dane wejściowe hasła.  
  
```csharp  
private Grammar CreatePasswordGrammar()  
{  
  GrammarBuilder wildcardBuilder = new GrammarBuilder();  
  wildcardBuilder.AppendWildcard();  
  SemanticResultKey passwordKey =  
    new SemanticResultKey("Password", wildcardBuilder);  
  
  GrammarBuilder passwordBuilder =  
    new GrammarBuilder("My Password is");  
  passwordBuilder.Append(passwordKey);  
  
  Grammar passwordGrammar = new Grammar(passwordBuilder);  
  passwordGrammar.Name = "Password input";  
  
  passwordGrammar.SpeechRecognized +=  
    new EventHandler<SpeechRecognizedEventArgs>(  
      PasswordInputHandler);  
  
  return passwordGrammar;  
}  
  
// Handle the SpeechRecognized event for the password grammar.  
private void PasswordInputHandler(object sender, SpeechRecognizedEventArgs e)  
{  
  if (e.Result == null) return;  
  
  RecognitionResult result = e.Result;  
  SemanticValue semantics = e.Result.Semantics;  
  
  if (semantics.ContainsKey("Password"))  
  {  
    RecognizedAudio passwordAudio =  
      result.GetAudioForWordRange(  
        result.Words[3], result.Words[result.Words.Count - 1]);  
  
    if (IsValidPassword(passwordAudio))  
    {  
      Console.WriteLine("Password accepted.");  
  
      // Add code to handle a valid password here.  
    }  
    else  
    {  
      Console.WriteLine("Invalid password.");  
  
      // Add code to handle an invalid password here.  
    }  
  }  
}  
  
// Validate the password input.   
private bool IsValidPassword(RecognizedAudio passwordAudio)  
{  
  Console.WriteLine("Validating password.");  
  
  // Add password validation code here.  
  
  return false;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo with get, set" Usage="System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kulturę gramatyki rozpoznawania mowy.</summary>
        <value>Kultura <see cref="T:System.Speech.Recognition.GrammarBuilder" />. Wartością domyślną jest <see cref="P:System.Threading.Thread.CurrentUICulture" /> Właściwość Executing wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> Konstruktor<xref:System.Speech.Recognition.Grammar> tworzy obiekt, który może być używany przez aparat rozpoznawania mowy odpowiedniej kultury. <xref:System.Speech.Recognition.GrammarBuilder.Culture%2A> Tylko właściwość <xref:System.Speech.Recognition.GrammarBuilder> , która jest dostarczana jako parametr do konstruktora gramatyki, jest używana do ustawiania kultury otrzymanej gramatyki rozpoznawania mowy.  
  
 Microsoft Windows i system. Speech API akceptują wszystkie prawidłowe kody krajów językowych. Aby przeprowadzić rozpoznawanie mowy przy użyciu języka określonego we `Culture` właściwości, należy zainstalować aparat rozpoznawania mowy obsługujący ten kod w języku kraju. Aparaty rozpoznawania mowy dostarczane z systemem Microsoft Windows 7 współpracują z poniższymi kodami kraju języka.  
  
-   pl GB. Angielski (Zjednoczone Królestwo)  
  
-   en-US. Angielski (Stany Zjednoczone)  
  
-   de-DE. Niemiecki (Niemcy)  
  
-   es-ES. Hiszpański (Hiszpania)  
  
-   fr-FR. Francuski (Francja)  
  
-   ja-JP. Japoński (Japonia)  
  
-   zh-CN. Chiński (Chiny)  
  
-   zh-TW. Chiński (Tajwan)  
  
 Dozwolone są również dwuliterowe kody języka, takie jak "en", "fr" lub "es".  
  
   
  
## Examples  
 Poniższy przykład tworzy gramatykę rozpoznawania mowy do porządkowania Pizza z maksymalnie czterema toppings. W <xref:System.Speech.Recognition.GrammarBuilder> tym celu ustawia kulturę obiektu na angielski (Stany Zjednoczone).  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.RecognizerInfo" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
      </Docs>
    </Member>
    <Member MemberName="DebugShowPhrases">
      <MemberSignature Language="C#" Value="public string DebugShowPhrases { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DebugShowPhrases" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DebugShowPhrases As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DebugShowPhrases { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DebugShowPhrases : string" Usage="System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg, który pokazuje zawartość i strukturę gramatyki zawartej <see cref="T:System.Speech.Recognition.GrammarBuilder" />w.</summary>
        <value>Bieżąca zawartość i struktura <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy gramatykę rozpoznawania mowy do porządkowania Pizza z maksymalnie czterema toppings. Przed utworzeniem gramatyki zapisuje status <xref:System.Speech.Recognition.GrammarBuilder> do konsoli programu. Ta metoda generuje następujące dane wyjściowe:  
  
-   `GrammarBuilder status: I would like a [cheese,mushroom,tomato,onion,anchovy,chic ken,pepperoni] and [cheese,mushroom,tomato,onion,anchovy,chicken,pepperoni] pizza`  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Write the contents and structure of the GrammarBuilder to the console.  
  Console.WriteLine("Grammar content and structure: {0}", gb.DebugShowPhrases);  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361640(v%3doffice.14)">Tworzenie gramatyki przy użyciu GrammarBuilder</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> , który odnosi się do sekwencji dwóch elementów gramatyki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność argumentów określa kolejność elementów w nowym <xref:System.Speech.Recognition.GrammarBuilder>.  
  
> [!IMPORTANT]
>  Należy zachować ostrożność podczas <xref:System.Speech.Recognition.Choices> łączenia <xref:System.Speech.Recognition.GrammarBuilder> lub obiektów zawierających <xref:System.Speech.Recognition.SemanticResultValue> wystąpienia <xref:System.Speech.Recognition.SemanticResultKey> lub z innymi elementami gramatyki. Aparat rozpoznawania mowy może zgłosić wyjątek przy użyciu gramatyki rozpoznawania mowy, która zawiera zduplikowane elementy semantyczne o tej samej nazwie klucza lub wielu elementach semantycznych, które mogą wielokrotnie modyfikować wartość tego samego elementu semantycznego. 
  
 Aby uzyskać więcej informacji na temat kompilowania i korzystania z gramatyki rozpoznawania mowy, zobacz [rozpoznawanie mowy](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) i [Tworzenie gramatyki GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="choices + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">Pierwszy element gramatyczny, który reprezentuje zestaw wariantów.</param>
        <param name="builder">Drugi element gramatyki.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> , który <see cref="T:System.Speech.Recognition.Choices" /> zawiera obiekt, po którym następuje <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiekt.</summary>
        <returns>Zwraca dla sekwencji <paramref name="choices" /> parametru, po którym następuje <paramref name="builder" /> parametr. <see cref="T:System.Speech.Recognition.GrammarBuilder" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>obsługuje konwersje z następujących klas.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda akceptuje obiekty wymienione powyżej dla `builder` parametru. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatory.  
  
> [!IMPORTANT]
>  W przypadku łączenia <xref:System.Speech.Recognition.Choices> i <xref:System.Speech.Recognition.GrammarBuilder> obiektów zawierających <xref:System.Speech.Recognition.SemanticResultValue> wystąpienia lub <xref:System.Speech.Recognition.SemanticResultKey> należy pamiętać, aby uniknąć tworzenia zduplikowanych elementów semantycznych o takiej samej nazwie klucza lub wielu elementach semantycznych, które mogą wielokrotnie modyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> Właściwość obiektu.<xref:System.Speech.Recognition.SemanticValue> Aparat rozpoznawania mowy może zgłosić wyjątek, Jeśli napotkają te okoliczności.
  
 Równoważna Metoda dla tego operatora to<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.Choices%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">Pierwszy element gramatyki.</param>
        <param name="choices">Drugi element gramatyki, który reprezentuje zestaw elementów alternatywnych.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> , który <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawiera, a po nim <see cref="T:System.Speech.Recognition.Choices" />.</summary>
        <returns>Zwraca dla sekwencji <paramref name="builder" /> parametru, po którym następuje <paramref name="choices" /> parametr. <see cref="T:System.Speech.Recognition.GrammarBuilder" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>obsługuje konwersje z następujących klas:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda akceptuje obiekty wymienione powyżej dla `builder` parametru. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatory.  
  
> [!IMPORTANT]
>  W przypadku łączenia <xref:System.Speech.Recognition.Choices> i <xref:System.Speech.Recognition.GrammarBuilder> obiektów zawierających <xref:System.Speech.Recognition.SemanticResultValue> wystąpienia lub <xref:System.Speech.Recognition.SemanticResultKey> należy pamiętać, aby uniknąć tworzenia zduplikowanych elementów semantycznych o takiej samej nazwie klucza lub wielu elementach semantycznych, które mogą wielokrotnie modyfikować <xref:System.Speech.Recognition.SemanticValue.Value%2A> Właściwość obiektu.<xref:System.Speech.Recognition.SemanticValue> Aparat rozpoznawania mowy może zgłosić wyjątek, Jeśli napotkają te okoliczności.
  
 Równoważna Metoda dla tego operatora to<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 W poniższym przykładzie przedstawiono tworzenie gramatyki rozpoznawania mowy, która może rozpoznać dwie frazy: "Ustaw *kolor*tła" i "Ustaw tło na *kolor*", gdzie *kolor* jest wybierany z zestawu kolorów. Różne typy są używane do tworzenia końcowej gramatyki, takiej [](https://go.microsoft.com/fwlink/?LinkId=159733)jak ciąg <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiekty.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder1 + builder2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">Pierwszy element gramatyki.</param>
        <param name="builder2">Drugi element gramatyki.</param>
        <summary>Tworzy nowy <see cref="T:System.Speech.Recognition.GrammarBuilder" /> , który zawiera sekwencję dwóch <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiektów.</summary>
        <returns>Zwraca dla sekwencji <paramref name="builder1" /> parametru, po którym następuje <paramref name="builder2" /> parametr. <see cref="T:System.Speech.Recognition.GrammarBuilder" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>obsługuje konwersje z następujących klas.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda akceptuje obiekty wymienione powyżej dla `builder1` parametrów i. `builder2` Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatory.  
  
> [!IMPORTANT]
>  W przypadku łączenia <xref:System.Speech.Recognition.GrammarBuilder> obiektów, które <xref:System.Speech.Recognition.SemanticResultValue> zawierają <xref:System.Speech.Recognition.SemanticResultKey> wystąpienia lub, upewnij się, że nie utworzysz zduplikowanych elementów semantycznych o tej samej nazwie klucza lub <xref:System.Speech.Recognition.SemanticValue.Value%2A> wielu elementach semantycznych, które mogą wielokrotnie modyfikować <xref:System.Speech.Recognition.SemanticValue> właściwość obiektu. Aparat rozpoznawania mowy może zgłosić wyjątek, Jeśli napotkają te okoliczności.
  
 Równoważna Metoda dla tego operatora to<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">Pierwszy element gramatyki.</param>
        <param name="phrase">Drugi element gramatyki, który reprezentuje sekwencję wyrazów.</param>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> , która <see cref="T:System.Speech.Recognition.GrammarBuilder" /> zawiera wyrażenie a po nim frazę.</summary>
        <returns>Zwraca dla sekwencji <paramref name="builder" /> parametru, po którym następuje <paramref name="phrase" /> parametr. <see cref="T:System.Speech.Recognition.GrammarBuilder" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>obsługuje konwersje z następujących klas.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda akceptuje obiekty wymienione powyżej dla `builder` parametru. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatory.  
  
 Równoważna Metoda dla tego operatora to<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.String%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="phrase + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">Pierwszy element gramatyczny, który reprezentuje sekwencję wyrazów.</param>
        <param name="builder">Drugi element gramatyki.</param>
        <summary>Tworzy nową <see cref="T:System.Speech.Recognition.GrammarBuilder" /> , która zawiera frazę, a po <see cref="T:System.Speech.Recognition.GrammarBuilder" />niej.</summary>
        <returns>Zwraca dla sekwencji <paramref name="phrase" /> parametru, po którym następuje <paramref name="builder" /> parametr. <see cref="T:System.Speech.Recognition.GrammarBuilder" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>obsługuje konwersje z następujących klas.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Ta metoda akceptuje obiekty wymienione powyżej dla `builder` parametru. Aby uzyskać więcej informacji, zobacz <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> operatory.  
  
 Równoważna Metoda dla tego operatora to<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.String%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>  
  
## Examples  
 W poniższym przykładzie przedstawiono tworzenie gramatyki rozpoznawania mowy, która może rozpoznać dwie frazy: "Ustaw *kolor*tła" i "Ustaw tło na *kolor*", gdzie *kolor* jest wybierany z zestawu kolorów. Różne typy są używane do tworzenia końcowej gramatyki, takiej [](https://go.microsoft.com/fwlink/?LinkId=159733)jak ciąg <xref:System.Speech.Recognition.Choices>, i <xref:System.Speech.Recognition.GrammarBuilder> obiekty.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje inny typ na <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie <xref:System.Speech.Recognition.GrammarBuilder>. Każdą z następujących klas można rzutować na <xref:System.Speech.Recognition.GrammarBuilder>.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Wszystkie rzuty niejawne są równoważne wywołaniu konstruktora.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="choices">Zestaw alternatyw do przekonwertowania.</param>
        <summary><see cref="T:System.Speech.Recognition.Choices" /> Konwertuje obiekt<see cref="T:System.Speech.Recognition.GrammarBuilder" /> na obiekt.</summary>
        <returns>Przekonwertowany <see cref="T:System.Speech.Recognition.Choices" /> obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie <xref:System.Speech.Recognition.GrammarBuilder>. Ten operator konwersji jest odpowiednikiem wywołania <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> i określenia `choices` dla `alternateChoices`.  
  
 Równoważna Metoda dla tego operatora to<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy gramatykę rozpoznawania mowy, która może rozpoznać odpowiedź na pytanie "yes" lub "No". Operator niejawnej konwersji jest używany w konstruowaniu <xref:System.Speech.Recognition.SemanticResultValue> obiektu <xref:System.Speech.Recognition.Choices> z obiektu, <xref:System.Speech.Recognition.Choices> w konstrukcji obiektu z dwóch <xref:System.Speech.Recognition.SemanticResultValue> obiektów i w konstrukcji <xref:System.Speech.Recognition.Grammar> obiektu z <xref:System.Speech.Recognition.SemanticResultKey> obiekt.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultKey semanticKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultKey semanticKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultKey)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticKey As SemanticResultKey) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultKey ^ semanticKey);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticKey" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="semanticKey">Klucz semantyczny do przekonwertowania.</param>
        <summary><see cref="T:System.Speech.Recognition.SemanticResultKey" /> Konwertuje obiekt<see cref="T:System.Speech.Recognition.GrammarBuilder" /> na obiekt.</summary>
        <returns>Przekonwertowany <see cref="T:System.Speech.Recognition.SemanticResultKey" /> obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie <xref:System.Speech.Recognition.GrammarBuilder>. Ten operator konwersji jest odpowiednikiem wywołania <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> i określenia `semanticKey` dla `key`.  
  
 Równoważna Metoda dla tego operatora to<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultKey%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy gramatykę rozpoznawania mowy, która może rozpoznać odpowiedź na pytanie "yes" lub "No". Operator niejawnej konwersji jest używany w konstruowaniu <xref:System.Speech.Recognition.SemanticResultValue> obiektu <xref:System.Speech.Recognition.Choices> z obiektu, <xref:System.Speech.Recognition.Choices> w konstrukcji obiektu z dwóch <xref:System.Speech.Recognition.SemanticResultValue> obiektów i w konstrukcji <xref:System.Speech.Recognition.Grammar> obiektu z <xref:System.Speech.Recognition.SemanticResultKey> obiekt.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultValue semanticValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultValue semanticValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultValue)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticValue As SemanticResultValue) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultValue ^ semanticValue);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticValue" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="semanticValue"><see cref="T:System.Speech.Recognition.SemanticResultValue" /> Obiekt do przekonwertowania.</param>
        <summary><see cref="T:System.Speech.Recognition.SemanticResultValue" /> Konwertuje obiekt<see cref="T:System.Speech.Recognition.GrammarBuilder" /> na obiekt.</summary>
        <returns>Przekonwertowany <see cref="T:System.Speech.Recognition.SemanticResultValue" /> obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie <xref:System.Speech.Recognition.GrammarBuilder>. Ten operator konwersji jest odpowiednikiem wywołania <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> i określenia `semanticValue` dla `value`.  
  
 Równoważna Metoda dla tego operatora to<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultValue%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy gramatykę rozpoznawania mowy, która może rozpoznać odpowiedź na pytanie "yes" lub "No". Operator niejawnej konwersji jest używany w konstruowaniu <xref:System.Speech.Recognition.SemanticResultValue> obiektu <xref:System.Speech.Recognition.Choices>z obiektu, <xref:System.Speech.Recognition.Choices> w konstrukcji obiektu z dwóch <xref:System.Speech.Recognition.SemanticResultValue> obiektów i w konstrukcji <xref:System.Speech.Recognition.Grammar> obiektu z <xref:System.Speech.Recognition.SemanticResultKey> obiekt.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.String)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Ciąg do konwersji.</param>
        <summary>Konwertuje ciąg na <see cref="T:System.Speech.Recognition.GrammarBuilder" /> obiekt.</summary>
        <returns>Przekonwertowany ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niejawna konwersja tworzy nowe wystąpienie <xref:System.Speech.Recognition.GrammarBuilder>. Ten operator konwersji jest odpowiednikiem wywołania <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> i określenia tego samego `phrase`.  
  
 Równoważna Metoda dla tego operatora to<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.String%29?displayProperty=nameWithType>  
  
## Examples  
 <xref:System.Speech.Recognition.GrammarBuilder> Poniższy przykład używa <xref:System.Speech.Recognition.Choices> i obiektów do konstruowania gramatyki, która może rozpoznawać jedną z dwóch fraz, " *colorChoice*w tle" lub "Set Background to *colorChoice*".  
  
 Po utworzeniu listy akceptowalnych wartości dla *colorChoice* przy użyciu <xref:System.Speech.Recognition.Choices> obiektu, przykład `makePhrase` inicjuje dwa <xref:System.Speech.Recognition.GrammarBuilder> obiekty i `setPhrase`, przy użyciu niejawnej konwersji z obiektów String.  
  
 Przykład tworzy <xref:System.Speech.Recognition.Grammar> obiekt na <xref:System.Speech.Recognition.Choices> podstawie rzutowania obiektu na <xref:System.Speech.Recognition.GrammarBuilder> obiekt.  
  
```csharp  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
  </Members>
</Type>

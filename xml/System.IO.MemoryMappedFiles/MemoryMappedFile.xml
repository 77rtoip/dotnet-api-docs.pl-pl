<Type Name="MemoryMappedFile" FullName="System.IO.MemoryMappedFiles.MemoryMappedFile">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a66a5dd4c90728e89b0d27733b7685923d2e2f64" />
    <Meta Name="ms.sourcegitcommit" Value="29c771f79cf4eac4f49e5fae5f1aa8b457acf146" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/21/2018" />
    <Meta Name="ms.locfileid" Value="36298820" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MemoryMappedFile : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryMappedFile extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryMappedFile&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryMappedFile : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje plik mapowanych na pamięć.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik mapowanych na pamięć mapuje zawartość pliku do przestrzeni adresów logicznych aplikacji. Pliki mapowane w pamięci umożliwiają deweloperom pracy z bardzo dużych plików, ponieważ pamięci, które mogą być zarządzane jednocześnie, a także zezwalać pełną, losowy dostępu do pliku bez konieczności wyszukiwania. Pliki mapowane w pamięci również mogą być współużytkowane przez wiele procesów.  
  
 <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> Metod tworzenia pliku mapowanych na pamięć z określonej ścieżki lub <xref:System.IO.FileStream> istniejącego pliku na dysku. Zmiany zostaną automatycznie rozpropagowane na dysku, gdy plik jest Niemapowane.  
  
 <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A> Metody tworzenia mapowanych na pamięć pliku, który nie jest zamapowany do istniejącego pliku na dysku; i nadają się do tworzenia pamięci współużytkowanej do komunikacji międzyprocesowej (IPC).  
  
 Plik mapowanych na pamięć może być skojarzony z opcjonalną nazwę umożliwiającą plików mapowanych na pamięć być współużytkowane z innymi procesami. 
  
 Można tworzyć widoki plików mapowanych na pamięć w tym widoków części pliku. Tę samą część pliku można zamapować na więcej niż jeden adres, aby utworzyć równoczesnych pamięci. Dla dwóch widoków pozostaje jednoczesnych muszą być utworzone na podstawie tego samego pliku mapowanych na pamięć. Tworzenie dwóch mapowania pliku tego samego pliku za pomocą dwóch widoków nie zapewnia współbieżność.  
  
   
  
## Examples  
 Poniższy przykład tworzy widok część bardzo dużych plików mapowanych na pamięć i manipuluje część.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#1)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateFromFile">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy plik mapowanych na pamięć z istniejącego pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku mapowania.</param>
        <summary>Tworzy plik mapowanych na pamięć z pliku na dysku.</summary>
        <returns>Plików mapowanych na pamięć.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> metodę w celu utworzenia pliku mapowanych na pamięć, a następnie tworzy widok części bardzo dużych plików mapowanych na pamięć.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#1)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty, zawiera tylko biały znak lub ma jeden lub więcej nieprawidłowych znaków, zgodnie z definicją <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> metody.  - lub - <paramref name="path" /> odwołuje się do nieprawidłowe urządzenie.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> przekracza maksymalną długość zdefiniowaną przez system operacyjny.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku mapowania.</param>
        <param name="mode">Tryb dostępu; musi być <see cref="F:System.IO.FileMode.Open" />.</param>
        <summary>Tworzy plik mapowanych na pamięć, który został określony tryb dostępu z pliku na dysku.</summary>
        <returns>Plik mapowanych na pamięć, który został określony tryb dostępu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr odnoszą się do pliku źródłowego na dysku. Można użyć tylko <xref:System.IO.FileMode.Open> wartość wyliczenia do tworzenia plików mapowanych na pamięć ze źródłowego pliku na dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty, zawiera tylko biały znak lub ma jeden lub więcej nieprawidłowych znaków, zgodnie z definicją <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> metody.  - lub - <paramref name="path" /> odwołuje się do nieprawidłowe urządzenie.  - lub - <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" />, lub <see cref="F:System.IO.FileMode.Truncate" />.  - lub - <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.OpenOrCreate" /> i plik na dysku nie istnieje.  - lub - wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> przekracza maksymalną długość zdefiniowaną przez system operacyjny.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku mapowania.</param>
        <param name="mode">Tryb dostępu; musi być <see cref="F:System.IO.FileMode.Open" />.</param>
        <param name="mapName">Nazwa do przypisania do plików mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , który nie jest planowane udostępnianie między procesami.</param>
        <summary>Tworzy plik mapowanych na pamięć, który został określony tryb dostępu i nazwa pliku na dysku.</summary>
        <returns>Plików mapowanych na pamięć został określony tryb nazwy i dostępu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr odnoszą się do pliku źródłowego na dysku. Można użyć tylko <xref:System.IO.FileMode.Open> wartość wyliczenia do tworzenia plików mapowanych na pamięć ze źródłowego pliku na dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty, zawiera tylko biały znak lub ma jeden lub więcej nieprawidłowych znaków, zgodnie z definicją <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> metody.  - lub - <paramref name="path" /> odwołuje się do nieprawidłowe urządzenie.  - lub - <paramref name="mapName" /> jest pustym ciągiem.  - lub - <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" />, lub <see cref="F:System.IO.FileMode.Truncate" />.  - lub - <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.OpenOrCreate" /> i plik na dysku nie istnieje.  - lub - wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> przekracza maksymalną długość zdefiniowaną przez system operacyjny.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName, long capacity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku mapowania.</param>
        <param name="mode">Tryb dostępu; Możesz użyć dowolnej z <see cref="T:System.IO.FileMode" /> wyliczenia wartości z wyjątkiem <see cref="F:System.IO.FileMode.Append" />.</param>
        <param name="mapName">Nazwa do przypisania do plików mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , który nie jest planowane udostępnianie między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach do przydzielenia do plików mapowanych na pamięć. Określona liczba 0, aby ustawić zdolności do rozmiaru pliku na dysku.</param>
        <summary>Tworzy plik mapowanych na pamięć, który został określony tryb dostępu, nazwy i pojemności z pliku na dysku.</summary>
        <returns>Plików mapowanych na pamięć ma określonej właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr odnoszą się do pliku źródłowego na dysku.  
  
 Jeśli `capacity` jest większy niż zwiększeniu rozmiaru pliku na dysku, plik na dysku do dopasowania określonej pojemności, nawet jeśli żadne dane nie są zapisywane do pliku mapowanych na pamięć. Aby temu zapobiec, należy określić 0 (zero) pojemności domyślnej, która wewnętrznie ustawi `capacity` rozmiar pliku na dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty, zawiera tylko biały znak lub ma jeden lub więcej nieprawidłowych znaków, zgodnie z definicją <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> metody.  - lub - <paramref name="path" /> odwołuje się do nieprawidłowe urządzenie.  - lub - <paramref name="mapName" /> jest pustym ciągiem.  - lub - <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest większe niż rozmiar przestrzeni adresów logicznych.  - lub - <paramref name="capacity" /> jest mniejsza od zera.  - lub - <paramref name="capacity" /> jest mniejszy niż rozmiar pliku (ale nie zero).  - lub - <paramref name="capacity" /> wynosi zero, a rozmiar pliku na dysku również wynosi zero.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> przekracza maksymalną długość zdefiniowaną przez system operacyjny.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku mapowania.</param>
        <param name="mode">Tryb dostępu; Możesz użyć dowolnej z <see cref="T:System.IO.FileMode" /> wyliczenia wartości z wyjątkiem <see cref="F:System.IO.FileMode.Append" />.</param>
        <param name="mapName">Nazwa do przypisania do plików mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , który nie jest planowane udostępnianie między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach do przydzielenia do plików mapowanych na pamięć. Określona liczba 0, aby ustawić zdolności do rozmiaru pliku na dysku.</param>
        <param name="access">Jedna z wartości wyliczenia, które określają typ dostępu mogą plików mapowanych na pamięć.</param>
        <summary>Tworzy plik mapowanych na pamięć, który został określony tryb dostępu, nazwa, pojemność i typ dostępu z pliku na dysku.</summary>
        <returns>Plików mapowanych na pamięć ma określonej właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr odnoszą się do pliku źródłowego na dysku.  
  
 Jeśli `capacity` jest większy niż zwiększeniu rozmiaru pliku na dysku, plik na dysku do dopasowania określonej pojemności, nawet jeśli żadne dane nie są zapisywane do pliku mapowanych na pamięć. Aby temu zapobiec, należy określić 0 (zero) pojemności domyślnej, która wewnętrznie ustawi `capacity` rozmiar pliku na dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> jest pustym ciągiem.  - lub - <paramref name="access" /> nie jest dopuszczalna wartość.  - lub - <paramref name="path" /> Określa pusty plik.  - lub - <paramref name="access" /> jest określony jako <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> i pojemność jest większy niż rozmiar pliku wskazywany przez <paramref name="path" />.  - lub - <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest większe niż rozmiar przestrzeni adresów logicznych.  - lub - <paramref name="capacity" /> jest mniejsza od zera.  - lub - <paramref name="capacity" /> jest mniejszy niż rozmiar pliku (ale nie zero).  - lub - <paramref name="capacity" /> wynosi zero, a rozmiar pliku na dysku również wynosi zero.  - lub - <paramref name="access" /> nie jest zdefiniowane <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartość.  - lub - rozmiar pliku wskazywany przez <paramref name="path" /> jest większa niż <paramref name="capacity" />.</exception>
        <exception cref="T:System.IO.IOException">- lub - wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> przekracza maksymalną długość zdefiniowaną przez system operacyjny.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do pliku.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (System.IO.FileStream fileStream, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(class System.IO.FileStream fileStream, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.HandleInheritability inheritability, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.HandleInheritability,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::IO::FileStream ^ fileStream, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::HandleInheritability inheritability, bool leaveOpen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileStream" Type="System.IO.FileStream" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileStream">Strumień pliku istniejący plik.</param>
        <param name="mapName">Nazwa do przypisania do plików mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , który nie jest planowane udostępnianie między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach do przydzielenia do plików mapowanych na pamięć. Określona liczba 0, aby ustawić zdolności do rozmiaru <c>filestream</c>.</param>
        <param name="access">Jedna z wartości wyliczenia, które określają typ dostępu mogą plików mapowanych na pamięć.  Nie można ustawić tego parametru <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</param>
        <param name="inheritability">Jedna z wartości wyliczenia, które określa, czy dojścia do plików mapowanych na pamięć mogą być dziedziczone przez procesu podrzędnego. Wartość domyślna to <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <param name="leaveOpen">Wartość, która wskazuje, czy można zamknąć pliku źródłowego strumienia, kiedy <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> został usunięty.</param>
        <summary>Tworzy plik mapowanych na pamięć z istniejącym plikiem z określony tryb dostępu, name, inheritability i pojemności.</summary>
        <returns>Plików mapowanych na pamięć ma określonej właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> jest <see langword="null" /> lub ciąg pusty.  - lub - <paramref name="capacity" /> długość pliku się od zera.  - lub - <paramref name="access" /> ustawiono <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> lub <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartość wyliczenia, co jest niedozwolone.  - lub - <paramref name="access" /> ustawiono <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> i <paramref name="capacity" /> jest większa niż długość <see langword="filestream" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileStream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza od zera.  - lub - <paramref name="capacity" /> jest mniejszy niż rozmiar pliku.  - lub - <paramref name="access" /> nie jest prawidłową <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartości wyliczenia.  - lub - <paramref name="inheritability" /> nie jest prawidłową <see cref="T:System.IO.HandleInheritability" /> wartości wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (System.IO.FileStream fileStream, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(class System.IO.FileStream fileStream, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::IO::FileStream ^ fileStream, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability, bool leaveOpen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileStream" Type="System.IO.FileStream" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileStream">
          <c>FileStream</c> do pliku mapowania.</param>
        <param name="mapName">Nazwa do przypisania do plików mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , który nie jest planowane udostępnianie między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach do przydzielenia do plików mapowanych na pamięć. Określona liczba 0, aby ustawić zdolności do rozmiaru pliku na dysku.</param>
        <param name="access">Jedna z wartości wyliczenia, które określają typ dostępu mogą plików mapowanych na pamięć.  Nie można ustawić tego parametru <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</param>
        <param name="memoryMappedFileSecurity">Uprawnienia, które można otrzymać dostęp do plików i operacji na plikach mapowanych na pamięć.  Ten parametr może być <see langword="null" />.</param>
        <param name="inheritability">Jedna z wartości wyliczenia, które określa, czy dojścia do plików mapowanych na pamięć mogą być dziedziczone przez procesu podrzędnego. Wartość domyślna to <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <param name="leaveOpen">
          <see langword="true" /> Aby nie usuwaj <c>fileStream</c> po <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> zamknięciu; <see langword="false" /> można zlikwidować <c>fileStream</c>.</param>
        <summary>Tworzy plik mapowanych na pamięć, która ma określoną nazwę, pojemności, typ dostępu, uprawnień zabezpieczeń, inheritability oraz usuwania wymaganie z pliku na dysku.</summary>
        <returns>Plików mapowanych na pamięć ma określonej właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `capacity` jest większy niż zwiększeniu rozmiaru pliku na dysku, plik na dysku do dopasowania określonej pojemności, nawet jeśli żadne dane nie są zapisywane do pliku mapowanych na pamięć. Aby temu zapobiec, należy określić 0 (zero) pojemności domyślnej, która wewnętrznie ustawi `capacity` rozmiar pliku na dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> jest pustym ciągiem.  - lub - <paramref name="capacity" /> długość pliku się od zera.  - lub - <paramref name="access" /> ustawiono <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> lub <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartość wyliczenia, co jest niedozwolone.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileStream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza od zera.  - lub - <paramref name="capacity" /> jest mniejszy niż rozmiar pliku.  - lub - <paramref name="access" /> nie jest prawidłową <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartości wyliczenia.  - lub - <paramref name="inheritability" /> nie jest prawidłową <see cref="T:System.IO.HandleInheritability" /> wartości wyliczenia.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="fileStream" /> został zamknięty.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> ustawiono <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" /> podczas <paramref name="fileStream" />jego dostępu ma ustawioną wartość <see cref="F:System.IO.FileAccess.Read" /> lub <see cref="F:System.IO.FileAccess.Write" />.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="mapName" /> już istnieje.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNew">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy plik mapowanych na pamięć w pamięci systemu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa do przypisania do plików mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , który nie jest planowane udostępnianie między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach do przydzielenia do plików mapowanych na pamięć.</param>
        <summary>Tworzy plik mapowanych na pamięć, który ma określoną pojemność pamięci systemu.</summary>
        <returns>Plików mapowanych na pamięć ma określoną nazwę i pojemności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia plików mapowanych na pamięć, który nie jest trwały (to znaczy nie są skojarzone z plikiem na dysku), którego można użyć do udostępnienia danych między procesami.  
  
   
  
## Examples  
 Poniższy przykład składa się z trzech oddzielnych procesów (aplikacji konsoli), które zapisu `Boolean` wartości w pliku mapowanych na pamięć. Występuje następująca sekwencja akcji:  
  
1.  Proces A tworzy plików mapowanych na pamięć i zapisuje wartość.  
  
2.  Proces B otwiera plików mapowanych na pamięć i zapisuje wartość.  
  
3.  Proces C otwiera plików mapowanych na pamięć i zapisuje wartość.  
  
4.  A proces odczytuje i wyświetla wartości z pliku mapowanych na pamięć.  
  
5.  Po zakończeniu procesu A z plików mapowanych na pamięć pliku jest natychmiast odzyskana przez wyrzucanie elementów bezużytecznych.  
  
 Aby uruchomić ten przykład, wykonaj następujące czynności:  
  
1.  Kompilowanie aplikacji, a następnie otwórz trzy polecenia systemu windows.  
  
2.  W pierwszym oknie polecenie Uruchom proces A.  
  
3.  W oknie drugiego polecenia Uruchom proces B.  
  
4.  Wróć do procesu A i naciśnij klawisz ENTER.  
  
5.  W oknie polecenia trzeci Uruchom proces C.  
  
6.  Wróć do procesu A i naciśnij klawisz ENTER.  
  
 Dane wyjściowe, a proces wygląda następująco:  
  
```  
Start Process B and press ENTER to continue.  
Start Process C and press ENTER to continue.  
Process A says: True  
Process B says: False  
Process C says: True  
```  
  
 **Proces A**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_X#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_X#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/vb/program.vb#1)]  
  
 **Proces B**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_A#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_a/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_A#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_a/vb/program.vb#1)]  
  
 **Proces C**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_B#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_b/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_B#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_b/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> jest pustym ciągiem.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza lub równa zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa do przypisania do plików mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , który nie jest planowane udostępnianie między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach do przydzielenia do plików mapowanych na pamięć.</param>
        <param name="access">Jedna z wartości wyliczenia, które określają typ dostępu mogą plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Tworzy plik mapowanych na pamięć, który ma określoną pojemność i typu dostępu w pamięci systemu.</summary>
        <returns>Plików mapowanych na pamięć ma określonej właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia plików mapowanych na pamięć, który nie jest trwały (to znaczy nie są skojarzone z plikiem na dysku), którego można użyć do udostępnienia danych między procesami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> jest pustym ciągiem.  - lub - <paramref name="access" /> jest ustawiona na tylko do zapisu z <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartości wyliczenia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza lub równa zero.  - lub - <paramref name="access" /> nie jest prawidłową <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartości wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long, access As MemoryMappedFileAccess, options As MemoryMappedFileOptions, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::HandleInheritability inheritability);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa do przypisania do plików mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , który nie jest planowane udostępnianie między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach do przydzielenia do plików mapowanych na pamięć.</param>
        <param name="access">Jedna z wartości wyliczenia, które określają typ dostępu mogą plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia określający opcje alokacji pamięci dla plików mapowanych na pamięć.</param>
        <param name="inheritability">Wartość, która określa, czy dojścia do plików mapowanych na pamięć mogą być dziedziczone przez procesu podrzędnego. Wartość domyślna to <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Tworzy plik mapowanych na pamięć, która ma określoną nazwę, wydajność, typ dostępu, opcje alokacji pamięci oraz inheritability.</summary>
        <returns>Plików mapowanych na pamięć ma określonej właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> jest pustym ciągiem.  - lub - <paramref name="access" /> jest ustawiona na tylko do zapisu z <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartości wyliczenia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza lub równa zero.  - lub - <paramref name="access" /> nie jest prawidłową <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartości wyliczenia.  - lub - <paramref name="inheritability" /> nie jest prawidłową <see cref="T:System.IO.HandleInheritability" /> wartość.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa do przypisania do plików mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , który nie jest planowane udostępnianie między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach do przydzielenia do plików mapowanych na pamięć.</param>
        <param name="access">Jedna z wartości wyliczenia, które określają typ dostępu mogą plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia określający opcje alokacji pamięci dla plików mapowanych na pamięć.</param>
        <param name="memoryMappedFileSecurity">Uprawnienia, które można otrzymać dostęp do plików i operacji na plikach mapowanych na pamięć.  Ten parametr może być <see langword="null" />.</param>
        <param name="inheritability">Jedna z wartości wyliczenia, które określa, czy dojścia do plików mapowanych na pamięć mogą być dziedziczone przez procesu podrzędnego. Wartość domyślna to <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Tworzy plik mapowanych na pamięć, która ma określoną pojemność, typ dostępu, Alokacja pamięci, uprawnienia zabezpieczeń oraz inheritability w pamięci systemu.</summary>
        <returns>Plików mapowanych na pamięć ma określonej właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia plików mapowanych na pamięć, który nie jest trwały (to znaczy nie są skojarzone z plikiem na dysku), którego można użyć do udostępnienia danych między procesami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> jest pustym ciągiem.  - lub - <paramref name="access" /> jest ustawiona na tylko do zapisu z <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartości wyliczenia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza lub równa zero.  - lub - <paramref name="access" /> nie jest prawidłową <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartości wyliczenia.  - lub - <paramref name="inheritability" /> nie jest prawidłową <see cref="T:System.IO.HandleInheritability" /> wartości wyliczenia.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateOrOpen">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy lub otwiera plik mapowanych na pamięć w pamięci systemu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa pliku mapowanych na pamięć.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach do przydzielenia do plików mapowanych na pamięć.</param>
        <summary>Tworzy lub otwiera plik mapowanych na pamięć, która ma określoną nazwę i pojemności w pamięci systemu.</summary>
        <returns>Plik mapowanych na pamięć, która ma określoną nazwę i rozmiar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia lub otwierania plików mapowanych na pamięć, który nie jest trwały (to znaczy nie są skojarzone z plikiem na dysku), którego można użyć do udostępnienia danych między procesami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> jest pustym ciągiem.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest większe niż rozmiar przestrzeni adresów logicznych.  - lub - <paramref name="capacity" /> jest mniejsza niż lub równa zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa pliku mapowanych na pamięć.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach do przydzielenia do plików mapowanych na pamięć.</param>
        <param name="access">Jedna z wartości wyliczenia, które określają typ dostępu mogą plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Tworzy lub otwiera mapowanych na pamięć pliku, który ma określony typ nazwy, wydajności i dostępu w pamięci systemu.</summary>
        <returns>Plików mapowanych na pamięć ma określonej właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia lub otwierania plików mapowanych na pamięć, który nie jest trwały (to znaczy nie są skojarzone z plikiem na dysku), którego można użyć do udostępnienia danych między procesami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> jest pustym ciągiem.  - lub - <paramref name="access" /> jest ustawiona na tylko do zapisu z <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartości wyliczenia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest większe niż rozmiar przestrzeni adresów logicznych.  - lub - <paramref name="capacity" /> jest mniejsza niż lub równa zero.  - lub - <paramref name="access" /> nie jest prawidłową <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartości wyliczenia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny określony dostępu do pliku. na przykład ustawiono dostępu <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> lub <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, ale plik lub katalog jest przeznaczony tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long, access As MemoryMappedFileAccess, options As MemoryMappedFileOptions, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::HandleInheritability inheritability);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa pliku mapowanych na pamięć.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach do przydzielenia do plików mapowanych na pamięć.</param>
        <param name="access">Jedna z wartości wyliczenia, które określają typ dostępu mogą plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Bitowe połączenie wartości, które wskazują opcje alokacji pamięci do zastosowania do pliku.</param>
        <param name="inheritability">Wartość, która określa, czy dojścia do plików mapowanych na pamięć mogą być dziedziczone przez procesu podrzędnego. Wartość domyślna to <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Tworzy nowy plik zamapowanej pamięci pusta lub otwiera istniejący plik zamapowanej pamięci, jeśli istnieje wpis o tej samej nazwie. Jeśli otwierania istniejącego pliku, argumenty pojemności i opcje pamięci zostaną zignorowane.</summary>
        <returns>Plików mapowanych na pamięć ma określonej właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> jest pustym ciągiem.  - lub - <paramref name="access" /> jest ustawiona na tylko do zapisu z <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartości wyliczenia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest większe niż rozmiar przestrzeni adresów logicznych.  - lub - <paramref name="capacity" /> jest mniejsza niż lub równa zero.  - lub - <paramref name="access" /> nie jest prawidłową <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartości wyliczenia.  - lub - <paramref name="inheritability" /> nie jest prawidłową <see cref="T:System.IO.HandleInheritability" /> wartości wyliczenia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny określony dostępu do pliku. na przykład ustawiono dostępu <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> lub <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, ale plik lub katalog jest przeznaczony tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa pliku mapowanych na pamięć.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach do przydzielenia do plików mapowanych na pamięć.</param>
        <param name="access">Jedna z wartości wyliczenia, które określają typ dostępu mogą plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia określający opcje alokacji pamięci dla plików mapowanych na pamięć.</param>
        <param name="memoryMappedFileSecurity">Uprawnienia, które można otrzymać dostęp do plików i operacji na plikach mapowanych na pamięć.  Ten parametr może być <see langword="null" />.</param>
        <param name="inheritability">Jedna z wartości wyliczenia, które określa, czy dojścia do plików mapowanych na pamięć mogą być dziedziczone przez procesu podrzędnego. Wartość domyślna to <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Tworzy lub otwiera plik mapowanych na pamięć, która ma określoną nazwę, pojemności, typ dostępu, Alokacja pamięci, uprawnienia zabezpieczeń oraz inheritability w pamięci systemu.</summary>
        <returns>Plików mapowanych na pamięć ma określonej właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia lub otwierania plików mapowanych na pamięć, który nie jest trwały (to znaczy nie są skojarzone z plikiem na dysku), którego można użyć do udostępnienia danych między procesami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> jest pustym ciągiem.  - lub - <paramref name="access" /> jest ustawiona na tylko do zapisu z <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartości wyliczenia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest większe niż rozmiar przestrzeni adresów logicznych.  - lub - <paramref name="capacity" /> jest mniejsza niż lub równa zero.  - lub - <paramref name="access" /> nie jest prawidłową <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartości wyliczenia.  - lub - <paramref name="inheritability" /> nie jest prawidłową <see cref="T:System.IO.HandleInheritability" /> wartości wyliczenia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa określonego systemu operacyjnego <paramref name="access" /> do pliku, na przykład <paramref name="access" /> ma ustawioną wartość <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> lub <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, ale plik lub katalog jest przeznaczony tylko do odczytu.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateViewAccessor">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mapujący do widoku plików mapowanych na pamięć.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor () As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mapujący do widoku plików mapowanych na pamięć.</summary>
        <returns>Losowo dostępny bloku pamięci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć widoku zwracany przez tę metodę losowe dostępu do pliku mapowanych na pamięć.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Nie ma autoryzacji dostępu do plików mapowanych na pamięć.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor (long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor (offset As Long, size As Long) As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor(long offset, long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Bajt, w którym należy uruchomić widoku.</param>
        <param name="size">Rozmiar widoku. Określ 0 (zero), aby utworzyć widok, który rozpoczyna się od <c>przesunięcie</c> i kończy się około na końcu plików mapowanych na pamięć.</param>
        <summary>Tworzy <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mapujący do widoku plików mapowanych na pamięć i ma określone przesunięcie i rozmiaru.</summary>
        <returns>Losowo dostępny bloku pamięci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć widoku zwracany przez tę metodę losowe dostępu do pliku mapowanych na pamięć.  
  
 Aby utworzyć pełny widok plików mapowanych na pamięć, należy określić 0 (zero) `size` parametru. Jeśli to zrobisz, rozmiar widoku może być mniejszy lub większy niż rozmiar pliku źródłowego na dysku. To dlatego widoków znajdują się w jednostkach stron systemu, i rozmiar widoku jest zaokrąglana do następnego rozmiaru strony systemowej.  
  
   
  
## Examples  
 Poniższy przykład tworzy widok pliku mapowanych na pamięć i edytować go. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> klasy.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#2](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#2)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="size" /> jest wartością ujemną.  - lub - <paramref name="size" /> jest większy niż przestrzeń adresów logicznych.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nie ma autoryzacji dostępu do plików mapowanych na pamięć.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor (long offset, long size, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(int64 offset, int64 size, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor (offset As Long, size As Long, access As MemoryMappedFileAccess) As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor(long offset, long size, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="offset">Bajt, w którym należy uruchomić widoku.</param>
        <param name="size">Rozmiar widoku. Określ 0 (zero), aby utworzyć widok, który rozpoczyna się od <c>przesunięcie</c> i kończy się około na końcu plików mapowanych na pamięć.</param>
        <param name="access">Jedna z wartości wyliczenia, które określają typ dostępu mogą plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Tworzy <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mapujący do widoku plików mapowanych na pamięć i ma określony przesunięcie, rozmiar i ograniczenia dostępu.</summary>
        <returns>Losowo dostępny bloku pamięci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć widoku zwracany przez tę metodę losowe dostępu do pliku mapowanych na pamięć.  
  
 Aby utworzyć pełny widok plików mapowanych na pamięć, należy określić 0 (zero) `size` parametru. Jeśli to zrobisz, rozmiar widoku może być mniejszy lub większy niż rozmiar pliku źródłowego na dysku. To dlatego widoków znajdują się w jednostkach stron systemu, i rozmiar widoku jest zaokrąglana do następnego rozmiaru strony systemowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="size" /> jest wartością ujemną.  - lub - <paramref name="size" /> jest większy niż przestrzeń adresów logicznych.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> jest nieprawidłowa dla plików mapowanych na pamięć.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateViewStream">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy strumień, który jest mapowany na widok plików mapowanych na pamięć.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream () As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy strumień, który jest mapowany na widok plików mapowanych na pamięć.</summary>
        <returns>Strumienia pamięci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć Strumień zwrócony przez tę metodę dostęp sekwencyjny do pliku mapowane w pamięci, takich jak komunikacji między procesami.  
  
   
  
## Examples  
 Poniższy przykład tworzy strumień i zapisuje wartość. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A> metody.  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_X#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/cs/program.cs#2)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_X#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Nie ma autoryzacji dostępu do plików mapowanych na pamięć.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream (long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream (offset As Long, size As Long) As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream(long offset, long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Bajt, w którym należy uruchomić widoku.</param>
        <param name="size">Rozmiar widoku. Określ 0 (zero), aby utworzyć widok, który rozpoczyna się od <c>przesunięcie</c> i kończy się około na końcu plików mapowanych na pamięć.</param>
        <summary>Tworzy strumień, która jest mapowana do widoku plików mapowanych na pamięć i ma określone przesunięcie i rozmiar.</summary>
        <returns>Strumień pamięci, która ma określone przesunięcie i rozmiar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć Strumień zwrócony przez tę metodę dostęp sekwencyjny do pliku mapowane w pamięci, takich jak komunikacji między procesami.  
  
 Aby utworzyć pełny widok plików mapowanych na pamięć, należy określić 0 (zero) `size` parametru. Jeśli to zrobisz, rozmiar widoku może być mniejszy lub większy niż rozmiar pliku źródłowego na dysku. To dlatego widoków znajdują się w jednostkach stron systemu, i rozmiar widoku jest zaokrąglana do następnego rozmiaru strony systemowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="size" /> jest wartością ujemną.  - lub - <paramref name="size" /> jest większy niż przestrzeń adresów logicznych.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nie ma autoryzacji dostępu do plików mapowanych na pamięć.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="size" /> jest większa niż łączna ilość pamięci wirtualnej.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream (long offset, long size, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(int64 offset, int64 size, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream (offset As Long, size As Long, access As MemoryMappedFileAccess) As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream(long offset, long size, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="offset">Bajt, w którym należy uruchomić widoku.</param>
        <param name="size">Rozmiar widoku. Określ 0 (zero), aby utworzyć widok, który rozpoczyna się od <c>przesunięcie</c> i kończy się około na końcu plików mapowanych na pamięć.</param>
        <param name="access">Jedna z wartości wyliczenia, które określają typ dostępu mogą plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Tworzy strumień, która jest mapowana do widoku plików mapowanych na pamięć i ma określone przesunięcie, rozmiar i typ dostępu.</summary>
        <returns>Strumień pamięci, która ma określonej właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć Strumień zwrócony przez tę metodę dostęp sekwencyjny do pliku mapowane w pamięci, takich jak komunikacji między procesami.  
  
 Aby utworzyć pełny widok plików mapowanych na pamięć, należy określić 0 (zero) `size` parametru. Jeśli to zrobisz, rozmiar widoku może być mniejszy lub większy niż rozmiar pliku źródłowego na dysku. To dlatego widoków znajdują się w jednostkach stron systemu, i rozmiar widoku jest zaokrąglana do następnego rozmiaru strony systemowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="size" /> jest wartością ujemną.  - lub - <paramref name="size" /> jest większy niż przestrzeń adresów logicznych.  - lub - <paramref name="access" /> nie jest prawidłową <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartości wyliczenia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> jest nieprawidłowa dla plików mapowanych na pamięć.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="size" /> jest większa niż łączna ilość pamięci wirtualnej.  - lub - <paramref name="access" /> jest nieprawidłowa dla plików mapowanych na pamięć.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedFileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MemoryMappedFileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kontroli dostępu do zasobów plików mapowanych na pamięć.</summary>
        <returns>Uprawnienia, które można otrzymać dostęp do plików i operacji na plikach mapowanych na pamięć.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Podstawowy można ustawić informacji zabezpieczeń nie powiodło się.</exception>
        <exception cref="T:System.NotSupportedException">Podstawowy można ustawić informacji zabezpieczeń nie powiodło się.</exception>
        <exception cref="T:System.ObjectDisposedException">Plików mapowanych na pamięć jest zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżąca platforma to Windows 98 lub starszym.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Podstawowy można ustawić informacji zabezpieczeń nie powiodło się.  - lub - plików mapowanych na pamięć został otwarty w trybie <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> tylko.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera istniejący plik mapowanych na pamięć nazwane w pamięci systemu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa pliku mapowanych na pamięć.</param>
        <summary>Otwiera istniejący plik mapowanych na pamięć, która ma określoną nazwę w pamięci systemu.</summary>
        <returns>Plików mapowanych na pamięć o określonej nazwie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plików mapowanych na pamięć może być albo utrwalonego mapowanych na pamięć pliku (skojarzonych z plikiem na dysku) lub -utrwalony.  
  
   
  
## Examples  
 **Otwieranie pliku utrwalonego mapowanych na pamięć**  
  
 Poniższy przykład otwiera mapowanych na pamięć plik o nazwie `ImgA` który została już utworzona na podstawie pliku na dysku (jak pokazano w przykładzie dla <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%28System.String%29> metody).  
  
 [!code-csharp[memorymappedfiles.memorymappedfile.openexisting#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.openexisting/cs/program.cs#1)]
 [!code-vb[memorymappedfiles.memorymappedfile.openexisting#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.openexisting/vb/program.vb#1)]  
  
 **Otwieranie pliku-utrwalony mapowanych na pamięć**  
  
 Poniższy przykład otwiera plik mapowanych na pamięć używana na potrzeby komunikacji między procesami. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%28System.String%2CSystem.Int64%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> jest pustym ciągiem.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony dla <paramref name="mapName" /> nie istnieje.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName, System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String, desiredAccessRights As MemoryMappedFileRights) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName, System::IO::MemoryMappedFiles::MemoryMappedFileRights desiredAccessRights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa pliku mapowanych na pamięć, aby otworzyć.</param>
        <param name="desiredAccessRights">Jedna z wartości wyliczenia, które określa prawa dostępu do zastosowania do plików mapowanych na pamięć.</param>
        <summary>Otwiera istniejący plik mapowanych na pamięć uprawnieniami określonej nazwy i dostępu w pamięci systemu.</summary>
        <returns>Plików mapowanych na pamięć ma określonej właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> jest pustym ciągiem.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="desiredAccessRights" /> nie jest prawidłową <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> wartości wyliczenia.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony dla <paramref name="mapName" /> nie istnieje.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName, System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String, desiredAccessRights As MemoryMappedFileRights, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName, System::IO::MemoryMappedFiles::MemoryMappedFileRights desiredAccessRights, System::IO::HandleInheritability inheritability);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa pliku mapowanych na pamięć, aby otworzyć.</param>
        <param name="desiredAccessRights">Jedna z wartości wyliczenia, które określa prawa dostępu do zastosowania do plików mapowanych na pamięć.</param>
        <param name="inheritability">Jedna z wartości wyliczenia, które określa, czy dojścia do plików mapowanych na pamięć mogą być dziedziczone przez procesu podrzędnego. Wartość domyślna to <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Otwiera istniejący plik mapowanych na pamięć, która ma określoną nazwę, prawa dostępu i inheritability w pamięci systemu.</summary>
        <returns>Plików mapowanych na pamięć ma określonej właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> jest pustym ciągiem.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="desiredAccessRights" /> nie jest prawidłową <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> wartości wyliczenia.  - lub - <paramref name="inheritability" /> nie jest prawidłową <see cref="T:System.IO.HandleInheritability" /> wartości wyliczenia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Żądany dostęp jest nieprawidłowa dla plików mapowanych na pamięć.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony dla <paramref name="mapName" /> nie istnieje.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SafeMemoryMappedFileHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryMappedFiles.MemoryMappedFile.SafeMemoryMappedFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeMemoryMappedFileHandle As SafeMemoryMappedFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeMemoryMappedFileHandle ^ SafeMemoryMappedFileHandle { Microsoft::Win32::SafeHandles::SafeMemoryMappedFileHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dojście do pliku pliku mapowanych na pamięć.</summary>
        <value>Dojścia do plików mapowanych na pamięć.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.SetAccessControl(System.IO.MemoryMappedFiles.MemoryMappedFileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" />
      </Parameters>
      <Docs>
        <param name="memoryMappedFileSecurity">Uprawnienia, które można otrzymać dostęp do plików i operacji na plikach mapowanych na pamięć.</param>
        <summary>Ustawia kontroli dostępu do zasobu plików mapowanych na pamięć.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="memoryMappedFileSecurity" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Podstawowy można ustawić informacji zabezpieczeń nie powiodło się.</exception>
        <exception cref="T:System.NotSupportedException">Podstawowy można ustawić informacji zabezpieczeń nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Podstawowy można ustawić informacji zabezpieczeń nie powiodło się.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
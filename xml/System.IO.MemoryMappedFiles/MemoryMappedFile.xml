<Type Name="MemoryMappedFile" FullName="System.IO.MemoryMappedFiles.MemoryMappedFile">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5794f41f678729fe3a0e5151b4d902f5da9b9863" /><Meta Name="ms.sourcegitcommit" Value="f9e71795ba0f9c2dfaa74bec233343ed0f3ffd99" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/14/2019" /><Meta Name="ms.locfileid" Value="57919991" /></Metadata><TypeSignature Language="C#" Value="public class MemoryMappedFile : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryMappedFile extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryMappedFile&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryMappedFile : IDisposable" />
  <TypeSignature Language="F#" Value="type MemoryMappedFile = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje plik mapowanych na pamięć.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik mapowanych na pamięć mapuje przestrzeń adresów logicznych aplikacji zawartości pliku. Pliki mapowane w pamięci umożliwiają deweloperom pracować z bardzo dużych plików, ponieważ w pamięci, które mogą być zarządzany współbieżnie i umożliwiają one ukończone, losowych dostęp do plików bez potrzeby przeszukiwania. Pliki mapowane w pamięci, również mogą być współużytkowane przez wiele procesów.  
  
 <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> Metod tworzenia pliku mapowane w pamięci z określonej ścieżki lub <xref:System.IO.FileStream> istniejącego pliku na dysku. Zmiany są automatycznie propagowane na dysku, gdy plik jest niezamapowany.  
  
 <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A> Metody Utwórz plik mapowany w pamięci, która nie została zamapowana do istniejącego pliku na dysku i są odpowiednie na potrzeby tworzenia współużytkowaną pamięć służącą do komunikacji międzyprocesowej (IPC).  
  
 Plik mapowanych na pamięć może być skojarzony z opcjonalną nazwę umożliwiającą plików zamapowanych w pamięci, być współużytkowane z innymi procesami. 
  
 Można utworzyć wiele widoków plik mapowany w pamięci, tym widoki części pliku. Tę samą część pliku można zamapować na więcej niż jeden adres, aby utworzyć pamięcią współbieżną. Dla dwóch widoków pozostaje współbieżnych muszą oni można tworzyć na podstawie tego samego pliku mapowanych na pamięć. Tworzenie dwóch mapowania pliku tego samego pliku za pomocą dwóch widoków nie zapewnia współbieżność.  
  
   
  
## Examples  
 Poniższy przykład tworzy widok część bardzo dużych plików zamapowanych w pamięci i manipuluje jego części.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#1)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateFromFile">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy plik mapowane w pamięci z istniejącego pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku mapowania.</param>
        <summary>Tworzy plik mapowane w pamięci z pliku na dysku.</summary>
        <returns>Plik mapowany w pamięci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> metodę, aby utworzyć plik mapowane w pamięci, a następnie tworzy widok część bardzo dużych plików mapowanych na pamięć.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#1)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem pustym, zawiera tylko białe miejsca lub ma jeden lub więcej nieprawidłowych znaków, zgodnie z definicją <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> metody.  
  
—lub— 
 <paramref name="path" /> odnosi się do urządzenia z systemem nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> przekracza maksymalną długość zdefiniowaną przez system operacyjny.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do pliku.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku mapowania.</param>
        <param name="mode">Tryb dostępu musi być <see cref="F:System.IO.FileMode.Open" />.</param>
        <summary>Tworzy plik mapowany w pamięci, który ma określony tryb dostępu z plikiem na dysku.</summary>
        <returns>Plik mapowany w pamięci, który ma określony tryb dostępu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr odnoszą się do pliku źródłowego na dysku. Można używać jedynie <xref:System.IO.FileMode.Open> wartości wyliczenia, aby utworzyć plik mapowany w pamięci z pliku źródłowego na dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem pustym, zawiera tylko białe miejsca lub ma jeden lub więcej nieprawidłowych znaków, zgodnie z definicją <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> metody.  
  
—lub— 
 <paramref name="path" /> odnosi się do urządzenia z systemem nieprawidłowy.  
  
—lub— 
 <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" />, lub <see cref="F:System.IO.FileMode.Truncate" />.  
  
—lub— 
 <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.OpenOrCreate" /> i plik na dysku nie istnieje.  
  
—lub— 
Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> przekracza maksymalną długość zdefiniowaną przez system operacyjny.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do pliku.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku mapowania.</param>
        <param name="mode">Tryb dostępu musi być <see cref="F:System.IO.FileMode.Open" />.</param>
        <param name="mapName">Nazwa do przypisania do pliku mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , nie będą udostępniać między procesami.</param>
        <summary>Tworzy plik mapowany w pamięci, który ma określony tryb dostępu oraz nazwę z plikiem na dysku.</summary>
        <returns>Pliku mapowane w pamięci, który ma określony tryb nazwy i dostępem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr odnoszą się do pliku źródłowego na dysku. Można używać jedynie <xref:System.IO.FileMode.Open> wartości wyliczenia, aby utworzyć plik mapowany w pamięci z pliku źródłowego na dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem pustym, zawiera tylko białe miejsca lub ma jeden lub więcej nieprawidłowych znaków, zgodnie z definicją <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> metody.  
  
—lub— 
 <paramref name="path" /> odnosi się do urządzenia z systemem nieprawidłowy.  
  
—lub— 
 <paramref name="mapName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" />, lub <see cref="F:System.IO.FileMode.Truncate" />.  
  
—lub— 
 <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.OpenOrCreate" /> i plik na dysku nie istnieje.  
  
—lub— 
Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> przekracza maksymalną długość zdefiniowaną przez system operacyjny.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku mapowania.</param>
        <param name="mode">Tryb dostępu może być dowolną z <see cref="T:System.IO.FileMode" /> wartości wyliczenia, z wyjątkiem <see cref="F:System.IO.FileMode.Append" />.</param>
        <param name="mapName">Nazwa do przypisania do pliku mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , nie będą udostępniać między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach, którą należy przydzielić plików zamapowanych w pamięci. Określ 0, aby ustawić pojemności do rozmiaru pliku na dysku.</param>
        <summary>Tworzy plik mapowany w pamięci, który ma określony tryb dostępu, nazwę i pojemności z plikiem na dysku.</summary>
        <returns>Plik mapowane w pamięci, który ma określone właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr odnoszą się do pliku źródłowego na dysku.  
  
 Jeśli `capacity` jest większy niż rozmiar pliku na dysku, plik na dysku zostaje zwiększona do dopasowania określonej pojemności, nawet jeśli dane nie są zapisywane do plików mapowanych na pamięć. Aby temu zapobiec, należy określić 0 (zero) w przypadku pojemności domyślne wewnętrznie ustawi `capacity` rozmiar pliku na dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem pustym, zawiera tylko białe miejsca lub ma jeden lub więcej nieprawidłowych znaków, zgodnie z definicją <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> metody.  
  
—lub— 
 <paramref name="path" /> odnosi się do urządzenia z systemem nieprawidłowy.  
  
—lub— 
 <paramref name="mapName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest większy niż rozmiar przestrzeń adresów logicznych.  
  
—lub— 
 <paramref name="capacity" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="capacity" /> jest mniejsza niż rozmiar pliku (ale nie zero).  
  
—lub— 
 <paramref name="capacity" /> wynosi zero, a rozmiar pliku na dysku jest również zero.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> przekracza maksymalną długość zdefiniowaną przez system operacyjny.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku mapowania.</param>
        <param name="mode">Tryb dostępu może być dowolną z <see cref="T:System.IO.FileMode" /> wartości wyliczenia, z wyjątkiem <see cref="F:System.IO.FileMode.Append" />.</param>
        <param name="mapName">Nazwa do przypisania do pliku mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , nie będą udostępniać między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach, którą należy przydzielić plików zamapowanych w pamięci. Określ 0, aby ustawić pojemności do rozmiaru pliku na dysku.</param>
        <param name="access">Jedna z wartości wyliczenia, które określa typ dostępu przyznany plików mapowanych na pamięć.</param>
        <summary>Tworzy plik mapowany w pamięci, który ma określony tryb dostępu, nazwisko, stanowisko i typ dostępu z plikiem na dysku.</summary>
        <returns>Plik mapowane w pamięci, który ma określone właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr odnoszą się do pliku źródłowego na dysku.  
  
 Jeśli `capacity` jest większy niż rozmiar pliku na dysku, plik na dysku zostaje zwiększona do dopasowania określonej pojemności, nawet jeśli dane nie są zapisywane do plików mapowanych na pamięć. Aby temu zapobiec, należy określić 0 (zero) w przypadku pojemności domyślne wewnętrznie ustawi `capacity` rozmiar pliku na dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="access" /> nie jest dozwoloną wartość.  
  
—lub— 
 <paramref name="path" /> Określa pusty plik.  
  
—lub— 
 <paramref name="access" /> jest określony jako <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> i pojemność jest większy niż rozmiar pliku wskazywany przez <paramref name="path" />.  
  
—lub— 
 <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest większy niż rozmiar przestrzeń adresów logicznych.  
  
—lub— 
 <paramref name="capacity" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="capacity" /> jest mniejsza niż rozmiar pliku (ale nie zero).  
  
—lub— 
 <paramref name="capacity" /> wynosi zero, a rozmiar pliku na dysku jest również zero.  
  
—lub— 
 <paramref name="access" /> nie jest zdefiniowane <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartość.  
  
—lub— 
Rozmiar pliku jest wskazywany przez <paramref name="path" /> jest większa niż <paramref name="capacity" />.</exception>
        <exception cref="T:System.IO.IOException">—lub— 
Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> przekracza maksymalną długość zdefiniowaną przez system operacyjny.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do pliku.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (System.IO.FileStream fileStream, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(class System.IO.FileStream fileStream, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.HandleInheritability inheritability, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.HandleInheritability,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::IO::FileStream ^ fileStream, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : System.IO.FileStream * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.HandleInheritability * bool -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (fileStream, mapName, capacity, access, inheritability, leaveOpen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileStream" Type="System.IO.FileStream" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mapName" Type="System.String" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="leaveOpen" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileStream">Strumień pliku istniejący plik.</param>
        <param name="mapName">Nazwa do przypisania do pliku mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , nie będą udostępniać między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach, którą należy przydzielić plików zamapowanych w pamięci. Określona wartość 0, aby ustawić rozmiar pojemności <c>filestream</c>.</param>
        <param name="access">Jedna z wartości wyliczenia, które określa typ dostępu przyznany plików mapowanych na pamięć.  
  
Nie można ustawić ten parametr <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</param>
        <param name="inheritability">Jedna z wartości wyliczenia, które określa, czy dojścia do plików mapowanych na pamięć może być dziedziczona przez proces podrzędny. Wartość domyślna to <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <param name="leaveOpen">Wartość, która wskazuje, czy można zamknąć pliku źródłowego, przesyłanie strumieniowe, kiedy <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> zostanie usunięty.</param>
        <summary>Tworzy plik mapowane w pamięci z istniejącego pliku określony tryb dostępu, name, inheritability i pojemności.</summary>
        <returns>Plik mapowane w pamięci, który ma określone właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> jest <see langword="null" /> ani być pustym ciągiem.  
  
—lub— 
 <paramref name="capacity" /> i długość pliku mają wartość zero.  
  
—lub— 
 <paramref name="access" /> ustawiono <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> lub <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartość wyliczenia jest niedozwolone.  
  
—lub— 
 <paramref name="access" /> ustawiono <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> i <paramref name="capacity" /> jest większa niż długość <see langword="filestream" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileStream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="capacity" /> jest mniejsza niż rozmiar pliku.  
  
—lub— 
 <paramref name="access" /> nie jest prawidłowym <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartość wyliczenia.  
  
—lub— 
 <paramref name="inheritability" /> nie jest prawidłowym <see cref="T:System.IO.HandleInheritability" /> wartość wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (System.IO.FileStream fileStream, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(class System.IO.FileStream fileStream, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::IO::FileStream ^ fileStream, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : System.IO.FileStream * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability * bool -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (fileStream, mapName, capacity, access, memoryMappedFileSecurity, inheritability, leaveOpen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileStream" Type="System.IO.FileStream" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mapName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="leaveOpen" Type="System.Boolean" Index="6" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileStream"><paramref name="fileStream" /> Do pliku mapowania.</param>
        <param name="mapName">Nazwa do przypisania do pliku mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , nie będą udostępniać między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach, którą należy przydzielić plików zamapowanych w pamięci. Określ 0, aby ustawić pojemności do rozmiaru pliku na dysku.</param>
        <param name="access">Jedna z wartości wyliczenia, które określa typ dostępu przyznany plików mapowanych na pamięć.  
  
Nie można ustawić ten parametr <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</param>
        <param name="memoryMappedFileSecurity">Uprawnienia, które można udzielić dostępu do plików i operacji na pliki mapowane w pamięci.  
  
Ten parametr może być <see langword="null" />.</param>
        <param name="inheritability">Jedna z wartości wyliczenia, które określa, czy dojścia do plików mapowanych na pamięć może być dziedziczona przez proces podrzędny. Wartość domyślna to <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <param name="leaveOpen"><see langword="true" /> Aby nie usuwaj <paramref name="fileStream" /> po <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> jest zamknięty; <see langword="false" /> można zlikwidować <paramref name="fileStream" />.</param>
        <summary>Tworzy plik mapowany w pamięci, która ma określoną nazwę pojemności, typ dostępu, uprawnień zabezpieczeń, inheritability i usuwania wymagań z plikiem na dysku.</summary>
        <returns>Plik mapowane w pamięci, który ma określone właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `capacity` jest większy niż rozmiar pliku na dysku, plik na dysku zostaje zwiększona do dopasowania określonej pojemności, nawet jeśli dane nie są zapisywane do plików mapowanych na pamięć. Aby temu zapobiec, należy określić 0 (zero) w przypadku pojemności domyślne wewnętrznie ustawi `capacity` rozmiar pliku na dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="capacity" /> i długość pliku mają wartość zero.  
  
—lub— 
 <paramref name="access" /> ustawiono <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> lub <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartość wyliczenia jest niedozwolone.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileStream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="capacity" /> jest mniejsza niż rozmiar pliku.  
  
—lub— 
 <paramref name="access" /> nie jest prawidłowym <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartość wyliczenia.  
  
—lub— 
 <paramref name="inheritability" /> nie jest prawidłowym <see cref="T:System.IO.HandleInheritability" /> wartość wyliczenia.</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="fileStream" /> zostało zamknięte.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> ustawiono <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" /> podczas <paramref name="fileStream" />firmy dostępu jest ustawiona na <see cref="F:System.IO.FileAccess.Read" /> lub <see cref="F:System.IO.FileAccess.Write" />.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="mapName" /> już istnieje.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNew">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy plik mapowane w pamięci w pamięci systemu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa do przypisania do pliku mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , nie będą udostępniać między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach, którą należy przydzielić plików zamapowanych w pamięci.</param>
        <summary>Tworzy plik mapowany w pamięci, która ma określoną pojemność w pamięci systemu.</summary>
        <returns>Plik mapowane w pamięci, który ma określoną nazwę i pojemności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia plików zamapowanych w pamięci, który nie jest trwały (czyli nie skojarzonych z plikiem na dysku), która umożliwia udostępnianie danych między procesami.  
  
   
  
## Examples  
 Poniższy przykład składa się z trzech osobnych procesach (aplikacje konsoli), które zapisać `Boolean` wartości w pliku mapowanych na pamięć. Występuje następującą sekwencję czynności:  
  
1.  Proces A tworzy plik mapowany w pamięci i zapisuje wartość.  
  
2.  Proces B zostanie otwarty plik mapowany w pamięci i zapisuje wartość.  
  
3.  Proces C otwiera plik mapowany w pamięci i zapisuje wartość.  
  
4.  A proces odczytuje i wyświetla wartości z pliku mapowanych na pamięć.  
  
5.  Po zakończeniu procesu A plikiem mapowanych na pamięć pliku jest natychmiast odzyskiwane przez wyrzucanie elementów bezużytecznych.  
  
 Aby uruchomić ten przykład, wykonaj następujące czynności:  
  
1.  Kompiluj aplikacje, a następnie otwórz trzy okna polecenia.  
  
2.  W oknie wiersza polecenia pierwszego uruchomienia procesu A.  
  
3.  W drugim oknie polecenia Uruchom proces B.  
  
4.  Wróć do procesu, A, a następnie naciśnij klawisz ENTER.  
  
5.  W oknie wiersza polecenia trzeci Uruchom proces C.  
  
6.  Wróć do procesu, A, a następnie naciśnij klawisz ENTER.  
  
 Dane wyjściowe, a proces jest następująca:  
  
```  
Start Process B and press ENTER to continue.  
Start Process C and press ENTER to continue.  
Process A says: True  
Process B says: False  
Process C says: True  
```  
  
 **Proces A**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_X#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_X#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/vb/program.vb#1)]  
  
 **Proces B**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_A#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_a/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_A#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_a/vb/program.vb#1)]  
  
 **Proces C**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_B#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_b/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_B#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_b/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> jest ciągiem pustym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest mniejsza niż lub równy zeru.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa do przypisania do pliku mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , nie będą udostępniać między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach, którą należy przydzielić plików zamapowanych w pamięci.</param>
        <param name="access">Jedna z wartości wyliczenia, które określa typ dostępu przyznany plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Tworzy plik mapowany w pamięci, która ma określoną pojemność i typu dostępu w pamięci systemu.</summary>
        <returns>Plik mapowane w pamięci, który ma określone właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia plików zamapowanych w pamięci, który nie jest trwały (czyli nie skojarzonych z plikiem na dysku), która umożliwia udostępnianie danych między procesami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="access" /> jest ustawiony na tylko do zapisu z <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartość wyliczenia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest mniejsza niż lub równy zeru.  
  
—lub— 
 <paramref name="access" /> nie jest prawidłowym <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartość wyliczenia.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long, access As MemoryMappedFileAccess, options As MemoryMappedFileOptions, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access, options, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa do przypisania do pliku mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , nie będą udostępniać między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach, którą należy przydzielić plików zamapowanych w pamięci.</param>
        <param name="access">Jedna z wartości wyliczenia, które określa typ dostępu przyznany plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, który określa opcje alokacji pamięci dla plików zamapowanych w pamięci.</param>
        <param name="inheritability">Wartość, która określa, czy dojścia do plików mapowanych na pamięć może być dziedziczona przez proces podrzędny. Wartość domyślna to <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Tworzy plik mapowany w pamięci, która ma określoną nazwę, pojemność, typ dostępu, opcje alokacji pamięci oraz inheritability.</summary>
        <returns>Plik mapowane w pamięci, który ma określone właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="access" /> jest ustawiony na tylko do zapisu z <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartość wyliczenia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest mniejsza niż lub równy zeru.  
  
—lub— 
 <paramref name="access" /> nie jest prawidłowym <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartość wyliczenia.  
  
—lub— 
 <paramref name="inheritability" /> nie jest prawidłowym <see cref="T:System.IO.HandleInheritability" /> wartość.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access, options, memoryMappedFileSecurity, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa do przypisania do pliku mapowanych na pamięć lub <see langword="null" /> dla <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> , nie będą udostępniać między procesami.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach, którą należy przydzielić plików zamapowanych w pamięci.</param>
        <param name="access">Jedna z wartości wyliczenia, które określa typ dostępu przyznany plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, który określa opcje alokacji pamięci dla plików zamapowanych w pamięci.</param>
        <param name="memoryMappedFileSecurity">Uprawnienia, które można udzielić dostępu do plików i operacji na pliki mapowane w pamięci.  
  
Ten parametr może być <see langword="null" />.</param>
        <param name="inheritability">Jedna z wartości wyliczenia, które określa, czy dojścia do plików mapowanych na pamięć może być dziedziczona przez proces podrzędny. Wartość domyślna to <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Tworzy plik mapowany w pamięci, która ma określoną pojemność, typ dostępu, alokacji pamięci, uprawnienia zabezpieczeń oraz inheritability w pamięci systemu.</summary>
        <returns>Plik mapowane w pamięci, który ma określone właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia plików zamapowanych w pamięci, który nie jest trwały (czyli nie skojarzonych z plikiem na dysku), która umożliwia udostępnianie danych między procesami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="access" /> jest ustawiony na tylko do zapisu z <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartość wyliczenia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest mniejsza niż lub równy zeru.  
  
—lub— 
 <paramref name="access" /> nie jest prawidłowym <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartość wyliczenia.  
  
—lub— 
 <paramref name="inheritability" /> nie jest prawidłowym <see cref="T:System.IO.HandleInheritability" /> wartość wyliczenia.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateOrOpen">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy lub otworzy plik mapowane w pamięci w pamięci systemu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa pliku mapowanych na pamięć.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach, którą należy przydzielić plików zamapowanych w pamięci.</param>
        <summary>Tworzy i otwiera plik mapowany w pamięci, która ma określoną nazwę i pojemności w pamięci systemu.</summary>
        <returns>Plik mapowany w pamięci, która ma określoną nazwę i rozmiar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia lub otwierania pliku mapowane w pamięci, który nie jest trwały (czyli nie skojarzonych z plikiem na dysku), która umożliwia udostępnianie danych między procesami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> jest ciągiem pustym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest większy niż rozmiar przestrzeń adresów logicznych.  
  
—lub— 
 <paramref name="capacity" /> jest mniejsza niż lub równy zeru.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa pliku mapowanych na pamięć.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach, którą należy przydzielić plików zamapowanych w pamięci.</param>
        <param name="access">Jedna z wartości wyliczenia, które określa typ dostępu przyznany plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Tworzy i otwiera plik mapowany w pamięci, który ma określony typ nazwisko, stanowisko i dostępu w pamięci systemu.</summary>
        <returns>Plik mapowane w pamięci, który ma określone właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia lub otwierania pliku mapowane w pamięci, który nie jest trwały (czyli nie skojarzonych z plikiem na dysku), która umożliwia udostępnianie danych między procesami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="access" /> jest ustawiony na tylko do zapisu z <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartość wyliczenia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest większy niż rozmiar przestrzeń adresów logicznych.  
  
—lub— 
 <paramref name="capacity" /> jest mniejsza niż lub równy zeru.  
  
—lub— 
 <paramref name="access" /> nie jest prawidłowym <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartość wyliczenia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny, odmowa określonej dostępu do pliku. na przykład, dostęp jest równa <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> lub <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, ale plik lub katalog jest tylko do odczytu.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long, access As MemoryMappedFileAccess, options As MemoryMappedFileOptions, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access, options, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa pliku mapowanych na pamięć.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach, którą należy przydzielić plików zamapowanych w pamięci.</param>
        <param name="access">Jedna z wartości wyliczenia, które określa typ dostępu przyznany plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Bitowa kombinacja wartości, które wskazują opcje alokacji pamięci, aby zastosować do pliku.</param>
        <param name="inheritability">Wartość, która określa, czy dojścia do plików mapowanych na pamięć może być dziedziczona przez proces podrzędny. Wartość domyślna to <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Tworzy nowy plik zamapowanego pusty pamięci lub otwiera istniejący plik zamapowanego pamięci, jeśli taki istnieje o takiej samej nazwie. Jeśli otwarcie istniejącego pliku, argumenty pojemności i opcje pamięci zostaną zignorowane.</summary>
        <returns>Plik mapowane w pamięci, który ma określone właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="access" /> jest ustawiony na tylko do zapisu z <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartość wyliczenia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest większy niż rozmiar przestrzeń adresów logicznych.  
  
—lub— 
 <paramref name="capacity" /> jest mniejsza niż lub równy zeru.  
  
—lub— 
 <paramref name="access" /> nie jest prawidłowym <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartość wyliczenia.  
  
—lub— 
 <paramref name="inheritability" /> nie jest prawidłowym <see cref="T:System.IO.HandleInheritability" /> wartość wyliczenia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny, odmowa określonej dostępu do pliku. na przykład, dostęp jest równa <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> lub <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, ale plik lub katalog jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access, options, memoryMappedFileSecurity, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa pliku mapowanych na pamięć.</param>
        <param name="capacity">Maksymalny rozmiar w bajtach, którą należy przydzielić plików zamapowanych w pamięci.</param>
        <param name="access">Jedna z wartości wyliczenia, które określa typ dostępu przyznany plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, który określa opcje alokacji pamięci dla plików zamapowanych w pamięci.</param>
        <param name="memoryMappedFileSecurity">Uprawnienia, które można udzielić dostępu do plików i operacji na pliki mapowane w pamięci.  
  
Ten parametr może być <see langword="null" />.</param>
        <param name="inheritability">Jedna z wartości wyliczenia, które określa, czy dojścia do plików mapowanych na pamięć może być dziedziczona przez proces podrzędny. Wartość domyślna to <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Tworzy i otwiera plik mapowany w pamięci, która ma określoną nazwę, pojemność, typ dostępu, alokacji pamięci, uprawnienia zabezpieczeń oraz inheritability w pamięci systemu.</summary>
        <returns>Plik mapowane w pamięci, który ma określone właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia lub otwierania pliku mapowane w pamięci, który nie jest trwały (czyli nie skojarzonych z plikiem na dysku), która umożliwia udostępnianie danych między procesami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="access" /> jest ustawiony na tylko do zapisu z <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> wartość wyliczenia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest większy niż rozmiar przestrzeń adresów logicznych.  
  
—lub— 
 <paramref name="capacity" /> jest mniejsza niż lub równy zeru.  
  
—lub— 
 <paramref name="access" /> nie jest prawidłowym <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartość wyliczenia.  
  
—lub— 
 <paramref name="inheritability" /> nie jest prawidłowym <see cref="T:System.IO.HandleInheritability" /> wartość wyliczenia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmowa określonej <paramref name="access" /> do pliku na przykład <paramref name="access" /> jest ustawiona na <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> lub <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, ale plik lub katalog jest tylko do odczytu.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateViewAccessor">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mapujący widok plików mapowanych na pamięć.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor () As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor();" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mapujący widok plików mapowanych na pamięć.</summary>
        <returns>Losowo dostępny bloku pamięci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć widoku, zwrócony przez tę metodę dostępu losowego pliku mapowanych na pamięć.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Nie ma autoryzacji dostępu do plików mapowanych na pamięć.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor (long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor (offset As Long, size As Long) As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor(long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : int64 * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor (offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Bajt, w której należy rozpocząć widoku.</param>
        <param name="size">Rozmiar tego widoku. Określ 0 (zero), aby utworzyć widok, który rozpoczyna się od <paramref name="offset" /> i kończy się około na końcu plików mapowanych na pamięć.</param>
        <summary>Tworzy <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mapujący widok plików zamapowanych w pamięci i ma określone przesunięcie i rozmiaru.</summary>
        <returns>Losowo dostępny bloku pamięci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć widoku, zwrócony przez tę metodę dostępu losowego pliku mapowanych na pamięć.  
  
 Aby utworzyć pełny przegląd plików zamapowanych w pamięci, należy określić 0 (zero) `size` parametru. Jeśli to zrobisz, rozmiar widoku może być mniejszy lub większy niż rozmiar pliku źródłowego na dysku. Jest to spowodowane widoki znajdują się w jednostkach stron systemowych i rozmiar widoku jest zaokrąglana do następnej rozmiaru strony systemowej.  
  
   
  
## Examples  
 Poniższy przykład tworzy widok pliku w mapowanych na pamięć i zacznie ją edytować. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> klasy.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#2](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#2)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> lub <paramref name="size" /> jest liczbą ujemną.  
  
—lub— 
 <paramref name="size" /> jest większe niż przestrzeń adresów logicznych.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nie ma autoryzacji dostępu do plików mapowanych na pamięć.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor (long offset, long size, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(int64 offset, int64 size, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor (offset As Long, size As Long, access As MemoryMappedFileAccess) As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor(long offset, long size, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : int64 * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor (offset, size, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="offset">Bajt, w której należy rozpocząć widoku.</param>
        <param name="size">Rozmiar tego widoku. Określ 0 (zero), aby utworzyć widok, który rozpoczyna się od <paramref name="offset" /> i kończy się około na końcu plików mapowanych na pamięć.</param>
        <param name="access">Jedna z wartości wyliczenia, które określa typ dostępu przyznany plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Tworzy <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mapujący widok plików zamapowanych w pamięci i ma określony przesunięcia, rozmiar i ograniczenia dostępu.</summary>
        <returns>Losowo dostępny bloku pamięci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć widoku, zwrócony przez tę metodę dostępu losowego pliku mapowanych na pamięć.  
  
 Aby utworzyć pełny przegląd plików zamapowanych w pamięci, należy określić 0 (zero) `size` parametru. Jeśli to zrobisz, rozmiar widoku może być mniejszy lub większy niż rozmiar pliku źródłowego na dysku. Jest to spowodowane widoki znajdują się w jednostkach stron systemowych i rozmiar widoku jest zaokrąglana do następnej rozmiaru strony systemowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> lub <paramref name="size" /> jest liczbą ujemną.  
  
—lub— 
 <paramref name="size" /> jest większe niż przestrzeń adresów logicznych.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> jest nieprawidłowa dla plików mapowanych na pamięć.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateViewStream">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy strumień, który mapuje widok plików mapowanych na pamięć.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream () As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream();" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy strumień, który mapuje widok plików mapowanych na pamięć.</summary>
        <returns>Strumień pamięci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć Strumień zwrócony przez tę metodę dostępu sekwencyjnego do pliku mapowane w pamięci, takich jak komunikacji między procesami.  
  
   
  
## Examples  
 Poniższy przykład tworzy strumień i zapisuje wartość. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A> metody.  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_X#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/cs/program.cs#2)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_X#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Nie ma autoryzacji dostępu do plików mapowanych na pamięć.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream (long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream (offset As Long, size As Long) As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream(long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : int64 * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream (offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Bajt, w której należy rozpocząć widoku.</param>
        <param name="size">Rozmiar tego widoku. Określ 0 (zero), aby utworzyć widok, który rozpoczyna się od <paramref name="offset" /> i kończy się około na końcu plików mapowanych na pamięć.</param>
        <summary>Tworzy strumień, która jest mapowana do widoku plików zamapowanych w pamięci i ma określone przesunięcie i rozmiaru.</summary>
        <returns>Strumień pamięci, który ma określone przesunięcie i rozmiar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć Strumień zwrócony przez tę metodę dostępu sekwencyjnego do pliku mapowane w pamięci, takich jak komunikacji między procesami.  
  
 Aby utworzyć pełny przegląd plików zamapowanych w pamięci, należy określić 0 (zero) `size` parametru. Jeśli to zrobisz, rozmiar widoku może być mniejszy lub większy niż rozmiar pliku źródłowego na dysku. Jest to spowodowane widoki znajdują się w jednostkach stron systemowych i rozmiar widoku jest zaokrąglana do następnej rozmiaru strony systemowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> lub <paramref name="size" /> jest liczbą ujemną.  
  
—lub— 
 <paramref name="size" /> jest większe niż przestrzeń adresów logicznych.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nie ma autoryzacji dostępu do plików mapowanych na pamięć.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="size" /> jest większa niż całkowita pamięć wirtualna.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream (long offset, long size, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(int64 offset, int64 size, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream (offset As Long, size As Long, access As MemoryMappedFileAccess) As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream(long offset, long size, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : int64 * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream (offset, size, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="offset">Bajt, w której należy rozpocząć widoku.</param>
        <param name="size">Rozmiar tego widoku. Określ 0 (zero), aby utworzyć widok, który rozpoczyna się od <paramref name="offset" /> i kończy się około na końcu plików mapowanych na pamięć.</param>
        <param name="access">Jedna z wartości wyliczenia, które określa typ dostępu przyznany plików mapowanych na pamięć. Wartość domyślna to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Tworzy strumień, która jest mapowana do widoku plików zamapowanych w pamięci i ma określone przesunięcie, rozmiar i typ dostępu.</summary>
        <returns>Strumień pamięci, która zawiera określone właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć Strumień zwrócony przez tę metodę dostępu sekwencyjnego do pliku mapowane w pamięci, takich jak komunikacji między procesami.  
  
 Aby utworzyć pełny przegląd plików zamapowanych w pamięci, należy określić 0 (zero) `size` parametru. Jeśli to zrobisz, rozmiar widoku może być mniejszy lub większy niż rozmiar pliku źródłowego na dysku. Jest to spowodowane widoki znajdują się w jednostkach stron systemowych i rozmiar widoku jest zaokrąglana do następnej rozmiaru strony systemowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> lub <paramref name="size" /> jest liczbą ujemną.  
  
—lub— 
 <paramref name="size" /> jest większe niż przestrzeń adresów logicznych.  
  
—lub— 
 <paramref name="access" /> nie jest prawidłowym <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> wartość wyliczenia.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> jest nieprawidłowa dla plików mapowanych na pamięć.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="size" /> jest większa niż całkowita pamięć wirtualna.  
  
—lub— 
 <paramref name="access" /> jest nieprawidłowa dla plików mapowanych na pamięć.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="memoryMappedFile.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="memoryMappedFile.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedFileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MemoryMappedFileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Usage="memoryMappedFile.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kontroli dostępu do zasobów plików mapowanych na pamięć.</summary>
        <returns>Uprawnienia, które można udzielić dostępu do plików i operacji na pliki mapowane w pamięci.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Podstawowym wywołaniu, można ustawić informacji zabezpieczeń nie powiodło się.</exception>
        <exception cref="T:System.NotSupportedException">Podstawowym wywołaniu, można ustawić informacji zabezpieczeń nie powiodło się.</exception>
        <exception cref="T:System.ObjectDisposedException">Plik mapowany w pamięci jest zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżąca platforma jest Windows 98 lub starszym.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Podstawowym wywołaniu, można ustawić informacji zabezpieczeń nie powiodło się.  
  
—lub— 
Plik mapowany w pamięci została otwarta <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> tylko.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera istniejący plik mapowanych na pamięć nazwane w pamięci systemu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting mapName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa pliku mapowanych na pamięć.</param>
        <summary>Otwiera istniejący plik mapowane w pamięci, która ma określoną nazwę w pamięci systemu.</summary>
        <returns>Plik mapowany w pamięci, która ma określoną nazwę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik mapowany w pamięci może być albo utrwalonych plik mapowany w pamięci (skojarzone z plikiem na dysku) lub nietrwałe.  
  
   
  
## Examples  
 **Otwieranie utrwalonego pliku mapowane w pamięci**  
  
 W poniższym przykładzie otwierany mapowanych na pamięć plik o nazwie `ImgA` która została już utworzona na podstawie pliku na dysku (jak pokazano w przykładzie dla <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%28System.String%29> metody).  
  
 [!code-csharp[memorymappedfiles.memorymappedfile.openexisting#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.openexisting/cs/program.cs#1)]
 [!code-vb[memorymappedfiles.memorymappedfile.openexisting#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.openexisting/vb/program.vb#1)]  
  
 **Otwieranie pliku Nieutrwaloną mapowane w pamięci**  
  
 W poniższym przykładzie otwierany plik mapowany w pamięci, używany do komunikacji między procesami. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%28System.String%2CSystem.Int64%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> jest ciągiem pustym.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony dla <paramref name="mapName" /> nie istnieje.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName, System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String, desiredAccessRights As MemoryMappedFileRights) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName, System::IO::MemoryMappedFiles::MemoryMappedFileRights desiredAccessRights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.IO.MemoryMappedFiles.MemoryMappedFileRights -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting (mapName, desiredAccessRights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa pliku mapowane w pamięci, aby otworzyć.</param>
        <param name="desiredAccessRights">Jedna z wartości wyliczenia, które określa prawa dostępu do zastosowania do pliku mapowanych na pamięć.</param>
        <summary>Otwiera istniejący plik mapowane w pamięci, która ma określoną nazwę i uprawnienia dostępu w pamięci systemu.</summary>
        <returns>Plik mapowane w pamięci, który ma określone właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> jest ciągiem pustym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="desiredAccessRights" /> nie jest prawidłowym <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> wartość wyliczenia.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony dla <paramref name="mapName" /> nie istnieje.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName, System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String, desiredAccessRights As MemoryMappedFileRights, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName, System::IO::MemoryMappedFiles::MemoryMappedFileRights desiredAccessRights, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.IO.MemoryMappedFiles.MemoryMappedFileRights * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting (mapName, desiredAccessRights, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nazwa pliku mapowane w pamięci, aby otworzyć.</param>
        <param name="desiredAccessRights">Jedna z wartości wyliczenia, które określa prawa dostępu do zastosowania do pliku mapowanych na pamięć.</param>
        <param name="inheritability">Jedna z wartości wyliczenia, które określa, czy dojścia do plików mapowanych na pamięć może być dziedziczona przez proces podrzędny. Wartość domyślna to <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Otwiera istniejący plik mapowane w pamięci, która ma określoną nazwę, prawa dostępu oraz inheritability w pamięci systemu.</summary>
        <returns>Plik mapowane w pamięci, który ma określone właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> jest ciągiem pustym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="desiredAccessRights" /> nie jest prawidłowym <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> wartość wyliczenia.  
  
—lub— 
 <paramref name="inheritability" /> nie jest prawidłowym <see cref="T:System.IO.HandleInheritability" /> wartość wyliczenia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Żądany dostęp jest nieprawidłowa dla plików mapowanych na pamięć.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony dla <paramref name="mapName" /> nie istnieje.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="SafeMemoryMappedFileHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryMappedFiles.MemoryMappedFile.SafeMemoryMappedFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeMemoryMappedFileHandle As SafeMemoryMappedFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeMemoryMappedFileHandle ^ SafeMemoryMappedFileHandle { Microsoft::Win32::SafeHandles::SafeMemoryMappedFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeMemoryMappedFileHandle : Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.SafeMemoryMappedFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt pliku plikiem mapowanych na pamięć.</summary>
        <value>Dojście do pliku mapowanych na pamięć.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.SetAccessControl(System.IO.MemoryMappedFiles.MemoryMappedFileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.IO.MemoryMappedFiles.MemoryMappedFileSecurity -&gt; unit" Usage="memoryMappedFile.SetAccessControl memoryMappedFileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="memoryMappedFileSecurity">Uprawnienia, które można udzielić dostępu do plików i operacji na pliki mapowane w pamięci.</param>
        <summary>Ustawia kontroli dostępu do zasobów plików mapowanych na pamięć.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="memoryMappedFileSecurity" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Podstawowym wywołaniu, można ustawić informacji zabezpieczeń nie powiodło się.</exception>
        <exception cref="T:System.NotSupportedException">Podstawowym wywołaniu, można ustawić informacji zabezpieczeń nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Podstawowym wywołaniu, można ustawić informacji zabezpieczeń nie powiodło się.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a483d1b5-64aa-45b6-86ef-11b859f7f02e">Pliki mapowane w pamięci</related>
      </Docs>
    </Member>
  </Members>
</Type>
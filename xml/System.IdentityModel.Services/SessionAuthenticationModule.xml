<Type Name="SessionAuthenticationModule" FullName="System.IdentityModel.Services.SessionAuthenticationModule">
  <Metadata><Meta Name="ms.openlocfilehash" Value="62f0f61a3c52bab77b13deb299045ef39e220ddc" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69282569" /></Metadata><TypeSignature Language="C#" Value="public class SessionAuthenticationModule : System.IdentityModel.Services.HttpModuleBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SessionAuthenticationModule extends System.IdentityModel.Services.HttpModuleBase" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Services.SessionAuthenticationModule" />
  <TypeSignature Language="VB.NET" Value="Public Class SessionAuthenticationModule&#xA;Inherits HttpModuleBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class SessionAuthenticationModule : System::IdentityModel::Services::HttpModuleBase" />
  <TypeSignature Language="F#" Value="type SessionAuthenticationModule = class&#xA;    inherit HttpModuleBase" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel.Services</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IdentityModel.Services.HttpModuleBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Implementuje moduł ASP.NET, który przetwarza pliki cookie sesji w scenariuszach WS-Federation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy jest <xref:System.IdentityModel.Services.SessionAuthenticationModule> obecny w potoku ASP.NET, (sam) przetwarza pliki cookie sesji w scenariuszach WS-Federation. Używa procedury obsługi plików cookie określonej przez <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> właściwość, aby odczytać plik cookie nieprzetworzonej sesji z żądania HTTP i zapisać go w odpowiedzi HTTP. Korzysta ona z <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> skonfigurowanej aplikacji do deserializacji pliku cookie nieprzetworzonej sesji na <xref:System.IdentityModel.Tokens.SessionSecurityToken> obiekty. Token zabezpieczeń sesji zawiera oświadczenia (<xref:System.Security.Claims.Claim>) i podmiot zabezpieczeń (<xref:System.Security.Claims.ClaimsPrincipal>) skojarzone z jednostką, dla której żądanie jest obsługiwane.  
  
 SAM dodaje swój <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> program obsługi zdarzeń <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> do zdarzenia w potoku ASP.NET. Ta procedura obsługi przechwytuje żądania logowania i, jeśli istnieje plik cookie sesji, deserializacji go do tokenu sesji i ustawia <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> właściwości i <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> dla podmiotu zabezpieczeń oświadczeń zawartego w tokenie sesji. Wywołuje kilka innych metod udostępnianych przez SAM proces w trakcie tego procesu.  
  
 <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> Metodę można wywołać w celu podpisania użytkownika poza sesją (na przykład w pliku z kodem SignOut.aspx.cs).  
  
 SAM udostępnia kilka zdarzeń, które zapewniają dostęp do jego potoku przetwarzania. Zdarzenia <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> i<xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> umożliwiają modyfikowanie tokenów sesji, które są odczytywane z plików cookie lub tworzone podczas przetwarzania. Zwykle jest to gotowe do dodawania, usuwania lub przekształcania oświadczeń w tokenie lub dostosowywania ich czasu wygaśnięcia. Zdarzenia <xref:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut>, <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut> i<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> zapewniają punkty zaczepienia do przetwarzania żądań wylogowania. W wielu scenariuszach wystarczy dodać programy obsługi dla tych zdarzeń, często do pliku global.asax.cs.  
  
 W przypadku bardziej skomplikowanych scenariuszy można utworzyć od <xref:System.IdentityModel.Services.SessionAuthenticationModule> , aby zaimplementować niestandardowy sam. W tym celu wiele metod, które są wywoływane w trakcie <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> i <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> są uwidocznione, aby umożliwić niestandardowe zachowanie na określonych etapach cyklu przetwarzania sesji.  
  
 Można dodać sam do potoku ASP.NET w pliku konfiguracyjnym, dodając go do modułów HTTP w ramach `<system.webServer>` elementu dla usług IIS w wersji 7 lub nowszej lub `<system.web>` w obszarze elementu dla wersji wcześniejszych niż usługi IIS 7. Program obsługi plików cookie używany przez sam element sam można skonfigurować przy [ &lt;użyciu&gt; elementu cookieHandler](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) .  
  
   
  
## Examples  
 [!code-csharp[WifSAM#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#1)]  
  
 Poniższy kod XML przedstawia sposób konfigurowania SAM w potoku ASP.NET. Wiele innych elementów, które są obecne w typowej konfiguracji, zostało pominięte w tym miejscu dla zwięzłości.  
  
```xml  
<configuration>  
  <system.webServer>  
    <modules>  
      <!--WIF 4.5 modules -->  
      <add name="SessionAuthenticationModule" type="System.IdentityModel.Services.SessionAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
      <add name="WsFederationAuthenticationModule" type="System.IdentityModel.Services.WSFederationAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
    </modules>  
  </system.webServer>  
</configuration>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionAuthenticationModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionAuthenticationModule();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IdentityModel.Services.SessionAuthenticationModule" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest ustawiona na `false` , a <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> Właściwość <xref:System.IdentityModel.Services.CookieHandlerElement.ChunkedCookieHandler%2A> jest inicjowana do domyślnego wystąpienia klasy. <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateSessionSecurityToken (System.IdentityModel.Tokens.SessionSecurityToken sessionToken, bool writeCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateSessionSecurityToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken, bool writeCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken(System.IdentityModel.Tokens.SessionSecurityToken,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateSessionSecurityToken (sessionToken As SessionSecurityToken, writeCookie As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateSessionSecurityToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionToken, bool writeCookie);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateSessionSecurityToken : System.IdentityModel.Tokens.SessionSecurityToken * bool -&gt; unit&#xA;override this.AuthenticateSessionSecurityToken : System.IdentityModel.Tokens.SessionSecurityToken * bool -&gt; unit" Usage="sessionAuthenticationModule.AuthenticateSessionSecurityToken (sessionToken, writeCookie)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
        <Parameter Name="writeCookie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Token zabezpieczeń sesji używany do uwierzytelniania przychodzącego żądania HTTP.</param>
        <param name="writeCookie"><see langword="true" />Aby zapisać plik cookie sesji; w przeciwnym razie. <see langword="false" /></param>
        <summary>Uwierzytelnia żądanie przychodzące przez zweryfikowanie tokenu sesji przychodzącej. Po pomyślnej weryfikacji program aktualizuje bieżący kontekst HTTP i podmiot zabezpieczeń wątku przy użyciu <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />określonego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest wywoływana <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> z metody. <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> Wywołuje metodę, <xref:System.IdentityModel.Services.SessionAuthenticationModule.SetPrincipalFromSessionToken%2A> aby zweryfikować przychodzący token i <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> zaktualizować <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> właściwości i. Jeśli parametr ma `true`wartość, <xref:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie%2A> Metoda jest wywoływana w celu zapisania tokenu sesji w pliku cookie. `writeCookie`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsSessionTokenCookie">
      <MemberSignature Language="C#" Value="public bool ContainsSessionTokenCookie (System.Web.HttpCookieCollection httpCookieCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsSessionTokenCookie(class System.Web.HttpCookieCollection httpCookieCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ContainsSessionTokenCookie(System.Web.HttpCookieCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsSessionTokenCookie(System::Web::HttpCookieCollection ^ httpCookieCollection);" />
      <MemberSignature Language="F#" Value="member this.ContainsSessionTokenCookie : System.Web.HttpCookieCollection -&gt; bool" Usage="sessionAuthenticationModule.ContainsSessionTokenCookie httpCookieCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="httpCookieCollection" Type="System.Web.HttpCookieCollection" />
      </Parameters>
      <Docs>
        <param name="httpCookieCollection">Kolekcja plików cookie, które mają być wyszukiwane.</param>
        <summary>Określa, czy plik cookie sesji znajduje się w określonej kolekcji plików cookie.</summary>
        <returns><see langword="true" />Jeśli zostanie znaleziony plik cookie sesji; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="httpCookieCollection" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContextSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SessionSecurityToken ContextSessionSecurityToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SessionSecurityToken ContextSessionSecurityToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.ContextSessionSecurityToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContextSessionSecurityToken As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IdentityModel::Tokens::SessionSecurityToken ^ ContextSessionSecurityToken { System::IdentityModel::Tokens::SessionSecurityToken ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContextSessionSecurityToken : System.IdentityModel.Tokens.SessionSecurityToken" Usage="System.IdentityModel.Services.SessionAuthenticationModule.ContextSessionSecurityToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera aktywny <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> dla bieżącego <see cref="T:System.Web.HttpContext" />.</summary>
        <value>Token zabezpieczeń aktywnej sesji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieHandler">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Services.CookieHandler CookieHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Services.CookieHandler CookieHandler" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property CookieHandler As CookieHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Services::CookieHandler ^ CookieHandler { System::IdentityModel::Services::CookieHandler ^ get(); void set(System::IdentityModel::Services::CookieHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieHandler : System.IdentityModel.Services.CookieHandler with get, set" Usage="System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Services.CookieHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera procedurę obsługi plików cookie służącą do odczytywania, zapisywania i usuwania plików cookie sesji.</summary>
        <value>Procedura obsługi plików cookie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest inicjowana <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializePropertiesFromConfiguration%2A> przez metodę. <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> Ta metoda inicjuje właściwość na podstawie procedury obsługi plików cookie określonej dla <xref:System.IdentityModel.Services.Configuration.FederationConfiguration> obiektu, który jest ustawiony <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType> we właściwości. Procedurę obsługi plików cookie można ustawić w pliku konfiguracji za pomocą [ &lt;elementu cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) .  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie" />
        <altmember cref="M:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie(System.IdentityModel.Tokens.SessionSecurityToken@)" />
        <altmember cref="M:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie(System.IdentityModel.Tokens.SessionSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken (System.Security.Claims.ClaimsPrincipal principal, string context, DateTime validFrom, DateTime validTo, bool isPersistent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken(class System.Security.Claims.ClaimsPrincipal principal, string context, valuetype System.DateTime validFrom, valuetype System.DateTime validTo, bool isPersistent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.CreateSessionSecurityToken(System.Security.Claims.ClaimsPrincipal,System.String,System.DateTime,System.DateTime,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSessionSecurityToken (principal As ClaimsPrincipal, context As String, validFrom As DateTime, validTo As DateTime, isPersistent As Boolean) As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IdentityModel::Tokens::SessionSecurityToken ^ CreateSessionSecurityToken(System::Security::Claims::ClaimsPrincipal ^ principal, System::String ^ context, DateTime validFrom, DateTime validTo, bool isPersistent);" />
      <MemberSignature Language="F#" Value="member this.CreateSessionSecurityToken : System.Security.Claims.ClaimsPrincipal * string * DateTime * DateTime * bool -&gt; System.IdentityModel.Tokens.SessionSecurityToken" Usage="sessionAuthenticationModule.CreateSessionSecurityToken (principal, context, validFrom, validTo, isPersistent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="validFrom" Type="System.DateTime" />
        <Parameter Name="validTo" Type="System.DateTime" />
        <Parameter Name="isPersistent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="principal">Podmiot zabezpieczeń do przechwycenia w tokenie.</param>
        <param name="context">Zdefiniowany przez aplikację ciąg kontekstowy.</param>
        <param name="validFrom">Pierwszy natychmiast, w którym token jest prawidłowy.</param>
        <param name="validTo">Ostatni natychmiast, w którym token jest prawidłowy.</param>
        <param name="isPersistent"><see langword="true" />Jeśli wartość powinna być utrwalona przez agenta użytkownika; w przeciwnym razie. <see langword="false" /></param>
        <summary><see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> Tworzy z określonych parametrów przy użyciu skonfigurowanej procedury obsługi tokenu sesji.</summary>
        <returns>Token sesji.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Nie ma skonfigurowanej prawidłowej obsługi tokenów sesji. (Nie <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> ma skonfigurowanych <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" /> właściwości).</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteSessionTokenCookie">
      <MemberSignature Language="C#" Value="public void DeleteSessionTokenCookie ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSessionTokenCookie() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSessionTokenCookie ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSessionTokenCookie();" />
      <MemberSignature Language="F#" Value="member this.DeleteSessionTokenCookie : unit -&gt; unit" Usage="sessionAuthenticationModule.DeleteSessionTokenCookie " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa plik cookie sesji i usuwa go z pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usuwa plik cookie sesji za pomocą procedury obsługi plików cookie określonej przez <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> właściwość. Ta metoda jest wywoływana podczas wylogowywania przez <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeModule">
      <MemberSignature Language="C#" Value="protected override void InitializeModule (System.Web.HttpApplication context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InitializeModule(class System.Web.HttpApplication context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule(System.Web.HttpApplication)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InitializeModule (context As HttpApplication)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InitializeModule(System::Web::HttpApplication ^ context);" />
      <MemberSignature Language="F#" Value="override this.InitializeModule : System.Web.HttpApplication -&gt; unit" Usage="sessionAuthenticationModule.InitializeModule context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpApplication" />
      </Parameters>
      <Docs>
        <param name="context">Obiekt aplikacji HTTP, który zawiera ten moduł.</param>
        <summary>Inicjuje moduł i przygotowuje go do obsługi zdarzeń z obiektu [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] aplikacji modułu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> Dodaje <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> <xref:System.Web.HttpApplication.PostAuthenticateRequest?displayProperty=nameWithType> `context` i programy obsługi do zdarzeń i obiektu aplikacji określonego przez parametr. <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializePropertiesFromConfiguration">
      <MemberSignature Language="C#" Value="protected override void InitializePropertiesFromConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InitializePropertiesFromConfiguration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.InitializePropertiesFromConfiguration" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InitializePropertiesFromConfiguration ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InitializePropertiesFromConfiguration();" />
      <MemberSignature Language="F#" Value="override this.InitializePropertiesFromConfiguration : unit -&gt; unit" Usage="sessionAuthenticationModule.InitializePropertiesFromConfiguration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje właściwości modułu na podstawie definicji w pliku konfiguracji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inicjuje Właściwość z procedury obsługi określonej w konfiguracji <xref:System.IdentityModel.Services.Configuration.FederationConfiguration?displayProperty=nameWithType> przez obiekt <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType> , który jest ustawiony we właściwości. <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> Procedurę obsługi plików cookie można określić w pliku konfiguracji za pomocą [ &lt;elementu cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReferenceMode">
      <MemberSignature Language="C#" Value="public bool IsReferenceMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReferenceMode" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReferenceMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReferenceMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsReferenceMode : bool with get, set" Usage="System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy informacje o sesji (wartości, itp.) powinny być przechowywane w pliku cookie sesji lub czy zawartość sesji powinna być przechowywana po stronie serwera, przy użyciu pliku cookie do przechowywania tylko odwołania.</summary>
        <value><see langword="true" />Jeśli pliki cookie są wystawione w trybie odwołania; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />, która określa, że wystawione pliki cookie nie są w trybie odwołania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W trybie odwołania, <xref:System.IdentityModel.Tokens.SessionSecurityToken> jest przechowywany w pamięci podręcznej po stronie serwera (obiekt, który pochodzi od <xref:System.IdentityModel.Tokens.SessionSecurityTokenCache>). Wystawiony plik cookie zawiera tylko identyfikator kontekstu, który jest używany do pobierania tokenu z pamięci podręcznej.  
  
> [!IMPORTANT]
>  Aby działać w trybie referencyjnym, firma Microsoft zaleca dostarczenie obsługi <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated?displayProperty=nameWithType> zdarzenia w pliku Global.asax.cs i <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> ustawienie właściwości dla tokenu przesłanego we <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A?displayProperty=nameWithType> właściwości. Zapewni to, że token sesji działa w trybie odwołania dla każdego żądania i jest preferowany tylko przez ustawienie <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A?displayProperty=nameWithType> właściwości w module uwierzytelniania sesji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAuthenticateRequest">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthenticateRequest (object sender, EventArgs eventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthenticateRequest(object sender, class System.EventArgs eventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest(System.Object,System.EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthenticateRequest(System::Object ^ sender, EventArgs ^ eventArgs);" />
      <MemberSignature Language="F#" Value="abstract member OnAuthenticateRequest : obj * EventArgs -&gt; unit&#xA;override this.OnAuthenticateRequest : obj * EventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnAuthenticateRequest (sender, eventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="eventArgs" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Źródło zdarzenia. Będzie <see cref="T:System.Web.HttpApplication" /> to obiekt.</param>
        <param name="eventArgs">Dane zdarzenia.</param>
        <summary><see cref="E:System.Web.HttpApplication.AuthenticateRequest" /> Obsługuje zdarzenie [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] z potoku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje następujące czynności:  
  
1.  <xref:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie%2A> Wywołuje metodę<xref:System.IdentityModel.Tokens.SessionSecurityToken> odczytu z pliku cookie sesji, jeśli istnieje.  
  
2.  Jeśli nie można odczytać tokenu zabezpieczeń sesji (najprawdopodobniej dlatego, że sesja nie została ustanowiona), Return.  
  
3.  Wywołuje metodę w celu podniesienia <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived>zdarzenia. <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenReceived%2A> Zapewnia to możliwość zmiany tokenu odczytywanego z pliku cookie lub żądania anulowania. Program obsługi może także określić, że token powinien zostać ponownie wystawiony przez ustawienie <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.ReissueCookie%2A?displayProperty=nameWithType> właściwości.  
  
4.  Jeśli token ma zostać ponownie wystawiony, program usuwa go z pamięci podręcznej i <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenCreated%2A> wywołuje metodę w celu <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> wywołania zdarzenia. Dzięki temu można ponownie zmodyfikować token. Zachowanie problemu można także zmodyfikować, ustawiając <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.WriteSessionCookie%2A?displayProperty=nameWithType> właściwość w programie obsługi zdarzeń.  
  
5.  <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> Wywołuje metodę w celu uwierzytelnienia użytkownika. Jeśli to się powiedzie, ma to wpływ na <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> ustawienie właściwości podmiotu, który jest zawarty <xref:System.IdentityModel.Tokens.SessionSecurityToken.ClaimsPrincipal%2A?displayProperty=nameWithType> we właściwości tokenu przychodzącego.  
  
6.  Jeśli sesja wygasła, wywołuje <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metodę.  
  
 Metoda jest dodawana do obsługi <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> zdarzenia w <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule%2A> metodzie. <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie ma skonfigurowanej prawidłowej obsługi tokenów sesji. (Nie <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> ma skonfigurowanych <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" /> właściwości).</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPostAuthenticateRequest">
      <MemberSignature Language="C#" Value="protected virtual void OnPostAuthenticateRequest (object sender, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPostAuthenticateRequest(object sender, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPostAuthenticateRequest (sender As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPostAuthenticateRequest(System::Object ^ sender, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPostAuthenticateRequest : obj * EventArgs -&gt; unit&#xA;override this.OnPostAuthenticateRequest : obj * EventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnPostAuthenticateRequest (sender, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Źródło zdarzenia. Będzie <see cref="T:System.Web.HttpApplication" /> to obiekt.</param>
        <param name="e">Dane zdarzenia.</param>
        <summary><see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" /> Obsługuje zdarzenie [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] z potoku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja jest pusta.  
  
 Procedura obsługi jest dodawana do programów obsługi <xref:System.Web.HttpApplication.PostAuthenticateRequest?displayProperty=nameWithType> dla zdarzenia w <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule%2A> metodzie. <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSessionSecurityTokenCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionSecurityTokenCreated (System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionSecurityTokenCreated(class System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenCreated(System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionSecurityTokenCreated (args As SessionSecurityTokenCreatedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionSecurityTokenCreated(System::IdentityModel::Services::SessionSecurityTokenCreatedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionSecurityTokenCreated : System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs -&gt; unit&#xA;override this.OnSessionSecurityTokenCreated : System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSessionSecurityTokenCreated args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Dane zdarzenia.</param>
        <summary><see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływana z <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSessionSecurityTokenReceived">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionSecurityTokenReceived (System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionSecurityTokenReceived(class System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenReceived(System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionSecurityTokenReceived (args As SessionSecurityTokenReceivedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionSecurityTokenReceived(System::IdentityModel::Services::SessionSecurityTokenReceivedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionSecurityTokenReceived : System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs -&gt; unit&#xA;override this.OnSessionSecurityTokenReceived : System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSessionSecurityTokenReceived args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Dane zdarzenia.</param>
        <summary><see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływana z <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSignedOut">
      <MemberSignature Language="C#" Value="protected virtual void OnSignedOut (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSignedOut(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSignedOut(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSignedOut (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSignedOut(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSignedOut : EventArgs -&gt; unit&#xA;override this.OnSignedOut : EventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSignedOut e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia.</param>
        <summary><see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana z <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metody po przeprowadzeniu wylogowania, a plik cookie sesji został usunięty.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSigningOut">
      <MemberSignature Language="C#" Value="protected virtual void OnSigningOut (System.IdentityModel.Services.SigningOutEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSigningOut(class System.IdentityModel.Services.SigningOutEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSigningOut(System.IdentityModel.Services.SigningOutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSigningOut (e As SigningOutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSigningOut(System::IdentityModel::Services::SigningOutEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSigningOut : System.IdentityModel.Services.SigningOutEventArgs -&gt; unit&#xA;override this.OnSigningOut : System.IdentityModel.Services.SigningOutEventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSigningOut e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IdentityModel.Services.SigningOutEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia.</param>
        <summary><see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana z <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metody w celu wykonania wylogowania. Jest wywoływana przed usunięciem pliku cookie sesji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSignOutError">
      <MemberSignature Language="C#" Value="protected virtual void OnSignOutError (System.IdentityModel.Services.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSignOutError(class System.IdentityModel.Services.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSignOutError(System.IdentityModel.Services.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSignOutError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSignOutError(System::IdentityModel::Services::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSignOutError : System.IdentityModel.Services.ErrorEventArgs -&gt; unit&#xA;override this.OnSignOutError : System.IdentityModel.Services.ErrorEventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSignOutError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IdentityModel.Services.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia.</param>
        <summary><see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana z metody <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> , jeśli wystąpi błąd podczas wylogowywania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadSessionTokenFromCookie">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SessionSecurityToken ReadSessionTokenFromCookie (byte[] sessionCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SessionSecurityToken ReadSessionTokenFromCookie(unsigned int8[] sessionCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ReadSessionTokenFromCookie(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadSessionTokenFromCookie (sessionCookie As Byte()) As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IdentityModel::Tokens::SessionSecurityToken ^ ReadSessionTokenFromCookie(cli::array &lt;System::Byte&gt; ^ sessionCookie);" />
      <MemberSignature Language="F#" Value="member this.ReadSessionTokenFromCookie : byte[] -&gt; System.IdentityModel.Tokens.SessionSecurityToken" Usage="sessionAuthenticationModule.ReadSessionTokenFromCookie sessionCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionCookie" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="sessionCookie">Plik cookie w postaci surowej, który zawiera token sesji.</param>
        <summary><see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> Odczytuje z określonego pliku cookie sesji.</summary>
        <returns>Token sesji odczytany z pliku cookie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Nie ma skonfigurowanej prawidłowej obsługi tokenów sesji. (Nie <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> ma skonfigurowanych <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" /> właściwości).</exception>
      </Docs>
    </Member>
    <Member MemberName="SessionSecurityTokenCreated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; SessionSecurityTokenCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; SessionSecurityTokenCreated" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated" />
      <MemberSignature Language="VB.NET" Value="Public Event SessionSecurityTokenCreated As EventHandler(Of SessionSecurityTokenCreatedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::SessionSecurityTokenCreatedEventArgs ^&gt; ^ SessionSecurityTokenCreated;" />
      <MemberSignature Language="F#" Value="member this.SessionSecurityTokenCreated : EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; " Usage="member this.SessionSecurityTokenCreated : System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po utworzeniu tokenu zabezpieczeń sesji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie służy do modyfikowania tokenu zabezpieczeń sesji przed zapisaniem w pliku cookie.  
  
 Zdarzenie jest wywoływane z <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> poziomu metody po utworzeniu tokenu sesji (<xref:System.IdentityModel.Tokens.SessionSecurityToken>). <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> Dzieje się tak na przykład wtedy, gdy program obsługi zdarzeń dla <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> zdarzenia modyfikuje token.  
  
 To zdarzenie służy do modyfikowania właściwości tokenu sesji przed przekazaniem ich do dalszej części potoku i służy do uwierzytelniania jednostki wysyłającej żądanie (użytkownika).  
  
 W programie obsługi zdarzeń można uzyskać dostęp do tokenu za pomocą <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A?displayProperty=nameWithType> właściwości. Po zmodyfikowaniu tokenu można upewnić się, że jest on zapisywana z powrotem do pliku cookie <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.WriteSessionCookie%2A?displayProperty=nameWithType> przez ustawienie `true`właściwości na. W przeciwieństwie do <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> , zdarzenie <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> nie jest zdarzeniem, które można anulować.  
  
   
  
## Examples  
 Poniższy kod przedstawia procedurę obsługi dla <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> zdarzenia zaimplementowanego w pliku Global.asax.cs aplikacji sieci Web ASP.NET. Należy również dodać procedurę obsługi do zdarzenia. Bardziej kompletny przykład przedstawiono w <xref:System.IdentityModel.Services.SessionAuthenticationModule> temacie Omówienie.  
  
 [!code-csharp[WifSAM#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionSecurityTokenReceived">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; SessionSecurityTokenReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; SessionSecurityTokenReceived" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived" />
      <MemberSignature Language="VB.NET" Value="Public Event SessionSecurityTokenReceived As EventHandler(Of SessionSecurityTokenReceivedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::SessionSecurityTokenReceivedEventArgs ^&gt; ^ SessionSecurityTokenReceived;" />
      <MemberSignature Language="F#" Value="member this.SessionSecurityTokenReceived : EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; " Usage="member this.SessionSecurityTokenReceived : System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy token zabezpieczeń sesji został odczytany z pliku cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie jest wywoływane z <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> poziomu metody po pomyślnym odczytaniu<xref:System.IdentityModel.Tokens.SessionSecurityToken>tokenu sesji () z pliku cookie sesji. <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived>  
  
 To zdarzenie służy do modyfikowania właściwości tokenu sesji przed przekazaniem ich do dalszej części potoku i służy do uwierzytelniania jednostki wysyłającej żądanie (użytkownika). Jeden z najczęstszych scenariuszy polega na zmodyfikowaniu czasu wygaśnięcia sesji (dostępnym za <xref:System.IdentityModel.Tokens.SessionSecurityToken.ValidTo%2A?displayProperty=nameWithType> pomocą właściwości) w celu zastąpienia czasu wygaśnięcia sesji ustawionego w konfiguracji `lifetime` za pomocą atrybutu [ &lt; sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) element. Modyfikując tę właściwość dla każdego żądania, można zaimplementować sesję przesuwaną; oznacza to, że sesja, w której okres istnienia jest rozszerzany za każdym razem, gdy użytkownik uzyskuje dostęp do lokacji.  
  
 W programie obsługi zdarzeń można uzyskać dostęp do tokenu za pomocą <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.SessionToken%2A?displayProperty=nameWithType> właściwości. Po zmodyfikowaniu tokenu można upewnić się, że jest on zapisywana z powrotem do pliku cookie <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.ReissueCookie%2A?displayProperty=nameWithType> przez `true`ustawienie do. Na koniec <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs> zdarzenie jest zdarzeniem, które można anulować, i ustawić właściwość, aby przerwać dalsze przetwarzanie żądania. <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived>  
  
   
  
## Examples  
 Poniższy kod przedstawia procedurę obsługi dla <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> zdarzenia zaimplementowanego w pliku Global.asax.cs aplikacji sieci Web ASP.NET. Należy również dodać procedurę obsługi do zdarzenia. Bardziej kompletny przykład przedstawiono w <xref:System.IdentityModel.Services.SessionAuthenticationModule> temacie Omówienie.  
  
 [!code-csharp[WifSAM#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalFromSessionToken">
      <MemberSignature Language="C#" Value="protected virtual void SetPrincipalFromSessionToken (System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetPrincipalFromSessionToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.SetPrincipalFromSessionToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetPrincipalFromSessionToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionSecurityToken);" />
      <MemberSignature Language="F#" Value="abstract member SetPrincipalFromSessionToken : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit&#xA;override this.SetPrincipalFromSessionToken : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit" Usage="sessionAuthenticationModule.SetPrincipalFromSessionToken sessionSecurityToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionSecurityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionSecurityToken">Token sesji, z którego ma zostać ustawiony podmiot zabezpieczeń.</param>
        <summary>Ustawia podmiot zabezpieczeń w <see cref="T:System.Web.HttpContext" /> i <see cref="T:System.Threading.Thread" /> do podmiotu zabezpieczeń, który jest zawarty w określonym tokenie sesji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołuje metodę i <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> ustawia<xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> Właściwość oraz właściwość przy użyciu zwracanych tożsamości. <xref:System.IdentityModel.Services.SessionAuthenticationModule.ValidateSessionToken%2A>  
  
 Ta metoda jest wywoływana z <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignedOut">
      <MemberSignature Language="C#" Value="public event EventHandler SignedOut;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SignedOut" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut" />
      <MemberSignature Language="VB.NET" Value="Public Event SignedOut As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SignedOut;" />
      <MemberSignature Language="F#" Value="member this.SignedOut : EventHandler " Usage="member this.SignedOut : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po wylogowaniu się użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływane z <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metody tuż <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A> po wywołaniu metody.  
  
 To zdarzenie nie jest gwarantowane do wywołania dla każdej sesji. Na przykład pliki cookie mogą zostać usunięte po stronie klienta, w takim przypadku to zdarzenie nigdy nie zostanie wywołane, ponieważ nie istnieje zdarzenie po stronie serwera do usunięcia sesji.  
  
   
  
## Examples  
 Poniższy kod przedstawia procedurę obsługi dla <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut> zdarzenia zaimplementowanego w pliku Global.asax.cs aplikacji sieci Web ASP.NET. Należy również dodać procedurę obsługi do zdarzenia. Bardziej kompletny przykład przedstawiono w <xref:System.IdentityModel.Services.SessionAuthenticationModule> temacie Omówienie.  
  
 [!code-csharp[WifSAM#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SigningOut">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt; SigningOut;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SigningOutEventArgs&gt; SigningOut" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut" />
      <MemberSignature Language="VB.NET" Value="Public Event SigningOut As EventHandler(Of SigningOutEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::SigningOutEventArgs ^&gt; ^ SigningOut;" />
      <MemberSignature Language="F#" Value="member this.SigningOut : EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt; " Usage="member this.SigningOut : System.EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed usunięciem sesji logowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływane z <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metody tuż <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A> przed wywołaniem metody.  
  
 To zdarzenie nie jest gwarantowane do wywołania dla każdej sesji. Na przykład pliki cookie mogą zostać usunięte po stronie klienta, w takim przypadku to zdarzenie nigdy nie zostanie wywołane, ponieważ nie istnieje zdarzenie po stronie serwera do usunięcia sesji.  
  
   
  
## Examples  
 Poniższy kod przedstawia procedurę obsługi dla <xref:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut> zdarzenia zaimplementowanego w pliku Global.asax.cs aplikacji sieci Web ASP.NET. Należy również dodać procedurę obsługi do zdarzenia. Bardziej kompletny przykład przedstawiono w <xref:System.IdentityModel.Services.SessionAuthenticationModule> temacie Omówienie.  
  
 [!code-csharp[WifSAM#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignOut">
      <MemberSignature Language="C#" Value="public virtual void SignOut ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SignOut() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.SignOut" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SignOut ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SignOut();" />
      <MemberSignature Language="F#" Value="abstract member SignOut : unit -&gt; unit&#xA;override this.SignOut : unit -&gt; unit" Usage="sessionAuthenticationModule.SignOut " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Podpisuje bieżącego użytkownika i wywołuje skojarzone zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołuje metody <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSigningOut%2A>, <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A> i<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSignedOut%2A> , aby wykonać wylogowywanie. Jeśli wystąpi wyjątek, <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSignOutError%2A> Metoda jest wywoływana w celu <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> podniesienia zdarzenia. Można ustawić <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Właściwość <xref:System.IdentityModel.Services.ErrorEventArgs> obiektu przekazanego do programu obsługi zdarzeń dla tego zdarzenia, aby anulować wylogowanie i uniemożliwić propagowanie wyjątku do klienta.  
  
 Można zastąpić tę metodę, aby dodać zachowanie specyficzne dla aplikacji.  
  
   
  
## Examples  
 Poniższy kod przedstawia kod wywołujący <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metodę ze strony wylogowaniu. aspx (SignOut.aspx.cs) w aplikacji sieci Web ASP.NET. Bardziej kompletny przykład przedstawiono w <xref:System.IdentityModel.Services.SessionAuthenticationModule> temacie Omówienie.  
  
 [!code-csharp[WifSAM#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignOutError">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt; SignOutError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.ErrorEventArgs&gt; SignOutError" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError" />
      <MemberSignature Language="VB.NET" Value="Public Event SignOutError As EventHandler(Of ErrorEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::ErrorEventArgs ^&gt; ^ SignOutError;" />
      <MemberSignature Language="F#" Value="member this.SignOutError : EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt; " Usage="member this.SignOutError : System.EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wystąpi błąd podczas wylogowywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływane z <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metody w przypadku wystąpienia błędu podczas wylogowywania.  
  
 W programie obsługi zdarzeń można uzyskać wyjątek, który spowodował wywywoływanie zdarzenia z <xref:System.IdentityModel.Services.ErrorEventArgs.Exception%2A?displayProperty=nameWithType> właściwości. Można anulować dalsze przetwarzanie wyjątku, który ma wynik niepropagowania wyjątku do klienta, przez ustawienie <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> właściwości <xref:System.IdentityModel.Services.ErrorEventArgs> na `true`.  
  
 To zdarzenie nie jest gwarantowane do wywołania dla każdej sesji. Na przykład pliki cookie mogą zostać usunięte po stronie klienta, w takim przypadku to zdarzenie nigdy nie zostanie wywołane, ponieważ nie istnieje zdarzenie po stronie serwera do usunięcia sesji.  
  
   
  
## Examples  
 Poniższy kod przedstawia procedurę obsługi dla <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> zdarzenia zaimplementowanego w pliku Global.asax.cs aplikacji sieci Web ASP.NET. Należy również dodać procedurę obsługi do zdarzenia. Bardziej kompletny przykład przedstawiono w <xref:System.IdentityModel.Services.SessionAuthenticationModule> temacie Omówienie.  
  
 [!code-csharp[WifSAM#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadSessionTokenFromCookie">
      <MemberSignature Language="C#" Value="public bool TryReadSessionTokenFromCookie (out System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadSessionTokenFromCookie([out] class System.IdentityModel.Tokens.SessionSecurityToken&amp; sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie(System.IdentityModel.Tokens.SessionSecurityToken@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadSessionTokenFromCookie (ByRef sessionToken As SessionSecurityToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReadSessionTokenFromCookie([Runtime::InteropServices::Out] System::IdentityModel::Tokens::SessionSecurityToken ^ % sessionToken);" />
      <MemberSignature Language="F#" Value="member this.TryReadSessionTokenFromCookie :  -&gt; bool" Usage="sessionAuthenticationModule.TryReadSessionTokenFromCookie sessionToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" RefType="out" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Gdy ta metoda zwraca, zawiera token zabezpieczający sesji, który został odczytany z pliku cookie sesji.</param>
        <summary>Próbuje odczytać <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> z pliku cookie sesji i zwraca wartość wskazującą, czy plik cookie sesji został pomyślnie odczytany.</summary>
        <returns><see langword="true" />Jeśli plik cookie sesji został pomyślnie odczytany z żądania; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odczytuje plik cookie przy użyciu programu obsługi plików cookie, który jest skonfigurowany <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> we właściwości, a następnie <xref:System.IdentityModel.Services.SessionAuthenticationModule.ReadSessionTokenFromCookie%2A> wywołuje metodę w celu odczytania tokenu z pliku cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateSessionToken">
      <MemberSignature Language="C#" Value="protected System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateSessionToken (System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateSessionToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ValidateSessionToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateSessionToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionSecurityToken);" />
      <MemberSignature Language="F#" Value="member this.ValidateSessionToken : System.IdentityModel.Tokens.SessionSecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="sessionAuthenticationModule.ValidateSessionToken sessionSecurityToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionSecurityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionSecurityToken">Token do zweryfikowania.</param>
        <summary>Sprawdza poprawność <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> określonego i zwraca swoją tożsamość.</summary>
        <returns>Kolekcja tożsamości, które znajdują się w tokenie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana z <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> metody. Wywołuje <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%2A?displayProperty=nameWithType> ona metodę procedury obsługi tokenu skonfigurowanego do sprawdzania poprawności tokenu i wyodrębnienia jej tożsamości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Services.FederatedSessionExpiredException">Token wygasł.</exception>
        <exception cref="T:System.IdentityModel.Services.FederationException">Czas rozpoczęcia tokenu nie jest jeszcze ważny.</exception>
        <exception cref="T:System.InvalidOperationException">Nie ma skonfigurowanej prawidłowej obsługi tokenów sesji. (Nie <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> ma skonfigurowanych <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" /> właściwości).</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSessionTokenToCookie">
      <MemberSignature Language="C#" Value="public void WriteSessionTokenToCookie (System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSessionTokenToCookie(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSessionTokenToCookie (sessionToken As SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSessionTokenToCookie(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionToken);" />
      <MemberSignature Language="F#" Value="member this.WriteSessionTokenToCookie : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit" Usage="sessionAuthenticationModule.WriteSessionTokenToCookie sessionToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Token zabezpieczeń sesji do zapisu.</param>
        <summary>Zapisuje określony <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> w pliku cookie sesji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zapisuje plik cookie przy użyciu programu obsługi plików cookie, który jest skonfigurowany <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> we właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sessionToken" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie ma skonfigurowanej prawidłowej obsługi tokenów sesji. (Nie <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> ma skonfigurowanych <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" /> właściwości).</exception>
      </Docs>
    </Member>
  </Members>
</Type>

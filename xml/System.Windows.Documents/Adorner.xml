<Type Name="Adorner" FullName="System.Windows.Documents.Adorner">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a1020d7807ac3fad350977d7ae65acf5b480a9b4" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30699929" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Adorner : System.Windows.FrameworkElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Adorner extends System.Windows.FrameworkElement" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.Adorner" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Adorner&#xA;Inherits FrameworkElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class Adorner abstract : System::Windows::FrameworkElement" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Abstrakcyjna klasa, która reprezentuje <see cref="T:System.Windows.FrameworkElement" /> który decorates <see cref="T:System.Windows.UIElement" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł definiowania układu jest niestandardowy <xref:System.Windows.FrameworkElement> który jest powiązany <xref:System.Windows.UIElement>. Modułu definiowania układu kodu są renderowane w warstwie modułu definiowania układu kodu, który jest powierzchnię renderowania, który jest zawsze element element lub zbiór elementów ze zdefiniowanym; Renderowanie moduł definiowania układu jest niezależna od renderowanie <xref:System.Windows.UIElement> powiązaną moduł definiowania układu. Moduł definiowania układu zazwyczaj znajduje się względem elementu, do którego jest powiązany, przy użyciu standardowych 2-D zerowy znajduje się w lewym górnym ze zdefiniowanym elementu.  
  
> [!NOTE]
>  Element nadrzędny <xref:System.Windows.Documents.Adorner> jest <xref:System.Windows.Documents.AdornerLayer> która renderuje <xref:System.Windows.Documents.Adorner>, nie jest adorned element.  
  
> [!NOTE]
>  Niczego umieszczone w warstwie modułu definiowania układu kodu jest renderowany na górze reszty wszystkie style, które zostało ustawione. Innymi słowy modułu definiowania układu kodu są zawsze wizualnie u góry i nie można zastąpić przy użyciu porządek osi z.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.AdornerDecorator" />
    <altmember cref="T:System.Windows.Documents.AdornerLayer" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Adorner (System.Windows.UIElement adornedElement);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Windows.UIElement adornedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Adorner.#ctor(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (adornedElement As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Adorner(System::Windows::UIElement ^ adornedElement);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="adornedElement" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="adornedElement">Element można powiązać modułu definiowania układu kodu do.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Documents.Adorner" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas implementowania klasy, która dziedziczy <xref:System.Windows.Documents.Adorner>, upewnij się, że Konstruktor klasy dziedziczące wywołuje konstruktor klasy podstawowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">*adornedElement* jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AdornedElement">
      <MemberSignature Language="C#" Value="public System.Windows.UIElement AdornedElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.UIElement AdornedElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Adorner.AdornedElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AdornedElement As UIElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::UIElement ^ AdornedElement { System::Windows::UIElement ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.UIElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.UIElement" /> powiązanej z tym moduł definiowania układu kodu.</summary>
        <value>Element, który jest powiązany ten moduł definiowania układu kodu. Wartość domyślna to <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDesiredTransform">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Media.GeneralTransform GetDesiredTransform (System.Windows.Media.GeneralTransform transform);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Media.GeneralTransform GetDesiredTransform(class System.Windows.Media.GeneralTransform transform) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Adorner.GetDesiredTransform(System.Windows.Media.GeneralTransform)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDesiredTransform (transform As GeneralTransform) As GeneralTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Media::GeneralTransform ^ GetDesiredTransform(System::Windows::Media::GeneralTransform ^ transform);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transform" Type="System.Windows.Media.GeneralTransform" />
      </Parameters>
      <Docs>
        <param name="transform">Transformacja aktualnie zastosowanych do elementu ze zdefiniowanym.</param>
        <summary>Zwraca <see cref="T:System.Windows.Media.Transform" /> dla modułu definiowania układu kodu, na podstawie aktualnie zastosowanych do elementu ze zdefiniowanym transformacji.</summary>
        <returns>Przekształcenie do zastosowania do modułu definiowania układu kodu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł definiowania układu kodu może być konieczne inaczej niż element, który go decorates przekształcenia. Dla wystąpienia modułu definiowania układu kodu, które działają podobnie jak punkty, takich jak uchwyty zmiany rozmiaru, powinien być translacji obracana wraz ze zdefiniowanym elementu, a skalowania nie. Z kolei moduł definiowania układu wyświetlający ramkę w elemencie może wymagać taką samą transformację jak ze zdefiniowanym element.  
  
 Ta metoda jest wywoływana przez skojarzony <xref:System.Windows.Documents.AdornerLayer> możliwość filtrowania niechciane lub niepotrzebne transformacji. Implementacje tej metody należy zbadać przekształcenia przychodzącego (czyli transformacji dla elementu ze zdefiniowanym), a następnie usuń aspektów, które nie są przydatne lub nie powinny być stosowane do modułu definiowania układu kodu samej. Tej metody można również dodać przekształcenia dodatkowe szczegółowe informacje w tej chwili na przykład dodawanie tłumaczenie umożliwiającą modułu definiowania układu kodu kontrolować jego położenie względem elementu ze zdefiniowanym.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Adorner.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">Dostępny rozmiar udostępnione przez element.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.UIElement.GetLayoutClip(System.Windows.Size)" />.</summary>
        <returns>Potencjalne geometrii wycinka.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja zawsze zwraca `null`.  
  
 Ta metoda zastępuje <xref:System.Windows.FrameworkElement.GetLayoutClip%2A>.  
  
 Aby zapewnić, że zawsze renderowaniem najwyższego poziomu modułu definiowania układu kodu, ograniczenia wycinka są ignorowane, chyba że <xref:System.Windows.Documents.Adorner.IsClipEnabled%2A> jest `true`. Dzięki temu moduł definiowania układu kodu do renderowania poza prostokątem ze zdefiniowanym elementu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClipEnabled">
      <MemberSignature Language="C#" Value="public bool IsClipEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClipEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Adorner.IsClipEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsClipEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClipEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy włączono wycinka moduł definiowania układu.</summary>
        <value>A <see langword="Boolean" /> wartość wskazującą, czy włączono wycinka moduł definiowania układu.  
  
 Jeśli ta właściwość jest <see langword="false" />, moduł definiowania układu kodu nie zostanie obcięta.  
  
 Jeśli ta właściwość jest <see langword="true" />, moduł definiowania układu ma zostać przycięta jako element ze zdefiniowanym przy użyciu tej samej geometrii wycinka.  
  
 Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Włączanie wycinka moduł definiowania układu wiąże koszt wydajności istotne. Ogólnie rzecz biorąc można wyłączyć wycinka moduł definiowania układu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Clip" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Adorner.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Rozmiar modułu definiowania układu kodu, aby ograniczyć.</param>
        <summary>Implementuje wszelkie niestandardowe zachowanie pomiaru dla moduł definiowania układu.</summary>
        <returns>A <see cref="T:System.Windows.Size" /> obiekt reprezentujący ilość miejsca układu wymagane przez moduł definiowania układu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie moduł definiowania układu zmieni rozmiar, aby dopasować element elementu.  
  
 Ta metoda zastępuje <xref:System.Windows.FrameworkElement.MeasureOverride%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" />
      </Docs>
    </Member>
  </Members>
</Type>
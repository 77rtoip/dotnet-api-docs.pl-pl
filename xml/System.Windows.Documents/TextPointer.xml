<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ab48ea222f69e09b0b493bad6b878974e0e32ebb" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69207490" /></Metadata><TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <TypeSignature Language="F#" Value="type TextPointer = class&#xA;    inherit ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje pozycję w <see cref="T:System.Windows.Documents.FlowDocument" /> lub <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Windows.Documents.TextPointer> klasie wprowadzono następującą terminologię:  
  
-   Położenie — z <xref:System.Windows.Documents.TextPointer> natury — zawsze wskazuje na *pozycję* zawartości.  Takie pozycje mieszczą się między znakami w zawartości lub między tagami elementów zawartości przepływu, które definiują strukturę zawartości.  
  
-   Bieżąca pozycja — ponieważ <xref:System.Windows.Documents.TextPointer> zawsze wskazuje pozycję, a wiele operacji, które mogą być wykonywane <xref:System.Windows.Documents.TextPointer> w odniesieniu do położenia <xref:System.Windows.Documents.TextPointer>obecnie wskazywanego przez, warto po prostu odwołać się do Pozycja wskazywana przez <xref:System.Windows.Documents.TextPointer> element jako *Bieżąca pozycja*.  
  
-   Pozycja wstawiania — pozycja *wstawiania* jest pozycją, w której można dodać nową zawartość bez przerywania żadnych reguł semantycznych dla skojarzonej zawartości.  W tej sytuacji pozycja wstawiania jest wszędzie w zawartości, w której można umieścić karetkę.  Przykładem prawidłowej <xref:System.Windows.Documents.TextPointer> pozycji, która nie jest pozycją wstawiania, jest pozycja między dwoma sąsiednimi <xref:System.Windows.Documents.Paragraph> tagami (czyli między tagiem zamykającym poprzedniego akapitu a tagiem otwierającym następnego akapitu).  
  
-   Symbol — do celów <xref:System.Windows.Documents.TextPointer> operacji obejmujących symbole, każdy z następujących elementów jest traktowany jako *symbol*:  
  
    -   Otwierając lub zamykający tag dla <xref:System.Windows.Documents.TextElement> elementu.  
  
    -   <xref:System.Windows.UIElement> Element zawarty<xref:System.Windows.Documents.InlineUIContainer> w lub <xref:System.Windows.Documents.BlockUIContainer>.  Należy zauważyć, że <xref:System.Windows.UIElement> takie a jest zawsze zliczane jako dokładnie jeden symbol; jakakolwiek dodatkowa zawartość lub elementy zawarte <xref:System.Windows.UIElement> przez nie są zliczane jako symbole.  
  
    -   Każdy znak 16- [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] bitowy wewnątrz elementu tekstowego. <xref:System.Windows.Documents.Run>  
  
-   Kontener tekstu — *kontener tekstowy* to element, który tworzy ostatecznie obramowanie dla zawartości przepływu. Pozycja wskazywana przez <xref:System.Windows.Documents.TextPointer> zawsze znajduje się w kontenerze tekstu.  Obecnie kontener tekstu musi być <xref:System.Windows.Documents.FlowDocument> albo <xref:System.Windows.Controls.TextBlock>albo.  Ogólnie mówiąc, operacje między <xref:System.Windows.Documents.TextPointer> wystąpieniami w różnych kontenerach tekstowych nie są obsługiwane.  
  
-   Dokument — zawartość w kontenerze tekstu jest określana jako *dokument*, jak w <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> metodzie i <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> właściwościach i <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> .  
  
 Klasa jest przeznaczona do ułatwienia przechodzenia i manipulowania zawartością reprezentowaną przez [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] elementy zawartości przepływu; ogólnie rzecz biorąc, te elementy pochodzą <xref:System.Windows.Documents.TextElement>od. <xref:System.Windows.Documents.TextPointer>  Poniżej wymieniono niektóre operacje <xref:System.Windows.Documents.TextPointer> , które ułatwiają:  
  
-   Wykonaj porównanie porządkowe bieżącej pozycji z drugą określoną pozycją.  <xref:System.Windows.Documents.TextPointer.CompareTo%2A> Zobacz metodę.  
  
-   Określ typ zawartości przylegającej do bieżącej pozycji w określonym kierunku.  Zobacz metodę i <xref:System.Windows.Documents.TextPointerContext>Wyliczenie. <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A>  
  
-   <xref:System.Windows.Documents.TextElement> Pobierz te zakresy lub sąsiadująco z bieżącą pozycją.  <xref:System.Windows.Documents.Paragraph> Zobacz<xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> i metoda.  
  
-   Pobierz kontener tekstu, który ma zakresy w bieżącym dokumencie.  <xref:System.Windows.Documents.TextPointer.Parent%2A> Zobacz właściwość.  
  
-   Pobierz określoną liczbę znaków wcześniejszą lub niższą od bieżącego położenia.  <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> Zobacz metodę.  
  
-   Wstaw ciąg znaków w bieżącym położeniu.  <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> Zobacz metodę.  
  
-   Znajdź granice linii w zawartości.  Zobacz metodę i <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A>Właściwość. <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A>  
  
-   Przekształć <xref:System.Windows.Documents.TextPointer> między położeniami i przesunięciami symboli do zawartości.  Zobacz metody <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>i. <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A>  
  
-   Wykonaj testowanie trafień wizualizacji, przetłumacząc między <xref:System.Windows.Documents.TextPointer> położenie <xref:System.Windows.Point> i reprezentującą współrzędne względne.  
  
-   Znajdź w pobliżu pozycję wstawienia lub sprawdź, czy bieżące położenie jest pozycją wstawiania.  Zobacz metody <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> i <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> i<xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> właściwości.  
  
 Pozycja i <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> wskazane <xref:System.Windows.Documents.TextPointer> przez obiekt są niezmienne.  Gdy zawartość jest edytowana lub modyfikowana, pozycja wskazywana <xref:System.Windows.Documents.TextPointer> przez nie zmienia się względem otaczającego tekstu, a przesunięcie tego położenia od początku zawartości jest odpowiednio dostosowywane w celu odzwierciedlenia nowej pozycji względnej w treści.  Na przykład, <xref:System.Windows.Documents.TextPointer> który wskazuje położenie na początku danego akapitu, kontynuuje wskazywanie na początku tego akapitu nawet wtedy, gdy zawartość jest wstawiana lub usuwana przed akapitem lub po nim.  
  
 <xref:System.Windows.Documents.TextPointer> Klasa nie udostępnia żadnych konstruktorów publicznych.  Wystąpienie <xref:System.Windows.Documents.TextPointer> jest tworzone przy użyciu właściwości lub metod innych obiektów (łącznie z innymi <xref:System.Windows.Documents.TextPointer> obiektami). Poniższa lista zawiera kilka przykładów metod i właściwości, które tworzą i zwracają <xref:System.Windows.Documents.TextPointer>.  Ta lista nie jest wyczerpująca:  
  
-   <xref:System.Windows.Documents.TextRange>Z: <xref:System.Windows.Documents.TextRange.Start%2A> i. <xref:System.Windows.Documents.TextRange.End%2A>  
  
-   <xref:System.Windows.Documents.TextElement>Z: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, ,<xref:System.Windows.Documents.TextElement.ContentEnd%2A> ,i<xref:System.Windows.Documents.TextElement.ElementEnd%2A>. <xref:System.Windows.Documents.TextElement.ElementStart%2A>  
  
-   Z (kontener tekstu): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, i <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>. <xref:System.Windows.Controls.TextBlock>  
  
-   Z (kontener tekstu): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, i <xref:System.Windows.Documents.FlowDocument><xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   Z istniejących <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, ,<xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>i .<xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak użyć, <xref:System.Windows.Documents.TextPointer> aby znaleźć pozycję bezpośrednio wewnątrz pierwszego <xref:System.Windows.Documents.Run> elementu w określonym kontenerze tekstu.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 Poniższy przykład implementuje algorytm wyszukiwania uproszczony za pomocą <xref:System.Windows.Documents.TextPointer> obiektów.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.CompareTo position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">A <see cref="T:System.Windows.Documents.TextPointer" /> , która określa położenie do porównania z bieżącym położeniem.</param>
        <summary>Wykonuje porównanie porządkowe między pozycjami określonymi przez bieżącą <see cref="T:System.Windows.Documents.TextPointer" /> i <see cref="T:System.Windows.Documents.TextPointer" />sekundową wartość.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> -1 Jeśli bieżąca <paramref name="position" />poprzedza; 0, jeśli lokalizacje są takie same; + <paramref name="position" />1, jeśli bieżąca <see cref="T:System.Windows.Documents.TextPointer" /> wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość-1 wskazuje, że pozycja określona przez bieżącą <xref:System.Windows.Documents.TextPointer> poprzedza pozycję określoną przez. `position`  Wartość 0 oznacza, że wskazane pozycje są równe.  Wartość dodatnia + 1 wskazuje, że pozycja określona przez bieżącą <xref:System.Windows.Documents.TextPointer> następuje zgodnie z pozycją określoną przez. `position`  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie dla tej metody.  W przykładzie <xref:System.Windows.Documents.TextPointer.CompareTo%2A> Metoda jest używana w połączeniu z metodą, aby sprawdzić <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> , czy określony <xref:System.Windows.Documents.TextElement> element jest pusty.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="position" />Określa pozycję poza kontenerem tekstu skojarzonym z bieżącym położeniem.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberSignature Language="F#" Value="member this.DeleteTextInRun : int -&gt; int" Usage="textPointer.DeleteTextInRun count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Liczba znaków do usunięcia, rozpoczynając od bieżącego położenia. Określ wartość dodatnią, aby usunąć znaki, które są zgodne z bieżącą pozycją; Określ wartość ujemną, aby usunąć znaki poprzedzające bieżącą pozycję.</param>
        <summary>Usuwa określoną liczbę znaków z pozycji wskazywanej przez bieżące <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Liczba znaków rzeczywiście usuniętych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określ wartość dodatnią, aby usunąć znaki, które są zgodne z bieżącym położeniem (jak w programie <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>); Określ wartość ujemną, aby usunąć znaki poprzedzające bieżącą pozycję (jak w programie <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Liczba znaków faktycznie usuniętych może być mniejsza niż liczba określona przez `count`.  Dzieje się tak w przypadkach `count` , gdy określa więcej znaków niż istnieje do usunięcia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda jest wywoływana w miejscu, w którym tekst jest niedozwolony.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.TextPointer" /> Pobiera na końcu zawartości w kontenerze tekstu skojarzonym z bieżącym położeniem.</summary>
        <value><see cref="T:System.Windows.Documents.TextPointer" /> Na końcu zawartości w kontenerze tekstu skojarzonym z bieżącym położeniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextPointer> <xref:System.Windows.Controls.TextBlock> <xref:System.Windows.Documents.FlowDocument>Dla zwracanego elementu jest zawsze kontener tekstowy (lub), a nie <xref:System.Windows.Documents.TextElement>. <xref:System.Windows.Documents.TextPointer.Parent%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.TextPointer" /> Pobiera na początku zawartości w kontenerze tekstu skojarzonym z bieżącym położeniem.</summary>
        <value><see cref="T:System.Windows.Documents.TextPointer" /> Na początku zawartości w kontenerze tekstu skojarzonym z bieżącym położeniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj pozycji zwróconej przez tę właściwość jako pozycji linii bazowej, z której ma nastąpić współpraca z względnymi przesunięciami do innych pozycji.  Metody <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> i<xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> umożliwiają przetłumaczenie między położeniami i przesunięciami położenia.  
  
 <xref:System.Windows.Documents.TextPointer> <xref:System.Windows.Controls.TextBlock> <xref:System.Windows.Documents.FlowDocument>Dla zwracanego elementu jest zawsze kontener tekstowy (lub), a nie <xref:System.Windows.Documents.TextElement>. <xref:System.Windows.Documents.TextPointer.Parent%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetAdjacentElement : System.Windows.Documents.LogicalDirection -&gt; System.Windows.DependencyObject" Usage="textPointer.GetAdjacentElement direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedna z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, która określa logiczny kierunek wyszukiwania sąsiadującego elementu.</param>
        <summary>Zwraca element, jeśli istnieje, który jest obramowany jako <see cref="T:System.Windows.Documents.TextPointer" /> bieżący w określonym kierunku logicznym.</summary>
        <returns>Przyległy element w określonym <paramref name="direction" />lub <see langword="null" /> nie istnieje przyległy element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony element jest zwykle a <xref:System.Windows.Documents.TextElement>.  Można <xref:System.Windows.UIElement> zwrócić, <xref:System.Windows.Documents.TextPointer> gdy wskazujepołożenie<xref:System.Windows.Documents.InlineUIContainer> wewnątrz elementu lub elementu. <xref:System.Windows.Documents.BlockUIContainer>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetCharacterRect : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Rect" Usage="textPointer.GetCharacterRect direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedna z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, która określa logiczny kierunek, w którym ma znajdować się ramka związana z zawartością.</param>
        <summary>Zwraca pole ograniczenia (<see cref="T:System.Windows.Rect" />) dla zawartości, która jest obramowana jako bieżąca <see cref="T:System.Windows.Documents.TextPointer" /> w określonym kierunku logicznym.</summary>
        <returns>Pole ograniczające zawartość, która jest obramowana jako <see cref="T:System.Windows.Documents.TextPointer" /> bieżąca w określonym kierunku lub <see cref="P:System.Windows.Rect.Empty" /> Jeśli bieżące, prawidłowe informacje o układzie są niedostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement>krawędzie nie są uważane za zawartość na potrzeby tej metody.  Jeśli jest ustawiona <xref:System.Windows.Documents.TextElement> przed krawędzią, wartość zwracana jest polem ograniczenia<xref:System.Windows.Documents.TextElement> dla następnej niezawartości w określonym kierunku. <xref:System.Windows.Documents.TextPointer>  Jeśli w określonym kierunku nie ma żadnej zawartości, jest zwracana zerowa szerokość <xref:System.Windows.Rect> z wysokością odpowiadającą wysokości każdej poprzedniej zawartości.  
  
 Operacja wykonywana przez tę metodę zależy od prawidłowego układu.  W razie potrzeby ta metoda próbuje automatycznie ponownie wygenerować prawidłowy układ przed kontynuowaniem operacji.  Ponowne generowanie układu może być stosunkowo kosztowną operacją.  <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> Użyj właściwości, aby sprawdzić poprawność układu przed wykonaniem operacji, które mogą ponownie wygenerować układ.  Aby uzyskać więcej informacji, zobacz [Układ](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedna z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, która określa logiczny kierunek, w którym ma zostać wyszukana Najbliższa pozycja wstawiania.</param>
        <summary><see cref="T:System.Windows.Documents.TextPointer" /> Zwraca do najbliższej pozycji wstawiania w określonym kierunku logicznym.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> Do najbliższej pozycji wstawiania w określonym kierunku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycja wstawiania jest pozycją, w której można dodać nową zawartość bez przerywania żadnych reguł semantycznych dla skojarzonej zawartości.  W tej sytuacji pozycja wstawiania jest wszędzie w zawartości, w której można umieścić karetkę.  Przykładem prawidłowej <xref:System.Windows.Documents.TextPointer> pozycji, która nie jest pozycją wstawiania, jest pozycja między dwoma sąsiednimi <xref:System.Windows.Documents.Paragraph> tagami (czyli między tagiem zamykającym poprzedniego akapitu a tagiem otwierającym następnego akapitu).  
  
 Jeśli już wskazuje na prawidłową pozycję wstawienia, ale tag zamykający niepustej sekwencji formatowania bezpośrednio następuje po tej pozycji w danym kierunku, <xref:System.Windows.Documents.TextPointer> a następnie zwracany przez tę metodę jest dostosowywany do punktu wstawiania <xref:System.Windows.Documents.TextPointer> Umieść bezpośrednio po zamknięciu sekwencji formatowania. Rozważmy na przykład sekwencję `<Bold>a</Bold>b`znaczników. Należy zauważyć, że istnieją dwa położenia wstawiania `a` między literami `b` i-jeden, które poprzedza tag `Bold` zamykający, i jeden bezpośrednio po tagu `Bold` zamykającym. Jeśli <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> jest wywoływana <xref:System.Windows.Documents.TextPointer> w odniesieniu do pozycji bezpośrednio po literze `a` i przed tagiem zamykającym `Bold` oraz z `direction` <xref:System.Windows.Documents.LogicalDirection.Forward>, zwracana <xref:System.Windows.Documents.TextPointer> wartość jest dostosowywana do wskazywania Umieść tuż przed literą `b`po tagu zamykającym `Bold` . Podobne dostosowanie jest wykonywane na potrzeby otwierania tagów formatowania podczas pracy w odwrotnym kierunku logicznym. Ta metoda jest przeznaczona do zapewnienia metody rozróżnienia między położeniami wstawiania w podobnych przypadkach.  
  
 Tej metody można również użyć, aby uzyskać wybiórcze punkty wstawiania w przypadku, gdy jest używana sekwencja tagów strukturalnych. Na przykład, gdy w położeniu między tagiem zamykającym i otwierającym znaczniki akapitu można użyć parametru kierunku, aby wybrać najbliższy punkt wstawiania na początku następnego akapitu (przez określenie <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) lub na końcu poprzedniego akapitu ( przez określenie <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Jeśli wskaźnik jest już w pozycji wstawienia i nie ma żadnych sąsiednich znaczników formatowania w określonym `direction`, zwrócone <xref:System.Windows.Documents.TextPointer> punkty do tego samego położenia co wywołanie <xref:System.Windows.Documents.TextPointer>.  
  
 Jest możliwe, że nie istnieje prawidłowa pozycja wstawiania względem pozycji wskazywanej przez <xref:System.Windows.Documents.TextPointer>.  Taka sytuacja może wystąpić, jeśli przywoływana zawartość jest strukturalnie niekompletna, tak jak w przypadku pustej tabeli lub listy.  W takich przypadkach ta metoda po prostu zwraca <xref:System.Windows.Documents.TextPointer> w tym samym miejscu co metoda, <xref:System.Windows.Documents.TextPointer> z której została wywołana.  Ta metoda zawsze zwraca prawidłowy <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 Ten przykład pokazuje, <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> jak używać metody do sprawdzenia, czy określony <xref:System.Windows.Documents.TextElement> element jest pusty w zawartości do wydrukowania.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość <see cref="T:System.Windows.Documents.TextPointer" />do początku wiersza, który jest określony względem bieżącej. <see cref="T:System.Windows.Documents.TextPointer" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Liczba znaczników początkowych, które mają zostać pominięte podczas określania wiersza, dla którego ma zostać zwrócona pozycja początkowa. Wartości ujemne określają poprzednie wiersze, 0 określa bieżący wiersz, a wartości dodatnie określają następujące wiersze.</param>
        <summary>Zwraca wartość <see cref="T:System.Windows.Documents.TextPointer" />do początku wiersza, który jest określony względem bieżącej. <see cref="T:System.Windows.Documents.TextPointer" /></summary>
        <returns>Wskazuje początek określonego wiersza ( <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> z ustawionym na <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />) lub <see langword="null" /> Jeśli określony wiersz znajduje się poza zakresem lub nie można go zlokalizować. <see cref="T:System.Windows.Documents.TextPointer" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wskazuje na niejednoznaczne położenie, na przykład między dwoma wierszami, linia w kierunku określonym przez <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> jest wybierana jako względna linia początkowa. <xref:System.Windows.Documents.TextPointer>  
  
 Operacja wykonywana przez tę metodę zależy od prawidłowego układu.  W razie potrzeby ta metoda próbuje automatycznie ponownie wygenerować prawidłowy układ przed kontynuowaniem operacji.  Ponowne generowanie układu może być stosunkowo kosztowną operacją.  Użyj <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> , aby sprawdzić poprawność układu przed wykonaniem operacji, które mogą ponownie wygenerować układ.  Aby uzyskać więcej informacji, zobacz [Układ](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int *  -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition (count, actualCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">Liczba znaczników początkowych, które mają zostać pominięte podczas określania wiersza, dla którego ma zostać zwrócona pozycja początkowa. Wartości ujemne określają poprzednie wiersze, 0 określa bieżący wiersz, a wartości dodatnie określają następujące wiersze.</param>
        <param name="actualCount">Gdy ta metoda zwraca, zawiera rzeczywistą liczbę znaczników początkowych, które zostały pominięte podczas określania wiersza, dla którego ma zostać zwrócona pozycja początkowa.  Ta wartość może być mniejsza niż <paramref name="count" /> jeśli początek lub koniec zawartości zostanie osiągnięty przed pominięciem określonej liczby wierszy. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Zwraca do początku wiersza, który jest określony względem bieżącego <see cref="T:System.Windows.Documents.TextPointer" />, i zgłasza liczbę pominiętych wierszy. <see cref="T:System.Windows.Documents.TextPointer" /></summary>
        <returns>Wskazuje początek określonego wiersza ( <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> z ustawionym na <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />) lub na początek wiersza znajdującego się najbliżej określonego wiersza, jeśli określony wiersz znajduje się poza zakresem. <see cref="T:System.Windows.Documents.TextPointer" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wskazuje na niejednoznaczne położenie, na przykład między dwoma wierszami, linia w kierunku określonym <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> przez właściwość jest wybierana jako względna linia początkowa. <xref:System.Windows.Documents.TextPointer>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextContextPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextContextPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedna z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, która określa logiczny kierunek wyszukiwania następnego symbolu.</param>
        <summary>Zwraca wskaźnik do następnego symbolu w określonym kierunku logicznym.</summary>
        <returns>Do następnego symbolu w żądanym kierunku lub <see langword="null" /> Jeśli bieżące <see cref="T:System.Windows.Documents.TextPointer" /> obramowanie zaczynają się lub kończą. <see cref="T:System.Windows.Documents.TextPointer" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dowolny z następujących elementów jest traktowany jako symbol:  
  
-   Otwierając lub zamykający tag dla <xref:System.Windows.Documents.TextElement> elementu.  
  
-   <xref:System.Windows.UIElement> Element zawarty<xref:System.Windows.Documents.InlineUIContainer> w lub <xref:System.Windows.Documents.BlockUIContainer>.  Należy zauważyć, że <xref:System.Windows.UIElement> takie a jest zawsze zliczane jako dokładnie jeden symbol; jakakolwiek dodatkowa zawartość lub elementy zawarte <xref:System.Windows.UIElement> przez nie są zliczane jako symbole.  
  
-   16-bitowy [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz elementu tekstowego <xref:System.Windows.Documents.Run> .  
  
 Jeśli <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>następny symbol jest kategoryzowany jako, <xref:System.Windows.Documents.TextPointerContext.ElementStart>lub <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (zgodnie z <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> definicją przez metodę), <xref:System.Windows.Documents.TextPointer> zwracany przez tę metodę jest zaawansowany przez dokładnie jeden symbol z bieżącego położenia.  
  
 Jeśli następny symbol <xref:System.Windows.Documents.TextPointerContext.Text>jest kategoryzowany jako, <xref:System.Windows.Documents.TextPointer> a następnie zwracany przez tę metodę jest zaawansowaną wklejając tekst do następnego symbolu nietekstowego (czyli następnego położenia, gdzie <xref:System.Windows.Documents.TextPointerContext> nie <xref:System.Windows.Documents.TextPointerContext.Text>jest).  Dokładna liczba symboli przekroczenia może zostać obliczona z wyprzedzeniem <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> przez wywołanie metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie dla tej metody.  W przykładzie zastosowano <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> metodę w połączeniu <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> z metodą w celu przechodzenia i wyodrębnienia symboli w określonym <xref:System.Windows.Documents.TextElement>.  
  
 Chociaż przykład może służyć do wyodrębnienia [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] struktury zawartości danego <xref:System.Windows.Documents.TextElement>elementu, jest on przeznaczony tylko do celów informacyjnych i nie powinien być używany w kodzie produkcyjnym.  Zapoznaj <xref:System.Xml> się z przestrzenią nazw bogaty zestaw typów przeznaczony do pracy z i przetwarzania kodu XML.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedna z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości określa kierunek logiczny, w którym ma zostać wyszukana następna pozycja wstawiania.</param>
        <summary><see cref="T:System.Windows.Documents.TextPointer" /> Zwraca do następnej pozycji wstawienia w określonym kierunku logicznym.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> , który identyfikuje następną pozycję wstawienia w żądanym kierunku, <see langword="null" /> lub jeśli nie można znaleźć kolejnej pozycji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Pozycja wstawiania* jest pozycją, w której można dodać nową zawartość bez przerywania żadnych reguł semantycznych dla skojarzonej zawartości.  W tej sytuacji pozycja wstawiania jest wszędzie w zawartości, w której można umieścić karetkę.  Przykładem prawidłowej <xref:System.Windows.Documents.TextPointer> pozycji, która nie jest pozycją wstawiania, jest pozycja między dwoma sąsiednimi <xref:System.Windows.Documents.Paragraph> tagami (czyli między tagiem zamykającym poprzedniego akapitu a tagiem otwierającym następnego akapitu).  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie dla tej metody. W przykładzie zastosowano <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> metodę w celu przechodzenia przez granice elementów zawartości w celu zliczenia <xref:System.Windows.Documents.Paragraph> liczby elementów obecnych między dwoma określonymi <xref:System.Windows.Documents.TextPointer> wystąpieniami.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetOffsetToPosition : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.GetOffsetToPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">A <see cref="T:System.Windows.Documents.TextPointer" /> , która określa pozycję, aby znaleźć odległość (w symbolach) na.</param>
        <summary>Zwraca liczbę symboli między bieżącą <see cref="T:System.Windows.Documents.TextPointer" /> i drugą określoną. <see cref="T:System.Windows.Documents.TextPointer" /></summary>
        <returns>Względna liczba symboli między bieżącą <see cref="T:System.Windows.Documents.TextPointer" /> i. <paramref name="position" />  Wartość ujemna wskazuje, że bieżąca <see cref="T:System.Windows.Documents.TextPointer" /> następuje po pozycji określonej przez <paramref name="position" />, 0 wskazuje, że pozycje są równe, a wartość dodatnia wskazuje, że bieżąca <see cref="T:System.Windows.Documents.TextPointer" /> poprzedza pozycję określoną przez <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dowolny z następujących elementów jest traktowany jako symbol:  
  
-   Otwierając lub zamykający tag dla <xref:System.Windows.Documents.TextElement> elementu.  
  
-   <xref:System.Windows.UIElement> Element zawarty<xref:System.Windows.Documents.InlineUIContainer> w lub <xref:System.Windows.Documents.BlockUIContainer>.  Należy zauważyć, że <xref:System.Windows.UIElement> takie a jest zawsze zliczane jako dokładnie jeden symbol; jakakolwiek dodatkowa zawartość lub elementy zawarte <xref:System.Windows.UIElement> przez nie są zliczane jako symbole.  
  
-   16-bitowy [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz elementu tekstowego <xref:System.Windows.Documents.Run> .  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie dla tej metody. W przykładzie zastosowano <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> metodę, aby znaleźć przesunięcia dla dwóch <xref:System.Windows.Documents.TextPointer> wystąpień, a następnie za pomocą tych informacji zapisać i <xref:System.Windows.Controls.RichTextBox>przywrócić zaznaczenie w.  W przykładzie założono, że zawartość <xref:System.Windows.Controls.RichTextBox> nie zmieniła się między pozycją Zapisz i Przywróć zaznaczenie.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="position" />Określa pozycję poza kontenerem tekstu skojarzonym z bieżącym położeniem.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPointerContext : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointerContext" Usage="textPointer.GetPointerContext direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedna z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, która określa logiczny kierunek określania kategorii dla sąsiedniej zawartości.</param>
        <summary>Zwraca wskaźnik kategorii dla zawartości przylegającej do bieżącej <see cref="T:System.Windows.Documents.TextPointer" /> w określonym kierunku logicznym.</summary>
        <returns>Jedna z <see cref="T:System.Windows.Documents.TextPointerContext" /> wartości, która wskazuje kategorię dla sąsiedniej zawartości w określonym kierunku logicznym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ilustruje użycie dla tej metody. W przykładzie zastosowano <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> metodę, aby zaimplementować algorytm służący do obliczania salda otwierania i zamykania tagów elementów między dwoma <xref:System.Windows.Documents.TextPointer> określonymi pozycjami.  Każdy tag otwierającego elementu jest liczony jako + 1, a każdy zamykający tag elementu jest liczony jako-1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.TextPointer" /> Zwraca do pozycji wskazywanej przez określone przesunięcie (w symbolach) od początku zawartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">Przesunięcie w symbolach, dla których należy obliczyć i zwrócić pozycję.  Jeśli przesunięcie jest ujemne, pozycja jest obliczana w logicznym kierunku odwrotnym od wskazanego przez <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> właściwość.</param>
        <summary>Zwraca do pozycji wskazywanej przez określone przesunięcie (w symbolach) od początku bieżącego <see cref="T:System.Windows.Documents.TextPointer" />. <see cref="T:System.Windows.Documents.TextPointer" /></summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> do pozycji wskazywanej przez określone przesunięcie lub <see langword="null" /> Jeśli nie można znaleźć odpowiadającej jej pozycji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dowolny z następujących elementów jest traktowany jako symbol:  
  
-   Otwierając lub zamykający tag dla <xref:System.Windows.Documents.TextElement> elementu.  
  
-   <xref:System.Windows.UIElement> Element zawarty<xref:System.Windows.Documents.InlineUIContainer> w lub <xref:System.Windows.Documents.BlockUIContainer>.  Należy zauważyć, że <xref:System.Windows.UIElement> takie a jest zawsze zliczane jako dokładnie jeden symbol; jakakolwiek dodatkowa zawartość lub elementy zawarte <xref:System.Windows.UIElement> przez nie są zliczane jako symbole.  
  
-   16-bitowy [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz elementu tekstowego <xref:System.Windows.Documents.Run> .  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie dla tej metody. W przykładzie zastosowano <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> metodę w celu zaimplementowania pary metod, jeden do obliczenia przesunięcia do określonego położenia względem dowolnego akapitu hostingu, a drugi do <xref:System.Windows.Documents.TextPointer> zwrócenia do określonego przesunięcia w określonym akapicie.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset (offset, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">Przesunięcie w symbolach, dla których należy obliczyć i zwrócić pozycję.  Jeśli przesunięcie jest ujemne, zwrócone <see cref="T:System.Windows.Documents.TextPointer" /> poprzedza bieżące <see cref="T:System.Windows.Documents.TextPointer" />; w przeciwnym razie następuje.</param>
        <param name="direction">Jedna z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, która określa logiczny kierunek zwracanego <see cref="T:System.Windows.Documents.TextPointer" />elementu.</param>
        <summary>Zwraca do pozycji wskazywanej przez określone przesunięcie, w symbolach, od początku bieżącego <see cref="T:System.Windows.Documents.TextPointer" /> i w określonym kierunku. <see cref="T:System.Windows.Documents.TextPointer" /></summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> do pozycji wskazywanej przez określone przesunięcie lub <see langword="null" /> przesunięcie wykracza poza koniec zawartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dowolny z następujących elementów jest traktowany jako symbol:  
  
-   Otwierając lub zamykający tag dla <xref:System.Windows.Documents.TextElement> elementu.  
  
-   <xref:System.Windows.UIElement> Element zawarty<xref:System.Windows.Documents.InlineUIContainer> w lub <xref:System.Windows.Documents.BlockUIContainer>.  Należy zauważyć, że <xref:System.Windows.UIElement> takie a jest zawsze zliczane jako dokładnie jeden symbol; jakakolwiek dodatkowa zawartość lub elementy zawarte <xref:System.Windows.UIElement> przez nie są zliczane jako symbole.  
  
-   16-bitowy [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz elementu tekstowego <xref:System.Windows.Documents.Run> .  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca tekst sąsiadujący z bieżącym <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection -&gt; string" Usage="textPointer.GetTextInRun direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedna z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, która określa logiczny kierunek, w którym można znaleźć i zwrócić dowolny tekst.</param>
        <summary>Zwraca ciąg zawierający dowolny tekst przylegający do bieżącego <see cref="T:System.Windows.Documents.TextPointer" /> w określonym kierunku logicznym.</summary>
        <returns>Ciąg zawierający każdy sąsiadujący tekst w określonym kierunku logicznym lub <see cref="F:System.String.Empty" /> nie można odnaleźć sąsiadującego tekstu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca tylko nieprzerwane uruchomienia tekstu.  Wartość Nothing nie jest zwracana, jeśli dowolny typ <xref:System.Windows.Documents.TextPointerContext.Text> symboli inny niż przylegają <xref:System.Windows.Documents.TextPointer> do bieżącego w określonym kierunku.  Podobnie tekst jest zwracany tylko do następnego symbolu innego niż tekst.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie dla tej metody. W przykładzie zastosowano <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> metodę w celu zaimplementowania prostego wyodrębniania tekstu.  Metoda zwraca ciąg łączenia całego tekstu między dwoma określonymi <xref:System.Windows.Documents.TextPointer> wystąpieniami.  
  
 Przykład może służyć do wyodrębnienia dowolnego tekstu między dwoma <xref:System.Windows.Documents.TextPointer> wystąpieniami, który jest przeznaczony tylko do celów informacyjnych i nie powinien być używany w kodzie produkcyjnym.  Zamiast tego użyj właściwości. <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType>  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection * char[] * int * int -&gt; int" Usage="textPointer.GetTextInRun (direction, textBuffer, startIndex, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Jedna z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, która określa logiczny kierunek, w którym można znaleźć i skopiować dowolny tekst.</param>
        <param name="textBuffer">Bufor, do którego kopiowany jest dowolny tekst.</param>
        <param name="startIndex">Indeks, w <paramref name="textBuffer" /> którym rozpocznie się pisanie skopiowanego tekstu.</param>
        <param name="count">Maksymalna liczba znaków do skopiowania.</param>
        <summary>Kopiuje określoną maksymalną liczbę znaków z dowolnego sąsiadującego tekstu w określonym kierunku do tablicy znaków dostarczonej przez obiekt wywołujący.</summary>
        <returns>Liczba znaków rzeczywiście skopiowanych do <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca tylko nieprzerwane uruchomienia tekstu.  Wartość Nothing nie jest zwracana, jeśli dowolny typ <xref:System.Windows.Documents.TextPointerContext.Text> symboli inny niż przylegają <xref:System.Windows.Documents.TextPointer> do bieżącego w określonym kierunku.  Podobnie tekst jest zwracany tylko do następnego symbolu innego niż tekst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="startIndex" />jest mniejsza niż 0 lub większa niż <see cref="P:System.Array.Length" /> <paramref name="textBuffer" />właściwość.  
  
—lub— 
 <paramref name="count" />jest mniejsza od 0 lub większa od pozostałego miejsca <paramref name="textBuffer" /> w<paramref name="textBuffer" />(.<see cref="P:System.Array.Length" /> minus <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextRunLength : System.Windows.Documents.LogicalDirection -&gt; int" Usage="textPointer.GetTextRunLength direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedna z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, która określa logiczny kierunek, w którym należy obliczyć liczbę znaków.</param>
        <summary>Zwraca liczbę znaków Unicode między bieżącym <see cref="T:System.Windows.Documents.TextPointer" /> i następnym symbolem innym niż tekst w określonym kierunku logicznym.</summary>
        <returns>Liczba znaków Unicode między bieżącym <see cref="T:System.Windows.Documents.TextPointer" /> i następnym symbolem niebędącym tekstem.  Ta liczba może mieć wartość 0, jeśli nie ma sąsiadującego tekstu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dowolny z następujących elementów jest traktowany jako symbol:  
  
-   Otwierając lub zamykający tag dla <xref:System.Windows.Documents.TextElement> elementu.  
  
-   <xref:System.Windows.UIElement> Element zawarty<xref:System.Windows.Documents.InlineUIContainer> w lub <xref:System.Windows.Documents.BlockUIContainer>.  Należy zauważyć, że <xref:System.Windows.UIElement> takie a jest zawsze zliczane jako dokładnie jeden symbol; jakakolwiek dodatkowa zawartość lub elementy zawarte <xref:System.Windows.UIElement> przez nie są zliczane jako symbole.  
  
-   16-bitowy [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz elementu tekstowego <xref:System.Windows.Documents.Run> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidLayout : bool" Usage="System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kontener tekstu skojarzony z bieżącym położeniem ma prawidłowy układ (Aktualności).</summary>
        <value><see langword="true" />Jeśli układ jest aktualny i prawidłowy; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W razie potrzeby operacje, które są zależne od prawidłowego układu (takie <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> jak Metoda <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> , Metoda i <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> Właściwość) podejmują próbę automatycznego ponownego wygenerowania prawidłowego układu przed kontynuowaniem operacji.  Ponowne generowanie układu może być stosunkowo kosztowną operacją.  Użyj tej właściwości, aby sprawdzić poprawność układu przed wykonaniem operacji, które mogą ponownie wygenerować układ.  Aby uzyskać więcej informacji, zobacz [Układ](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertLineBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertLineBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstawia podział wiersza w bieżącym położeniu.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> Umieszczone bezpośrednio<see cref="T:System.Windows.Documents.LineBreak" /> po elemencie wstawionym przez tę metodę.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertParagraphBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertParagraphBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstawia podział akapitu w bieżącym położeniu.</summary>
        <returns>Od <see cref="T:System.Windows.Documents.TextPointer" /> A do początku (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) nowego akapitu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda jest wywoływana, gdy bieżąca pozycja znajduje się wewnątrz istniejącego <xref:System.Windows.Documents.Paragraph> elementu, istniejący akapit i jakakolwiek zawartość, którą zawiera, są podzielone na dwa akapity w bieżącym położeniu.  Jeśli ta metoda jest wywoływana, gdy bieżąca pozycja nie znajduje się w istniejącym akapicie, wstawiany jest nowy pusty akapit.  Jeśli ta metoda jest wywoływana w pozycji nieodpowiedniej do dzielenia lub wstawiania akapitu (na przykład jeśli bieżące położenie jest wewnątrz <xref:System.Windows.Documents.Hyperlink> elementu), zgłaszany jest wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta metoda jest wywoływana na pozycji, której nie można podzielić, aby pomieścić nowy akapit, taki jak zakres <see cref="T:System.Windows.Documents.Hyperlink" /> lub. <see cref="T:System.Windows.Documents.InlineUIContainer" /></exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberSignature Language="F#" Value="member this.InsertTextInRun : string -&gt; unit" Usage="textPointer.InsertTextInRun textData" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Tekst do wstawienia.</param>
        <summary>Wstawia określony tekst do tekstu <see cref="T:System.Windows.Documents.Run" /> w bieżącym położeniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element nie <xref:System.Windows.Documents.Run> `textData`jest objęty zakresem, zostanie wstawiony wraz z. <xref:System.Windows.Documents.TextPointer> <xref:System.Windows.Documents.Run>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżąca pozycja nie znajduje się w obrębie <see cref="T:System.Windows.Documents.Run" /> elementu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="textData" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtInsertionPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżąca pozycja jest pozycją wstawiania.</summary>
        <value><see langword="true" />Jeśli bieżąca pozycja jest pozycją wstawiania; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycja wstawiania jest pozycją, w której można dodać nową zawartość bez przerywania żadnych reguł semantycznych dla skojarzonej zawartości.  W tej sytuacji pozycja wstawiania jest wszędzie w zawartości, w której można umieścić karetkę.  Przykładem prawidłowej <xref:System.Windows.Documents.TextPointer> pozycji, która nie jest pozycją wstawiania, jest pozycja między dwoma sąsiednimi <xref:System.Windows.Documents.Paragraph> tagami (czyli między tagiem zamykającym poprzedniego akapitu a tagiem otwierającym następnego akapitu).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtLineStartPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące położenie jest na początku wiersza.</summary>
        <value><see langword="true" />Jeśli bieżące położenie znajduje się na początku wiersza; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wskazuje na niejednoznaczne położenie, na przykład między dwoma wierszami, linia w kierunku określonym <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> przez właściwość jest wybierana jako względna linia początkowa. <xref:System.Windows.Documents.TextPointer>  
  
 Operacja wykonywana przez tę właściwość zależy od prawidłowego układu.  W razie potrzeby ta metoda próbuje automatycznie ponownie wygenerować prawidłowy układ przed kontynuowaniem operacji.  Ponowne generowanie układu może być stosunkowo kosztowną operacją.  <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> Użyj właściwości, aby sprawdzić poprawność układu przed wykonaniem operacji, które mogą ponownie wygenerować układ.  Aby uzyskać więcej informacji, zobacz [Układ](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberSignature Language="F#" Value="member this.IsInSameDocument : System.Windows.Documents.TextPointer -&gt; bool" Usage="textPointer.IsInSameDocument textPosition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">A <see cref="T:System.Windows.Documents.TextPointer" /> , która określa położenie do porównania z bieżącym położeniem.</param>
        <summary>Wskazuje, czy określona pozycja znajduje się w tym samym kontenerze tekstu co bieżąca pozycja.</summary>
        <returns><see langword="true" />Jeśli <paramref name="textPosition" /> wskazuje pozycję znajdującą się w tym samym kontenerze tekstu co bieżąca pozycja; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość operacji obejmujących wiele <xref:System.Windows.Documents.TextPointer> wystąpień jest prawidłowa tylko wtedy, gdy wystąpienia w danym przypadku wskazują pozycje, które znajdują się w tym samym zakresie kontenera tekstu.  Na przykład <xref:System.Windows.Documents.TextPointer.CompareTo%2A> metody i <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A>niemogą być używane z dopozycjipozakonteneremtekstuskojarzonymzbieżącympołożeniem.<xref:System.Windows.Documents.TextPointer>  Użyj tej metody, aby sprawdzić, czy <xref:System.Windows.Documents.TextPointer> określony jest zgodny z bieżącą pozycją dla takich operacji.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie dla tej metody.  W przykładzie zastosowano <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> metodę, aby sprawdzić, czy <xref:System.Windows.Documents.TextPointer> określony element jest umieszczony między dwoma <xref:System.Windows.Documents.TextPointer> innymi określonymi wystąpieniami w sytuacji, gdy nie ma żadnej gwarancji, że wszystkie trzy pozycje należą do tego samego kontenera tekstu.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="textPosition" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalDirection : System.Windows.Documents.LogicalDirection" Usage="System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera logiczny kierunek skojarzony z bieżącą pozycją, która jest używana do rozróżniania zawartości skojarzonej z bieżącym położeniem.</summary>
        <value><see cref="T:System.Windows.Documents.LogicalDirection" /> Wartość, która jest skojarzona z bieżącym położeniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykładem sposobu użycia tej właściwości jest to, <xref:System.Windows.Documents.LogicalDirection> <xref:System.Windows.Documents.TextPointer> że zwracana przez metodę test trafień zawiera trafienie między dwoma znakami tekstu. Logiczny kierunek określa, które z dwóch znaków zostały faktycznie trafione — w lewo lub w prawo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Paragraph : System.Windows.Documents.Paragraph" Usage="System.Windows.Documents.TextPointer.Paragraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera akapit, który nakłada się na bieżące położenie (jeśli istnieje).</summary>
        <value>To zakresy w bieżącym położeniu lub <see langword="null" /> w przypadku, gdy taki akapit nie istnieje. <see cref="T:System.Windows.Documents.Paragraph" /></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Documents.TextPointer.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera logiczny element nadrzędny, który ma zakresy w bieżącym położeniu.</summary>
        <value>Logiczny element nadrzędny, który ma zakresy w bieżącym położeniu.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="textPointer.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ten typ lub element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczony do użycia bezpośrednio w kodzie.</summary>
        <returns>Ciąg reprezentujący obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

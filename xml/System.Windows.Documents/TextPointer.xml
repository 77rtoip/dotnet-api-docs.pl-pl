<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="80ffc4468fcd8385587be234b88e4272ca043528" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37577932" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <TypeSignature Language="F#" Value="type TextPointer = class&#xA;    inherit ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje pozycją w parametrze <see cref="T:System.Windows.Documents.FlowDocument" /> lub <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextPointer> Klasy wprowadzono następującą terminologią:  
  
-   Umieść — założenia, <xref:System.Windows.Documents.TextPointer> zawsze wskazuje *pozycji* w zawartości.  Takie pozycje, że albo można podzielić między znakami w zawartości lub przepływ zawartości elementu tagi, które definiują strukturę dla zawartości.  
  
-   Bieżące położenie — ponieważ <xref:System.Windows.Documents.TextPointer> zawsze wskazuje pozycję i dlatego wiele operacji, które mogą być wykonywane za pośrednictwem <xref:System.Windows.Documents.TextPointer> są względne wobec pozycji obecnie wskazywany przez <xref:System.Windows.Documents.TextPointer>, dobrym pomysłem będzie po prostu odwoływać się do miejscu wskazywanym przez <xref:System.Windows.Documents.TextPointer> jako *bieżącej pozycji*.  
  
-   Pozycja wstawiania — *wstawiania* pozycji, gdzie można dodać nową zawartość bez przerywania wszelkie semantycznego reguły dla skojarzonej zawartości.  W praktyce wstawiania w jest zawartość, w którym należy umieścić znak daszka.  Przykładem prawidłowego <xref:System.Windows.Documents.TextPointer> pozycji wstawiania nie jest to pozycja między dwoma sąsiadujących <xref:System.Windows.Documents.Paragraph> tagi (oznacza to, między tag zamykający w poprzednim akapicie i otwierający tag następnego akapitu).  
  
-   Symbol — na potrzeby <xref:System.Windows.Documents.TextPointer> operacji, które obejmują symbole, dowolny z następujących jest uważany za *symbol*:  
  
    -   Otwieranie lub tagu zamykającego <xref:System.Windows.Documents.TextElement> elementu.  
  
    -   A <xref:System.Windows.UIElement> zawartych w elemencie <xref:System.Windows.Documents.InlineUIContainer> lub <xref:System.Windows.Documents.BlockUIContainer>.  Pamiętaj, że takie <xref:System.Windows.UIElement> jest zawsze traktowanych jak dokładnie jeden symbol; dodatkowej zawartości lub elementy zawarte w <xref:System.Windows.UIElement> nie są liczone jako symbole.  
  
    -   Każdy 16-bitowych [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz tekstu <xref:System.Windows.Documents.Run> elementu.  
  
-   Kontener tekstu — A *kontenerze tekstu* element, który wchodzi w skład ultimate obramowanie pod ręką zawartość przepływu, a w miejscu wskazywanym przez <xref:System.Windows.Documents.TextPointer> zawsze mieści się w kontenerze tekstu.  Obecnie kontenerze tekstu musi być albo <xref:System.Windows.Documents.FlowDocument> lub <xref:System.Windows.Controls.TextBlock>.  Ogólnie rzecz biorąc, operacji między <xref:System.Windows.Documents.TextPointer> wystąpień w kontenerach inny tekst nie są obsługiwane.  
  
-   Dokument - zawartość w kontenerze tekstu jest określany jako *dokumentu*, jak w <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> metody i <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> i <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> właściwości.  
  
 <xref:System.Windows.Documents.TextPointer> Klasy ma na celu ułatwienie przechodzenia i manipulowania nimi zawartość, która jest reprezentowana przez [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] elementy zawartości przepływu; ogólnie rzecz biorąc, takie elementy pochodzić od <xref:System.Windows.Documents.TextElement>.  Niektóre operacje, które <xref:System.Windows.Documents.TextPointer> ułatwia obejmują następujące elementy:  
  
-   Wykonać porównanie porządkowe bieżącego położenia z drugiego określonej pozycji.  Zobacz <xref:System.Windows.Documents.TextPointer.CompareTo%2A> metody.  
  
-   Określ typ zawartości przylegające do bieżącego położenia w określonym kierunku.  Zobacz <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> metody i <xref:System.Windows.Documents.TextPointerContext> wyliczenia.  
  
-   Pobierz <xref:System.Windows.Documents.TextElement> , zakresów lub jest przyległa do bieżącego położenia.  Zobacz <xref:System.Windows.Documents.Paragraph> i <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> metody.  
  
-   Pobierz kontener tekst, który zakresów bieżącego dokumentu.  Zobacz <xref:System.Windows.Documents.TextPointer.Parent%2A> właściwości.  
  
-   Pobierz określoną liczbę znaków poprzedzających lub po bieżącej pozycji.  Zobacz <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> metody.  
  
-   Wstaw ciąg znaków w bieżącym położeniu.  Zobacz <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> metody.  
  
-   Znajdź wiersz granice zawartości.  Zobacz <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> metody i <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> właściwości.  
  
-   Tłumaczenie <xref:System.Windows.Documents.TextPointer> stanowiska i symbol przesunięcia do zawartości.  Zobacz <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> i <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> metody.  
  
-   Wykonaj visual testowania trafień, w miarę możliwości zamieniane między <xref:System.Windows.Documents.TextPointer> pozycji i <xref:System.Windows.Point> reprezentujący współrzędnych względnych.  
  
-   Znajdź pobliskich wstawiania lub sprawdź, czy bieżące położenie jest wstawiania.  Zobacz <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> i <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> metod i <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> właściwości.  
  
 Położenie i <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> wskazywanym przez <xref:System.Windows.Documents.TextPointer> obiektu są niezmienne.  Po edycji lub zmodyfikowane na miejscu wskazywanym przez zawartość <xref:System.Windows.Documents.TextPointer> nie zmienia względem otaczającego tekstu; raczej przesunięcie tej pozycji od samego początku zawartości jest dostosowywany odpowiednio do nowego względne położenie w zawartość.  Na przykład <xref:System.Windows.Documents.TextPointer> oznacza pozycji na początku danego akapitu w dalszym ciągu wskazują na początku tego akapitu, nawet wtedy, gdy zawartość jest wstawionych lub usuniętych przed lub po akapitu.  
  
 <xref:System.Windows.Documents.TextPointer> Klasa nie zapewnia żadnych konstruktorów publicznych.  Wystąpienie <xref:System.Windows.Documents.TextPointer> jest tworzona przy użyciu właściwości lub metody innych obiektów (włączając inne <xref:System.Windows.Documents.TextPointer> obiektów). Poniższa lista zawiera kilka przykładów metod i właściwości, które umożliwiają tworzenie i zwracać <xref:System.Windows.Documents.TextPointer>.  Ta lista nie jest wyczerpująca:  
  
-   Z <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> i <xref:System.Windows.Documents.TextRange.End%2A>.  
  
-   Z <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, i <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   Z <xref:System.Windows.Controls.TextBlock> (kontener tekst): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, i <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.  
  
-   Z <xref:System.Windows.Documents.FlowDocument> (kontener tekst): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, i <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   Z istniejącego <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, i <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Windows.Documents.TextPointer> można znaleźć położenie tylko wewnątrz pierwszy <xref:System.Windows.Documents.Run> elementu w kontenerze określony tekst.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 Poniższy przykład implementuje algorytm uproszczony wyszukiwanie przy użyciu <xref:System.Windows.Documents.TextPointer> urządzenia.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.CompareTo position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Element <see cref="T:System.Windows.Documents.TextPointer" /> , który określa pozycję do porównania z bieżącym położeniu.</param>
        <summary>Wykonuje porównanie porządkowe między położeniami, określony przez bieżącą <see cref="T:System.Windows.Documents.TextPointer" /> i drugi określony <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>– 1, jeśli bieżący <see cref="T:System.Windows.Documents.TextPointer" /> poprzedza <paramref name="position" />; 0, jeśli lokalizacje są takie same; + 1, jeśli bieżący <see cref="T:System.Windows.Documents.TextPointer" /> następuje <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość -1 wskazuje, że pozycja określony przez bieżącą <xref:System.Windows.Documents.TextPointer> poprzedza pozycji określonej przez `position`.  Wartość 0 wskazuje, że wskazany pozycje są równe.  Wartość dodatnią + 1 wskazuje, że pozycja określony przez bieżącą <xref:System.Windows.Documents.TextPointer> poniżej pozycji określonej przez `position`.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tej metody.  W tym przykładzie <xref:System.Windows.Documents.TextPointer.CompareTo%2A> metoda jest używana w połączeniu z <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> metodę, aby sprawdzić, czy określony <xref:System.Windows.Documents.TextElement> jest pusty.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> Określa położenie poza kontenerem tekst skojarzony z bieżącym położeniu.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberSignature Language="F#" Value="member this.DeleteTextInRun : int -&gt; int" Usage="textPointer.DeleteTextInRun count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Liczba znaków do usunięcia, zaczynając od bieżącej pozycji. Określ wartość dodatnią, aby usunąć znaki, które należy wykonać bieżącej pozycji; Określ wartość ujemną, aby usunąć znaki, które poprzedzają dopasowanie bieżącej pozycji.</param>
        <summary>Usuwa określoną liczbę znaków od pozycji wskazywanym przez bieżącego <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Liczba znaków rzeczywiście zostały usunięte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określ wartość dodatnią, aby usunąć znaki, które należy wykonać bieżącej pozycji (podobnie jak w <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>); określ wartość ujemną, aby usunąć znaki, które poprzedzają dopasowanie bieżącego położenia (podobnie jak w <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Liczba znaków rzeczywiście zostały usunięte, może być mniejsza niż liczba określona przez `count`.  Dzieje się tak w przypadku których `count` określa więcej znaków niż istnieje do usunięcia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda jest wywoływana w miejscu, w którym tekst jest niedozwolony.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Documents.TextPointer" /> na końcu zawartość w kontenerze tekst skojarzony z bieżącym położeniu.</summary>
        <value>A <see cref="T:System.Windows.Documents.TextPointer" /> na końcu zawartość w kontenerze tekst skojarzony z bieżącym położeniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextPointer.Parent%2A> Dla zwracanego <xref:System.Windows.Documents.TextPointer> zawsze jest kontenerem tekstu (<xref:System.Windows.Controls.TextBlock> lub <xref:System.Windows.Documents.FlowDocument>), a nie <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Documents.TextPointer" /> na początku zawartość w kontenerze tekst skojarzony z bieżącym położeniu.</summary>
        <value>A <see cref="T:System.Windows.Documents.TextPointer" /> na początku zawartość w kontenerze tekst skojarzony z bieżącym położeniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj pozycji zwracane przez tę właściwość jako pozycja linii bazowej, w którym chcesz pracować z przesunięcia względną do innych pozycji.  <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> i <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> metody umożliwiają tłumaczenie między położeniami i pozycji przesunięcia.  
  
 <xref:System.Windows.Documents.TextPointer.Parent%2A> Dla zwracanego <xref:System.Windows.Documents.TextPointer> zawsze jest kontenerem tekstu (<xref:System.Windows.Controls.TextBlock> lub <xref:System.Windows.Documents.FlowDocument>), a nie <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetAdjacentElement : System.Windows.Documents.LogicalDirection -&gt; System.Windows.DependencyObject" Usage="textPointer.GetAdjacentElement direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedną z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logiczny kierunek, w których należy szukać sąsiadujących elementu.</param>
        <summary>Zwraca element, jeśli obramowania bieżącego <see cref="T:System.Windows.Documents.TextPointer" /> w określonym kierunku logiczne.</summary>
        <returns>Sąsiadująco elementu w określonym <paramref name="direction" />, lub <see langword="null" /> Jeśli element sąsiadujące, nie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony element jest zwykle <xref:System.Windows.Documents.TextElement>.  A <xref:System.Windows.UIElement> mogą być zwracane podczas <xref:System.Windows.Documents.TextPointer> wskazuje pozycję wewnątrz <xref:System.Windows.Documents.BlockUIContainer> element lub <xref:System.Windows.Documents.InlineUIContainer> elementu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetCharacterRect : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Rect" Usage="textPointer.GetCharacterRect direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedną z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logiczne kierunek, w którym można znaleźć zawartości, pole ograniczenia.</param>
        <summary>Zwraca obwiedni (<see cref="T:System.Windows.Rect" />) dla zawartości, która obramowania bieżącego <see cref="T:System.Windows.Documents.TextPointer" /> w określonym kierunku logiczne.</summary>
        <returns>Obwiedni zawartości ograniczająca bieżącego <see cref="T:System.Windows.Documents.TextPointer" /> w określonym kierunku lub <see cref="P:System.Windows.Rect.Empty" /> Jeśli bieżąca, informacji o układzie prawidłowe jest niedostępny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> krawędzie nie są uważane za zawartość na potrzeby tej metody.  Jeśli <xref:System.Windows.Documents.TextPointer> jest umieszczony przed <xref:System.Windows.Documents.TextElement> krawędzi, wartość zwracana jest obwiednią Następna non -<xref:System.Windows.Documents.TextElement> zawartość w określonym kierunku.  Jeśli nie istnieje żadna zawartość w określonym kierunku zerowej szerokości <xref:System.Windows.Rect> jest zwracany za pomocą wysokości dopasowania wysokość wszelkich poprzednich zawartości.  
  
 Operacja wykonana przez tę metodę jest zależna od układu prawidłowe.  Gdy jest to konieczne, ta metoda próbuje automatycznie Generuj układ prawidłowe przed wykonaniem operacji.  Trwa ponowne generowanie układu może być stosunkowo kosztowną operacją.  Użyj <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> właściwość do sprawdzenia układu prawidłowe przed wykonaniem operacji, które może wygenerować ponownie układ.  Aby uzyskać więcej informacji, zobacz [układ](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedną z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logiczny kierunek, w których należy szukać najbliższego wstawiania.</param>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> do najbliższego wstawiania w określonym kierunku logiczne.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> do najbliższego wstawiania w określonym kierunku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wstawianie jest to pozycja, gdzie można dodać nową zawartość bez przerywania wszelkie semantycznego reguły dla skojarzonej zawartości.  W praktyce wstawiania w jest zawartość, w którym należy umieścić znak daszka.  Przykładem prawidłowego <xref:System.Windows.Documents.TextPointer> pozycji wstawiania nie jest to pozycja między dwoma sąsiadujących <xref:System.Windows.Documents.Paragraph> tagi (oznacza to, między tag zamykający w poprzednim akapicie i otwierający tag następnego akapitu).  
  
 Jeśli <xref:System.Windows.Documents.TextPointer> już wskazuje prawidłowy wstawiania, lecz tag zamykający dla niepustej sekwencji formatowania następuje bezpośrednio po tej pozycji w określonym kierunku, a następnie <xref:System.Windows.Documents.TextPointer> zwróconych przez to metoda jest dostosowywana do wskaż wstawiania Umieść zaraz po zamknięciu formatowania sekwencji. Na przykład, należy wziąć pod uwagę sekwencji znaczników `<Bold>a</Bold>b`. Należy pamiętać, że nie istnieją dwie pozycje wstawiania między literami `a` i `b` — taki, który poprzedza zamykającym `Bold` tag i jeden bezpośrednio po zamykającym `Bold` tagu. Jeśli <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> jest wywoływana w <xref:System.Windows.Documents.TextPointer> miejsce bezpośrednio po literę `a` i przed zamknięcia `Bold` tagu i `direction` z <xref:System.Windows.Documents.LogicalDirection.Forward>, zwrócony <xref:System.Windows.Documents.TextPointer> jest uwzględniany, aby wskazywał Pozycja tuż przed literę `b`, po upływie `Bold` tagu. Podobnie jest korekty otwierania tagi formatowania podczas pracy w odwrotnym kierunku logiczne. Ta metoda jest przeznaczona do umożliwiają rozróżniania między pozycje wstawiania w podobnych przypadków.  
  
 Ta metoda może również być selektywnie punkty wstawienia, gdy uczestniczy sekwencję znaczniki strukturalnych. Na przykład, gdy pozycja między zamykania i otwarcia tagów akapitu, parametr kierunku może służyć do wybierz najbliższy punkt wstawiania na początku następujący akapit (przez określenie <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) lub na końcu poprzedniego (akapitu określając <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Jeśli kursor znajduje się już na pozycji wstawiania i nie ma żadnych sąsiadujących znaczników formatowania w określonym `direction`, zwrócony <xref:System.Windows.Documents.TextPointer> wskazuje na tym samym miejscu wywołania <xref:System.Windows.Documents.TextPointer>.  
  
 Istnieje możliwość, czy nie prawidłowy wstawiania istnieje względem pozycji wskazywanej przez <xref:System.Windows.Documents.TextPointer>.  Może to nastąpić, jeśli przywoływany zawartość jest strukturalnie ukończona, tak jak w pustej tabeli lub listy.  W takich przypadkach, ta metoda po prostu zwraca <xref:System.Windows.Documents.TextPointer> na tym samym położeniu co <xref:System.Windows.Documents.TextPointer> z której ta metoda została wywołana.  Ta metoda zawsze zwraca prawidłową <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 W tym przykładzie pokazano, jak używać <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> metodę, aby sprawdzić, czy określony <xref:System.Windows.Documents.TextElement> jest pusty drukowalnych zawartości.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> do początku wiersza, który jest określony względem bieżącego <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Liczba znaczników rozpoczęcia wiersza do pominięcia podczas określania wiersza, dla której ma zostać zwrócone pozycja początkowa. Wartości ujemne Określ poprzednich wierszy, 0 określa bieżący wiersz i wartości dodatnich, określ następujące wiersze.</param>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> do początku wiersza, który jest określony względem bieżącego <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> wskazujące na początku określonego wiersza (przy użyciu <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> równa <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), lub <see langword="null" /> czy określonego wiersza znajduje się poza zakresem w przeciwnym razie nie można odnaleźć.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Documents.TextPointer> wskazuje niejednoznacznego położenia, na przykład między dwoma liniami wiersza w kierunku określony przez <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> jest wybrany jako względną wiersza początkowego.  
  
 Operacja wykonana przez tę metodę jest zależna od układu prawidłowe.  Gdy jest to konieczne, ta metoda próbuje automatycznie Generuj układ prawidłowe przed wykonaniem operacji.  Trwa ponowne generowanie układu może być stosunkowo kosztowną operacją.  Użyj <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> pod kątem układ prawidłowe przed wykonaniem operacji, które może wygenerować ponownie układ.  Aby uzyskać więcej informacji, zobacz [układ](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int *  -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition (count, actualCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">Liczba znaczników rozpoczęcia wiersza do pominięcia podczas określania wiersza, dla której ma zostać zwrócone pozycja początkowa. Wartości ujemne Określ poprzednich wierszy, 0 określa bieżący wiersz i wartości dodatnich, określ następujące wiersze.</param>
        <param name="actualCount">Po powrocie z tej metody zawiera aktualną liczbę znaczniki początek wiersza, które zostały pominięte podczas określania wiersza, dla której ma zostać zwrócone pozycja początkowa.  Ta wartość może być mniejsza niż <c>liczba</c> Jeśli początek lub koniec zawartości występuje przed określoną liczbę wierszy jest pomijane. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> do początku wiersza, który jest określony względem bieżącego <see cref="T:System.Windows.Documents.TextPointer" />i zgłasza, ile wierszy zostały pominięte.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> wskazujące na początku określonego wiersza (przy użyciu <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> równa <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), lub do początku wiersza najbardziej zbliżony do określonego wiersza, jeśli określony wiersz jest poza zakresem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Documents.TextPointer> wskazuje niejednoznacznego położenia, na przykład między dwoma liniami wiersza w kierunku określony przez <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> właściwość jest wybrany jako względną wiersza początkowego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextContextPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextContextPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedną z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logiczny kierunek, w których należy szukać następny symbol.</param>
        <summary>Zwraca wskaźnik do następny symbol w określonym kierunku logiczne.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> na następny symbol w kierunku żądanej lub <see langword="null" /> Jeśli bieżące <see cref="T:System.Windows.Documents.TextPointer" /> obramowania początek lub koniec zawartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednym z następujących jest uważany za symbol:  
  
-   Otwieranie lub tagu zamykającego <xref:System.Windows.Documents.TextElement> elementu.  
  
-   A <xref:System.Windows.UIElement> elementów znajdujących się w <xref:System.Windows.Documents.InlineUIContainer> lub <xref:System.Windows.Documents.BlockUIContainer>.  Pamiętaj, że takie <xref:System.Windows.UIElement> jest zawsze traktowanych jak dokładnie jeden symbol; dodatkowej zawartości lub elementy zawarte w <xref:System.Windows.UIElement> nie są liczone jako symbole.  
  
-   16-bitowych [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz tekstu <xref:System.Windows.Documents.Run> elementu.  
  
 Jeśli następny symbol należą do kategorii <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, lub <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (identyfikowanego przez <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> metoda), a następnie <xref:System.Windows.Documents.TextPointer> zwróconych przez to metoda jest zaawansowany symbolem dokładnie jeden z bieżącego położenia.  
  
 Jeśli następny symbol należą do kategorii <xref:System.Windows.Documents.TextPointerContext.Text>, a następnie <xref:System.Windows.Documents.TextPointer> zwróconych przez to metoda jest zaawansowany ostatnie tekst na następny symbol-text (czyli następnej pozycji gdzie <xref:System.Windows.Documents.TextPointerContext> nie jest <xref:System.Windows.Documents.TextPointerContext.Text>).  Liczba dokładnie symbol progów można obliczyć z wyprzedzeniem, wywołując <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tej metody.  W przykładzie użyto <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> metody w połączeniu z <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> metody przechodzenia i wyodrębniać symbole w określonej <xref:System.Windows.Documents.TextElement>.  
  
 Przykład można zastosować do wyodrębnienia [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] struktury zawartość danego <xref:System.Windows.Documents.TextElement>, jest przeznaczona wyłącznie w celach ilustracyjnych i nie należy używać w kodzie produkcyjnym.  Zobacz <xref:System.Xml> przestrzeni nazw bogaty zestaw typów, zaprojektowana pod kątem pracy z i przetwarzania XML.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedną z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logiczny kierunek, w których należy szukać następnej pozycji wstawiania.</param>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> do następnej pozycji wstawiania w określonym kierunku logiczne.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> określający dalej wstawiania w kierunku żądanej lub <see langword="null" /> Jeśli można znaleźć nie następnej pozycji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Wstawiania* pozycji, gdzie można dodać nową zawartość bez przerywania wszelkie semantycznego reguły dla skojarzonej zawartości.  W praktyce wstawiania w jest zawartość, w którym należy umieścić znak daszka.  Przykładem prawidłowego <xref:System.Windows.Documents.TextPointer> pozycji wstawiania nie jest to pozycja między dwoma sąsiadujących <xref:System.Windows.Documents.Paragraph> tagi (oznacza to, między tag zamykający w poprzednim akapicie i otwierający tag następnego akapitu).  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tej metody. W przykładzie użyto <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> metodę, aby przechodzić przez granice elementu zawartości, aby można było policzyć liczbę <xref:System.Windows.Documents.Paragraph> elementów istnieje między dwoma określony <xref:System.Windows.Documents.TextPointer> wystąpień.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetOffsetToPosition : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.GetOffsetToPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">A <see cref="T:System.Windows.Documents.TextPointer" /> Określa, w stanie znaleźć odległość (w symbole).</param>
        <summary>Zwraca liczbę symboli między bieżącą <see cref="T:System.Windows.Documents.TextPointer" /> i drugi określony <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Względna liczbę symboli między bieżącą <see cref="T:System.Windows.Documents.TextPointer" /> i <paramref name="position" />.  Ujemna wartość oznacza, że bieżący <see cref="T:System.Windows.Documents.TextPointer" /> poniżej pozycji określonej przez <paramref name="position" />, 0 wskazuje, że położenie są takie same, a wartość dodatnia wskazuje, że bieżący <see cref="T:System.Windows.Documents.TextPointer" /> poprzedza w położeniu wskazanym przez <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednym z następujących jest uważany za symbol:  
  
-   Otwieranie lub tagu zamykającego <xref:System.Windows.Documents.TextElement> elementu.  
  
-   A <xref:System.Windows.UIElement> elementów znajdujących się w <xref:System.Windows.Documents.InlineUIContainer> lub <xref:System.Windows.Documents.BlockUIContainer>.  Pamiętaj, że takie <xref:System.Windows.UIElement> jest zawsze traktowanych jak dokładnie jeden symbol; dodatkowej zawartości lub elementy zawarte w <xref:System.Windows.UIElement> nie są liczone jako symbole.  
  
-   16-bitowych [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz tekstu <xref:System.Windows.Documents.Run> elementu.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tej metody. W przykładzie użyto <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> metody do znalezienia przesunięcia dwóch <xref:System.Windows.Documents.TextPointer> wystąpień, a następnie używa tych informacji do zapisywania i przywracania zaznaczenie w <xref:System.Windows.Controls.RichTextBox>.  W przykładzie założono, że zawartość <xref:System.Windows.Controls.RichTextBox> nie uległy zmianie między wybór zapisywanie i przywracanie zaznaczenia.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> Określa położenie poza kontenerem tekst skojarzony z bieżącym położeniu.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPointerContext : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointerContext" Usage="textPointer.GetPointerContext direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedną z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logiczny kierunek, w którym do określenia kategorii sąsiadujących zawartości.</param>
        <summary>Zwraca wskaźnik kategorii dla zawartości przylegające do bieżącego <see cref="T:System.Windows.Documents.TextPointer" /> w określonym kierunku logiczne.</summary>
        <returns>Jedną z <see cref="T:System.Windows.Documents.TextPointerContext" /> wartości, które wskazuje, że kategoria sąsiadujących zawartości w określonym kierunku logiczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład demonstruje użycie tej metody. W przykładzie użyto <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> metody do zaimplementowania algorytm obliczania saldo otwierające i zamykające znaczniki elementów między dwoma określony <xref:System.Windows.Documents.TextPointer> pozycji.  Każdy element tagu początkowego jest traktowana jako + 1, a każdy element tag zamykający są traktowane jako -1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> pozycji wskazywanym przez określonego przesunięcia, w symbolach, od początku elementu zawartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">Przesunięcie w symbolach, dla którego jest obliczana i wrócić położenie.  Jeśli przesunięcie jest ujemna, pozycja jest obliczana w kierunku logiczne przeciwne wskazaną przez <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> właściwości.</param>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> pozycji wskazywanym przez określonego przesunięcia, w symbolach, od początku bieżącego <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> pozycji wskazywanym przez określonego przesunięcia lub <see langword="null" /> Jeśli można znaleźć nie odpowiedniej pozycji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednym z następujących jest uważany za symbol:  
  
-   Otwieranie lub tagu zamykającego <xref:System.Windows.Documents.TextElement> elementu.  
  
-   A <xref:System.Windows.UIElement> elementów znajdujących się w <xref:System.Windows.Documents.InlineUIContainer> lub <xref:System.Windows.Documents.BlockUIContainer>.  Pamiętaj, że takie <xref:System.Windows.UIElement> jest zawsze traktowanych jak dokładnie jeden symbol; dodatkowej zawartości lub elementy zawarte w <xref:System.Windows.UIElement> nie są liczone jako symbole.  
  
-   16-bitowych [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz tekstu <xref:System.Windows.Documents.Run> elementu.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tej metody. W przykładzie użyto <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> metody do zaimplementowania pary metod, jednego do obliczania przesunięcie do określonej pozycji względem dowolnego hostingu akapitu, a druga do zwrócenia <xref:System.Windows.Documents.TextPointer> do określonego przesunięcia w określonym akapicie.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset (offset, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">Przesunięcie w symbolach, dla którego jest obliczana i wrócić położenie.  Jeśli przesunięcie jest ujemna, zwrócony <see cref="T:System.Windows.Documents.TextPointer" /> poprzedza bieżącego <see cref="T:System.Windows.Documents.TextPointer" />; w przeciwnym razie jest zgodna.</param>
        <param name="direction">Jedną z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa kierunek logiczne zwracanego <see cref="T:System.Windows.Documents.TextPointer" />.</param>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> pozycji wskazywanym przez określonego przesunięcia, w symbolach, od początku bieżącego <see cref="T:System.Windows.Documents.TextPointer" /> w określonym kierunku.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> pozycji wskazywanym przez określonego przesunięcia lub <see langword="null" /> Jeśli przesunięcie wykracza poza koniec zawartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednym z następujących jest uważany za symbol:  
  
-   Otwieranie lub tagu zamykającego <xref:System.Windows.Documents.TextElement> elementu.  
  
-   A <xref:System.Windows.UIElement> elementów znajdujących się w <xref:System.Windows.Documents.InlineUIContainer> lub <xref:System.Windows.Documents.BlockUIContainer>.  Pamiętaj, że takie <xref:System.Windows.UIElement> jest zawsze traktowanych jak dokładnie jeden symbol; dodatkowej zawartości lub elementy zawarte w <xref:System.Windows.UIElement> nie są liczone jako symbole.  
  
-   16-bitowych [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz tekstu <xref:System.Windows.Documents.Run> elementu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca tekst przylegające do bieżącego <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection -&gt; string" Usage="textPointer.GetTextInRun direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedną z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logiczny kierunek, w którym można znaleźć i wszelkich sąsiadujących tekst zwrotny.</param>
        <summary>Zwraca ciąg zawierający tekstem do bieżącego <see cref="T:System.Windows.Documents.TextPointer" /> w określonym kierunku logiczne.</summary>
        <returns>Ciąg zawierający sąsiadujących tekst w określonym kierunku logiczne, lub <see cref="F:System.String.Empty" /> Jeśli można znaleźć nie tekstem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta zwraca tylko niezakłócony przebiegów tekstu.  Nic nie zostanie zwrócone, jeśli dowolny symbol typu innego niż <xref:System.Windows.Documents.TextPointerContext.Text> jest przyległa do bieżącego <xref:System.Windows.Documents.TextPointer> w określonym kierunku.  Podobnie tekst zwracany jest tylko do następny symbol-text.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tej metody. W przykładzie użyto <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> metody do zaimplementowania ekstraktor zwykłego tekstu.  Metoda ta zwraca ciągów cały tekst pomiędzy dwoma określony <xref:System.Windows.Documents.TextPointer> wystąpień.  
  
 Przykład można zastosować do wyodrębnienia dowolny tekst pomiędzy dwoma <xref:System.Windows.Documents.TextPointer> wystąpień, jego jest przeznaczona wyłącznie w celach ilustracyjnych i nie należy używać w kodzie produkcyjnym.  Użyj <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType> właściwości zamiast tego.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection * char[] * int * int -&gt; int" Usage="textPointer.GetTextInRun (direction, textBuffer, startIndex, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Jedną z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logiczny kierunek, w którym można znaleźć i skopiować wszelkich sąsiadujących tekst.</param>
        <param name="textBuffer">Bufor, do którego są kopiowane dowolny tekst.</param>
        <param name="startIndex">Indeks <c>textBuffer</c> od którego należy rozpocząć pisanie skopiowany tekst.</param>
        <param name="count">Maksymalna liczba znaków do skopiowania.</param>
        <summary>Kopiuje określoną maksymalną liczbę znaków z wszelkich sąsiadujących tekst w określonym kierunku do tablicy znaków dostarczonych przez obiekt wywołujący.</summary>
        <returns>Liczba znaków rzeczywiście zostały skopiowane do <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta zwraca tylko niezakłócony przebiegów tekstu.  Nic nie zostanie zwrócone, jeśli dowolny symbol typu innego niż <xref:System.Windows.Documents.TextPointerContext.Text> jest przyległa do bieżącego <xref:System.Windows.Documents.TextPointer> w określonym kierunku.  Podobnie tekst zwracany jest tylko do następny symbol-text.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> jest mniejsza niż 0 lub większa niż <see cref="P:System.Array.Length" /> właściwość <paramref name="textBuffer" />.  - lub - <paramref name="count" /> jest mniejszy niż 0 lub większy niż pozostałe miejsce w <paramref name="textBuffer" /> (<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> minus <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextRunLength : System.Windows.Documents.LogicalDirection -&gt; int" Usage="textPointer.GetTextRunLength direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jedną z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logiczny kierunek, w którym można określić liczbę znaków.</param>
        <summary>Zwraca liczbę znaków Unicode z zakresu od bieżącego <see cref="T:System.Windows.Documents.TextPointer" /> i następny symbol nietekstowych w określonym kierunku logiczne.</summary>
        <returns>Liczba znaków Unicode od bieżącego <see cref="T:System.Windows.Documents.TextPointer" /> i następny symbol-text.  Ta liczba może być 0, jeśli nie ma żadnego sąsiadujących tekstu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednym z następujących jest uważany za symbol:  
  
-   Otwieranie lub tagu zamykającego <xref:System.Windows.Documents.TextElement> elementu.  
  
-   A <xref:System.Windows.UIElement> elementów znajdujących się w <xref:System.Windows.Documents.InlineUIContainer> lub <xref:System.Windows.Documents.BlockUIContainer>.  Pamiętaj, że takie <xref:System.Windows.UIElement> jest zawsze traktowanych jak dokładnie jeden symbol; dodatkowej zawartości lub elementy zawarte w <xref:System.Windows.UIElement> nie są liczone jako symbole.  
  
-   16-bitowych [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz tekstu <xref:System.Windows.Documents.Run> elementu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidLayout : bool" Usage="System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kontener tekst skojarzony z bieżącą pozycję ma prawidłową układ (aktualna).</summary>
        <value>
          <see langword="true" /> Jeśli układ jest aktualne i prawidłowe; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy jest to konieczne, operacje, które są zależne od układu prawidłowy (takich jak <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> metody, <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> metody, i <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> właściwości) próbować automatycznie Generuj układ prawidłowe przed wykonaniem operacji.  Trwa ponowne generowanie układu może być stosunkowo kosztowną operacją.  Ta właściwość służy do sprawdzania układu prawidłowy przed przystąpieniem do wykonywania operacji, które może wygenerować ponownie układ.  Aby uzyskać więcej informacji, zobacz [układ](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertLineBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertLineBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstawia podział wiersza w bieżącym położeniu.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> pozycjonowane natychmiast po <see cref="T:System.Windows.Documents.LineBreak" /> element wstawiony przez tę metodę.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertParagraphBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertParagraphBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstawia podział akapitu w bieżącym położeniu.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> na początku (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) z nowy akapit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda jest wywoływana, gdy bieżąca pozycja jest wewnątrz istniejącego <xref:System.Windows.Documents.Paragraph> elementu, akapitu istniejących oraz zawartość zawiera są podzielone na dwie akapitów w bieżącym położeniu.  Jeśli ta metoda jest wywoływana, gdy bieżąca pozycja nie znajduje się wewnątrz istniejącego akapitu, dodaje się nową, pustą akapitu.  Jeśli ta metoda jest wywoływana w położeniu nie nadaje się do podziału lub wstawianie akapitu (na przykład, jeśli bieżące położenie jest wewnątrz <xref:System.Windows.Documents.Hyperlink> element), zgłaszany jest wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta metoda jest wywoływana w pozycji nie będzie można podzielić, aby pomieścić nowy akapit, takie jak w zakresie <see cref="T:System.Windows.Documents.Hyperlink" /> lub <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberSignature Language="F#" Value="member this.InsertTextInRun : string -&gt; unit" Usage="textPointer.InsertTextInRun textData" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Tekst do wstawienia.</param>
        <summary>Wstawia określony tekst do tekstu <see cref="T:System.Windows.Documents.Run" /> w bieżącym położeniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Documents.TextPointer> nie jest objęte zakresem <xref:System.Windows.Documents.Run> elementu <xref:System.Windows.Documents.Run> dodaje się wraz z `textData`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżąca pozycja nie znajduje się w ramach <see cref="T:System.Windows.Documents.Run" /> elementu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textData" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtInsertionPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące położenie jest wstawiania.</summary>
        <value>
          <see langword="true" /> Jeśli bieżące położenie jest wstawiania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wstawianie jest to pozycja, gdzie można dodać nową zawartość bez przerywania wszelkie semantycznego reguły dla skojarzonej zawartości.  W praktyce wstawiania w jest zawartość, w którym należy umieścić znak daszka.  Przykładem prawidłowego <xref:System.Windows.Documents.TextPointer> pozycji wstawiania nie jest to pozycja między dwoma sąsiadujących <xref:System.Windows.Documents.Paragraph> tagi (oznacza to, między tag zamykający w poprzednim akapicie i otwierający tag następnego akapitu).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtLineStartPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące położenie jest na początku wiersza.</summary>
        <value>
          <see langword="true" /> Jeśli bieżące położenie jest na początku wiersza; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Documents.TextPointer> wskazuje niejednoznacznego położenia, na przykład między dwoma liniami wiersza w kierunku określony przez <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> właściwość jest wybrany jako względną wiersza początkowego.  
  
 Operacja wykonywana przez tę właściwość zależy od układ prawidłowe.  Gdy jest to konieczne, ta metoda próbuje automatycznie Generuj układ prawidłowe przed wykonaniem operacji.  Trwa ponowne generowanie układu może być stosunkowo kosztowną operacją.  Użyj <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> właściwość do sprawdzenia układu prawidłowe przed wykonaniem operacji, które może wygenerować ponownie układ.  Aby uzyskać więcej informacji, zobacz [układ](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberSignature Language="F#" Value="member this.IsInSameDocument : System.Windows.Documents.TextPointer -&gt; bool" Usage="textPointer.IsInSameDocument textPosition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">Element <see cref="T:System.Windows.Documents.TextPointer" /> , który określa pozycję do porównania z bieżącym położeniu.</param>
        <summary>Wskazuje, czy określona pozycja znajduje się w tym samym kontenerze tekstu jako bieżącej pozycji.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="textPosition" /> wskazuje pozycję, która znajduje się w tym samym kontenerze tekstu jako bieżącej pozycji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość operacji, które obejmują wiele <xref:System.Windows.Documents.TextPointer> wystąpienia są prawidłowe tylko, jeśli wystąpienia danego wskazują miejsca, w których znajdują się w tym samym zakresie tekstu w kontenerze.  Na przykład <xref:System.Windows.Documents.TextPointer.CompareTo%2A> i <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> nie można używać metod <xref:System.Windows.Documents.TextPointer> pozycji poza kontenerem tekst skojarzony z bieżącym położeniu.  Ta metoda służy do Sprawdź, czy określony <xref:System.Windows.Documents.TextPointer> jest zgodny z bieżącą pozycję dla takich operacji.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tej metody.  W przykładzie użyto <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> metodę, aby sprawdzić, czy określony <xref:System.Windows.Documents.TextPointer> znajduje się między dwoma innymi określony <xref:System.Windows.Documents.TextPointer> wystąpień w sytuacji, gdy nie ma żadnej gwarancji, że wszystkie trzy pozycje należą do tego samego kontenera tekstu.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textPosition" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalDirection : System.Windows.Documents.LogicalDirection" Usage="System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera logiczne kierunek skojarzony z bieżącą pozycję, który jest używany do odróżnienia zawartości skojarzonej z bieżącego położenia.</summary>
        <value>
          <see cref="T:System.Windows.Documents.LogicalDirection" /> Wartość, która jest skojarzona z bieżącego położenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jak ta właściwość jest używana, na przykład <xref:System.Windows.Documents.LogicalDirection> z <xref:System.Windows.Documents.TextPointer> zwrócony przez hit test metoda daje trafień, od dwóch znaków tekstu. Logiczne direction Określa, które z dwóch znaków rzeczywiście został trafiony — po lewej stronie lub w prawo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Paragraph : System.Windows.Documents.Paragraph" Usage="System.Windows.Documents.TextPointer.Paragraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera akapitu, w którym zakresów bieżącą pozycję, jeśli istnieje.</summary>
        <value>
          <see cref="T:System.Windows.Documents.Paragraph" /> , Zakresów bieżącej pozycji lub <see langword="null" /> Jeśli istnieje nie takich akapitu.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Documents.TextPointer.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera logiczne obiektu nadrzędnego, który zakresów bieżącej pozycji.</summary>
        <value>Nadrzędny logiczne zakresów bieżącej pozycji.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="textPointer.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obsługuje tego typu lub elementu członkowskiego [! Infrastruktura include[TLA#tla_winclient](~/includes/tlasharptla-winclient-MD.MD)] i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <returns>Ciąg, który reprezentuje obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
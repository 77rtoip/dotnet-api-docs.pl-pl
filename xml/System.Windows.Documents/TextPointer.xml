<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a5691fcb27097765370af5592f11712f056d7fa3" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36361701" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <TypeSignature Language="F#" Value="type TextPointer = class&#xA;    inherit ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje pozycję w <see cref="T:System.Windows.Documents.FlowDocument" /> lub <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextPointer> Klasy wprowadzono następującą terminologią:  
  
-   Umieść — z założenia, <xref:System.Windows.Documents.TextPointer> zawsze wskazuje *pozycji* w zawartości.  Takie pozycji, albo można podzielić między znaków w zawartości lub przepływ zawartości elementu tagi, które definiowania struktury zawartości.  
  
-   Bieżące położenie — ponieważ <xref:System.Windows.Documents.TextPointer> zawsze wskazuje pozycję i dlatego wiele operacji, które mogą być wykonywane za pośrednictwem <xref:System.Windows.Documents.TextPointer> są związane z pozycji wskazywanej aktualnie przez <xref:System.Windows.Documents.TextPointer>, dobrym rozwiązaniem jest po prostu odwoływać się do pozycji <xref:System.Windows.Documents.TextPointer> jako *bieżącego położenia*.  
  
-   Pozycja wstawiania — *wstawiania* jest położenie, w którym można dodać nowej zawartości bez przerywania wszelkie semantycznego reguły dla skojarzonej zawartości.  W praktyce wstawiania jest dowolne miejsce w sytuacjach, gdy znajduje się daszek zawartości.  Przykład prawidłowego <xref:System.Windows.Documents.TextPointer> pozycji, która nie jest wstawiania jest pozycją między dwóch sąsiadujących ze sobą <xref:System.Windows.Documents.Paragraph> tagi (oznacza to, że między tagu zamykającego z poprzednim akapicie i otwierający tag następnego akapitu).  
  
-   Symbol — na potrzeby <xref:System.Windows.Documents.TextPointer> operacji obejmujących symbole, następujących jest traktowany jako *symbol*:  
  
    -   Otwieranie lub tagu zamykającego <xref:System.Windows.Documents.TextElement> elementu.  
  
    -   A <xref:System.Windows.UIElement> zawartym w elemencie <xref:System.Windows.Documents.InlineUIContainer> lub <xref:System.Windows.Documents.BlockUIContainer>.  Uwaga takich <xref:System.Windows.UIElement> jest zawsze traktowanych jak dokładnie jeden symbol; zawartość dodatkowych ani elementów zawartych w <xref:System.Windows.UIElement> nie są liczone jako symbole.  
  
    -   Każdy 16-bitowych [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz tekstu <xref:System.Windows.Documents.Run> elementu.  
  
-   Kontener tekstu — A *kontenera dopisków fonetycznych* jest element, który stanowi ultimate obramowanie wykonywanego zawartość śródwierszowa; pozycji <xref:System.Windows.Documents.TextPointer> zawsze mieści się w kontenerze tekstu.  Obecnie kontener tekst musi być albo <xref:System.Windows.Documents.FlowDocument> lub <xref:System.Windows.Controls.TextBlock>.  Ogólnie rzecz biorąc, operacji między <xref:System.Windows.Documents.TextPointer> wystąpień w różnych kontenerach nie są obsługiwane.  
  
-   Dokument - zawartości w kontenerze tekstu jest określany jako *dokumentu*, jak w <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> — metoda i <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> i <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> właściwości.  
  
 <xref:System.Windows.Documents.TextPointer> Klasy ma na celu ułatwienie przechodzenie i manipulowania nimi zawartość, która jest reprezentowana przez [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] przepływ elementy zawartości; zazwyczaj takie elementy pochodzi od <xref:System.Windows.Documents.TextElement>.  Niektóre operacje, które <xref:System.Windows.Documents.TextPointer> ułatwia są następujące:  
  
-   Wykonaj porządkowej porównanie bieżącej pozycji z drugiego określonej pozycji.  Zobacz <xref:System.Windows.Documents.TextPointer.CompareTo%2A> metody.  
  
-   Określ typ zawartości sąsiadujące bieżącą pozycję w określonym kierunku.  Zobacz <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> — metoda i <xref:System.Windows.Documents.TextPointerContext> wyliczenia.  
  
-   Pobierz <xref:System.Windows.Documents.TextElement> zakresów lub jest przylegające do bieżącego położenia.  Zobacz <xref:System.Windows.Documents.Paragraph> i <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> metody.  
  
-   Pobierz kontener tekst, który zakresów bieżącego dokumentu.  Zobacz <xref:System.Windows.Documents.TextPointer.Parent%2A> właściwości.  
  
-   Pobierz określoną liczbę znaków poprzedzające lub następujące bieżącego położenia.  Zobacz <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> metody.  
  
-   Wstaw ciąg znaków w bieżącym położeniu.  Zobacz <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> metody.  
  
-   Znajdź wiersz granice zawartości.  Zobacz <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> — metoda i <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> właściwości.  
  
-   Tłumaczenie między <xref:System.Windows.Documents.TextPointer> pozycji i symbol przesunięcia do zawartości.  Zobacz <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> i <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> metody.  
  
-   Testowanie visual trafień przez tłumaczenie między <xref:System.Windows.Documents.TextPointer> pozycji i <xref:System.Windows.Point> reprezentujący współrzędnych względnych.  
  
-   Znajdź pobliskich wstawiania lub sprawdź, czy bieżące położenie jest wstawiania.  Zobacz <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> i <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> metod i <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> właściwości.  
  
 Położenie i <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> wskazywanym przez <xref:System.Windows.Documents.TextPointer> obiektu są niezmienne.  Gdy zawartość jest edytowany lub zmodyfikować pozycji <xref:System.Windows.Documents.TextPointer> nie ulega zmianie względem otaczającego tekstu; zamiast przesunięcie tej pozycji od początku zawartości jest odpowiednio dostosowane do nowej pozycji względnej w zawartość.  Na przykład <xref:System.Windows.Documents.TextPointer> wskazujące pozycji na początku danego akapitu w dalszym ciągu punktu Początek ust nawet wtedy, gdy zawartość zostanie wstawiony lub usunięty przed lub po akapicie.  
  
 <xref:System.Windows.Documents.TextPointer> Klasa nie zapewnia żadnych konstruktorów publicznych.  Wystąpienie <xref:System.Windows.Documents.TextPointer> jest tworzona przy użyciu właściwości lub metody innych obiektów (także inne <xref:System.Windows.Documents.TextPointer> obiektów). Poniższa lista zawiera kilka przykładów metody i właściwości, które tworzą i zwracać <xref:System.Windows.Documents.TextPointer>.  Ta lista nie jest wyczerpująca:  
  
-   Z <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> i <xref:System.Windows.Documents.TextRange.End%2A>.  
  
-   Z <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, i <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   Z <xref:System.Windows.Controls.TextBlock> (kontener tekst): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, i <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.  
  
-   Z <xref:System.Windows.Documents.FlowDocument> (kontener tekst): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, i <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   Z istniejącego <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, i <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Windows.Documents.TextPointer> można znaleźć pozycji tylko wewnątrz pierwszy <xref:System.Windows.Documents.Run> elementu w kontenerze określony tekst.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 Poniższy przykład implementuje algorytmu simplistic Znajdź przy użyciu <xref:System.Windows.Documents.TextPointer> urządzenia.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.CompareTo position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">A <see cref="T:System.Windows.Documents.TextPointer" /> , który określa położenie do porównania z bieżącym położeniu.</param>
        <summary>Wykonuje porządkowej porównanie położenia określonego przez bieżący <see cref="T:System.Windows.Documents.TextPointer" /> i określić drugi <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>– 1, gdy bieżący <see cref="T:System.Windows.Documents.TextPointer" /> poprzedza <paramref name="position" />; 0, jeśli lokalizacje są takie same; + 1, jeśli bieżący <see cref="T:System.Windows.Documents.TextPointer" /> następuje <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość -1 wskazuje, że pozycja określona przez bieżące <xref:System.Windows.Documents.TextPointer> poprzedza pozycja określona przez `position`.  Wartość 0 wskazuje, że wskazany pozycje są takie same.  Wartość dodatnią + 1 oznacza, że pozycja określona przez bieżące <xref:System.Windows.Documents.TextPointer> następuje pozycja określona przez `position`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie tej metody.  W tym przykładzie <xref:System.Windows.Documents.TextPointer.CompareTo%2A> metoda jest używana w połączeniu z <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> metody, aby sprawdzić, czy określony <xref:System.Windows.Documents.TextElement> jest pusta.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> Określa położenie poza kontener tekst skojarzony z bieżącym położeniu.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberSignature Language="F#" Value="member this.DeleteTextInRun : int -&gt; int" Usage="textPointer.DeleteTextInRun count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Liczba znaków do usunięcia, zaczynając od bieżącego położenia. Określ wartość dodatnią, aby usunąć znaki, które należy wykonać bieżącej pozycji; Określ wartość ujemną, aby usunąć znaki, które należy poprzedzić bieżącego położenia.</param>
        <summary>Usuwa określoną liczbę znaków od pozycji bieżącej <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Liczba znaków w rzeczywistości usunięty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określ wartość dodatnią, aby usunąć znaki, które należy wykonać bieżącej pozycji (podobnie jak w <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>); określ wartość ujemną, aby usunąć znaki, które należy poprzedzić bieżącego położenia (podobnie jak w <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Liczba znaków w rzeczywistości usunięty może być mniejsza niż liczba określona przez `count`.  Dzieje się tak w przypadku których `count` określa więcej znaków niż istnieje do usunięcia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda jest wywoływana w miejscu, w których tekst nie jest dozwolone.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Documents.TextPointer" /> na końcu zawartości kontenera tekstowego skojarzonego z bieżącego położenia.</summary>
        <value>A <see cref="T:System.Windows.Documents.TextPointer" /> na końcu zawartości kontenera tekstowego skojarzonego z bieżącego położenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextPointer.Parent%2A> Dla zwróconego <xref:System.Windows.Documents.TextPointer> jest zawsze kontenerze tekstu (<xref:System.Windows.Controls.TextBlock> lub <xref:System.Windows.Documents.FlowDocument>), a nie <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Documents.TextPointer" /> na początku zawartości kontenera tekstowego skojarzonego z bieżącego położenia.</summary>
        <value>A <see cref="T:System.Windows.Documents.TextPointer" /> na początku zawartości kontenera tekstowego skojarzonego z bieżącego położenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj pozycji zwracane przez tę właściwość jako pozycji linii bazowej, w którym do pracy z przesunięciem względną do innych pozycji.  <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> i <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> metody umożliwiają tłumaczenie między i pozycji przesunięcia.  
  
 <xref:System.Windows.Documents.TextPointer.Parent%2A> Dla zwróconego <xref:System.Windows.Documents.TextPointer> jest zawsze kontenerze tekstu (<xref:System.Windows.Controls.TextBlock> lub <xref:System.Windows.Documents.FlowDocument>), a nie <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetAdjacentElement : System.Windows.Documents.LogicalDirection -&gt; System.Windows.DependencyObject" Usage="textPointer.GetAdjacentElement direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jeden z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa kierunek logicznej wyszukiwania dla elementu sąsiadujących ze sobą.</param>
        <summary>Zwraca element, jeśli obramowania bieżącej <see cref="T:System.Windows.Documents.TextPointer" /> w określonym kierunku logiczne.</summary>
        <returns>Element sąsiadujących ze sobą w określonym <paramref name="direction" />, lub <see langword="null" /> Jeśli sąsiadujących ze sobą nie zawiera żadnego elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony element jest zwykle <xref:System.Windows.Documents.TextElement>.  A <xref:System.Windows.UIElement> może być zwracany podczas <xref:System.Windows.Documents.TextPointer> wskazuje położenie wewnątrz <xref:System.Windows.Documents.BlockUIContainer> element lub <xref:System.Windows.Documents.InlineUIContainer> elementu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetCharacterRect : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Rect" Usage="textPointer.GetCharacterRect direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jeden z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logicznej kierunek, w którym można znaleźć zawartości obwiedni.</param>
        <summary>Zwraca obwiedni (<see cref="T:System.Windows.Rect" />) dla zawartości, która obramowania bieżącej <see cref="T:System.Windows.Documents.TextPointer" /> w określonym kierunku logiczne.</summary>
        <returns>Obwiedni zawartości ograniczająca bieżącego <see cref="T:System.Windows.Documents.TextPointer" /> w określonym kierunku lub <see cref="P:System.Windows.Rect.Empty" /> Jeśli bieżąca, informacje o układzie prawidłowy jest niedostępny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> krawędziach nie są uznawane za zawartości na potrzeby tej metody.  Jeśli <xref:System.Windows.Documents.TextPointer> jest umieszczony przed <xref:System.Windows.Documents.TextElement> krawędzi, zwracana wartość jest obwiednią Następna z systemem innym niż<xref:System.Windows.Documents.TextElement> zawartości w określonym kierunku.  Jeśli brak zawartości w określonym kierunku zerowej szerokości <xref:System.Windows.Rect> jest zwracany za wysokości dopasowania wysokości żadnych poprzedzających zawartości.  
  
 Operacja wykonywana przez tę metodę zależy od prawidłowy układu.  Jeśli to konieczne, ta metoda próbuje automatycznie ponownie wygenerować układzie prawidłowe przed wykonaniem operacji.  Trwa ponowne generowanie układu może być dość kosztowna operacja.  Użyj <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> właściwość do sprawdzenia układu prawidłowe przed wykonaniem operacji, które może ponownie wygenerować układu.  Aby uzyskać więcej informacji, zobacz [układu](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jeden z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logicznej kierunek, w których będą poszukiwane najbliższego wstawiania.</param>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> do najbliższego wstawiania w określonym kierunku logiczne.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> do najbliższego wstawiania w określonym kierunku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycja wstawiania jest położenie, w którym można dodać nowej zawartości bez przerywania wszelkie semantycznego reguły dla skojarzonej zawartości.  W praktyce wstawiania jest dowolne miejsce w sytuacjach, gdy znajduje się daszek zawartości.  Przykład prawidłowego <xref:System.Windows.Documents.TextPointer> pozycji, która nie jest wstawiania jest pozycją między dwóch sąsiadujących ze sobą <xref:System.Windows.Documents.Paragraph> tagi (oznacza to, że między tagu zamykającego z poprzednim akapicie i otwierający tag następnego akapitu).  
  
 Jeśli <xref:System.Windows.Documents.TextPointer> już wskazuje prawidłowy wstawiania, lecz tag zamykający dla niepustej sekwencji formatowania bezpośrednio następuje tej pozycji w określonym kierunku, a następnie <xref:System.Windows.Documents.TextPointer> zwróconych przez to metody jest dostosowana do wskaż wstawiania Umieść zaraz po zamknięciu formatowania sekwencji. Rozważmy na przykład sekwencji znaczników `<Bold>a</Bold>b`. Należy pamiętać, że istnieją dwie pozycje wstawiania między literami `a` i `b` — poprzedzającym zamknięcia `Bold` tag, a drugi, bezpośrednio po upływie `Bold` tagu. Jeśli <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> jest wywoływana na <xref:System.Windows.Documents.TextPointer> do położenia bezpośrednio po literę `a` i przed zamknięcia `Bold` tag i z `direction` z <xref:System.Windows.Documents.LogicalDirection.Forward>, zwracana <xref:System.Windows.Documents.TextPointer> jest dostosowana do wskaż Pozycja tuż przed literą `b`, po upływie `Bold` tagu. Podobne dostosowań do otwarcia tagów formatowania podczas pracy w przeciwnym kierunku logiczne. Ta metoda jest przeznaczona do pozwalają Uściślanie między pozycje wstawiania w podobnych przypadków.  
  
 Ta metoda umożliwia również można selektywnie punkty wstawienia, gdy uczestniczy sekwencji strukturalnych tagów. Na przykład, gdy na pozycji od zamknięcia i otwarcia tagów akapitu, kierunku parametru może służyć do wybierz najbliższy punkt wstawiania na początku następujący ustęp (określając <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) lub na końcu poprzedniego (akapitu określając <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Gdy wskaźnik myszy znajduje się już w wstawiania i nie ma żadnych sąsiadujących znaczników formatowania w określonym `direction`, zwracana <xref:System.Windows.Documents.TextPointer> wskazuje na tym samym miejscu wywołujący <xref:System.Windows.Documents.TextPointer>.  
  
 Istnieje możliwość, czy nie prawidłowy wstawiania istnieje względem pozycji wskazywanej przez <xref:System.Windows.Documents.TextPointer>.  Może to nastąpić, jeśli przywoływanej zawartości jest strukturalnie niekompletne, jak pusta tabela lub listy.  W takich przypadkach, ta metoda po prostu zwraca <xref:System.Windows.Documents.TextPointer> na tym samym miejscu <xref:System.Windows.Documents.TextPointer> z którego ta metoda została wywołana.  Ta metoda zawsze zwraca prawidłową <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 Ten przykład przedstawia sposób użycia <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> , aby sprawdzić, czy określony <xref:System.Windows.Documents.TextElement> jest pusta drukowania zawartości.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> na początku wiersza, który został określony względem bieżącej <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Liczba znaczników linii początkowej można pominąć w przypadku określenia wiersza, dla którego ma zostać zwrócona pozycji początkowej. Wartości ujemne określić poprzednich wierszy, 0 określa bieżącego wiersza i określ liczbę wartości dodatnich kolejne wiersze.</param>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> na początku wiersza, który został określony względem bieżącej <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> wskazujące na początku określonego wiersza (z <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> ustawioną <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), lub <see langword="null" /> określonego wiersza jest spoza zakresu lub w przeciwnym razie nie można odnaleźć.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Documents.TextPointer> punktów niejednoznaczne pozycji, na przykład między dwoma liniami wiersza w kierunku określony przez <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> został wybrany jako względną wiersza początkowego.  
  
 Operacja wykonywana przez tę metodę zależy od prawidłowy układu.  Jeśli to konieczne, ta metoda próbuje automatycznie ponownie wygenerować układzie prawidłowe przed wykonaniem operacji.  Trwa ponowne generowanie układu może być dość kosztowna operacja.  Użyj <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> do sprawdzenia układu prawidłowe przed wykonaniem operacji, które może ponownie wygenerować układu.  Aby uzyskać więcej informacji, zobacz [układu](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int *  -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition (count, actualCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">Liczba znaczników linii początkowej można pominąć w przypadku określenia wiersza, dla którego ma zostać zwrócona pozycji początkowej. Wartości ujemne określić poprzednich wierszy, 0 określa bieżącego wiersza i określ liczbę wartości dodatnich kolejne wiersze.</param>
        <param name="actualCount">Gdy metoda zwróci wartość, zawiera rzeczywistą liczbę znaczników początek wiersza, które zostały pominięte podczas określania wiersza, dla którego ma zostać zwrócona pozycji początkowej.  Ta wartość może być mniejsza niż <c>liczba</c> Jeśli początek lub koniec zawartości napotkano przed określoną liczbę wierszy są pomijane. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> na początku wiersza, który został określony względem bieżącej <see cref="T:System.Windows.Documents.TextPointer" />i w raportach, ile wierszy zostały pominięte.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> wskazujące na początku określonego wiersza (z <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> ustawioną <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), lub do początku wiersza najbliżej określonego wiersza, jeśli określony wiersz jest poza zakresem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Documents.TextPointer> punktów niejednoznaczne pozycji, na przykład między dwoma liniami wiersza w kierunku określony przez <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> właściwość został wybrany jako względną wiersza początkowego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextContextPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextContextPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jeden z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logicznej kierunek, w których będą poszukiwane następny symbol.</param>
        <summary>Zwraca wskaźnik do następny symbol w określonym kierunku logiczne.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> na następny symbol w kierunku żądanej lub <see langword="null" /> Jeśli bieżące <see cref="T:System.Windows.Documents.TextPointer" /> obramowania początek lub koniec zawartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedną z następujących czynności jest uznawane za symbolu:  
  
-   Otwieranie lub tagu zamykającego <xref:System.Windows.Documents.TextElement> elementu.  
  
-   A <xref:System.Windows.UIElement> element zawarty w <xref:System.Windows.Documents.InlineUIContainer> lub <xref:System.Windows.Documents.BlockUIContainer>.  Uwaga takich <xref:System.Windows.UIElement> jest zawsze traktowanych jak dokładnie jeden symbol; zawartość dodatkowych ani elementów zawartych w <xref:System.Windows.UIElement> nie są liczone jako symbole.  
  
-   16-bitowych [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz tekstu <xref:System.Windows.Documents.Run> elementu.  
  
 Jeśli następny symbol jest skategoryzowany jako <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, lub <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (określonej za pomocą <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> — metoda), a następnie <xref:System.Windows.Documents.TextPointer> zwróconych przez to metoda jest zaawansowane dokładnie jeden symbol od bieżącego położenia.  
  
 Jeśli następny symbol jest skategoryzowany jako <xref:System.Windows.Documents.TextPointerContext.Text>, a następnie <xref:System.Windows.Documents.TextPointer> zwróconych przez to metody jest zaawansowane poza tekst, aby następny symbol nietekstowych (czyli następnej pozycji where <xref:System.Windows.Documents.TextPointerContext> nie jest <xref:System.Windows.Documents.TextPointerContext.Text>).  Liczba dokładne symbol przekroczyła może zostać obliczona wcześniej przez wywołanie metody <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie tej metody.  W przykładzie użyto <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> w połączeniu z metody <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> metodę, aby przechodzić między nimi i wyodrębniać symbole w określonym <xref:System.Windows.Documents.TextElement>.  
  
 Chociaż przykładzie mogą być używane do wyodrębnienia [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] struktury zawartości danego <xref:System.Windows.Documents.TextElement>, jest przeznaczona wyłącznie w celach ilustracyjnych i nie powinna być używana w kodzie produkcyjnym.  Zobacz <xref:System.Xml> przestrzeń nazw dla bogaty zestaw typy przeznaczone do pracy z i przetwarzania kodu XML.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jeden z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logicznej kierunek, w których będą poszukiwane dalej wstawiania.</param>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> do następnego wstawiania w określonym kierunku logiczne.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> , które identyfikują dalej wstawiania w kierunku żądanej lub <see langword="null" /> w przypadku nieodnalezienia nie dalej wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Wstawiania* jest położenie, w którym można dodać nowej zawartości bez przerywania wszelkie semantycznego reguły dla skojarzonej zawartości.  W praktyce wstawiania jest dowolne miejsce w sytuacjach, gdy znajduje się daszek zawartości.  Przykład prawidłowego <xref:System.Windows.Documents.TextPointer> pozycji, która nie jest wstawiania jest pozycją między dwóch sąsiadujących ze sobą <xref:System.Windows.Documents.Paragraph> tagi (oznacza to, że między tagu zamykającego z poprzednim akapicie i otwierający tag następnego akapitu).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie tej metody. W przykładzie użyto <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> metody przechodzenia przez granice elementu zawartości, aby określić liczbę <xref:System.Windows.Documents.Paragraph> elementy stanowią między dwiema określony <xref:System.Windows.Documents.TextPointer> wystąpień.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetOffsetToPosition : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.GetOffsetToPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">A <see cref="T:System.Windows.Documents.TextPointer" /> Określa, w stanie znaleźć odległość (w symboli).</param>
        <summary>Zwraca liczbę symbole między bieżącą <see cref="T:System.Windows.Documents.TextPointer" /> i określić drugi <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Względne liczbę symboli między bieżącą <see cref="T:System.Windows.Documents.TextPointer" /> i <paramref name="position" />.  Ujemna wartość oznacza, że bieżący <see cref="T:System.Windows.Documents.TextPointer" /> następuje pozycja określona przez <paramref name="position" />, 0 wskazuje, że pozycje są takie same i dodatnią wartość wskazuje, że bieżące <see cref="T:System.Windows.Documents.TextPointer" /> poprzedza pozycja określona przez <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedną z następujących czynności jest uznawane za symbolu:  
  
-   Otwieranie lub tagu zamykającego <xref:System.Windows.Documents.TextElement> elementu.  
  
-   A <xref:System.Windows.UIElement> element zawarty w <xref:System.Windows.Documents.InlineUIContainer> lub <xref:System.Windows.Documents.BlockUIContainer>.  Uwaga takich <xref:System.Windows.UIElement> jest zawsze traktowanych jak dokładnie jeden symbol; zawartość dodatkowych ani elementów zawartych w <xref:System.Windows.UIElement> nie są liczone jako symbole.  
  
-   16-bitowych [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz tekstu <xref:System.Windows.Documents.Run> elementu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie tej metody. W przykładzie użyto <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> metody do znalezienia przesunięcia dla dwóch <xref:System.Windows.Documents.TextPointer> wystąpienia, a następnie używa tych informacji do zapisywania i przywracania zaznaczenie w <xref:System.Windows.Controls.RichTextBox>.  W przykładzie założono, że zawartość <xref:System.Windows.Controls.RichTextBox> nie uległy zmianie od wyboru zapisywanie i przywracanie zaznaczenia.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> Określa położenie poza kontener tekst skojarzony z bieżącym położeniu.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPointerContext : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointerContext" Usage="textPointer.GetPointerContext direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jeden z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logicznej kierunek, w którym można określić kategorię dla zawartości sąsiadujących ze sobą.</param>
        <summary>Zwraca wskaźnik kategorii, dla zawartości przylegające do bieżącego <see cref="T:System.Windows.Documents.TextPointer" /> w określonym kierunku logiczne.</summary>
        <returns>Jeden z <see cref="T:System.Windows.Documents.TextPointerContext" /> wartości, które wskazuje, że kategoria sąsiadujących zawartości w określonym kierunku logiczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano użycie tej metody. W przykładzie użyto <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> metody do zaimplementowania algorytm obliczania saldo otwierające i zamykające znaczniki elementów między dwiema określony <xref:System.Windows.Documents.TextPointer> pozycji.  Każdy element tagu początkowego jest traktowane jako + 1, a każdy element tagu zamykającego jest traktowane jako -1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> pozycji przez określone przesunięcie w symbolach, począwszy od zawartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">Przesunięcie w symbolach, dla której obliczana i zwraca położenie.  Jeśli przesunięcie jest ujemna, pozycja jest obliczana w kierunku logicznej przeciwne wskazaną przez <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> właściwości.</param>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> przez określone przesunięcie w symbolach, począwszy od bieżącej pozycji <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> pozycji przez określone przesunięcie lub <see langword="null" /> w przypadku nieodnalezienia nie odpowiedniej pozycji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedną z następujących czynności jest uznawane za symbolu:  
  
-   Otwieranie lub tagu zamykającego <xref:System.Windows.Documents.TextElement> elementu.  
  
-   A <xref:System.Windows.UIElement> element zawarty w <xref:System.Windows.Documents.InlineUIContainer> lub <xref:System.Windows.Documents.BlockUIContainer>.  Uwaga takich <xref:System.Windows.UIElement> jest zawsze traktowanych jak dokładnie jeden symbol; zawartość dodatkowych ani elementów zawartych w <xref:System.Windows.UIElement> nie są liczone jako symbole.  
  
-   16-bitowych [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz tekstu <xref:System.Windows.Documents.Run> elementu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie tej metody. W przykładzie użyto <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> metody użycia dwóch metod, co do obliczenia przesunięcia do określonej pozycji względem dowolnego hostingu akapitu, a drugi do zwrócenia <xref:System.Windows.Documents.TextPointer> do określone przesunięcie w określonym akapicie.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset (offset, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">Przesunięcie w symbolach, dla której obliczana i zwraca położenie.  Jeśli przesunięcie jest ujemna, zwracana <see cref="T:System.Windows.Documents.TextPointer" /> poprzedza bieżącego <see cref="T:System.Windows.Documents.TextPointer" />; w przeciwnym razie wynika z.</param>
        <param name="direction">Jeden z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa kierunek logicznej zwróconego elementu <see cref="T:System.Windows.Documents.TextPointer" />.</param>
        <summary>Zwraca <see cref="T:System.Windows.Documents.TextPointer" /> przez określone przesunięcie w symbolach, począwszy od bieżącej pozycji <see cref="T:System.Windows.Documents.TextPointer" /> i w określonym kierunku.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> pozycji przez określone przesunięcie lub <see langword="null" /> Jeśli przesunięcie rozciąga się poza koniec zawartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedną z następujących czynności jest uznawane za symbolu:  
  
-   Otwieranie lub tagu zamykającego <xref:System.Windows.Documents.TextElement> elementu.  
  
-   A <xref:System.Windows.UIElement> element zawarty w <xref:System.Windows.Documents.InlineUIContainer> lub <xref:System.Windows.Documents.BlockUIContainer>.  Uwaga takich <xref:System.Windows.UIElement> jest zawsze traktowanych jak dokładnie jeden symbol; zawartość dodatkowych ani elementów zawartych w <xref:System.Windows.UIElement> nie są liczone jako symbole.  
  
-   16-bitowych [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz tekstu <xref:System.Windows.Documents.Run> elementu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca tekst obok bieżącej <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection -&gt; string" Usage="textPointer.GetTextInRun direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jeden z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logicznej kierunek, w którym można znaleźć i zwracać dowolnym sąsiadującym tekstem.</param>
        <summary>Zwraca ciąg zawierający tekst obok bieżącej <see cref="T:System.Windows.Documents.TextPointer" /> w określonym kierunku logiczne.</summary>
        <returns>Ciąg zawierający dowolnym sąsiadującym tekstem w określonym kierunku logiczne, lub <see cref="F:System.String.Empty" /> w przypadku nieodnalezienia nie sąsiadującym tekstem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca tylko nieprzerwaną serii tekstu.  Nic nie zostanie zwrócone, jeśli żadnego typu symbolu innego niż <xref:System.Windows.Documents.TextPointerContext.Text> sąsiaduje z bieżącej <xref:System.Windows.Documents.TextPointer> w określonym kierunku.  Podobnie tekstu jest zwracana tylko do następny symbol nietekstowych.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie tej metody. W przykładzie użyto <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> metody do zaimplementowania ekstraktor zwykły tekst.  Metoda zwraca złączony ciąg dla całego tekstu między dwiema określony <xref:System.Windows.Documents.TextPointer> wystąpień.  
  
 Gdy na przykład można wyodrębnić tekst między dwiema <xref:System.Windows.Documents.TextPointer> wystąpień, jego jest przeznaczona wyłącznie w celach ilustracyjnych i nie powinna być używana w kodzie produkcyjnym.  Użyj <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType> właściwości zamiast tego.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection * char[] * int * int -&gt; int" Usage="textPointer.GetTextInRun (direction, textBuffer, startIndex, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Jeden z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logicznej kierunek, w którym można znaleźć i skopiować dowolnym sąsiadującym tekstem.</param>
        <param name="textBuffer">Bufor, do którego jest skopiowany tekst.</param>
        <param name="startIndex">Indeks do <c>textBuffer</c> od której ma rozpocząć pisanie skopiowany tekst.</param>
        <param name="count">Maksymalna liczba znaków do skopiowania.</param>
        <summary>Kopiuje określoną maksymalną liczbę znaków z dowolnym sąsiadującym tekstem w określonym kierunku do tablicy znaków dostarczony przez obiekt wywołujący.</summary>
        <returns>Liczba znaków, które faktycznie kopiowane do <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca tylko nieprzerwaną serii tekstu.  Nic nie zostanie zwrócone, jeśli żadnego typu symbolu innego niż <xref:System.Windows.Documents.TextPointerContext.Text> sąsiaduje z bieżącej <xref:System.Windows.Documents.TextPointer> w określonym kierunku.  Podobnie tekstu jest zwracana tylko do następny symbol nietekstowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> jest mniejsza niż 0 lub większą niż <see cref="P:System.Array.Length" /> właściwość <paramref name="textBuffer" />.  - lub - <paramref name="count" /> jest mniejsza niż 0 lub większą niż pozostałe miejsce w <paramref name="textBuffer" /> (<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> minus <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextRunLength : System.Windows.Documents.LogicalDirection -&gt; int" Usage="textPointer.GetTextRunLength direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Jeden z <see cref="T:System.Windows.Documents.LogicalDirection" /> wartości, które określa logicznej kierunek, w którym można określić liczbę znaków.</param>
        <summary>Zwraca liczbę znaków Unicode między bieżącą <see cref="T:System.Windows.Documents.TextPointer" /> i następny symbol nietekstowych w określonym kierunku logiczne.</summary>
        <returns>Liczba znaków Unicode między bieżącą <see cref="T:System.Windows.Documents.TextPointer" /> i następny symbol nietekstowych.  Ta liczba może być 0, jeśli nie ma żadnego tekstu sąsiadujących ze sobą.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedną z następujących czynności jest uznawane za symbolu:  
  
-   Otwieranie lub tagu zamykającego <xref:System.Windows.Documents.TextElement> elementu.  
  
-   A <xref:System.Windows.UIElement> element zawarty w <xref:System.Windows.Documents.InlineUIContainer> lub <xref:System.Windows.Documents.BlockUIContainer>.  Uwaga takich <xref:System.Windows.UIElement> jest zawsze traktowanych jak dokładnie jeden symbol; zawartość dodatkowych ani elementów zawartych w <xref:System.Windows.UIElement> nie są liczone jako symbole.  
  
-   16-bitowych [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] znak wewnątrz tekstu <xref:System.Windows.Documents.Run> elementu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidLayout : bool" Usage="System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kontener tekst skojarzony z bieżącą pozycję ma prawidłową układ (aktualne).</summary>
        <value>
          <see langword="true" /> Jeśli układ są aktualne i prawidłowe; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W razie potrzeby operacje, które są zależne od prawidłowy układu (takich jak <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> metody <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> metody i <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> właściwości) próbować automatycznie ponownie wygenerować układzie prawidłowe przed wykonaniem operacji.  Trwa ponowne generowanie układu może być dość kosztowna operacja.  Tej właściwości należy użyć, aby sprawdzić układ prawidłowe przed wykonaniem operacji, które może ponownie wygenerować układu.  Aby uzyskać więcej informacji, zobacz [układu](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertLineBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertLineBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstawia podział wiersza w bieżącym położeniu.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> pozycjonowane natychmiast po <see cref="T:System.Windows.Documents.LineBreak" /> element wstawiony przez tę metodę.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertParagraphBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertParagraphBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstawia podział akapitu w bieżącym położeniu.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> na początku (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) nowy akapit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda jest wywoływana, gdy bieżące położenie jest wewnątrz istniejącego <xref:System.Windows.Documents.Paragraph> elementu, istniejące akapitu oraz zawartość zawiera są podzielone na dwa akapity w bieżącym położeniu.  Jeśli ta metoda jest wywoływana, gdy bieżąca pozycja nie znajduje się wewnątrz istniejącego akapitu, jest wstawiany akapitu nowy, pusty.  Jeśli ta metoda jest wywoływana na pozycji nie nadaje się do dzielenia lub wstawianie akapitu (na przykład, jeśli bieżące położenie jest wewnątrz <xref:System.Windows.Documents.Hyperlink> element), jest zgłaszany wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta metoda jest wywoływana na pozycji nie można podzielić, aby pomieścić nowy akapit, takich jak w zakresie <see cref="T:System.Windows.Documents.Hyperlink" /> lub <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberSignature Language="F#" Value="member this.InsertTextInRun : string -&gt; unit" Usage="textPointer.InsertTextInRun textData" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Tekst do wstawienia.</param>
        <summary>Wstawia określony tekst w tekście <see cref="T:System.Windows.Documents.Run" /> w bieżącym położeniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Documents.TextPointer> jest poza zakresem przez <xref:System.Windows.Documents.Run> elementu <xref:System.Windows.Documents.Run> dodaje się wraz z programem `textData`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżąca pozycja nie znajduje się w <see cref="T:System.Windows.Documents.Run" /> elementu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textData" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtInsertionPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące położenie jest wstawiania.</summary>
        <value>
          <see langword="true" /> Jeśli bieżące położenie jest wstawiania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycja wstawiania jest położenie, w którym można dodać nowej zawartości bez przerywania wszelkie semantycznego reguły dla skojarzonej zawartości.  W praktyce wstawiania jest dowolne miejsce w sytuacjach, gdy znajduje się daszek zawartości.  Przykład prawidłowego <xref:System.Windows.Documents.TextPointer> pozycji, która nie jest wstawiania jest pozycją między dwóch sąsiadujących ze sobą <xref:System.Windows.Documents.Paragraph> tagi (oznacza to, że między tagu zamykającego z poprzednim akapicie i otwierający tag następnego akapitu).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtLineStartPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące położenie jest na początku wiersza.</summary>
        <value>
          <see langword="true" /> Jeśli bieżące położenie jest na początku wiersza; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Documents.TextPointer> punktów niejednoznaczne pozycji, na przykład między dwoma liniami wiersza w kierunku określony przez <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> właściwość został wybrany jako względną wiersza początkowego.  
  
 Operacja wykonywana przez tę właściwość zależy od prawidłowy układu.  Jeśli to konieczne, ta metoda próbuje automatycznie ponownie wygenerować układzie prawidłowe przed wykonaniem operacji.  Trwa ponowne generowanie układu może być dość kosztowna operacja.  Użyj <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> właściwość do sprawdzenia układu prawidłowe przed wykonaniem operacji, które może ponownie wygenerować układu.  Aby uzyskać więcej informacji, zobacz [układu](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberSignature Language="F#" Value="member this.IsInSameDocument : System.Windows.Documents.TextPointer -&gt; bool" Usage="textPointer.IsInSameDocument textPosition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">A <see cref="T:System.Windows.Documents.TextPointer" /> , który określa położenie do porównania z bieżącym położeniu.</param>
        <summary>Wskazuje, czy określona pozycja jest w tym samym kontenerze tekstu jako bieżącego położenia.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="textPosition" /> wskazuje pozycję, który znajduje się w tym samym kontenerze tekstu jako bieżącego położenia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość operacji obejmujących wiele <xref:System.Windows.Documents.TextPointer> wystąpienia są prawidłowe tylko, jeśli wystąpienia danego wskazują miejsca, w których znajdują się w tym samym zakresie tekstu w kontenerze.  Na przykład <xref:System.Windows.Documents.TextPointer.CompareTo%2A> i <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> nie można używać metod <xref:System.Windows.Documents.TextPointer> do położenia poza kontener tekst skojarzony z bieżącym położeniu.  Ta metoda służy do sprawdzenia, czy określonej <xref:System.Windows.Documents.TextPointer> jest zgodny z bieżącą pozycję w takich operacjach.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie tej metody.  W przykładzie użyto <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> , aby sprawdzić, czy określony <xref:System.Windows.Documents.TextPointer> znajduje się między dwoma innymi określony <xref:System.Windows.Documents.TextPointer> wystąpień w sytuacji, gdy nie ma żadnej gwarancji, że wszystkie trzy pozycje należą do tego samego kontenera tekstu.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textPosition" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalDirection : System.Windows.Documents.LogicalDirection" Usage="System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kierunek logiczne skojarzone z bieżącą pozycję, który służy do odróżniania zawartości skojarzonej z bieżącą pozycję.</summary>
        <value>
          <see cref="T:System.Windows.Documents.LogicalDirection" /> Wartość, która jest skojarzona z bieżącym położeniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jak ta właściwość jest używana, na przykład <xref:System.Windows.Documents.LogicalDirection> z <xref:System.Windows.Documents.TextPointer> zwrócony przez testu trafienia metoda daje trafień, który jest między znakami tekstu. Logiczne direction Określa, które dwóch znaków faktycznie został trafiony — po lewej lub prawej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Paragraph : System.Windows.Documents.Paragraph" Usage="System.Windows.Documents.TextPointer.Paragraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera akapicie zakresów bieżącą pozycję, jeśli istnieje.</summary>
        <value>
          <see cref="T:System.Windows.Documents.Paragraph" /> Który zakresów bieżącego położenia lub <see langword="null" /> Jeśli istnieje nie takie akapitu.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Documents.TextPointer.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera logicznej nadrzędnej, czy bieżące położenie zakresów.</summary>
        <value>Logiczne nadrzędnej, czy bieżące położenie zakresów.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="textPointer.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ten typ lub element członkowski obsługuje [! Infrastruktura include[TLA#tla_winclient](~/includes/tlasharptla-winclient-MD.MD)] i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <returns>Ciąg reprezentujący obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
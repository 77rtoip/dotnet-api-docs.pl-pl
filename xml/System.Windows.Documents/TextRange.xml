<Type Name="TextRange" FullName="System.Windows.Documents.TextRange">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fb8c911bcd50ae7df0bc24cc8b65e1bdb494e3e5" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30700529" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextRange" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextRange extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextRange" />
  <TypeSignature Language="VB.NET" Value="Public Class TextRange" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextRange" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje wybór zawartości między dwiema <see cref="T:System.Windows.Documents.TextPointer" /> pozycji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextRange> Klasy wprowadzono następującą terminologią.  
  
-   **Wybór** — <xref:System.Windows.Documents.TextRange> wybór zawartości między dwiema pozycjami wskazywanym przez **TextPointers**.  Stały zakotwiczenia względem zaznaczenia, jeden z nich umieszcza zablokowaniu ruchomy innych pozycji.  Jest to podobne do zachowania wyboru wprowadzone przez użytkownika za pomocą myszy lub klawiatury.  
  
-   **Bieżące zaznaczenie** — ponieważ <xref:System.Windows.Documents.TextRange> zawsze wskazuje zaznaczenie w zawartości, warto po prostu odwoływać się do zaznaczenia wskazywanym przez <xref:System.Windows.Documents.TextRange> jako *bieżące zaznaczenie*.  
  
-   **Kontener tekstu** — *kontenera dopisków fonetycznych* jest element, który stanowi ultimate obramowanie wykonywanego zawartość śródwierszowa; wskazywanym przez zaznaczenie <xref:System.Windows.Documents.TextRange> zawsze mieści się w kontenerze tekstu.  Obecnie kontener tekst musi być albo <xref:System.Windows.Documents.FlowDocument> lub <xref:System.Windows.Controls.TextBlock>.  
  
-   **Dokument** -zawartości zbiorczo zawartych w kontenerze tekstu jest określany jako *dokumentu*.  
  
 Więcej informacji na temat innych związanych z warunków, takich jak *pozycji*, zobacz <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, za pomocą <xref:System.Windows.Documents.TextRange.Text%2A> właściwość <xref:System.Windows.Documents.TextRange> do zwrócenia zwykły tekst reprezentację określonej <xref:System.Windows.Documents.FlowDocument>.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextRange (System.Windows.Documents.TextPointer position1, System.Windows.Documents.TextPointer position2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.TextPointer position1, class System.Windows.Documents.TextPointer position2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.#ctor(System.Windows.Documents.TextPointer,System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (position1 As TextPointer, position2 As TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextRange(System::Windows::Documents::TextPointer ^ position1, System::Windows::Documents::TextPointer ^ position2);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="position1" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="position2" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position1">Pozycji zakotwiczenia stały, która oznacza jeden koniec zaznaczenia używana do utworzenia nowego <see cref="T:System.Windows.Documents.TextRange" />.</param>
        <param name="position2">Ruchome pozycji, która oznacza koniec zaznaczenia używana do utworzenia nowego <see cref="T:System.Windows.Documents.TextRange" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Documents.TextRange" /> klasy, biorąc dwa określone <see cref="T:System.Windows.Documents.TextPointer" /> pozycje jako pozycje początku i na końcu nowego zakresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Documents.TextRange> został utworzony z wyboru między dwie pozycje wskazywanym przez **TextPointers**.  Jedną z tych pozycji (wskazywanym przez `position1`) ma położenie ustalone względem zaznaczenia, podczas innych pozycji (wskazywanym przez `position2`) jest ruchomy.  Jest to podobne do zachowania wyboru wprowadzone przez użytkownika za pomocą myszy lub klawiatury.  
  
 Rzeczywiste zakończenia nowej <xref:System.Windows.Documents.TextRange> mogą być dostosowywane do dopasowania żadnych heurystyki wyboru, które mają zastosowanie do dokumentu, który zawiera nowe <xref:System.Windows.Documents.TextRange>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange> konstruktora.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, gdy <paramref name="position1" /> i <paramref name="position2" /> nie znajduje się w tym samym dokumencie.</exception>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy <paramref name="position1" /> lub <paramref name="position2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyPropertyValue">
      <MemberSignature Language="C#" Value="public void ApplyPropertyValue (System.Windows.DependencyProperty formattingProperty, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyPropertyValue(class System.Windows.DependencyProperty formattingProperty, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyPropertyValue (formattingProperty As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyPropertyValue(System::Windows::DependencyProperty ^ formattingProperty, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattingProperty" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="formattingProperty">Właściwość formatowania do zastosowania.</param>
        <param name="value">Wartość właściwości formatowania.</param>
        <summary>Dotyczy określonej właściwości formatowania i wartości do bieżącego zaznaczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda stosuje formatowanie wstawiając odpowiednie <xref:System.Windows.Documents.Inline> elementów, takich jak <xref:System.Windows.Documents.Bold> i <xref:System.Windows.Documents.Italic>, do wyboru wskazywanym przez to <xref:System.Windows.Documents.TextRange>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.ApplyPropertyValue%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, gdy <paramref name="formattingProperty" /> nie określa prawidłowej właściwości formatowania, lub <paramref name="value" /> określa nieprawidłową wartość dla <paramref name="formattingProperty" />.</exception>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy <paramref name="formattingProperty" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.ClearAllProperties" />
        <altmember cref="M:System.Windows.Documents.TextRange.GetPropertyValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="CanLoad">
      <MemberSignature Language="C#" Value="public bool CanLoad (string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanLoad(string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanLoad (dataFormat As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanLoad(System::String ^ dataFormat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataFormat">Format danych, aby sprawdzić zgodność obciążenia w bieżącym zaznaczeniu.  Zobacz <see cref="T:System.Windows.DataFormats" /> listę predefiniowanych formatów danych.</param>
        <summary>Sprawdza, czy bieżące zaznaczenie mogą być ładowane z zawartością w formacie określone dane.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące zaznaczenie mogą być ładowane z zawartością w formacie określone dane. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj odpowiedniej <xref:System.Windows.Documents.TextRange.Load%2A> metodę, aby rzeczywiście Załaduj zawartość do bieżącego zaznaczenia w formacie określone dane.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.CanLoad%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CanSave">
      <MemberSignature Language="C#" Value="public bool CanSave (string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanSave(string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanSave (dataFormat As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanSave(System::String ^ dataFormat);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.CanSave(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataFormat">Format danych, aby wyszukać zapisać zgodność z bieżącego zaznaczenia.  Zobacz <see cref="T:System.Windows.DataFormats" /> listę predefiniowanych formatów danych.</param>
        <summary>Sprawdza, czy bieżące zaznaczenie mogą zostać zapisane jako formatu określone dane.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące zaznaczenie mogą zostać zapisane jako formacie określone dane. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj odpowiedniej <xref:System.Windows.Documents.TextRange.Save%2A> metody faktycznie zapisać bieżące zaznaczenie w formacie określone dane.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.CanSave%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Documents.TextRange.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.Documents.ITextRange.Changed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy przedział zostaje przeniesiony, aby pokryć nowy zakres zawartości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearAllProperties">
      <MemberSignature Language="C#" Value="public void ClearAllProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearAllProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.ClearAllProperties" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearAllProperties ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearAllProperties();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie właściwości formatowania (reprezentowane przez <see cref="T:System.Windows.Documents.Inline" /> elementy) z bieżącego zaznaczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma wpływ tylko na dowolne <xref:System.Windows.Documents.Inline> formatowania elementów, takich jak <xref:System.Windows.Documents.Bold> lub <xref:System.Windows.Documents.Italic>. Właściwości ustawione w akapitów i innych otaczającej <xref:System.Windows.Documents.Block> elementy nie są zmieniane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Documents.TextPointer textPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Documents.TextPointer textPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Contains(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Documents::TextPointer ^ textPointer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPointer" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPointer">Pozycja do testowania do włączenia w bieżącym zaznaczeniu.</param>
        <summary>Sprawdza, czy stanie (określonego przez <see cref="T:System.Windows.Documents.TextPointer" />) znajduje się w bieżącym zaznaczeniu.</summary>
        <returns>
          <see langword="true" /> Jeśli w określonej pozycji znajduje się w bieżącym zaznaczeniu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje na końcu bieżące zaznaczenie (wskazywanym przez <xref:System.Windows.Documents.TextRange.Start%2A> i <xref:System.Windows.Documents.TextRange.End%2A>) są traktowane jako część bieżącego zaznaczenia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.Contains%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, gdy *wskaźnika textPointer* nie znajduje się w tym samym dokumencie bieżącego zaznaczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer End { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer End" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.End" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property End As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ End { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobierz pozycję oznaczającą zakończenie bieżącego zaznaczenia.</summary>
        <value>A <see cref="T:System.Windows.Documents.TextPointer" /> wskazującego na koniec bieżącego zaznaczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.End%2A> właściwości.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextRange.Start" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValue">
      <MemberSignature Language="C#" Value="public object GetPropertyValue (System.Windows.DependencyProperty formattingProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetPropertyValue(class System.Windows.DependencyProperty formattingProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.GetPropertyValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyValue (formattingProperty As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPropertyValue(System::Windows::DependencyProperty ^ formattingProperty);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.GetPropertyValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattingProperty" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="formattingProperty">Właściwość formatowania, aby uzyskać wartość względem bieżącego zaznaczenia.</param>
        <summary>Zwraca wartość efektywna określonej właściwości formatowania w bieżącym zaznaczeniu.</summary>
        <returns>Obiekt określający wartość określonej właściwości formatowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zwrócić wartość właściwości całą <xref:System.Windows.Documents.TextRange> muszą być rozszerzane nad tekstem z tylko jedną wartość `formattingProperty`. Jeśli <xref:System.Windows.Documents.TextRange> rozszerza nad tekstem z co najmniej dwa różne wartości `formattingProperty`, <xref:System.Windows.DependencyProperty.UnsetValue> jest zwracany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, gdy <paramref name="formattingProperty" /> nie określa prawidłowej właściwości formatowania, lub <paramref name="value" /> określa nieprawidłową wartość dla <paramref name="formattingProperty" />.</exception>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy <paramref name="formattingProperty" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.ClearAllProperties" />
        <altmember cref="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextRange.IsEmpty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące zaznaczenie jest puste.</summary>
        <value>
          <see langword="true" /> Jeśli bieżące zaznaczenie jest puste; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Documents.TextRange> jest uznawany za pusta, jeśli <xref:System.Windows.Documents.TextRange.Start%2A> i <xref:System.Windows.Documents.TextRange.End%2A> pozycje są takie same.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.IsEmpty%2A> właściwości.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.IO.Stream stream, string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.IO.Stream stream, string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::IO::Stream ^ stream, System::String ^ dataFormat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do odczytu, zawierający dane, aby załadować do bieżącego zaznaczenia.</param>
        <param name="dataFormat">Format danych do ładowania danych jako.  Obecnie obsługiwane formaty to dane <see cref="F:System.Windows.DataFormats.Rtf" />, <see cref="F:System.Windows.DataFormats.Text" />, <see cref="F:System.Windows.DataFormats.Xaml" />, i <see cref="F:System.Windows.DataFormats.XamlPackage" />.</param>
        <summary>Ładuje bieżące zaznaczenie w formacie określone dane z określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.IO.Stream.CanSeek%2A> jest `true` dla `stream`, zawartość zostanie załadowany z początkiem strumienia do końca strumienia.  W przeciwnym razie zawartość zostanie odczytana z bieżącego <xref:System.IO.Stream.Position%2A> koniec strumienia.  Gdy metoda zwróci wartość, `stream` pozostanie otwarte i bieżącą pozycję w `stream` jest niezdefiniowana.  
  
 Operacja ładowania Zamienia bieżące zaznaczenie nowo ładowanej zawartości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.Load%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy <paramref name="stream" /> lub <paramref name="dataFormat" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Występuje, gdy format określonych danych nie jest obsługiwany.  Również może zostać zgłoszone, jeśli zawartość załadowana z <paramref name="stream" /> nie jest zgodny z formatem określone dane.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje bieżące zaznaczenie określonego strumienia w formacie określone dane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::String ^ dataFormat);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.Save(System.IO.Stream,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">Pusty, zapisywalny strumień do zapisania bieżącego zaznaczenia.</param>
        <param name="dataFormat">Format danych, aby zapisać bieżące zaznaczenie jako.  Obecnie obsługiwane formaty to dane <see cref="F:System.Windows.DataFormats.Rtf" />, <see cref="F:System.Windows.DataFormats.Text" />, <see cref="F:System.Windows.DataFormats.Xaml" />, i <see cref="F:System.Windows.DataFormats.XamlPackage" />.</param>
        <summary>Zapisuje bieżące zaznaczenie określonego strumienia w formacie określone dane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy metoda zwróci wartość, `stream` pozostanie otwarte i bieżącą pozycję w `stream` jest niezdefiniowana.  
  
 Zapisz w ramach operacji w bieżącym zaznaczeniu zawartości mogą być konwertowane na określonej przez format danych `dataFormat`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.Save%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> lub <paramref name="dataFormat" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Format określonych danych nie jest obsługiwany.  
  
 - lub  
  
 Zawartość załadowana z <paramref name="stream" /> nie jest zgodny z formatem określone dane.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, string dataFormat, bool preserveTextElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, string dataFormat, bool preserveTextElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::String ^ dataFormat, bool preserveTextElements);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.Save(System.IO.Stream,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
        <Parameter Name="preserveTextElements" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Pusty, zapisywalny strumień do zapisania bieżącego zaznaczenia.</param>
        <param name="dataFormat">Format danych, aby zapisać bieżące zaznaczenie jako.  Obecnie obsługiwane formaty to dane <see cref="F:System.Windows.DataFormats.Rtf" />, <see cref="F:System.Windows.DataFormats.Text" />, <see cref="F:System.Windows.DataFormats.Xaml" />, i <see cref="F:System.Windows.DataFormats.XamlPackage" />.</param>
        <param name="preserveTextElements">
          <see langword="true" /> Aby zachować niestandardowe <see cref="T:System.Windows.Documents.TextElement" /> obiekty; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zapisuje bieżące zaznaczenie do określonego strumienia w formacie określone dane z opcją zachowania niestandardowe <see cref="T:System.Windows.Documents.TextElement" /> obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `preserveTextElements` jest `false`, niestandardowe <xref:System.Windows.Documents.TextElement> obiekty są zapisywane jako znane <xref:System.Windows.Documents.TextElement> typów.  Na przykład, załóżmy, że utworzenie niestandardowego <xref:System.Windows.Documents.TextElement> o nazwie `Heading1`, który dziedziczy z <xref:System.Windows.Documents.Paragraph>. Gdy wywołanie tej metody za pomocą `preserveTextElements` ustawioną `false`, `Heading1` jest konwertowana na <xref:System.Windows.Documents.Paragraph> podczas <xref:System.Windows.Documents.TextRange> jest zapisywany.  Gdy wywołanie tej metody za pomocą `preserveTextElements` ustawioną `true`, `Heading1` zapisaniu bez konwersji. Aby zachować elementy niestandardowego tekstu `dataFormat` musi mieć ustawioną <xref:System.Windows.DataFormats.Xaml?displayProperty=nameWithType>.  
  
 <xref:System.Windows.Documents.TextRange.Save%28System.IO.Stream%2CSystem.String%2CSystem.Boolean%29> wprowadzono w programie .NET Framework w wersji 3.5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy <paramref name="stream" /> lub <paramref name="dataFormat" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Występuje, gdy format określonych danych nie jest obsługiwany.  Również może zostać zgłoszone, jeśli zawartość załadowana z <paramref name="stream" /> nie jest zgodny z formatem określone dane.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (System.Windows.Documents.TextPointer position1, System.Windows.Documents.TextPointer position2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(class System.Windows.Documents.TextPointer position1, class System.Windows.Documents.TextPointer position2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Select(System.Windows.Documents.TextPointer,System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (position1 As TextPointer, position2 As TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(System::Windows::Documents::TextPointer ^ position1, System::Windows::Documents::TextPointer ^ position2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position1" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="position2" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position1">Pozycji zakotwiczenia stałym oznacza jeden koniec zaznaczenia zaktualizowane.</param>
        <param name="position2">Pozycja ruchomy oznacza koniec zaktualizowane zaznaczenia.</param>
        <summary>Aktualizuje bieżącego zaznaczenia, biorąc dwa <see cref="T:System.Windows.Documents.TextPointer" /> pozycji w celu wskazania zaktualizowanych zaznaczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Documents.TextRange> został utworzony z wyboru między dwie pozycje wskazywanym przez **TextPointers**.  Jedną z tych pozycji (wskazywanym przez `position1`) ma położenie ustalone względem zaznaczenia, podczas innych pozycji (wskazywanym przez `position2`) jest ruchomy.  Jest to podobne do zachowania wyboru wprowadzone przez użytkownika za pomocą myszy lub klawiatury.  
  
 Rzeczywiste końców wyboru nowego może dopasowany do dowolnego heurystyki wyboru, które mają zastosowanie do dokumentu, który zawiera nowe bieżącego zaznaczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, gdy <paramref name="position1" /> i <paramref name="position2" /> nie znajduje się w tym samym dokumencie.</exception>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy <paramref name="position1" /> lub <paramref name="position2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer Start { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer Start" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.Start" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Start As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ Start { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pozycję wskazującą na początku bieżącego zaznaczenia.</summary>
        <value>A <see cref="T:System.Windows.Documents.TextPointer" /> wskazującego na początku bieżącego zaznaczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.Start%2A> właściwości.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextRange.End" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextRange.Text</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zawartość zwykły tekst bieżącego zaznaczenia.</summary>
        <value>Ciąg zawierający zwykły tekst zawartości bieżącego zaznaczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do wyodrębniania zawartości zwykłego tekstu w bieżącym zaznaczeniu, niezależnie od żadnego formatowania, które mogą być obecne.  
  
 Znaki nowego wiersza i podziały akapitu są traktowane jako równoważne względem tej właściwości.  Wszystkie typy podziałów zawartości istnieje w bieżącym zaznaczeniu są konwertowane na nowe wiersze, jeśli ta właściwość jest do odczytu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.Text%2A> właściwości.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy podejmowana jest próba, aby ustawić tę właściwość <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
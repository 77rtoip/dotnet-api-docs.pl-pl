<Type Name="TextRange" FullName="System.Windows.Documents.TextRange">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8ad4f6734ef5d6f41df8d584066d746b17c57019" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37577613" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextRange" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextRange extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextRange" />
  <TypeSignature Language="VB.NET" Value="Public Class TextRange" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextRange" />
  <TypeSignature Language="F#" Value="type TextRange = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje wybór zawartości między dwoma <see cref="T:System.Windows.Documents.TextPointer" /> pozycji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextRange> Klasy wprowadzono następującą terminologią.  
  
-   **Wybór** — <xref:System.Windows.Documents.TextRange> wybór zawartości między dwie pozycje wskazywanym przez **TextPointers**.  Jeden z nich umieszcza stały zakotwiczenia w odniesieniu do wyboru, podczas gdy inne położenie jest ruchomy.  Jest to podobne do zachowania wybranej przez użytkownika za pomocą myszy lub klawiatury.  
  
-   **Bieżące zaznaczenie** — ponieważ <xref:System.Windows.Documents.TextRange> zawsze wskazuje zaznaczenia w zawartości, dobrym pomysłem będzie po prostu odwoływać się do wyboru wskazywanym przez <xref:System.Windows.Documents.TextRange> jako *bieżące zaznaczenie*.  
  
-   **Kontener tekstu** — *kontenerze tekstu* jest element, który wchodzi w skład ultimate obramowanie pod ręką zawartość przepływu, a wybór wskazywanym przez <xref:System.Windows.Documents.TextRange> zawsze mieści się w kontenerze tekstu.  Obecnie kontenerze tekstu musi być albo <xref:System.Windows.Documents.FlowDocument> lub <xref:System.Windows.Controls.TextBlock>.  
  
-   **Dokument** — zawartość zbiorczo zawartych w kontenerze tekstu jest określany jako *dokumentu*.  
  
 Aby dowiedzieć się więcej o innych powiązanych warunków, takich jak *pozycji*, zobacz <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Windows.Documents.TextRange.Text%2A> właściwość <xref:System.Windows.Documents.TextRange> do zwrócenia na zwykły tekst reprezentujący określonego <xref:System.Windows.Documents.FlowDocument>.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextRange (System.Windows.Documents.TextPointer position1, System.Windows.Documents.TextPointer position2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.TextPointer position1, class System.Windows.Documents.TextPointer position2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.#ctor(System.Windows.Documents.TextPointer,System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (position1 As TextPointer, position2 As TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextRange(System::Windows::Documents::TextPointer ^ position1, System::Windows::Documents::TextPointer ^ position2);" />
      <MemberSignature Language="F#" Value="new System.Windows.Documents.TextRange : System.Windows.Documents.TextPointer * System.Windows.Documents.TextPointer -&gt; System.Windows.Documents.TextRange" Usage="new System.Windows.Documents.TextRange (position1, position2)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="position1" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="position2" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position1">Oznaczający jednym końcu wyboru używany do tworzenia nowej pozycji zakotwiczenia stały <see cref="T:System.Windows.Documents.TextRange" />.</param>
        <param name="position2">Ruchomy pozycji oznaczający drugi koniec zaznaczenia, używany do tworzenia nowego <see cref="T:System.Windows.Documents.TextRange" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Documents.TextRange" /> klasy, biorąc dwóch określony <see cref="T:System.Windows.Documents.TextPointer" /> pozycje jako początek i koniec pozycje dla nowego zakresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Documents.TextRange> jest tworzony na podstawie wyboru między dwie pozycje wskazywanym przez **TextPointers**.  Jedną z tych pozycji (wskazywanym przez `position1`) jest ustalone względem zaznaczoną opcję podczas innych pozycji (wskazywanym przez `position2`) jest ruchomy.  Jest to podobne do zachowania wybranej przez użytkownika za pomocą myszy lub klawiatury.  
  
 Rzeczywiste kończy się nowej <xref:System.Windows.Documents.TextRange> mogą być dostosowane do dopasowania Algorytm heurystyczny wyboru, które mają zastosowanie do dokumentu, który zawiera nowe <xref:System.Windows.Documents.TextRange>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange> konstruktora.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, gdy <paramref name="position1" /> i <paramref name="position2" /> nie znajduje się w obrębie tego samego dokumentu.</exception>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy <paramref name="position1" /> lub <paramref name="position2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyPropertyValue">
      <MemberSignature Language="C#" Value="public void ApplyPropertyValue (System.Windows.DependencyProperty formattingProperty, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyPropertyValue(class System.Windows.DependencyProperty formattingProperty, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyPropertyValue (formattingProperty As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyPropertyValue(System::Windows::DependencyProperty ^ formattingProperty, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ApplyPropertyValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="textRange.ApplyPropertyValue (formattingProperty, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattingProperty" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="formattingProperty">Właściwości formatowania, aby zastosować.</param>
        <param name="value">Wartość właściwości formatowania.</param>
        <summary>Dotyczy określonej właściwości formatowania i wartości do bieżącego zaznaczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma zastosowanie formatowania, wstawiając odpowiednie <xref:System.Windows.Documents.Inline> elementów, takich jak <xref:System.Windows.Documents.Bold> i <xref:System.Windows.Documents.Italic>, do wyboru wskazywanym przez to <xref:System.Windows.Documents.TextRange>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.ApplyPropertyValue%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, gdy <paramref name="formattingProperty" /> nie określa prawidłowej właściwości formatowania lub <paramref name="value" /> określa nieprawidłową wartość dla <paramref name="formattingProperty" />.</exception>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy <paramref name="formattingProperty" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.ClearAllProperties" />
        <altmember cref="M:System.Windows.Documents.TextRange.GetPropertyValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="CanLoad">
      <MemberSignature Language="C#" Value="public bool CanLoad (string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanLoad(string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanLoad (dataFormat As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanLoad(System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.CanLoad : string -&gt; bool" Usage="textRange.CanLoad dataFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataFormat">Format danych pod kątem zgodności z obciążenia w bieżącym zaznaczeniu.  Zobacz <see cref="T:System.Windows.DataFormats" /> Aby uzyskać listę predefiniowanych formatów danych.</param>
        <summary>Sprawdza, czy bieżące zaznaczenie mogą być ładowane z zawartością w formacie określone dane.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące zaznaczenie mogą być ładowane z zawartością w formacie określone dane. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyć odpowiedniego <xref:System.Windows.Documents.TextRange.Load%2A> metodę, aby faktycznie Załaduj zawartość do bieżącego zaznaczenia w formacie określone dane.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.CanLoad%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CanSave">
      <MemberSignature Language="C#" Value="public bool CanSave (string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanSave(string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanSave (dataFormat As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanSave(System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.CanSave : string -&gt; bool" Usage="textRange.CanSave dataFormat" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.CanSave(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataFormat">Format danych pod kątem zapisać zgodność z bieżącego zaznaczenia.  Zobacz <see cref="T:System.Windows.DataFormats" /> Aby uzyskać listę predefiniowanych formatów danych.</param>
        <summary>Sprawdza, czy bieżące zaznaczenie można zapisać w formacie określone dane.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące zaznaczenie, można zapisać jako formacie określone dane. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyć odpowiedniego <xref:System.Windows.Documents.TextRange.Save%2A> metodę, aby faktycznie zapisać bieżące zaznaczenie w formacie określone dane.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.CanSave%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Documents.TextRange.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.Documents.ITextRange.Changed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy przedział zostaje przeniesiony, aby pokryć nowy zakres zawartości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearAllProperties">
      <MemberSignature Language="C#" Value="public void ClearAllProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearAllProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.ClearAllProperties" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearAllProperties ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearAllProperties();" />
      <MemberSignature Language="F#" Value="member this.ClearAllProperties : unit -&gt; unit" Usage="textRange.ClearAllProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie właściwości formatowania (reprezentowane przez <see cref="T:System.Windows.Documents.Inline" /> elementy) z bieżącego zaznaczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma wpływ tylko na dowolny <xref:System.Windows.Documents.Inline> formatowanie elementów, takich jak <xref:System.Windows.Documents.Bold> lub <xref:System.Windows.Documents.Italic>. Właściwości ustawione w akapitów i innych otaczający <xref:System.Windows.Documents.Block> elementy nie są zmieniane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Documents.TextPointer textPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Documents.TextPointer textPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Contains(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Documents::TextPointer ^ textPointer);" />
      <MemberSignature Language="F#" Value="member this.Contains : System.Windows.Documents.TextPointer -&gt; bool" Usage="textRange.Contains textPointer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPointer" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPointer">Pozycja do testowania do włączenia w bieżącym zaznaczeniu.</param>
        <summary>Sprawdza, czy pozycja (określony przez <see cref="T:System.Windows.Documents.TextPointer" />) znajduje się w bieżącym zaznaczeniu.</summary>
        <returns>
          <see langword="true" /> Jeśli określona pozycja znajduje się w bieżącym zaznaczeniu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje na końcu bieżącego zaznaczenia (wskazywanym przez <xref:System.Windows.Documents.TextRange.Start%2A> i <xref:System.Windows.Documents.TextRange.End%2A>) są traktowane jako część bieżącego zaznaczenia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.Contains%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, gdy * textpointer — * nie znajduje się w tym samym dokumencie co bieżącego zaznaczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer End { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer End" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.End" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property End As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ End { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.End : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextRange.End" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobierz położenie oznaczający koniec bieżącego zaznaczenia.</summary>
        <value>A <see cref="T:System.Windows.Documents.TextPointer" /> wskazującego na koniec bieżącego zaznaczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.End%2A> właściwości.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextRange.Start" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValue">
      <MemberSignature Language="C#" Value="public object GetPropertyValue (System.Windows.DependencyProperty formattingProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetPropertyValue(class System.Windows.DependencyProperty formattingProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.GetPropertyValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyValue (formattingProperty As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPropertyValue(System::Windows::DependencyProperty ^ formattingProperty);" />
      <MemberSignature Language="F#" Value="member this.GetPropertyValue : System.Windows.DependencyProperty -&gt; obj" Usage="textRange.GetPropertyValue formattingProperty" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.GetPropertyValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattingProperty" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="formattingProperty">Formatowania właściwości w celu uzyskania wartości w odniesieniu do bieżącego zaznaczenia.</param>
        <summary>Zwraca efektywną wartość określonej właściwości formatowania na bieżącym zaznaczeniu.</summary>
        <returns>Obiekt, określając wartość określonej właściwości formatowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zwrócić wartość właściwości całą <xref:System.Windows.Documents.TextRange> musi rozszerzać nad tekstem z tylko jedną wartość `formattingProperty`. Jeśli <xref:System.Windows.Documents.TextRange> rozszerza nad tekstem z co najmniej dwóch różnych wartości `formattingProperty`, <xref:System.Windows.DependencyProperty.UnsetValue> jest zwracana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, gdy <paramref name="formattingProperty" /> nie określa prawidłowej właściwości formatowania lub <paramref name="value" /> określa nieprawidłową wartość dla <paramref name="formattingProperty" />.</exception>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy <paramref name="formattingProperty" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.ClearAllProperties" />
        <altmember cref="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Windows.Documents.TextRange.IsEmpty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextRange.IsEmpty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące zaznaczenie jest puste.</summary>
        <value>
          <see langword="true" /> Jeśli bieżące zaznaczenie jest puste; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Documents.TextRange> jest uznawana za puste, jeśli <xref:System.Windows.Documents.TextRange.Start%2A> i <xref:System.Windows.Documents.TextRange.End%2A> położenie są takie same.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.IsEmpty%2A> właściwości.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.IO.Stream stream, string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.IO.Stream stream, string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::IO::Stream ^ stream, System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.Load : System.IO.Stream * string -&gt; unit" Usage="textRange.Load (stream, dataFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do odczytu, która zawiera dane do załadowania do bieżącego zaznaczenia.</param>
        <param name="dataFormat">Format danych do ładowania danych jako.  Obecnie obsługiwane formaty danych <see cref="F:System.Windows.DataFormats.Rtf" />, <see cref="F:System.Windows.DataFormats.Text" />, <see cref="F:System.Windows.DataFormats.Xaml" />, i <see cref="F:System.Windows.DataFormats.XamlPackage" />.</param>
        <summary>Ładuje bieżącego zaznaczenia w formacie określone dane z określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.IO.Stream.CanSeek%2A> jest `true` dla `stream`, zawartości zostaną załadowane z początku strumienia na końcu strumienia.  W przeciwnym razie zawartość zostanie odczytany z bieżącej <xref:System.IO.Stream.Position%2A> na końcu strumienia.  Po powrocie z tej metody `stream` pozostanie otwarte, a bieżącą pozycję w `stream` jest niezdefiniowana.  
  
 Operacja ładowania Zamienia bieżące zaznaczenie nowo załadowanych zawartości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.Load%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy <paramref name="stream" /> lub <paramref name="dataFormat" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Występuje, gdy nie jest obsługiwany formatu określone dane.  Również może być zgłaszany, jeśli zawartość załadowana z <paramref name="stream" /> nie jest zgodny z formatem określone dane.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje bieżące zaznaczenie do określonego strumienia w formacie określone dane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * string -&gt; unit" Usage="textRange.Save (stream, dataFormat)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.Save(System.IO.Stream,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">Pusty, zapisywalne strumień można zapisać bieżącego zaznaczenia.</param>
        <param name="dataFormat">Format danych, aby zapisać bieżące zaznaczenie jako.  Obecnie obsługiwane formaty danych <see cref="F:System.Windows.DataFormats.Rtf" />, <see cref="F:System.Windows.DataFormats.Text" />, <see cref="F:System.Windows.DataFormats.Xaml" />, i <see cref="F:System.Windows.DataFormats.XamlPackage" />.</param>
        <summary>Zapisuje bieżące zaznaczenie do określonego strumienia w formacie określone dane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po powrocie z tej metody `stream` pozostanie otwarte, a bieżącą pozycję w `stream` jest niezdefiniowana.  
  
 Zapisz w ramach operacji zawartości w bieżącym zaznaczeniu może zostać przekonwertowany na format danych określony przez `dataFormat`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.Save%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> lub <paramref name="dataFormat" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Format określone dane nie jest obsługiwany.  - ani zawartości ładowane z <paramref name="stream" /> nie jest zgodny z formatem określone dane.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, string dataFormat, bool preserveTextElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, string dataFormat, bool preserveTextElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::String ^ dataFormat, bool preserveTextElements);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * string * bool -&gt; unit" Usage="textRange.Save (stream, dataFormat, preserveTextElements)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.Save(System.IO.Stream,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
        <Parameter Name="preserveTextElements" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Pusty, zapisywalne strumień można zapisać bieżącego zaznaczenia.</param>
        <param name="dataFormat">Format danych, aby zapisać bieżące zaznaczenie jako.  Obecnie obsługiwane formaty danych <see cref="F:System.Windows.DataFormats.Rtf" />, <see cref="F:System.Windows.DataFormats.Text" />, <see cref="F:System.Windows.DataFormats.Xaml" />, i <see cref="F:System.Windows.DataFormats.XamlPackage" />.</param>
        <param name="preserveTextElements">
          <see langword="true" /> Aby zachować niestandardowe <see cref="T:System.Windows.Documents.TextElement" /> obiekty; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zapisuje bieżące zaznaczenie do określonego strumienia w formacie określone dane z opcją zachowania niestandardowe <see cref="T:System.Windows.Documents.TextElement" /> obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `preserveTextElements` jest `false`, niestandardowe <xref:System.Windows.Documents.TextElement> obiekty są zapisywane jako znanych <xref:System.Windows.Documents.TextElement> typów.  Załóżmy na przykład, Utwórz niestandardową <xref:System.Windows.Documents.TextElement> o nazwie `Heading1`, który dziedziczy z <xref:System.Windows.Documents.Paragraph>. Wywołanie tej metody za pomocą `preserveTextElements` równa `false`, `Heading1` jest konwertowana na <xref:System.Windows.Documents.Paragraph> podczas <xref:System.Windows.Documents.TextRange> jest zapisywany.  Wywołanie tej metody za pomocą `preserveTextElements` równa `true`, `Heading1` są zapisywane bez konwersji. Aby zachować elementy niestandardowego tekstu `dataFormat` musi być równa <xref:System.Windows.DataFormats.Xaml?displayProperty=nameWithType>.  
  
 <xref:System.Windows.Documents.TextRange.Save%28System.IO.Stream%2CSystem.String%2CSystem.Boolean%29> został wprowadzony w .NET Framework w wersji 3.5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy <paramref name="stream" /> lub <paramref name="dataFormat" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Występuje, gdy nie jest obsługiwany formatu określone dane.  Również może być zgłaszany, jeśli zawartość załadowana z <paramref name="stream" /> nie jest zgodny z formatem określone dane.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (System.Windows.Documents.TextPointer position1, System.Windows.Documents.TextPointer position2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(class System.Windows.Documents.TextPointer position1, class System.Windows.Documents.TextPointer position2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Select(System.Windows.Documents.TextPointer,System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (position1 As TextPointer, position2 As TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(System::Windows::Documents::TextPointer ^ position1, System::Windows::Documents::TextPointer ^ position2);" />
      <MemberSignature Language="F#" Value="member this.Select : System.Windows.Documents.TextPointer * System.Windows.Documents.TextPointer -&gt; unit" Usage="textRange.Select (position1, position2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position1" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="position2" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position1">Pozycji zakotwiczenia stały, oznaczający jednym końcu zaznaczenia zaktualizowane.</param>
        <param name="position2">Pozycja ruchome oznaczający drugi koniec zaznaczenia zaktualizowane.</param>
        <summary>Aktualizuje bieżącego zaznaczenia, biorąc dwóch <see cref="T:System.Windows.Documents.TextPointer" /> pozycji do wskazania zaktualizowanych zaznaczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Documents.TextRange> jest tworzony na podstawie wyboru między dwie pozycje wskazywanym przez **TextPointers**.  Jedną z tych pozycji (wskazywanym przez `position1`) jest ustalone względem zaznaczoną opcję podczas innych pozycji (wskazywanym przez `position2`) jest ruchomy.  Jest to podobne do zachowania wybranej przez użytkownika za pomocą myszy lub klawiatury.  
  
 Rzeczywiste zakończenia nowe zaznaczenie może dopasowane do algorytmów heurystycznych wyboru, które mają zastosowanie do dokumentu, który zawiera nowe bieżącego zaznaczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, gdy <paramref name="position1" /> i <paramref name="position2" /> nie znajduje się w obrębie tego samego dokumentu.</exception>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy <paramref name="position1" /> lub <paramref name="position2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer Start { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer Start" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.Start" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Start As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ Start { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Start : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextRange.Start" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pozycję, która oznacza początek bieżącego zaznaczenia.</summary>
        <value>A <see cref="T:System.Windows.Documents.TextPointer" /> wskazującego na początku bieżącego zaznaczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.Start%2A> właściwości.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextRange.End" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Documents.TextRange.Text" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextRange.Text</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zawartość tekstową zwykły bieżącego zaznaczenia.</summary>
        <value>Ciąg zawierający zwykły tekst z bieżącego zaznaczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do wyodrębniania zawartości zwykłego tekstu w bieżącym zaznaczeniu, niezależnie od wszelkich formatowania, które mogą być obecne.  
  
 Znaki nowego wiersza i podziałów akapitów są traktowane jako równoważne w odniesieniu do tej właściwości.  Wszystkie typy zawartości przerwy obecny w bieżącym zaznaczeniu są konwertowane na nowe wiersze, gdy ta właściwość jest do odczytu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Windows.Documents.TextRange.Text%2A> właściwości.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy podejmowana jest próba ustawić tę właściwość na <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
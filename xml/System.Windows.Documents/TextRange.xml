<Type Name="TextRange" FullName="System.Windows.Documents.TextRange">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3a8fedae2f82694ec498b005ee452d4736ff49bf" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69207418" /></Metadata><TypeSignature Language="C#" Value="public class TextRange" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextRange extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextRange" />
  <TypeSignature Language="VB.NET" Value="Public Class TextRange" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextRange" />
  <TypeSignature Language="F#" Value="type TextRange = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje wybór zawartości między dwoma <see cref="T:System.Windows.Documents.TextPointer" /> pozycjami.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Windows.Documents.TextRange> klasie wprowadzono poniższą terminologię.  
  
-   **Wybór** -A <xref:System.Windows.Documents.TextRange> to wybór zawartości między dwoma pozycjami wskazywanymi przez elementy textpoints. ****  Jednym z tych pozycji jest stałe zakotwiczenie w odniesieniu do zaznaczenia, podczas gdy inne położenie jest Movable.  Jest to podobne do tego, jak działa wybór przez użytkownika przy użyciu myszy lub klawiatury.  
  
-   **Bieżące zaznaczenie** — ponieważ <xref:System.Windows.Documents.TextRange> zawsze wskazuje zaznaczenie w zawartości, warto po prostu odwołać się do <xref:System.Windows.Documents.TextRange> zaznaczenia wskazanego przez jako *bieżące zaznaczenie*.  
  
-   **Kontener tekstu** — *kontener tekstowy* to element, który tworzy ostatecznie obramowanie dla zawartości przepływu. zaznaczenie wskazywane przez <xref:System.Windows.Documents.TextRange> zawsze znajduje się w kontenerze tekstu.  Obecnie kontener tekstu musi być <xref:System.Windows.Documents.FlowDocument> albo <xref:System.Windows.Controls.TextBlock>albo.  
  
-   **Dokument** — zawartość zbiorczą znajdującą się w kontenerze tekstu nazywa się *dokumentem*.  
  
 Aby uzyskać więcej informacji na temat innych powiązanych ** terminów, takich <xref:System.Windows.Documents.TextPointer>jak pozycja, zobacz.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Windows.Documents.TextRange.Text%2A> właściwości a <xref:System.Windows.Documents.TextRange> , aby zwrócić tekst reprezentujący określony <xref:System.Windows.Documents.FlowDocument>.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextRange (System.Windows.Documents.TextPointer position1, System.Windows.Documents.TextPointer position2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.TextPointer position1, class System.Windows.Documents.TextPointer position2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.#ctor(System.Windows.Documents.TextPointer,System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (position1 As TextPointer, position2 As TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextRange(System::Windows::Documents::TextPointer ^ position1, System::Windows::Documents::TextPointer ^ position2);" />
      <MemberSignature Language="F#" Value="new System.Windows.Documents.TextRange : System.Windows.Documents.TextPointer * System.Windows.Documents.TextPointer -&gt; System.Windows.Documents.TextRange" Usage="new System.Windows.Documents.TextRange (position1, position2)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="position1" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="position2" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position1">Stała Pozycja zakotwiczenia, która oznacza jeden koniec zaznaczenia użytego do utworzenia nowego <see cref="T:System.Windows.Documents.TextRange" />.</param>
        <param name="position2">Pozycja ruchoma oznaczająca drugi koniec zaznaczenia używanego do tworzenia nowego <see cref="T:System.Windows.Documents.TextRange" />.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Documents.TextRange" /> klasy, pobierając dwie określone <see cref="T:System.Windows.Documents.TextPointer" /> pozycje jako początkową i końcową pozycję dla nowego zakresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest tworzony z zaznaczenia między dwoma położeniami wskazywanymi przez textpoints. **** <xref:System.Windows.Documents.TextRange>  Jedno z tych pozycji (wskazywane `position1`przez) jest rozwiązane w odniesieniu do zaznaczenia, podczas gdy drugie stanowisko `position2`(wskazywane przez) jest Movable.  Jest to podobne do tego, jak działa wybór przez użytkownika przy użyciu myszy lub klawiatury.  
  
 Rzeczywiste zakończenia nowego <xref:System.Windows.Documents.TextRange> elementu mogą zostać dopasowane do dopasowania wszelkich heurystycznych wyboru, które mają zastosowanie do dokumentu zawierającego nowy <xref:System.Windows.Documents.TextRange>.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Windows.Documents.TextRange> konstruktora.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, <paramref name="position1" /> gdy <paramref name="position2" /> i nie są umieszczone w tym samym dokumencie.</exception>
        <exception cref="T:System.ArgumentNullException">Występuje, <paramref name="position1" /> gdy <paramref name="position2" /> lub <see langword="null" />jest.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyPropertyValue">
      <MemberSignature Language="C#" Value="public void ApplyPropertyValue (System.Windows.DependencyProperty formattingProperty, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyPropertyValue(class System.Windows.DependencyProperty formattingProperty, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyPropertyValue (formattingProperty As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyPropertyValue(System::Windows::DependencyProperty ^ formattingProperty, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ApplyPropertyValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="textRange.ApplyPropertyValue (formattingProperty, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattingProperty" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="formattingProperty">Właściwość formatowania do zastosowania.</param>
        <param name="value">Wartość właściwości formatowania.</param>
        <summary>Stosuje określoną właściwość formatowania i wartość do bieżącego zaznaczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda stosuje formatowanie, wstawiając odpowiednie <xref:System.Windows.Documents.Inline> elementy, takie jak <xref:System.Windows.Documents.Bold> i <xref:System.Windows.Documents.Italic>, do zaznaczenia wskazanego w tym <xref:System.Windows.Documents.TextRange>elemencie.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Windows.Documents.TextRange.ApplyPropertyValue%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, <paramref name="formattingProperty" /> gdy nie określa prawidłowej właściwości formatowania lub <paramref name="value" /> określa nieprawidłową wartość dla <paramref name="formattingProperty" />.</exception>
        <exception cref="T:System.ArgumentNullException">Występuje, <paramref name="formattingProperty" /> gdy <see langword="null" />jest.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.ClearAllProperties" />
        <altmember cref="M:System.Windows.Documents.TextRange.GetPropertyValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="CanLoad">
      <MemberSignature Language="C#" Value="public bool CanLoad (string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanLoad(string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanLoad (dataFormat As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanLoad(System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.CanLoad : string -&gt; bool" Usage="textRange.CanLoad dataFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataFormat">Format danych służący do sprawdzania zgodności z równoważeniem obciążenia w bieżącym zaznaczeniu.  Zapoznaj <see cref="T:System.Windows.DataFormats" /> się z listą wstępnie zdefiniowanych formatów danych.</param>
        <summary>Sprawdza, czy bieżące zaznaczenie może zostać załadowane z zawartością w określonym formacie danych.</summary>
        <returns><see langword="true" />Jeśli bieżące zaznaczenie może zostać załadowane z zawartością w określonym formacie danych; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj odpowiedniej <xref:System.Windows.Documents.TextRange.Load%2A> metody, aby faktycznie załadować zawartość do bieżącego zaznaczenia w określonym formacie danych.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Windows.Documents.TextRange.CanLoad%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CanSave">
      <MemberSignature Language="C#" Value="public bool CanSave (string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanSave(string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanSave (dataFormat As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanSave(System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.CanSave : string -&gt; bool" Usage="textRange.CanSave dataFormat" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.CanSave(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataFormat">Format danych służący do sprawdzania zgodności z bieżącym wyborem.  Zapoznaj <see cref="T:System.Windows.DataFormats" /> się z listą wstępnie zdefiniowanych formatów danych.</param>
        <summary>Sprawdza, czy bieżące zaznaczenie można zapisać w określonym formacie danych.</summary>
        <returns><see langword="true" />Jeśli bieżące zaznaczenie można zapisać jako określony format danych; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj odpowiedniej <xref:System.Windows.Documents.TextRange.Save%2A> metody, aby rzeczywiście zapisywać bieżące zaznaczenie w określonym formacie danych.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Windows.Documents.TextRange.CanSave%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Documents.TextRange.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.Documents.ITextRange.Changed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po przełożeniu zakresu w celu pokrycia nowego zakresu zawartości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearAllProperties">
      <MemberSignature Language="C#" Value="public void ClearAllProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearAllProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.ClearAllProperties" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearAllProperties ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearAllProperties();" />
      <MemberSignature Language="F#" Value="member this.ClearAllProperties : unit -&gt; unit" Usage="textRange.ClearAllProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie właściwości formatowania (reprezentowane przez <see cref="T:System.Windows.Documents.Inline" /> elementy) z bieżącego zaznaczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma wpływ tylko <xref:System.Windows.Documents.Inline> na elementy formatowania, takie <xref:System.Windows.Documents.Bold> jak <xref:System.Windows.Documents.Italic>lub. Właściwości ustawione w akapitach i innych otaczających <xref:System.Windows.Documents.Block> elementów nie są zmieniane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Documents.TextPointer textPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Documents.TextPointer textPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Contains(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Documents::TextPointer ^ textPointer);" />
      <MemberSignature Language="F#" Value="member this.Contains : System.Windows.Documents.TextPointer -&gt; bool" Usage="textRange.Contains textPointer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPointer" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPointer">Położenie do przetestowania w celu uwzględnienia w bieżącym zaznaczeniu.</param>
        <summary>Sprawdza, czy pozycja (określona przez <see cref="T:System.Windows.Documents.TextPointer" />) znajduje się w bieżącym zaznaczeniu.</summary>
        <returns><see langword="true" />Jeśli określona pozycja znajduje się w bieżącym zaznaczeniu; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycje na końcu bieżącego zaznaczenia (oznaczone przez <xref:System.Windows.Documents.TextRange.Start%2A> i <xref:System.Windows.Documents.TextRange.End%2A>) są uważane za część bieżącego zaznaczenia.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Windows.Documents.TextRange.Contains%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, ** gdy element TextPointer nie znajduje się w tym samym dokumencie co bieżące zaznaczenie.</exception>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer End { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer End" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.End" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property End As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ End { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.End : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextRange.End" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobierz pozycję, która oznacza koniec bieżącego zaznaczenia.</summary>
        <value><see cref="T:System.Windows.Documents.TextPointer" /> Wskazuje koniec bieżącego zaznaczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Windows.Documents.TextRange.End%2A> właściwości.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextRange.Start" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValue">
      <MemberSignature Language="C#" Value="public object GetPropertyValue (System.Windows.DependencyProperty formattingProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetPropertyValue(class System.Windows.DependencyProperty formattingProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.GetPropertyValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyValue (formattingProperty As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPropertyValue(System::Windows::DependencyProperty ^ formattingProperty);" />
      <MemberSignature Language="F#" Value="member this.GetPropertyValue : System.Windows.DependencyProperty -&gt; obj" Usage="textRange.GetPropertyValue formattingProperty" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.GetPropertyValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattingProperty" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="formattingProperty">Właściwość formatowania służąca do uzyskiwania wartości względem bieżącego zaznaczenia.</param>
        <summary>Zwraca wartość efektywną określonej właściwości formatowania w bieżącym zaznaczeniu.</summary>
        <returns>Obiekt określający wartość określonej właściwości formatowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby można było zwrócić wartość właściwości, cała <xref:System.Windows.Documents.TextRange> musi przekroczyć tekst tylko jedną z wartości. `formattingProperty` Jeśli zwracany jest element `formattingProperty` <xref:System.Windows.DependencyProperty.UnsetValue> rozciągający się na tekst z co najmniej dwoma różnymi wartościami dla elementu,. <xref:System.Windows.Documents.TextRange>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, <paramref name="formattingProperty" /> gdy nie określa prawidłowej właściwości formatowania lub <paramref name="value" /> określa nieprawidłową wartość dla <paramref name="formattingProperty" />.</exception>
        <exception cref="T:System.ArgumentNullException">Występuje, <paramref name="formattingProperty" /> gdy <see langword="null" />jest.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.ClearAllProperties" />
        <altmember cref="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Windows.Documents.TextRange.IsEmpty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextRange.IsEmpty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące zaznaczenie jest puste.</summary>
        <value><see langword="true" />Jeśli bieżące zaznaczenie jest puste; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Windows.Documents.TextRange> a jest uważana za <xref:System.Windows.Documents.TextRange.Start%2A> pustą, jeśli pozycje i <xref:System.Windows.Documents.TextRange.End%2A> są równe.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Windows.Documents.TextRange.IsEmpty%2A> właściwości.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.IO.Stream stream, string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.IO.Stream stream, string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::IO::Stream ^ stream, System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.Load : System.IO.Stream * string -&gt; unit" Usage="textRange.Load (stream, dataFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień możliwy do odczytu zawierający dane, które mają zostać załadowane do bieżącego zaznaczenia.</param>
        <param name="dataFormat">Format danych służący do ładowania danych.  Obecnie obsługiwane formaty danych to <see cref="F:System.Windows.DataFormats.Rtf" /> <see cref="F:System.Windows.DataFormats.Xaml" />, <see cref="F:System.Windows.DataFormats.Text" />,, i <see cref="F:System.Windows.DataFormats.XamlPackage" />.</param>
        <summary>Ładuje bieżące zaznaczenie w określonym formacie danych z określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.IO.Stream.CanSeek%2A> jest `true` dla`stream`, zawartość zostanie załadowana od początku strumienia do końca strumienia.  W przeciwnym razie zawartość zostanie odczytana z <xref:System.IO.Stream.Position%2A> bieżącego do końca strumienia.  Gdy ta metoda zwraca, `stream` jest otwarta, a bieżąca pozycja w obszarze `stream` jest niezdefiniowana.  
  
 Operacja ładowania zastępuje bieżące zaznaczenie nowo załadowanej zawartości.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Windows.Documents.TextRange.Load%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Występuje, <paramref name="stream" /> gdy <paramref name="dataFormat" /> lub <see langword="null" />jest.</exception>
        <exception cref="T:System.ArgumentException">Występuje, gdy określony format danych jest nieobsługiwany.  Może być również zgłaszane, jeśli zawartość załadowana z <paramref name="stream" /> nie jest zgodna z określonym formatem danych.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje bieżące zaznaczenie do określonego strumienia w określonym formacie danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * string -&gt; unit" Usage="textRange.Save (stream, dataFormat)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.Save(System.IO.Stream,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">Pusty, zapisywalny strumień, do którego zostanie zapisany bieżący wybór.</param>
        <param name="dataFormat">Format danych, w którym ma zostać zapisany bieżący wybór.  Obecnie obsługiwane formaty danych to <see cref="F:System.Windows.DataFormats.Rtf" /> <see cref="F:System.Windows.DataFormats.Xaml" />, <see cref="F:System.Windows.DataFormats.Text" />,, i <see cref="F:System.Windows.DataFormats.XamlPackage" />.</param>
        <summary>Zapisuje bieżące zaznaczenie do określonego strumienia w określonym formacie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda zwraca, `stream` jest otwarta, a bieżąca pozycja w obszarze `stream` jest niezdefiniowana.  
  
 W ramach operacji zapisywania zawartość w bieżącym zaznaczeniu może zostać przekonwertowana na format danych określony przez `dataFormat`.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Windows.Documents.TextRange.Save%2A> metody.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />lub <paramref name="dataFormat" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Określony format danych nie jest obsługiwany.  
  
-lub 
Zawartość załadowana <paramref name="stream" /> z jest niezgodna z określonym formatem danych.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, string dataFormat, bool preserveTextElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, string dataFormat, bool preserveTextElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::String ^ dataFormat, bool preserveTextElements);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * string * bool -&gt; unit" Usage="textRange.Save (stream, dataFormat, preserveTextElements)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextRange.Save(System.IO.Stream,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
        <Parameter Name="preserveTextElements" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Pusty, zapisywalny strumień, do którego zostanie zapisany bieżący wybór.</param>
        <param name="dataFormat">Format danych, w którym ma zostać zapisany bieżący wybór.  Obecnie obsługiwane formaty danych to <see cref="F:System.Windows.DataFormats.Rtf" /> <see cref="F:System.Windows.DataFormats.Xaml" />, <see cref="F:System.Windows.DataFormats.Text" />,, i <see cref="F:System.Windows.DataFormats.XamlPackage" />.</param>
        <param name="preserveTextElements"><see langword="true" />Aby zachować obiekty <see cref="T:System.Windows.Documents.TextElement" /> niestandardowe; <see langword="false" />w przeciwnym razie.</param>
        <summary>Zapisuje bieżące zaznaczenie do określonego strumienia w określonym formacie danych z opcją zachowania obiektów niestandardowych <see cref="T:System.Windows.Documents.TextElement" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `preserveTextElements` tak `false`jest, <xref:System.Windows.Documents.TextElement> obiekty niestandardowe są zapisywane jako <xref:System.Windows.Documents.TextElement> znane typy.  Załóżmy na przykład, że tworzysz niestandardową <xref:System.Windows.Documents.TextElement> nazwę `Heading1`, która dziedziczy z <xref:System.Windows.Documents.Paragraph>. Wywołanie tej metody `preserveTextElements` z ustawionym na <xref:System.Windows.Documents.Paragraph> `false`, jest `Heading1` konwertowane na, gdy <xref:System.Windows.Documents.TextRange> zostanie zapisany.  Wywołanie tej metody z `preserveTextElements` ustawionym na `true`, `Heading1` jest zapisywane bez konwersji. Aby zachować niestandardowe elementy tekstowe, `dataFormat` należy ustawić na. <xref:System.Windows.DataFormats.Xaml?displayProperty=nameWithType>  
  
 <xref:System.Windows.Documents.TextRange.Save%28System.IO.Stream%2CSystem.String%2CSystem.Boolean%29>wprowadzono w .NET Framework w wersji 3,5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Występuje, <paramref name="stream" /> gdy <paramref name="dataFormat" /> lub <see langword="null" />jest.</exception>
        <exception cref="T:System.ArgumentException">Występuje, gdy określony format danych jest nieobsługiwany.  Może być również zgłaszane, jeśli zawartość załadowana z <paramref name="stream" /> nie jest zgodna z określonym formatem danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (System.Windows.Documents.TextPointer position1, System.Windows.Documents.TextPointer position2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(class System.Windows.Documents.TextPointer position1, class System.Windows.Documents.TextPointer position2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Select(System.Windows.Documents.TextPointer,System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (position1 As TextPointer, position2 As TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(System::Windows::Documents::TextPointer ^ position1, System::Windows::Documents::TextPointer ^ position2);" />
      <MemberSignature Language="F#" Value="member this.Select : System.Windows.Documents.TextPointer * System.Windows.Documents.TextPointer -&gt; unit" Usage="textRange.Select (position1, position2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position1" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="position2" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position1">Stała pozycja kotwicy, która oznacza jeden koniec zaktualizowanego zaznaczenia.</param>
        <param name="position2">Pozycja ruchoma oznaczająca inny koniec zaktualizowanego zaznaczenia.</param>
        <summary>Aktualizuje bieżące zaznaczenie, biorąc pod uwagę <see cref="T:System.Windows.Documents.TextPointer" /> dwie pozycje, aby wskazać zaktualizowany wybór.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest tworzony z zaznaczenia między dwoma położeniami wskazywanymi przez textpoints. **** <xref:System.Windows.Documents.TextRange>  Jedno z tych pozycji (wskazywane `position1`przez) jest rozwiązane w odniesieniu do zaznaczenia, podczas gdy drugie stanowisko `position2`(wskazywane przez) jest Movable.  Jest to podobne do tego, jak działa wybór przez użytkownika przy użyciu myszy lub klawiatury.  
  
 Rzeczywiste zakończenia nowego zaznaczenia można dopasować do wszystkich algorytmów heurystycznych wyboru, które mają zastosowanie do dokumentu, który zawiera nowe bieżące zaznaczenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, <paramref name="position1" /> gdy <paramref name="position2" /> i nie są umieszczone w tym samym dokumencie.</exception>
        <exception cref="T:System.ArgumentNullException">Występuje, <paramref name="position1" /> gdy <paramref name="position2" /> lub <see langword="null" />jest.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer Start { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer Start" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.Start" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Start As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ Start { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Start : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextRange.Start" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pozycję oznaczającą początek bieżącego zaznaczenia.</summary>
        <value><see cref="T:System.Windows.Documents.TextPointer" /> Wskazuje początek bieżącego zaznaczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Windows.Documents.TextRange.Start%2A> właściwości.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextRange.End" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Documents.TextRange.Text" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextRange.Text</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zawartość zwykłego tekstu bieżącego zaznaczenia.</summary>
        <value>Ciąg zawierający zawartość zwykłego tekstu bieżącego zaznaczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do wyodrębniania zawartości zwykłego tekstu w bieżącym zaznaczeniu, niezależnie od dowolnego formatowania, które może być obecne.  
  
 Nowe znaki wiersza i podziały akapitu są traktowane jako równoważne z uwzględnieniem tej właściwości.  Wszystkie typy podziałów zawartości obecne w bieżącym zaznaczeniu są konwertowane na nowe wiersze, gdy ta właściwość jest odczytywana.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Windows.Documents.TextRange.Text%2A> właściwości.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Występuje, gdy podjęto próbę ustawienia tej właściwości na <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

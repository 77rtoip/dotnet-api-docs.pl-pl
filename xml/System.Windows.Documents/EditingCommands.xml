<Type Name="EditingCommands" FullName="System.Windows.Documents.EditingCommands">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="30b353139e00ffa86a542c259a68250718297ece" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30700955" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class EditingCommands" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EditingCommands extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.EditingCommands" />
  <TypeSignature Language="VB.NET" Value="Public Class EditingCommands" />
  <TypeSignature Language="C++ CLI" Value="public ref class EditingCommands abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera standardowy zestaw pokrewne polecenia edycji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono poleceń edycji i skojarzoną domyślną gestów klucza (z nazwami kluczy z <xref:System.Windows.Input.Key> i <xref:System.Windows.Input.ModifierKeys> wyliczenia).  
  
|Polecenie edycji|Domyślne gestu klucza|  
|---------------------|-------------------------|  
|<xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>|`Ctrl`+`E`|  
|<xref:System.Windows.Documents.EditingCommands.AlignJustify%2A>|`Ctrl`+`J`|  
|<xref:System.Windows.Documents.EditingCommands.AlignLeft%2A>|`Ctrl`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.AlignRight%2A>|`Ctrl`+`R`|  
|<xref:System.Windows.Documents.EditingCommands.Backspace%2A>|`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A>|nie domyślnego gestu klucza|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A>|`Ctrl`+`OemOpenBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>|`Ctrl`+`Shift`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.Delete%2A>|`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A>|`Ctrl`+`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A>|`Ctrl`+`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A>|`Shift`+`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A>|`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A>|nie domyślnego gestu klucza|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A>|`Ctrl`+`OemCloseBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>|`Ctrl`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A>|`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A>|`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A>|`Ctrl`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>|`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A>|`Ctrl`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A>|`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A>|`Ctrl`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>|`Ctrl`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>|`Ctrl`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A>|`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A>|`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A>|`Up`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A>|`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A>|`Ctrl`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A>|`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A>|`Shift`+`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A>|`Ctrl`+`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>|`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>|`Ctrl`+`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A>|`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>|`Ctrl`+`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A>|`Ctrl`+`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A>|`Ctrl`+`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A>|`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A>|`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A>|`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A>|`Shift`+`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A>|`Ctrl`+`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.TabBackward%2A>|`Shift`+`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.TabForward%2A>|`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBold%2A>|`Ctrl`+`B`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A>|`Ctrl`+`Shift`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A>|`Insert`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A>|`Ctrl`+`I`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A>|`Ctrl`+`Shift`+`N`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A>|`Ctrl`+`OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A>|`Ctrl`+`Shift+OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A>|`Ctrl`+`U`|  
  
 Polecenia przepływu karetki i wybór rozwijanie polecenia korzystają ze wspólnego zestawu kluczy gestów domyślne, ogólne różnica jest dodanie <xref:System.Windows.Input.ModifierKeys.Shift> klucza do odróżnienia polecenia wyboru poleceń przepływu karetki.  Na przykład <xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A> polecenie ma domyślne gestu klucza z <xref:System.Windows.Input.Key.Left>i odpowiadający mu <xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A> polecenie ma domyślne gestu klucza z <xref:System.Windows.Input.ModifierKeys.Shift> + <xref:System.Windows.Input.Key.Left>.  
  
 Ogólnie rzecz biorąc, definicje polecenia udostępniane przez <xref:System.Windows.Documents.EditingCommands> nie wprowadzaj klasy korzystanie z parametrów polecenia ( `parameter` parametru oczekiwany przez <xref:System.Windows.Input.ICommand.Execute%2A> — metoda).  
  
 Aby uzyskać więcej informacji na polecenia i steruje, zobacz [omówienie wprowadzania](~/docs/framework/wpf/advanced/input-overview.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.MediaCommands" />
    <altmember cref="T:System.Windows.Input.ApplicationCommands" />
    <altmember cref="T:System.Windows.Input.ComponentCommands" />
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.CommandManager" />
    <altmember cref="T:System.Windows.Input.NavigationCommands" />
  </Docs>
  <Members>
    <Member MemberName="AlignCenter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignCenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignCenter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignCenter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.AlignCenter" /> polecenia, które żądania, że wyśrodkowany bieżącego akapitu lub akapitów zaznaczenia.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="E" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa w <xref:System.Windows.Documents.Paragraph> poziom.  Jeśli to polecenie jest wywoływana częściowy wybór zawartości akapitu (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt jest stosowane do całego akapitu.  Jeśli to polecenie jest wywoływana, wybór, obejmującej wiele akapitów, efekt jest stosowane do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Na poniższej ilustracji przedstawiono przykład wyśrodkowany zawartości.  
  
 ![Zrzut ekranu: Wartość właściwości TextAlign Centrum](~/add/media/flowdoc-textalign-center.png "zrzut ekranu: wartość właściwości TextAlign Centrum")  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignCenter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="AlignCenter"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignJustify">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignJustify { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignJustify" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignJustify As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignJustify { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.AlignJustify" /> polecenia, które żądań być uzasadnione bieżącego akapitu lub akapitów zaznaczenia.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="J" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa w <xref:System.Windows.Documents.Paragraph> poziom.  Jeśli to polecenie jest wywoływana częściowy wybór zawartości akapitu (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt jest stosowane do całego akapitu.  Jeśli to polecenie jest wywoływana, wybór, obejmującej wiele akapitów, efekt jest stosowany do wszystkich akapitów w zaznaczeniu.  
  
 Gdy zawartość jest uzasadnione, odstępy w poziomie w każdym wierszu zawartość zostanie zmieniona tak, aby uzasadnionych wiersze są takie same lub w pobliżu równy szerokości.  Zawartość jest uzasadnione zwykle utworzyć smooth krawędzi na strony zawartość.  
  
 Często jest krótszy niż pozostałe, w ostatnim wierszu akapitu mogą pozostać nieuzasadnione po wywołaniu tego polecenia.  
  
 Na poniższej ilustracji przedstawiono nieuzasadnione zawartości (wyrównanego do lewej).  
  
 ![Zrzut ekranu: Zawartość jest uzasadnione](~/add/media/content-unjustified.png "zrzut ekranu: zawartość jest uzasadnione")  
  
 Na poniższej ilustracji przedstawiono tę samą zawartość po została uzasadniona.  
  
 ![Zrzut ekranu przedstawiający zawartości uzasadnione tekst](~/add/media/content-justified.png "zrzut ekranu przedstawiający zawartości uzasadnione tekstu")  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignJustify"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="AlignJustify"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.AlignLeft" /> polecenia, które żądań zaznaczenia zawartości wyrównać po lewej.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="L" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa w <xref:System.Windows.Documents.Paragraph> poziom.  Jeśli to polecenie jest wywoływana częściowy wybór zawartości akapitu (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt jest stosowane do całego akapitu.  Jeśli to polecenie jest wywoływana, wybór, obejmującej wiele akapitów, efekt jest stosowane do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Na poniższej ilustracji przedstawiono przykład wyrównany zawartości.  
  
 ![Zrzut ekranu: Wartość właściwości TextAlign lewej](~/add/media/flowdoc-textalign-left.png "zrzut ekranu: wartość właściwości TextAlign z lewej strony")  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignLeft"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="AlignLeft"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.AlignRight" /> polecenia, które żądań zaznaczenia zawartości być wyrównane do prawej strony.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="R" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa w <xref:System.Windows.Documents.Paragraph> poziom.  Jeśli to polecenie jest wywoływana częściowy wybór zawartości akapitu (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt jest stosowane do całego akapitu.  Jeśli to polecenie jest wywoływana, wybór, obejmującej wiele akapitów, efekt jest stosowane do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Na poniższej ilustracji przedstawiono przykład wyrównany zawartości.  
  
 ![Zrzut ekranu: Wartość TextAlign prawa](~/add/media/flowdoc-textalign-right.png "zrzut ekranu: wartość TextAlign prawa")  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignRight"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="AlignRight"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="Backspace">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Backspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Backspace" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Backspace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Backspace As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Backspace { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.Backspace" /> polecenia, które żądania wprowadzenia polecenie backspace w bieżącym położeniu lub za pośrednictwem bieżącego zaznaczenia.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu na zaznaczenie jest puste, to polecenie usuwa separatora znaków lub bezpośrednio przed karetką. Po wywołaniu wyboru niepustym, to polecenie usuwa zaznaczenie.  
  
 To polecenie zachowuje formatowanie usunięto zaznaczenie zawartości natychmiast wstawione w tej samej lokalizacji, po wywołaniu tego polecenia.  Natomiast z <xref:System.Windows.Documents.EditingCommands.Delete%2A> polecenia, które nie zachowuje poprzedniej formatowania.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Backspace"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="Backspace"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CorrectSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand CorrectSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand CorrectSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CorrectSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ CorrectSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" /> polecenia, które żądań korygowane żadnych wyraz w bieżącym położeniu.</summary>
        <value>Żądane polecenie.  Nie domyślnego gestu klucza nie ma tego polecenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
<a name="xamlAttributeUsage_CorrectSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="CorrectSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" /> polecenia, które żądań zmniejszyć rozmiar czcionki dla bieżącego zaznaczenia przez punkt 1.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="OemOpenBrackets" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli to polecenie jest wywoływana, zaznaczenie jest puste, gdzie karetka znajduje się wewnątrz słowa, zaznaczenie jest automatycznie dodawany do dotyczą polecenie całe wyrazy.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_DecreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="DecreaseFontSize"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" /> polecenia, który żąda tego wcięcie dla bieżącego akapitu należy zmniejszyć o jedną pozycję tabulatora.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="T" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  To polecenie nie ma wpływu na element tekstowy chyba że <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> właściwość tekst elementu ma wartość `true`.  
  
<a name="xamlAttributeUsage_DecreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="DecreaseIndentation"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Delete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Delete" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Delete As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Delete { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.Delete" /> polecenia, które żądania, czy można usunąć bieżącego zaznaczenia.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie spowoduje odrzucenie formatowanie usunięto zaznaczenie.  Natomiast z <xref:System.Windows.Documents.EditingCommands.Backspace%2A> polecenia, który zachowuje formatowanie usunięto zaznaczenie zawartości natychmiast wstawione w tej samej lokalizacji, po wywołaniu tego polecenia.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Delete"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="Delete"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteNextWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeleteNextWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeleteNextWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeleteNextWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeleteNextWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" /> polecenia, które żądań usunięte wyrazu (względem bieżącej pozycji).</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karetka znajduje się wewnątrz słowa, zostaną usunięte w pozostałej części słowa między bieżącą pozycję i na końcu słowo.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeleteNextWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="DeleteNextWord"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="DeletePreviousWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeletePreviousWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeletePreviousWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeletePreviousWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeletePreviousWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" /> polecenia, które żądań usunięte poprzedniego wyrazu (względem bieżącej pozycji).</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karetka znajduje się wewnątrz słowa, zostaną usunięte w pozostałej części słowa między bieżącą pozycję i początek wyrazu.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeletePreviousWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="DeletePreviousWord"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="EnterLineBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterLineBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterLineBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterLineBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterLineBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" /> polecenia, które żądań wstawić podział wiersza w bieżącym położeniu lub za pośrednictwem bieżącego zaznaczenia.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Shift" /> + <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla edytory obsługujących zawartość przepływu, takich jak <xref:System.Windows.Controls.RichTextBox>, to polecenie powoduje, że <xref:System.Windows.Documents.LineBreak> element do wstawienia w bieżącym położeniu.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_EnterLineBreak"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="EnterLineBreak"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      </Docs>
    </Member>
    <Member MemberName="EnterParagraphBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterParagraphBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterParagraphBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterParagraphBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterParagraphBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" /> polecenia, które żądań wstawić podział akapitu w bieżącym położeniu lub za pośrednictwem bieżącego zaznaczenia.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie jest odpowiednikiem użytkownika, naciskając klawisz ENTER.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox> (gdy <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> jest właściwość `true`).  
  
> [!IMPORTANT]
>  To polecenie nie ma wpływu na element tekstowy chyba że <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> właściwość tekst elementu ma wartość `true`.  
  
<a name="xamlAttributeUsage_EnterParagraphBreak"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="EnterParagraphBreak"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IgnoreSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IgnoreSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IgnoreSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IgnoreSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" /> polecenia, które żądań zignorowane wystąpienia pisowni w bieżącym położeniu lub w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Nie domyślnego gestu klucza nie ma tego polecenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
<a name="xamlAttributeUsage_IgnoreSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="IgnoreSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" /> polecenia, które żądania, czy rozmiar czcionki dla bieżącego wyboru zwiększana o 1 punktu.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="OemCloseBrackets" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli to polecenie jest wywoływana, zaznaczenie jest puste, gdzie karetka znajduje się wewnątrz słowa, zaznaczenie jest rozwinięty, dotyczą polecenie całe wyrazy.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_IncreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="IncreaseFontSize"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" /> polecenia, który żąda tego wcięcie dla bieżącego akapitu zwiększana o jedną pozycję tabulatora.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="T" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  To polecenie nie ma wpływu na element tekstowy chyba że <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> właściwość tekst elementu ma wartość `true`.  
  
<a name="xamlAttributeUsage_IncreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="IncreaseIndentation"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" /> polecenia, które żądań Przenieś karetkę w dół o jeden wiersz.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveDownByLine"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" /> polecenia, które żądań karetkę Przenieś o jedną stronę w dół.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveDownByPage"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" /> polecenia, które żądań Przenieś karetkę dół przez jeden akapit.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie ustawia położenie karetki na początku następnego akapitu.  
  
 To polecenie zachowuje się jak <xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A> po wywołaniu na <xref:System.Windows.Controls.TextBox>.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveDownByParagraph"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" /> polecenia, które żądań karetkę lewej Przesuń o jeden znak.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveLeftByCharacter"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" /> polecenia, które żądania, że karetkę przenieść o jedno słowo w lewo.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karetkę wyrazu, to polecenie spowoduje przeniesienie karetkę do początku wyrazie.  W przeciwnym razie to polecenie spowoduje przeniesienie karetkę na początek poprzedniego wyrazu.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveLeftByWord"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" /> polecenia, które żądań czy karetki w prawo o jeden znak.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveRightByCharacter"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" /> polecenia, które żądań prawo Przesuń karetkę o jedno słowo.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karetkę wyrazu, to polecenie spowoduje przeniesienie karetkę na końcu tego wyrazu.  W przeciwnym razie to polecenie spowoduje przeniesienie karetkę na początek następnego wyrazu.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveRightByWord"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" /> polecenia, które żądania, że karetkę przenosić do bardzo koniec zawartości.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *kontenera dopisków fonetycznych* jest elementem formularzy ultimate obramowania wykonywanego zawartości.  <xref:System.Windows.Controls.TextBlock> i <xref:System.Windows.Documents.FlowDocument> przedstawiono kontenery tekstu.  Zawartość zbiorczo zawartych w kontenerze tekstu jest określany jako *dokumentu*.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveToDocumentEnd"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" /> polecenia, które żądania, że karetkę przenosić do początku części zawartości.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *kontenera dopisków fonetycznych* jest elementem formularzy ultimate obramowania wykonywanego zawartości.  <xref:System.Windows.Controls.TextBlock> i <xref:System.Windows.Documents.FlowDocument> przedstawiono kontenery tekstu.  Zawartość zbiorczo zawartych w kontenerze tekstu jest określany jako *dokumentu*.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveToDocumentStart"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" /> polecenia, które żądania, że karetkę Przenieś na koniec bieżącego wiersza.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveToLineEnd"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" /> polecenia, które żądania, że karetkę Przenieś na początek bieżącego wiersza.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveToLineStart"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" /> polecenia, które żądania, że karetkę Przenieś w górę o jeden wiersz.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveUpByLine"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" /> polecenia, które żądań karetkę przesunięty o jedną stronę.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveUpByPage"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" /> polecenia, które żądań Przenieś karetkę górę przez jeden akapit.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie ustawia położenie karetki na początku następnego akapitu.  
  
 To polecenie zachowuje się jak <xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A> po wywołaniu na <xref:System.Windows.Controls.TextBox>.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveUpByParagraph"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" /> polecenia, które żądań rozszerzona bieżące zaznaczenie w dół o jeden wiersz.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Shift" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectDownByLine"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" /> polecenia, które żądań rozszerzona bieżące zaznaczenie w dół o jedną stronę.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Shift" /> + <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectDownByPage"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" /> polecenia, które żądań rozszerzona bieżące zaznaczenie w dół przez jeden akapit.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie rozszerza zaznaczenie na początek następnego akapitu.  W przeciwnym razie polecenie rozszerza zaznaczenie do końca bieżącego akapitu.  Rozszerzony wybór zawiera podział akapit, który oznacza koniec akapitu.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectDownByParagraph"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" /> polecenia, które żądania, że bieżące zaznaczenie lewej rozszerzona o jeden znak.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Shift" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectLeftByCharacter"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" /> polecenia, które żądania, że bieżące zaznaczenie lewej rozszerzona o jedno słowo.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karetkę wyrazu, to polecenie rozszerza zaznaczenie na początku tego programu word.  W przeciwnym razie polecenie rozszerza zaznaczenie na początek poprzedniego wyrazu.  
  
 Rozszerzony wybór nie ma ogranicznika słowa.  Natomiast z <xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>, który ma ogranicznika słowa w rozszerzony wybór.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectLeftByWord"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" /> polecenia, które żądań rozszerzona bieżące zaznaczenie w prawo o jeden znak.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Shift" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectRightByCharacter"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" /> polecenia, które żądań rozszerzona bieżące zaznaczenie w prawo o jedno słowo.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karetkę wyrazu, to polecenie rozszerza zaznaczenie na końcu tego wyrazu.  W przeciwnym razie to polecenie rozszerza zaznaczenie do zakończenia następnego wyrazu.  
  
 Rozszerzony wybór obejmuje ogranicznika słowa.  Natomiast z <xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A> której nie ma ogranicznika słowa w rozszerzony wybór.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectRightByWord"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" /> polecenia, które żądań rozszerzona bieżące zaznaczenie na końcu zawartości.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *kontenera dopisków fonetycznych* jest elementem formularzy ultimate obramowania wykonywanego zawartości.  <xref:System.Windows.Controls.TextBlock> i <xref:System.Windows.Documents.FlowDocument> przedstawiono kontenery tekstu.  Zawartość zbiorczo zawartych w kontenerze tekstu jest określany jako *dokumentu*.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectToDocumentEnd"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" /> polecenia, które żądań rozszerzona bieżące zaznaczenie na samym początku zawartości.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *kontenera dopisków fonetycznych* jest elementem formularzy ultimate obramowania wykonywanego zawartości.  <xref:System.Windows.Controls.TextBlock> i <xref:System.Windows.Documents.FlowDocument> przedstawiono kontenery tekstu.  Zawartość zbiorczo zawartych w kontenerze tekstu jest określany jako *dokumentu*.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectToDocumentStart"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" /> polecenia, które żądań rozszerzona bieżące zaznaczenie do końca bieżącego wiersza.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Shift" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectToLineEnd"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" /> polecenia, które żądań rozszerzona bieżący wybór do początku bieżącego wiersza.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Shift" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectToLineStart"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" /> polecenia, które żądań rozszerzona bieżące zaznaczenie górę o jeden wiersz.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Shift" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectUpByLine"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" /> polecenia, które żądań rozszerzona bieżące zaznaczenie się o jedną stronę.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Shift" /> + <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectUpByPage"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" /> polecenia, które żądania, czy bieżące zaznaczenie można rozszerzać się przez jeden akapit.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karetka znajduje się na początku akapitu, to polecenie rozszerza zaznaczenie na początek poprzedniego akapitu.  W przeciwnym razie polecenie rozszerza zaznaczenie do początku bieżącego akapitu.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectUpByParagraph"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="TabBackward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabBackward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabBackward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabBackward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabBackward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.TabBackward" /> polecenia.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Shift" /> + <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie dla tego polecenia jest zależny od bieżącego zaznaczenia. Jeśli zaznaczenie jest pusta, to polecenie jest odpowiednikiem <xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>. Jeśli karetka znajduje się w komórce tabeli (reprezentowane przez <xref:System.Windows.Documents.TableCell> element), to polecenie spowoduje przeniesienie karetkę do poprzedniej komórki. W przeciwnym razie wstawiany jest znak tabulacji w bieżącym położeniu.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox> (gdy <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> jest właściwość `true`).  
  
<a name="xamlAttributeUsage_TabBackward"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="TabBackward"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabForward" />
      </Docs>
    </Member>
    <Member MemberName="TabForward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabForward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabForward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabForward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.TabForward" /> polecenia.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie dla tego polecenia jest zależny od bieżącego zaznaczenia. Jeśli zaznaczenie jest pusty lub jeśli zaznaczenie jest puste i jest bieżącym położeniu karetki na początku akapitu, to polecenie jest odpowiednikiem <xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>. Jeśli karetka znajduje się w komórce tabeli (reprezentowane przez <xref:System.Windows.Documents.TableCell> element), to polecenie spowoduje przeniesienie karetkę do następnej komórki. Jeśli karetka znajduje się w ostatniej komórce tabeli, to polecenie powoduje, że nowy wiersz do dołączenia do tabeli z karetka znajduje się w pierwszej komórki nowego wiersza.  W przeciwnym razie wstawiany jest znak tabulacji w bieżącym położeniu.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox> (gdy <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> jest właściwość `true`).  
  
<a name="xamlAttributeUsage_TabForward"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="TabForward"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabBackward" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBold">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBold { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBold" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBold As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBold { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleBold" /> polecenia, które żądania wysyłane przez <see cref="T:System.Windows.Documents.Bold" /> formatowania zostać przełączona w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="B" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.FontWeight> bieżące zaznaczenie jest poza zakresem od <xref:System.Windows.FontWeights.Thin%2A> do <xref:System.Windows.FontWeights.SemiBold%2A>, <xref:System.Windows.FontWeights.Bold%2A> jest stosowany do bieżącego zaznaczenia.  W przeciwnym razie <xref:System.Windows.FontWeights.Normal%2A> została zastosowana.  Lista porównawczych <xref:System.Windows.FontWeight> wartości, zobacz <xref:System.Windows.FontWeights>.  
  
 Jeśli zaznaczenie jest puste i karetka znajduje się wewnątrz słowa, zaznaczenie jest rozszerzona w celu uwzględnienia całe wyrazy.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleBold"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleBold"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBullets">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBullets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBullets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBullets As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBullets { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleBullets" /> polecenia, które żądania, że formatowanie nieuporządkowaną listę (określane również jako listy punktowane) zostać przełączona w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="L" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa w <xref:System.Windows.Documents.Paragraph> poziom.  Jeśli to polecenie jest wywoływana częściowy wybór zawartości akapitu (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt jest stosowane do całego akapitu.  Jeśli to polecenie jest wywoływana, wybór, obejmującej wiele akapitów, efekt jest stosowane do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleBullets"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleBullets"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      </Docs>
    </Member>
    <Member MemberName="ToggleInsert">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleInsert { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleInsert" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleInsert As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleInsert { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleInsert" /> polecenia, które Przełącza tryb pisania pomiędzy wstawianiem, a zastępowaniem.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Insert" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_ToggleInsert"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleInsert"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalic">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleItalic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleItalic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleItalic As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleItalic { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" /> polecenia, które żądania wysyłane przez <see cref="T:System.Windows.Documents.Italic" /> formatowania zostać przełączona w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="I" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.FontStyle> bieżące zaznaczenie jest <xref:System.Windows.FontStyles.Normal%2A>, <xref:System.Windows.FontStyles.Italic%2A> jest stosowany do bieżącego zaznaczenia.  W przeciwnym razie <xref:System.Windows.FontStyles.Normal%2A> została zastosowana.  
  
 Jeśli zaznaczenie jest puste i karetka znajduje się wewnątrz słowa, zaznaczenie jest rozszerzona w celu uwzględnienia całe wyrazy.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleItalic"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleItalic"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleNumbering">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleNumbering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleNumbering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleNumbering As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleNumbering { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" /> polecenia, które żądania, że formatowanie listy uporządkowanej (nazywane również lista numerowana) zostać przełączona w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="N" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa w <xref:System.Windows.Documents.Paragraph> poziom.  Jeśli to polecenie jest wywoływana częściowy wybór zawartości akapitu (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt jest stosowane do całego akapitu.  Jeśli to polecenie jest wywoływana, wybór, obejmującej wiele akapitów, efekt jest stosowane do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleNumbering"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleNumbering"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSubscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSubscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSubscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSubscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSubscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" /> polecenia, które żądania, że indeks dolny zostać przełączona w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="OemPlus" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
<a name="xamlAttributeUsage_ToggleSubscript"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleSubscript"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSuperscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSuperscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSuperscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSuperscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSuperscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" /> polecenia, które żądania, czy górny zostać przełączona w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="OemPlus" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
<a name="xamlAttributeUsage_ToggleSuperscript"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleSuperscript"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleUnderline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleUnderline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleUnderline As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleUnderline { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" /> polecenia, które żądania wysyłane przez <see cref="T:System.Windows.Documents.Underline" /> formatowania zostać przełączona w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <see langword="Ctrl" /> + <see langword="U" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zaznaczenie jest puste i karetka znajduje się wewnątrz słowa, zaznaczenie jest rozszerzona w celu uwzględnienia całe wyrazy.  
  
 Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.  
  
 To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleUnderline"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleUnderline"/>  
```  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 Na przykład <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (dziedziczone z <xref:System.Windows.FrameworkElement>), a także macierzystą obsługę wielu poleceń edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metoda jest parametrem polecenia.  Parametr polecenia; ignorowanie polecenia najbardziej edycji Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejsu i powinien zawierać obsługę określonego polecenia.  Ogólnie rzecz biorąc polecenie jest ignorowane, gdy została wywołana dla obiektu, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
  </Members>
</Type>